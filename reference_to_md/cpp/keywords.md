* goal
  * C++'s reserved keywords 
  * C++'s identifiers / special meaning

# C++'s reserved keywords
* C++'s reserved keywords
  * ❌NOT available -- for -- re-definition OR overloading❌
    * ⚠️EXCEPTION: | [attributes](language/attributes.md)⚠️
      * | C++11

A – C | D – P | R – Z   
---|---|---  
[`alignas`](keyword/alignas.html "cpp/keyword/alignas") (C++11)  
[`alignof`](keyword/alignof.html "cpp/keyword/alignof") (C++11)  
[`and`](keyword/and.html "cpp/keyword/and")  
[`and_eq`](keyword/and_eq.html "cpp/keyword/and eq")  
[`asm`](keyword/asm.html "cpp/keyword/asm")  
[`atomic_cancel`](keyword/atomic_cancel.html "cpp/keyword/atomic cancel") (TM TS)  
[`atomic_commit`](keyword/atomic_commit.html "cpp/keyword/atomic commit") (TM TS)  
[`atomic_noexcept`](keyword/atomic_noexcept.html "cpp/keyword/atomic noexcept") (TM TS)  
[`auto`](keyword/auto.html "cpp/keyword/auto") (1) (3) (4) (5)  
[`bitand`](keyword/bitand.html "cpp/keyword/bitand")  
[`bitor`](keyword/bitor.html "cpp/keyword/bitor")  
[`bool`](keyword/bool.html "cpp/keyword/bool")  
[`break`](keyword/break.html "cpp/keyword/break")  
[`case`](keyword/case.html "cpp/keyword/case")  
[`catch`](keyword/catch.html "cpp/keyword/catch")  
[`char`](keyword/char.html "cpp/keyword/char")  
[`char8_t`](keyword/char8_t.html "cpp/keyword/char8 t") (C++20)  
[`char16_t`](keyword/char16_t.html "cpp/keyword/char16 t") (C++11)  
[`char32_t`](keyword/char32_t.html "cpp/keyword/char32 t") (C++11)  
[`class`](keyword/class.html "cpp/keyword/class") (1)  
[`compl`](keyword/compl.html "cpp/keyword/compl")  
[`concept`](keyword/concept.html "cpp/keyword/concept") (C++20)  
[`const`](keyword/const.html "cpp/keyword/const")  
[`consteval`](keyword/consteval.html "cpp/keyword/consteval") (C++20) (5)  
[`constexpr`](keyword/constexpr.html "cpp/keyword/constexpr") (C++11) (3)  
[`constinit`](keyword/constinit.html "cpp/keyword/constinit") (C++20)  
[`const_cast`](keyword/const_cast.html "cpp/keyword/const cast")  
[`continue`](keyword/continue.html "cpp/keyword/continue")  
[`contract_assert`](keyword/contract_assert.html "cpp/keyword/contract assert") (C++26)  
[`co_await`](keyword/co_await.html "cpp/keyword/co await") (C++20)  
[`co_return`](keyword/co_return.html "cpp/keyword/co return") (C++20)  
[`co_yield`](keyword/co_yield.html "cpp/keyword/co yield") (C++20)  
|  [`decltype`](keywords/decltype.html "cpp/keyword/decltype") (C++11) (2)  
[`default`](keyword/default.html "cpp/keyword/default") (1)  
[`delete`](keyword/delete.html "cpp/keyword/delete") (1)  
[`do`](keyword/do.html "cpp/keyword/do")  
[`double`](keyword/double.html "cpp/keyword/double")  
[`dynamic_cast`](keyword/dynamic_cast.html "cpp/keyword/dynamic cast")  
[`else`](keyword/else.html "cpp/keyword/else")  
[`enum`](keyword/enum.html "cpp/keyword/enum") (1)  
[`explicit`](keyword/explicit.html "cpp/keyword/explicit")  
[`export`](keyword/export.html "cpp/keyword/export") (1) (4)  
[`extern`](keyword/extern.html "cpp/keyword/extern") (1)  
[`false`](keyword/false.html "cpp/keyword/false")  
[`float`](keyword/float.html "cpp/keyword/float")  
[`for`](keyword/for.html "cpp/keyword/for") (1)  
[`friend`](keyword/friend.html "cpp/keyword/friend")  
[`goto`](keyword/goto.html "cpp/keyword/goto")  
[`if`](keywords/if.html "cpp/keyword/if") (3) (5)  
[`inline`](keyword/inline.html "cpp/keyword/inline") (1) (3)  
[`int`](keyword/int.html "cpp/keyword/int") (1)  
[`long`](keyword/long.html "cpp/keyword/long")  
[`mutable`](keyword/mutable.html "cpp/keyword/mutable") (1)  
[`namespace`](keyword/namespace.html "cpp/keyword/namespace")  
[`new`](keyword/new.html "cpp/keyword/new")  
[`noexcept`](keyword/noexcept.html "cpp/keyword/noexcept") (C++11)  
[`not`](keyword/not.html "cpp/keyword/not")  
[`not_eq`](keyword/not_eq.html "cpp/keyword/not eq")  
[`nullptr`](keyword/nullptr.html "cpp/keyword/nullptr") (C++11)  
[`operator`](keyword/operator.html "cpp/keyword/operator") (1)  
[`or`](keyword/or.html "cpp/keyword/or")  
[`or_eq`](keyword/or_eq.html "cpp/keyword/or eq")  
[`private`](keyword/private.html "cpp/keyword/private") (4)  
[`protected`](keyword/protected.html "cpp/keyword/protected")  
[`public`](keyword/public.html "cpp/keyword/public")  
|  [`reflexpr`](keyword/reflexpr.html "cpp/keyword/reflexpr") (reflection TS)  
[`register`](keyword/register.html "cpp/keyword/register") (3)  
[`reinterpret_cast`](keyword/reinterpret_cast.html "cpp/keyword/reinterpret cast")  
[`requires`](keyword/requires.html "cpp/keyword/requires") (C++20)  
[`return`](keyword/return.html "cpp/keyword/return")  
[`short`](keyword/short.html "cpp/keyword/short")  
[`signed`](keyword/signed.html "cpp/keyword/signed")  
[`sizeof`](keyword/sizeof.html "cpp/keyword/sizeof") (1)  
[`static`](keywords/static.html "cpp/keyword/static")  
[`static_assert`](keyword/static_assert.html "cpp/keyword/static assert") (C++11)  
[`static_cast`](keyword/static_cast.html "cpp/keyword/static cast")  
[`struct`](keyword/struct.html "cpp/keyword/struct") (1)  
[`switch`](keyword/switch.html "cpp/keyword/switch")  
[`synchronized`](keyword/synchronized.html "cpp/keyword/synchronized") (TM TS)  
[`template`](keyword/template.html "cpp/keyword/template")  
[`this`](keyword/this.html "cpp/keyword/this") (5)  
[`thread_local`](keyword/thread_local.html "cpp/keyword/thread local") (C++11)  
[`throw`](keyword/throw.html "cpp/keyword/throw") (3) (4)  
[`true`](keyword/true.html "cpp/keyword/true")  
[`try`](keyword/try.html "cpp/keyword/try")  
[`typedef`](keyword/typedef.html "cpp/keyword/typedef")  
[`typeid`](keyword/typeid.html "cpp/keyword/typeid")  
[`typename`](keyword/typename.html "cpp/keyword/typename") (3) (4)  
[`union`](keyword/union.html "cpp/keyword/union")  
[`unsigned`](keyword/unsigned.html "cpp/keyword/unsigned")  
[`using`](keyword/using.html "cpp/keyword/using") (1) (4)  
[`virtual`](keyword/virtual.html "cpp/keyword/virtual")  
[`void`](keyword/void.html "cpp/keyword/void")  
[`volatile`](keyword/volatile.html "cpp/keyword/volatile")  
[`wchar_t`](keyword/wchar_t.html "cpp/keyword/wchar t")  
[`while`](keyword/while.html "cpp/keyword/while")  
[`xor`](keyword/xor.html "cpp/keyword/xor")  
[`xor_eq`](keyword/xor_eq.html "cpp/keyword/xor eq")  
  
  * (1) — meaning changed or new meaning added in C++11. 
  * (2) — new meaning added in C++14. 
  * (3) — meaning changed or new meaning added in C++17. 
  * (4) — meaning changed or new meaning added in C++20. 
  * (5) — new meaning added in C++23. 



Note that: [`and`](keyword/and.html "cpp/keyword/and"), [`bitor`](keyword/bitor.html "cpp/keyword/bitor"), [`or`](keyword/or.html "cpp/keyword/or"), [`xor`](keyword/xor.html "cpp/keyword/xor"), [`compl`](keyword/compl.html "cpp/keyword/compl"), [`bitand`](keyword/bitand.html "cpp/keyword/bitand"), [`and_eq`](keyword/and_eq.html "cpp/keyword/and eq"), [`or_eq`](keyword/or_eq.html "cpp/keyword/or eq"), [`xor_eq`](keyword/xor_eq.html "cpp/keyword/xor eq"), [`not`](keyword/not.html "cpp/keyword/not") and [`not_eq`](keyword/not_eq.html "cpp/keyword/not eq") (along with digraphs: <%, %>, <:, :>, %:, %:%: and trigraphs: ??<, ??>, ??(, ??), ??=, ??/, ??', ??!, ??-(until C++17)) provide an [alternative way to represent standard tokens](language/operator_alternative.html "cpp/language/operator alternative")
* These keywords are also considered reserved in attributes (excluding attribute argument lists), but some implementations handle them the same as the others.(since C++11)

# C++'s identifiers / special meaning
* C++'s identifiers / special meaning
  * uses
    * object names OR function names 

[`final`](identifier_with_special_meaning/final.html "cpp/identifier with special meaning/final") (C++11)  
[`override`](identifier_with_special_meaning/override.html "cpp/identifier with special meaning/override") (C++11)  
[`transaction_safe`](keyword/transaction_safe.html "cpp/keyword/transaction safe") (TM TS)  
[`transaction_safe_dynamic`](keyword/transaction_safe_dynamic.html "cpp/keyword/transaction safe dynamic") (TM TS)  
[`import`](identifier_with_special_meaning/import.html "cpp/identifier with special meaning/import") (C++20)  
[`module`](identifier_with_special_meaning/module.html "cpp/identifier with special meaning/module") (C++20)  
[`pre`](identifier_with_special_meaning/pre.html "cpp/identifier with special meaning/pre") (C++26)  
[`post`](identifier_with_special_meaning/post.html "cpp/identifier with special meaning/post") (C++26)  
[`trivially_relocatable_if_eligible`](identifier_with_special_meaning/trivially_relocatable_if_eligible.html "cpp/identifier with special meaning/trivially relocatable if eligible") (C++26)  
[`replaceable_if_eligible`](identifier_with_special_meaning/replaceable_if_eligible.html "cpp/identifier with special meaning/replaceable if eligible") (C++26)  
---  
  
Also, all [identifiers](language/name.html "cpp/language/identifiers") that contain a double underscore `__` in any position and each identifier that begins with an underscore followed by an uppercase letter is always reserved, and all identifiers that begin with an underscore are reserved for use as names in the global namespace
* See [identifiers](language/name.html "cpp/language/identifiers") for more details. 

The namespace `std` is used to place names of the standard C++ library
* See [Extending namespace std](language/extending_std.html "cpp/language/extending std") for the rules about adding names to it. 

The name `posix` is reserved for a future top-level namespace
* The behavior is undefined if a program declares or defines anything in that namespace.  | (since C++11)  
---|---  
  
The following tokens are recognized by the [preprocessor](preprocessor.html "cpp/preprocessor") when in context of a preprocessor directive: 

[`if`](preprocessor/conditional.html "cpp/preprocessor/conditional")  
[`elif`](preprocessor/conditional.html "cpp/preprocessor/conditional")  
[`else`](preprocessor/conditional.html "cpp/preprocessor/conditional")  
[`endif`](preprocessor/conditional.html "cpp/preprocessor/conditional") |  [`ifdef`](preprocessor/conditional.html "cpp/preprocessor/conditional")  
[`ifndef`](preprocessor/conditional.html "cpp/preprocessor/conditional")  
[`elifdef`](preprocessor/conditional.html "cpp/preprocessor/conditional") (C++23)  
[`elifndef`](preprocessor/conditional.html "cpp/preprocessor/conditional") (C++23)  
[`define`](preprocessor/replace.html "cpp/preprocessor/replace")  
[`undef`](preprocessor/replace.html "cpp/preprocessor/replace") |  [`include`](preprocessor/include.html "cpp/preprocessor/include")  
[`embed`](preprocessor/embed.html "cpp/preprocessor/embed") (C++26)  
[`line`](preprocessor/line.html "cpp/preprocessor/line") |  [`error`](preprocessor/warning.html "cpp/preprocessor/error")  
[`warning`](preprocessor/warning.html "cpp/preprocessor/error") (C++23)  
[`pragma`](preprocessor/impl.html "cpp/preprocessor/impl") |  [`defined`](preprocessor/conditional.html "cpp/preprocessor/conditional")  
[`__has_include`](experimental/feature_test.html "cpp/feature test") (C++17)  
[`__has_cpp_attribute`](experimental/feature_test.html "cpp/feature test") (C++20)  
[`__has_embed`](experimental/feature_test.html "cpp/feature test") (C++26) |  [`export`](keyword/export.html "cpp/keyword/export") (C++20)  
[`import`](identifier_with_special_meaning/import.html "cpp/identifier with special meaning/import") (C++20)  
[`module`](identifier_with_special_meaning/module.html "cpp/identifier with special meaning/module") (C++20)  
---|---|---|---|---|---  
  
The following tokens are recognized by the [preprocessor](preprocessor.html "cpp/preprocessor") _outside_ the context of a preprocessor directive: 

[`_Pragma`](preprocessor/impl.html "cpp/preprocessor/impl") (C++11)  
---  
  
### See also

[C documentation](../c/keyword.html "c/keyword") for keywords  
---
