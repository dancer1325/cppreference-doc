[C++](../../../cpp.html "cpp")

[Compiler support](../../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../../freestanding.html "cpp/freestanding")  
[Language](../../language.html "cpp/language")  
[Standard library](../../standard_library.html "cpp/standard library")  
[Standard library headers](../../headers.html "cpp/header")  
[Named requirements](../../iterator/concepts.html "cpp/named req")  
[Feature test macros](../feature_test.html "cpp/feature test") (C++20)  
[Language support library](../../utility.html#Language_support "cpp/utility")  
[Concepts library](../../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../../error.html "cpp/error")  
[Memory management library](../../memory.html "cpp/memory")  
[Metaprogramming library](../../meta.html "cpp/meta") (C++11)  
[General utilities library](../../utility.html "cpp/utility")  
[Containers library](../../container.html "cpp/container")  
[Iterators library](../../iterator.html "cpp/iterator")  
[Ranges library](../../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../../algorithm.html "cpp/algorithm")  
[Strings library](../../string.html "cpp/string")  
[Text processing library](../../text.html "cpp/text")  
[Numerics library](../../numeric.html "cpp/numeric")  
[Date and time library](../../chrono.html "cpp/chrono")  
[Input/output library](../../io.html "cpp/io")  
[Filesystem library](../../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../../atomic.html "cpp/thread") (C++11)  
[Execution control library](../execution.html "cpp/execution") (C++26)  
[Technical specifications](../../experimental.html "cpp/experimental")  
[Symbols index](../../symbol_index.html "cpp/symbol index")  
[External libraries](../../links/libs.html "cpp/links/libs")  
  


[Experimental](../../experimental.html "cpp/experimental")

[Technical Specification](../../experimental.html#Technical_Specification "cpp/experimental")  
---  
[Filesystem library](../fs.html "cpp/experimental/fs") (filesystem TS)  
[Library fundamentals](../memory.html "cpp/experimental/lib extensions") (library fundamentals TS)  
[Library fundamentals 2](../lib_extensions_2.html "cpp/experimental/lib extensions 2") (library fundamentals TS v2)  
[Library fundamentals 3](../lib_extensions_3.html "cpp/experimental/lib extensions 3") (library fundamentals TS v3)  
[Extensions for parallelism](../parallelism.html "cpp/experimental/parallelism") (parallelism TS)  
[Extensions for parallelism 2](../parallelism_2.html "cpp/experimental/parallelism 2") (parallelism TS v2)  
[Extensions for concurrency](../concurrency.html "cpp/experimental/concurrency") (concurrency TS)  
[Extensions for concurrency 2](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/concurrency_2&action=edit&redlink=1 "cpp/experimental/concurrency 2 \(page does not exist\)") (concurrency TS v2)  
[Concepts](../constraints.html "cpp/experimental/constraints") (concepts TS)  
[Ranges](../ranges.html "cpp/experimental/ranges") (ranges TS)  
[Reflection](../reflect.html "cpp/experimental/reflect") (reflection TS)  
[Mathematical special functions](../special_math.html "cpp/experimental/special functions") (special functions TR)  
[Experimental Non-TS](../../experimental.html#Experimental_Non-TS "cpp/experimental")  
[Pattern Matching](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/pm&action=edit&redlink=1 "cpp/experimental/pm \(page does not exist\)")  
[Linear Algebra](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/la&action=edit&redlink=1 "cpp/experimental/la \(page does not exist\)")  
[std::execution](../execution.html "cpp/experimental/execution")  
[Contracts](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/contracts&action=edit&redlink=1 "cpp/experimental/contracts \(page does not exist\)")  
[2D Graphics](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/2dgraphics&action=edit&redlink=1 "cpp/experimental/2dgraphics \(page does not exist\)")  
  


[Extensions for parallelism](../parallelism.html "cpp/experimental/parallelism")

[Execution policies](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/parallelism/execution_policy&action=edit&redlink=1 "cpp/experimental/parallelism/execution policy \(page does not exist\)")  
---  
[parallel::execution_policy](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/execution_policy&action=edit&redlink=1 "cpp/experimental/execution policy \(page does not exist\)")  
[parallel::sequential_execution_policyparallel::parallel_execution_policyparallel::parallel_vector_execution_policy](../execution_policy_tag_t.html "cpp/experimental/execution policy tag t")  
[parallel::seqparallel::parparallel::par_vec](../execution_policy_tag.html "cpp/experimental/execution policy tag")  
[Parallel algorithms](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/parallelism/parallel_algorithms&action=edit&redlink=1 "cpp/experimental/parallelism/parallel algorithms \(page does not exist\)")  
Parallel exceptions  
[parallel::exception_list](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/exception_list&action=edit&redlink=1 "cpp/experimental/exception list \(page does not exist\)")  
**Parallelized version of existing algorithms**  
New algorithms  
[parallel::for_eachparallel::for_each_n](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/for_each&action=edit&redlink=1 "cpp/experimental/for each \(page does not exist\)")  
[parallel::reduce](../reduce.html "cpp/experimental/reduce")  
[parallel::exclusive_scan](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/exclusive_scan&action=edit&redlink=1 "cpp/experimental/exclusive scan \(page does not exist\)")  
[parallel::inclusive_scan](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/inclusive_scan&action=edit&redlink=1 "cpp/experimental/inclusive scan \(page does not exist\)")  
[parallel::transform_reduce](../transform_reduce.html "cpp/experimental/transform reduce")  
[parallel::transform_exclusive_scan](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/transform_exclusive_scan&action=edit&redlink=1 "cpp/experimental/transform exclusive scan \(page does not exist\)")  
[parallel::transform_inclusive_scan](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/transform_inclusive_scan&action=edit&redlink=1 "cpp/experimental/transform inclusive scan \(page does not exist\)")  
  


![](https://upload.cppreference.com/mwiki/images/3/31/Imbox_notice.png) |  **Merged into ISO C++** The functionality described on this page was merged into the mainline ISO C++ standard as of 3/2016; see [the algorithm library](../../algorithm.html "cpp/algorithm") (since C++17)  
---|---  
  
The C++ Extensions for Parallelism TS provides parallelized versions of the following 69 existing algorithms. Each of the following parallelized algorithms 

  * is declared in the `std::experimental::parallel` namespace, 
  * does not participate in overload resolution unless `is_execution_policy<std::decay_t<ExecutionPolicy>>::value` is `true`, and 
  * has the same semantics as the corresponding existing algorithm in the C++ standard library, except as noted in the page on [parallel algorithms](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/parallelism/parallel_algorithms&action=edit&redlink=1 "cpp/experimental/parallelism/parallel algorithms \(page does not exist\)"). 



  


| 

## Contents

  * [1 Non-modifying sequence operations](existing.html#Non-modifying_sequence_operations)
  * [2 Modifying sequence operations](existing.html#Modifying_sequence_operations)
  * [3 Partitioning operations](existing.html#Partitioning_operations)
  * [4 Sorting operations](existing.html#Sorting_operations)
  * [5 Set operations (on sorted ranges)](existing.html#Set_operations_.28on_sorted_ranges.29)
  * [6 Heap operations](existing.html#Heap_operations)
  * [7 Minimum/maximum operations](existing.html#Minimum.2Fmaximum_operations)
  * [8 Numeric operations](existing.html#Numeric_operations)
  * [9 Operations on uninitialized memory](existing.html#Operations_on_uninitialized_memory)

  
---  
  
#####  Non-modifying sequence operations   
  
Parallelized algorithm  |  Existing algorithm   
template< class ExecutionPolicy, class InputIt, class UnaryPred >  
bool all_of( ExecutionPolicy&& policy, InputIt first, InputIt last,  
UnaryPred p ); |  [std::all_of](../../algorithm/none_of.html "cpp/algorithm/all any none of")  
template< class ExecutionPolicy, class InputIt, class UnaryPred >  
bool any_of( ExecutionPolicy&& policy, InputIt first, InputIt last,  
UnaryPred p ); |  [std::any_of](../../algorithm/none_of.html "cpp/algorithm/all any none of")  
template< class ExecutionPolicy, class InputIt, class UnaryPred >  
bool none_of( ExecutionPolicy&& policy, InputIt first, InputIt last,  
UnaryPred p ); |  [std::none_of](../../algorithm/none_of.html "cpp/algorithm/all any none of")  
template< class ExecutionPolicy, class InputIt, class T >  
typename iterator_traits<InputIt>::difference_type  
count( ExecutionPolicy&& policy, InputIt first, InputIt last,   
const T &value ); |  [std::count](../../algorithm/count.html "cpp/algorithm/count")  
template< class ExecutionPolicy, class InputIt, class UnaryPred >  
typename iterator_traits<InputIt>::difference_type  
count_if( ExecutionPolicy&& policy, InputIt first, InputIt last,  
UnaryPred p ); |  [std::count_if](../../algorithm/count.html "cpp/algorithm/count")  
template< class ExecutionPolicy, class InputIt1, class InputIt2 >  
[std::pair](../../utility/pair.html)<InputIt1,InputIt2>  
mismatch( ExecutionPolicy&& policy,  
InputIt1 first1, InputIt1 last1,  
InputIt2 first2 );  
  
template< class ExecutionPolicy, class InputIt1,   
class InputIt2, class BinaryPred >  
[std::pair](../../utility/pair.html)<InputIt1,InputIt2>  
mismatch( ExecutionPolicy&& policy,  
InputIt1 first1, InputIt1 last1,  
InputIt2 first2, BinaryPred p );  
  
template< class ExecutionPolicy, class InputIt1, class InputIt2 >  
[std::pair](../../utility/pair.html)<InputIt1,InputIt2>  
mismatch( ExecutionPolicy&& policy,  
InputIt1 first1, InputIt1 last1,  
InputIt2 first2, InputIt2 last2 );  
  
template< class ExecutionPolicy, class InputIt1,  
class InputIt2, class BinaryPred >  
[std::pair](../../utility/pair.html)<InputIt1,InputIt2>  
mismatch( ExecutionPolicy&& policy,  
InputIt1 first1, InputIt1 last1,  
InputIt2 first2, InputIt2 last2, BinaryPred p ); |  [std::mismatch](../../algorithm/mismatch.html "cpp/algorithm/mismatch")  
template< class ExecutionPolicy, class InputIt1, class InputIt2 >  
bool equal( ExecutionPolicy&& policy,  
InputIt1 first1, InputIt1 last1,  
InputIt2 first2 );  
  
template< class ExecutionPolicy, class InputIt1,   
class InputIt2, class BinaryPred >  
bool equal( ExecutionPolicy&& policy,  
InputIt1 first1, InputIt1 last1,  
InputIt2 first2, BinaryPred p );  
  
template< class ExecutionPolicy, class InputIt1, class InputIt2 >  
bool equal( ExecutionPolicy&& policy,  
InputIt1 first1, InputIt1 last1,  
InputIt2 first2, InputIt2 last2 );  
  
template< class ExecutionPolicy, class InputIt1,  
class InputIt2, class BinaryPred >  
bool equal( ExecutionPolicy&& policy,  
InputIt1 first1, InputIt1 last1,   
InputIt2 first2, InputIt2 last2, BinaryPred p ); |  [std::equal](../../algorithm/equal.html "cpp/algorithm/equal")  
template< class ExecutionPolicy, class InputIt, class T >  
InputIt find( ExecutionPolicy&& policy, InputIt first, InputIt last,  
const T& value ); |  [std::find](../../algorithm/find.html "cpp/algorithm/find")  
template< class ExecutionPolicy, class InputIt, class UnaryPred >  
InputIt find_if( ExecutionPolicy&& policy, InputIt first, InputIt last,  
UnaryPred p ); |  [std::find_if](../../algorithm/find.html "cpp/algorithm/find")  
template< class ExecutionPolicy, class InputIt, class UnaryPred >  
InputIt find_if_not( ExecutionPolicy&& policy,  
InputIt first, InputIt last,   
UnaryPred p ); |  [std::find_if_not](../../algorithm/find.html "cpp/algorithm/find")  
template< class ExecutionPolicy, class ForwardIt1, class ForwardIt2 >  
ForwardIt1 find_end( ExecutionPolicy&& policy,  
ForwardIt1 first, ForwardIt1 last,  
ForwardIt2 s_first, ForwardIt2 s_last );  
  
template< class ExecutionPolicy, class ForwardIt1,  
class ForwardIt2, class BinaryPred >  
ForwardIt1 find_end( ExecutionPolicy&& policy,  
ForwardIt1 first, ForwardIt1 last,  
ForwardIt2 s_first, ForwardIt2 s_last,  
BinaryPred p ); |  [std::find_end](../../algorithm/find_end.html "cpp/algorithm/find end")  
template< class ExecutionPolicy, class InputIt, class ForwardIt >  
InputIt find_first_of( ExecutionPolicy&& policy,  
InputIt first, InputIt last,  
ForwardIt s_first, ForwardIt s_last );  
  
template< class ExecutionPolicy, class InputIt,  
class ForwardIt, class BinaryPred >  
InputIt find_first_of( ExecutionPolicy&& policy,  
InputIt first, InputIt last,  
ForwardIt s_first, ForwardIt s_last,  
BinaryPred p ); |  [std::find_first_of](../../algorithm/find_first_of.html "cpp/algorithm/find first of")  
template< class ExecutionPolicy, class ForwardIt >  
ForwardIt adjacent_find( ExecutionPolicy&& policy,   
ForwardIt first, ForwardIt last );  
  
template< class ExecutionPolicy, class ForwardIt, class BinaryPred >  
ForwardIt adjacent_find( ExecutionPolicy&& policy,   
ForwardIt first, ForwardIt last,  
BinaryPred p ); |  [std::adjacent_find](../../algorithm/adjacent_find.html "cpp/algorithm/adjacent find")  
template< class ExecutionPolicy, class ForwardIt1, class ForwardIt2 >  
ForwardIt1 search( ExecutionPolicy&& policy,   
ForwardIt1 first, ForwardIt1 last,  
ForwardIt2 s_first, ForwardIt2 s_last );  
  
template< class ExecutionPolicy, class ForwardIt1,  
class ForwardIt2, class BinaryPred >  
ForwardIt1 search( ExecutionPolicy&& policy,  
ForwardIt1 first, ForwardIt1 last,  
ForwardIt2 s_first, ForwardIt2 s_last,  
BinaryPred p ); |  [std::search](../../algorithm/search.html "cpp/algorithm/search")  
template< class ExecutionPolicy, class ForwardIt, class Size, class T >  
ForwardIt search_n( ExecutionPolicy&& policy,  
ForwardIt first, ForwardIt last,  
Size count, const T& value );  
  
template< class ExecutionPolicy, class ForwardIt,  
class Size, class T, class BinaryPred >  
ForwardIt search_n( ExecutionPolicy&& policy,  
ForwardIt first, ForwardIt last,  
Size count, const T& value,   
BinaryPred p ); |  [std::search_n](../../algorithm/search_n.html "cpp/algorithm/search n")  
  
#####  Modifying sequence operations   
  
Parallelized algorithm  |  Existing algorithm   
template< class ExecutionPolicy, class InputIt, class OutputIt >  
OutputIt copy( ExecutionPolicy&& policy, InputIt first, InputIt last,   
OutputIt d_first ); |  [std::copy](../../algorithm/copy.html "cpp/algorithm/copy")  
template< class ExecutionPolicy, class InputIt,  
class OutputIt, class UnaryPred >  
OutputIt copy_if( ExecutionPolicy&& policy, InputIt first, InputIt last,  
OutputIt d_first, UnaryPred pred ); |  [std::copy_if](../../algorithm/copy.html "cpp/algorithm/copy")  
template< class ExecutionPolicy, class InputIt,  
class Size, class OutputIt >  
OutputIt copy_n( ExecutionPolicy&& policy, InputIt first, Size count,  
OutputIt result ); |  [std::copy_n](../../algorithm/copy_n.html "cpp/algorithm/copy n")  
template< class ExecutionPolicy, class InputIt, class OutputIt >  
OutputIt move( ExecutionPolicy&& policy, InputIt first, InputIt last,  
OutputIt d_first ); |  [`std::move`](../../algorithm/move.html "cpp/algorithm/move")  
template< class ExecutionPolicy, class ForwardIt, class T >  
void fill( ExecutionPolicy&& policy, ForwardIt first, ForwardIt last,  
const T& value ); |  [std::fill](../../algorithm/fill.html "cpp/algorithm/fill")  
template< class ExecutionPolicy, class OutputIt, class Size, class T >  
OutputIt fill_n( ExecutionPolicy&& policy, OutputIt first, Size count,  
const T& value ); |  [std::fill_n](../../algorithm/fill_n.html "cpp/algorithm/fill n")  
template< class ExecutionPolicy, class InputIt,   
class OutputIt, class UnaryOp >  
OutputIt transform( ExecutionPolicy&& policy,   
InputIt first1, InputIt last1,   
OutputIt d_first, UnaryOp unary_op );  
  
template< class ExecutionPolicy, class InputIt1, class InputIt2,  
class OutputIt, class BinaryOp >  
OutputIt transform( ExecutionPolicy&& policy,   
InputIt1 first1, InputIt1 last1,   
InputIt2 first2, OutputIt d_first,  
BinaryOp binary_op ); |  [std::transform](../../algorithm/transform.html "cpp/algorithm/transform")  
template< class ExecutionPolicy, class ForwardIt, class Generator >  
void generate( ExecutionPolicy&& policy, ForwardIt first, ForwardIt last,  
Generator g ); |  [std::generate](../../algorithm/generate.html "cpp/algorithm/generate")  
template< class ExecutionPolicy, class OutputIt,  
class Size, class Generator >  
OutputIt generate_n( ExecutionPolicy&& policy, OutputIt first,  
Size count, Generator g ); |  [std::generate_n](../../algorithm/generate_n.html "cpp/algorithm/generate n")  
template< class ExecutionPolicy, class ForwardIt, class T >  
ForwardIt remove( ExecutionPolicy&& policy,  
ForwardIt first, ForwardIt last, const T& value ); |  [`std::remove`](../../algorithm/remove.html "cpp/algorithm/remove")  
template< class ExecutionPolicy, class ForwardIt, class UnaryPred >  
ForwardIt remove_if( ExecutionPolicy&& policy,   
ForwardIt first, ForwardIt last, UnaryPred p ); |  [std::remove_if](../../algorithm/remove.html "cpp/algorithm/remove")  
template< class ExecutionPolicy, class InputIt, class OutputIt, class T >  
OutputIt remove_copy( ExecutionPolicy&& policy,   
InputIt first, InputIt last,   
OutputIt d_first, const T& value ); |  [std::remove_copy](../../algorithm/remove_copy.html "cpp/algorithm/remove copy")  
template< class ExecutionPolicy, class InputIt,  
class OutputIt, class UnaryPred >  
OutputIt remove_copy_if( ExecutionPolicy&& policy,   
InputIt first, InputIt last,   
OutputIt d_first, UnaryPred p ); |  [std::remove_copy_if](../../algorithm/remove_copy.html "cpp/algorithm/remove copy")  
template< class ExecutionPolicy, class ForwardIt, class T >  
void replace( ExecutionPolicy&& policy,  
ForwardIt first, ForwardIt last,  
const T& old_value, const T& new_value ); |  [std::replace](../../algorithm/replace.html "cpp/algorithm/replace")  
template< class ExecutionPolicy, class ForwardIt,  
class UnaryPred, class T >  
void replace_if( ExecutionPolicy&& policy,  
ForwardIt first, ForwardIt last,  
UnaryPred p, const T& new_value ); |  [std::replace_if](../../algorithm/replace.html "cpp/algorithm/replace")  
template< class ExecutionPolicy, class InputIt, class OutputIt, class T >  
OutputIt replace_copy( ExecutionPolicy&& policy,   
InputIt first, InputIt last, OutputIt d_first,  
const T& old_value, const T& new_value ); |  [std::replace_copy](../../algorithm/replace_copy.html "cpp/algorithm/replace copy")  
template< class ExecutionPolicy, class InputIt, class OutputIt,  
class UnaryPred, class T >  
OutputIt replace_copy_if( ExecutionPolicy&& policy,   
InputIt first, InputIt last, OutputIt d_first,  
UnaryPred p, const T& new_value ); |  [std::replace_copy_if](../../algorithm/replace_copy.html "cpp/algorithm/replace copy")  
template< class ExecutionPolicy, class ForwardIt1, class ForwardIt2 >  
ForwardIt2 swap_ranges( ExecutionPolicy&& policy,  
ForwardIt1 first1, ForwardIt1 last1,  
ForwardIt2 first2 ); |  [std::swap_ranges](../../algorithm/swap_ranges.html "cpp/algorithm/swap ranges")  
template< class ExecutionPolicy, class BidirIt >  
void reverse( ExecutionPolicy&& policy, BidirIt first, BidirIt last ); |  [std::reverse](../../algorithm/reverse.html "cpp/algorithm/reverse")  
template< class ExecutionPolicy, class BidirIt, class OutputIt >  
OutputIt reverse_copy( ExecutionPolicy&& policy,   
BidirIt first, BidirIt last, OutputIt d_first ); |  [std::reverse_copy](../../algorithm/reverse_copy.html "cpp/algorithm/reverse copy")  
template< class ExecutionPolicy, class ForwardIt >  
ForwardIt rotate( ExecutionPolicy&& policy,   
ForwardIt first, ForwardIt n_first, ForwardIt last ); |  [std::rotate](../../algorithm/rotate.html "cpp/algorithm/rotate")  
template< class ExecutionPolicy, class ForwardIt, class OutputIt >  
OutputIt rotate_copy( ExecutionPolicy&& policy,   
ForwardIt first, ForwardIt n_first, ForwardIt last,  
OutputIt d_first ); |  [std::rotate_copy](../../algorithm/rotate_copy.html "cpp/algorithm/rotate copy")  
template< class ExecutionPolicy, class ForwardIt >  
ForwardIt unique( ExecutionPolicy&& policy,   
ForwardIt first, ForwardIt last );  
  
template< class ExecutionPolicy, class ForwardIt, class BinaryPred >  
ForwardIt unique( ExecutionPolicy&& policy,   
ForwardIt first, ForwardIt last, BinaryPred p ); |  [std::unique](../../algorithm/unique.html "cpp/algorithm/unique")  
template< class ExecutionPolicy, class InputIt, class OutputIt >  
OutputIt unique_copy( ExecutionPolicy&& policy,   
InputIt first, InputIt last,  
OutputIt d_first );  
  
template< class ExecutionPolicy, class InputIt,  
class OutputIt, class BinaryPred >  
OutputIt unique_copy( ExecutionPolicy&& policy,   
InputIt first, InputIt last,  
OutputIt d_first, BinaryPred p ); |  [std::unique_copy](../../algorithm/unique_copy.html "cpp/algorithm/unique copy")  
  
#####  Partitioning operations   
  
Parallelized algorithm  |  Existing algorithm   
template< class ExecutionPolicy, class InputIt, class UnaryPred >  
bool is_partitioned( ExecutionPolicy&& policy,   
InputIt first, InputIt last, UnaryPred p ); |  [std::is_partitioned](../../algorithm/is_partitioned.html "cpp/algorithm/is partitioned")  
template< class ExecutionPolicy, class ForwardIt, class UnaryPred >  
ForwardIt partition( ExecutionPolicy&& policy,   
ForwardIt first, ForwardIt last, UnaryPred p ); |  [std::partition](../../algorithm/partition.html "cpp/algorithm/partition")  
template< class ExecutionPolicy, class InputIt, class OutputIt1,  
class OutputIt2, class UnaryPred >  
[std::pair](../../utility/pair.html)<OutputIt1, OutputIt2>  
partition_copy( ExecutionPolicy&& policy,   
InputIt first, InputIt last,  
OutputIt1 d_first_true, OutputIt2 d_first_false,  
UnaryPred p ); |  [std::partition_copy](../../algorithm/partition_copy.html "cpp/algorithm/partition copy")  
template< class ExecutionPolicy, class BidirIt, class UnaryPred >  
BidirIt stable_partition( ExecutionPolicy&& policy,   
BidirIt first, BidirIt last, UnaryPred p ); |  [std::stable_partition](../../algorithm/stable_partition.html "cpp/algorithm/stable partition")  
  
#####  Sorting operations   
  
Parallelized algorithm  |  Existing algorithm   
template< class ExecutionPolicy, class ForwardIt >  
bool is_sorted( ExecutionPolicy&& policy,  
ForwardIt first, ForwardIt last );  
  
template< class ExecutionPolicy, class ForwardIt, class Compare >  
bool is_sorted( ExecutionPolicy&& policy,   
ForwardIt first, ForwardIt last, Compare cmp ); |  [std::is_sorted](../../algorithm/is_sorted.html "cpp/algorithm/is sorted")  
template< class ExecutionPolicy, class ForwardIt >  
ForwardIt is_sorted_until( ExecutionPolicy&& policy,  
ForwardIt first, ForwardIt last );  
  
template< class ExecutionPolicy, class ForwardIt, class Compare >  
ForwardIt is_sorted_until( ExecutionPolicy&& policy,   
ForwardIt first, ForwardIt last,   
Compare cmp ); |  [std::is_sorted_until](../../algorithm/is_sorted_until.html "cpp/algorithm/is sorted until")  
template< class ExecutionPolicy, class RandomIt >  
void sort( ExecutionPolicy&& policy, RandomIt first, RandomIt last );  
  
template< class ExecutionPolicy, class RandomIt, class Compare >  
void sort( ExecutionPolicy&& policy,   
RandomIt first, RandomIt last, Compare cmp ); |  [std::sort](../../algorithm/sort.html "cpp/algorithm/sort")  
template< class ExecutionPolicy, class RandomIt >  
void partial_sort( ExecutionPolicy&& policy,  
RandomIt first, RandomIt middle, RandomIt last );  
  
template< class ExecutionPolicy, class RandomIt, class Compare >  
void partial_sort( ExecutionPolicy&& policy,   
RandomIt first, RandomIt middle, RandomIt last,  
Compare cmp ); |  [std::partial_sort](../../algorithm/partial_sort.html "cpp/algorithm/partial sort")  
template< class ExecutionPolicy, class InputIt, class RandomIt >  
RandomIt partial_sort_copy( ExecutionPolicy&& policy,   
InputIt first, InputIt last,  
RandomIt d_first, RandomIt d_last );  
  
template< class ExecutionPolicy, class InputIt,  
class RandomIt, class Compare >  
RandomIt partial_sort_copy( ExecutionPolicy&& policy,   
InputIt first, InputIt last,  
RandomIt d_first, RandomIt d_last,  
Compare cmp ); |  [std::partial_sort_copy](../../algorithm/partial_sort_copy.html "cpp/algorithm/partial sort copy")  
template< class ExecutionPolicy, class RandomIt >  
void stable_sort( ExecutionPolicy&& policy,   
RandomIt first, RandomIt last );  
  
template< class ExecutionPolicy, class RandomIt, class Compare >  
void stable_sort( ExecutionPolicy&& policy,  
RandomIt first, RandomIt last, Compare cmp ); |  [std::stable_sort](../../algorithm/stable_sort.html "cpp/algorithm/stable sort")  
template< class ExecutionPolicy, class RandomIt >  
void nth_element( ExecutionPolicy&& policy,  
RandomIt first, RandomIt nth, RandomIt last );  
  
template< class ExecutionPolicy, class RandomIt, class Compare >  
void nth_element( ExecutionPolicy&& policy,  
RandomIt first, RandomIt nth, RandomIt last,  
Compare cmp ); |  [std::nth_element](../../algorithm/nth_element.html "cpp/algorithm/nth element")  
  
#####  Set operations (on sorted ranges)   
  
Parallelized algorithm  |  Existing algorithm   
template< class ExecutionPolicy, class InputIt1,  
class InputIt2, class OutputIt >  
OutputIt merge( ExecutionPolicy&& policy,  
InputIt1 first1, InputIt1 last1,  
InputIt2 first2, InputIt2 last2,  
OutputIt d_first );  
  
template< class ExecutionPolicy, class InputIt1, class InputIt2,  
class OutputIt, class Compare >  
OutputIt merge( ExecutionPolicy&& policy,   
InputIt1 first1, InputIt1 last1,  
InputIt2 first2, InputIt2 last2,  
OutputIt d_first, Compare cmp ); |  [std::merge](../../algorithm/merge.html "cpp/algorithm/merge")  
template< class ExecutionPolicy, class BidirIt >  
void inplace_merge( ExecutionPolicy&& policy,  
BidirIt first, BidirIt middle, BidirIt last );  
  
template< class ExecutionPolicy, class BidirIt, class Compare >  
void inplace_merge( ExecutionPolicy&& policy,  
BidirIt first, BidirIt middle, BidirIt last,  
Compare cmp ); |  [std::inplace_merge](../../algorithm/inplace_merge.html "cpp/algorithm/inplace merge")  
template< class ExecutionPolicy, class InputIt1, class InputIt2 >  
bool includes( ExecutionPolicy&& policy,  
InputIt1 first1, InputIt1 last1,  
InputIt2 first2, InputIt2 last2 );  
  
template< class ExecutionPolicy, class InputIt1,  
class InputIt2, class Compare >  
bool includes( ExecutionPolicy&& policy,  
InputIt1 first1, InputIt1 last1,  
InputIt2 first2, InputIt2 last2, Compare cmp ); |  [std::includes](../../algorithm/includes.html "cpp/algorithm/includes")  
template< class ExecutionPolicy, class InputIt1,  
class InputIt2, class OutputIt >  
OutputIt set_difference( ExecutionPolicy&& policy,   
InputIt1 first1, InputIt1 last1,  
InputIt2 first2, InputIt2 last2,  
OutputIt d_first );  
  
template< class ExecutionPolicy, class InputIt1, class InputIt2,  
class OutputIt, class Compare >  
OutputIt set_difference( ExecutionPolicy&& policy,  
InputIt1 first1, InputIt1 last1,  
InputIt2 first2, InputIt2 last2,  
OutputIt d_first, Compare cmp ); |  [std::set_difference](../../algorithm/set_difference.html "cpp/algorithm/set difference")  
template< class ExecutionPolicy, class InputIt1,  
class InputIt2, class OutputIt >  
OutputIt set_intersection( ExecutionPolicy&& policy,  
InputIt1 first1, InputIt1 last1,  
InputIt2 first2, InputIt2 last2,  
OutputIt d_first );  
  
template< class ExecutionPolicy, class InputIt1, class InputIt2,  
class OutputIt, class Compare >  
OutputIt set_intersection( ExecutionPolicy&& policy,   
InputIt1 first1, InputIt1 last1,  
InputIt2 first2, InputIt2 last2,  
OutputIt d_first, Compare cmp ); |  [std::set_intersection](../../algorithm/set_intersection.html "cpp/algorithm/set intersection")  
template< class ExecutionPolicy, class InputIt1,  
class InputIt2, class OutputIt >  
OutputIt set_symmetric_difference( ExecutionPolicy&& policy,   
InputIt1 first1, InputIt1 last1,  
InputIt2 first2, InputIt2 last2,  
OutputIt d_first );  
  
template< class ExecutionPolicy, class InputIt1, class InputIt2,  
class OutputIt, class Compare >  
OutputIt set_symmetric_difference( ExecutionPolicy&& policy,   
InputIt1 first1, InputIt1 last1,  
InputIt2 first2, InputIt2 last2,  
OutputIt d_first, Compare cmp ); |  [std::set_symmetric_difference](../../algorithm/set_symmetric_difference.html "cpp/algorithm/set symmetric difference")  
template< class ExecutionPolicy, class InputIt1,  
class InputIt2, class OutputIt >  
OutputIt set_union( ExecutionPolicy&& policy,   
InputIt1 first1, InputIt1 last1,  
InputIt2 first2, InputIt2 last2,  
OutputIt d_first );  
  
template< class ExecutionPolicy, class InputIt1, class InputIt2,  
class OutputIt, class Compare >  
OutputIt set_union( ExecutionPolicy&& policy,   
InputIt1 first1, InputIt1 last1,  
InputIt2 first2, InputIt2 last2,  
OutputIt d_first, Compare cmp ); |  [std::set_union](../../algorithm/set_union.html "cpp/algorithm/set union")  
  
#####  Heap operations   
  
Parallelized algorithm  |  Existing algorithm   
template< class ExecutionPolicy, class RandomIt >  
bool is_heap( ExecutionPolicy&& policy,  
RandomIt first, RandomIt last );  
  
template< class ExecutionPolicy, class RandomIt, class Compare >  
bool is_heap( ExecutionPolicy&& policy,  
RandomIt first, RandomIt last, Compare cmp ); |  [std::is_heap](../../algorithm/is_heap.html "cpp/algorithm/is heap")  
template< class ExecutionPolicy, class RandomIt >  
RandomIt is_heap_until( ExecutionPolicy&& policy,   
RandomIt first, RandomIt last );  
  
template< class ExecutionPolicy, class RandomIt, class Compare >  
RandomIt is_heap_until( ExecutionPolicy&& policy,   
RandomIt first, RandomIt last, Compare cmp ); |  [std::is_heap_until](../../algorithm/is_heap_until.html "cpp/algorithm/is heap until")  
  
#####  Minimum/maximum operations   
  
Parallelized algorithm  |  Existing algorithm   
template< class ExecutionPolicy, class ForwardIt >   
ForwardIt max_element( ExecutionPolicy&& policy,  
ForwardIt first, ForwardIt last );  
  
template< class ExecutionPolicy, class ForwardIt, class Compare >  
ForwardIt max_element( ExecutionPolicy&& policy,   
ForwardIt first, ForwardIt last, Compare cmp ); |  [std::max_element](../../algorithm/max_element.html "cpp/algorithm/max element")  
template< class ExecutionPolicy, class ForwardIt >   
ForwardIt min_element( ExecutionPolicy&& policy,  
ForwardIt first, ForwardIt last );  
  
template< class ExecutionPolicy, class ForwardIt, class Compare >  
ForwardIt min_element( ExecutionPolicy&& policy,   
ForwardIt first, ForwardIt last, Compare cmp ); |  [std::min_element](../../algorithm/min_element.html "cpp/algorithm/min element")  
template< class ExecutionPolicy, class ForwardIt >   
[std::pair](../../utility/pair.html)<ForwardIt,ForwardIt>  
minmax_element( ExecutionPolicy&& policy,  
ForwardIt first, ForwardIt last );  
  
template< class ExecutionPolicy, class ForwardIt, class Compare >  
[std::pair](../../utility/pair.html)<ForwardIt,ForwardIt>   
minmax_element( ExecutionPolicy&& policy,   
ForwardIt first, ForwardIt last, Compare cmp ); |  [std::minmax_element](../../algorithm/minmax_element.html "cpp/algorithm/minmax element")  
template< class ExecutionPolicy, class InputIt1, class InputIt2 >  
bool lexicographical_compare( ExecutionPolicy&& policy,  
InputIt1 first1, InputIt1 last1,  
InputIt2 first2, InputIt2 last2 );  
  
template< class ExecutionPolicy, class InputIt1,   
class InputIt2, class Compare >  
bool lexicographical_compare( ExecutionPolicy&& policy,  
InputIt1 first1, InputIt1 last1,  
InputIt2 first2, InputIt2 last2,  
Compare cmp ); |  [std::lexicographical_compare](../../algorithm/lexicographical_compare.html "cpp/algorithm/lexicographical compare")  
  
#####  Numeric operations   
  
Parallelized algorithm  |  Existing algorithm   
template< class ExecutionPolicy, class InputIt, class OutputIt >  
OutputIt adjacent_difference( ExecutionPolicy&& policy,   
InputIt first, InputIt last,   
OutputIt d_first );  
  
template< class ExecutionPolicy, class InputIt,  
class OutputIt, class BinaryOp >  
OutputIt adjacent_difference( ExecutionPolicy&& policy,   
InputIt first, InputIt last,   
OutputIt d_first, BinaryOp op ); |  [std::adjacent_difference](../../algorithm/adjacent_difference.html "cpp/algorithm/adjacent difference")  
template< class ExecutionPolicy, class InputIt1,  
class InputIt2, class T >  
T inner_product( ExecutionPolicy&& policy,   
InputIt1 first1, InputIt1 last1, InputIt2 first2,  
T value );  
  
template< class ExecutionPolicy, class InputIt1, class InputIt2,  
class T, class BinaryOp1, class BinaryOp2 >   
T inner_product( ExecutionPolicy&& policy,   
InputIt1 first1, InputIt1 last1, InputIt2 first2,  
T value, BinaryOp1 op1, BinaryOp2 op2 ); |  [std::inner_product](../../algorithm/inner_product.html "cpp/algorithm/inner product")  
  
#####  Operations on uninitialized memory   
  
Parallelized algorithm  |  Existing algorithm   
template< class ExecutionPolicy, class InputIt, class ForwardIt >  
ForwardIt uninitialized_copy( ExecutionPolicy&& policy,   
InputIt first, InputIt last,  
ForwardIt d_first ); |  [std::uninitialized_copy](../../memory/uninitialized_copy.html "cpp/memory/uninitialized copy")  
template< class ExecutionPolicy, class InputIt,  
class Size, class ForwardIt >  
ForwardIt uninitialized_copy_n( ExecutionPolicy&& policy,  
InputIt first, Size count,   
ForwardIt d_first ); |  [std::uninitialized_copy_n](../../memory/uninitialized_copy_n.html "cpp/memory/uninitialized copy n")  
template< class ExecutionPolicy, class ForwardIt, class T >  
void uninitialized_fill( ExecutionPolicy&& policy,   
ForwardIt first, ForwardIt last,  
const T& value ); |  [std::uninitialized_fill](../../memory/uninitialized_fill.html "cpp/memory/uninitialized fill")  
template< class ExecutionPolicy, class ForwardIt, class Size, class T >  
ForwardIt uninitialized_fill_n( ExecutionPolicy&& policy,  
ForwardIt first, Size count,  
const T& value ); |  [std::uninitialized_fill_n](../../memory/uninitialized_fill_n.html "cpp/memory/uninitialized fill n")
