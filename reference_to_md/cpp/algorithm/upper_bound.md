
  


[Algorithm library](../algorithm.html "cpp/algorithm")

[Constrained algorithms and algorithms on ranges](ranges.html "cpp/algorithm/ranges") (C++20)  
---  
Constrained algorithms, e.g. [`ranges::copy`](ranges/copy.html "cpp/algorithm/ranges/copy"), [`ranges::sort`](ranges/sort.html "cpp/algorithm/ranges/sort"), ...  
[Execution policies (C++17)](../algorithm.html#Execution_policies "cpp/algorithm")  
|  | [is_execution_policy](is_execution_policy.html "cpp/algorithm/is execution policy")(C++17)  
---  
  
| [execution::seqexecution::parexecution::par_unseqexecution::unseq](execution_policy_tag.html "cpp/algorithm/execution policy tag")(C++17) (C++17)(C++17)(C++20)  
---  
  
|  | [execution::sequenced_policyexecution::parallel_policyexecution::parallel_unsequenced_policyexecution::parallel_unsequenced](execution_policy_tag_t.html "cpp/algorithm/execution policy tag t")(C++17)(C++17)(C++17)(C++20)  
---  
  
| [Non-modifying sequence operations](../algorithm.html#Non-modifying_sequence_operations "cpp/algorithm")  
---  
[Batch operations](../algorithm.html#Batch_operations "cpp/algorithm")  
| [for_each](for_each.html "cpp/algorithm/for each")  
---  
  
| [for_each_n](for_each_n.html "cpp/algorithm/for each n")(C++17)  
---  
  
[Search operations](../algorithm.html#Search_operations "cpp/algorithm")  
| [all_ofany_ofnone_of](none_of.html "cpp/algorithm/all any none of")(C++11) (C++11)(C++11)  
---  
[countcount_if](count.html "cpp/algorithm/count")  
[mismatch](mismatch.html "cpp/algorithm/mismatch")  
[equal](equal.html "cpp/algorithm/equal")  
  
  
  
| [findfind_iffind_if_not](find.html "cpp/algorithm/find")(C++11)  
---  
[find_end](find_end.html "cpp/algorithm/find end")  
[find_first_of](find_first_of.html "cpp/algorithm/find first of")  
[adjacent_find](adjacent_find.html "cpp/algorithm/adjacent find")  
[search](search.html "cpp/algorithm/search")  
[search_n](search_n.html "cpp/algorithm/search n")  
  
[Modifying sequence operations](../algorithm.html#Modifying_sequence_operations "cpp/algorithm")  
[Copy operations](../algorithm.html#Copy_operations "cpp/algorithm")  
| [copycopy_if](copy.html "cpp/algorithm/copy")(C++11)  
---  
[copy_backward](copy_backward.html "cpp/algorithm/copy backward")  
  
| [copy_n](copy_n.html "cpp/algorithm/copy n")(C++11)  
---  
[move](move.html "cpp/algorithm/move")(C++11)  
[move_backward](move_backward.html "cpp/algorithm/move backward")(C++11)  
  
[Swap operations](../algorithm.html#Swap_operations "cpp/algorithm")  
| [swap](../utility/swap.html "cpp/algorithm/swap")  
---  
[iter_swap](iter_swap.html "cpp/algorithm/iter swap")  
  
| [swap_ranges](swap_ranges.html "cpp/algorithm/swap ranges")  
---  
  
  
  
[Transformation operations](../algorithm.html#Transformation_operations "cpp/algorithm")  
| [replacereplace_if](replace.html "cpp/algorithm/replace")  
---  
[transform](transform.html "cpp/algorithm/transform")  
  
| [replace_copyreplace_copy_if](replace_copy.html "cpp/algorithm/replace copy")  
---  
  
  
  
[Generation operations](../algorithm.html#Generation_operations "cpp/algorithm")  
| [fill](fill.html "cpp/algorithm/fill")  
---  
[fill_n](fill_n.html "cpp/algorithm/fill n")  
  
| [generate](generate.html "cpp/algorithm/generate")  
---  
[generate_n](generate_n.html "cpp/algorithm/generate n")  
  
[Removing operations](../algorithm.html#Removing_operations "cpp/algorithm")  
| [removeremove_if](remove.html "cpp/algorithm/remove")  
---  
[unique](unique.html "cpp/algorithm/unique")  
  
| [remove_copyremove_copy_if](remove_copy.html "cpp/algorithm/remove copy")  
---  
[unique_copy](unique_copy.html "cpp/algorithm/unique copy")  
  
[Order-changing operations](../algorithm.html#Order-changing_operations "cpp/algorithm")  
| [reverse](reverse.html "cpp/algorithm/reverse")  
---  
[reverse_copy](reverse_copy.html "cpp/algorithm/reverse copy")  
[rotate](rotate.html "cpp/algorithm/rotate")  
[rotate_copy](rotate_copy.html "cpp/algorithm/rotate copy")  
  
| [random_shuffleshuffle](random_shuffle.html "cpp/algorithm/random shuffle")(until C++17)(C++11)  
---  
[shift_leftshift_right](shift.html "cpp/algorithm/shift")(C++20)(C++20)  
  
[Sampling operations](../algorithm.html#Sampling_operations "cpp/algorithm")  
| [sample](sample.html "cpp/algorithm/sample")(C++17)  
---  
  
|   
  
---  
  
| [Sorting and related operations](../algorithm.html#Sorting_and_related_operations "cpp/algorithm")  
---  
[Partitioning operations](../algorithm.html#Partitioning_operations "cpp/algorithm")  
| [partition](partition.html "cpp/algorithm/partition")  
---  
[partition_copy](partition_copy.html "cpp/algorithm/partition copy")(C++11)  
[stable_partition](stable_partition.html "cpp/algorithm/stable partition")  
  
| [is_partitioned](is_partitioned.html "cpp/algorithm/is partitioned")(C++11)  
---  
[partition_point](partition_point.html "cpp/algorithm/partition point")(C++11)  
  
  
  
[Sorting operations](../algorithm.html#Sorting_operations "cpp/algorithm")  
| [sort](sort.html "cpp/algorithm/sort")  
---  
[stable_sort](stable_sort.html "cpp/algorithm/stable sort")  
[partial_sort](partial_sort.html "cpp/algorithm/partial sort")  
[partial_sort_copy](partial_sort_copy.html "cpp/algorithm/partial sort copy")  
  
| [is_sorted](is_sorted.html "cpp/algorithm/is sorted")(C++11)  
---  
[is_sorted_until](is_sorted_until.html "cpp/algorithm/is sorted until")(C++11)  
[nth_element](nth_element.html "cpp/algorithm/nth element")  
  
  
  
[Binary search operations  
(on partitioned ranges)](../algorithm.html#Binary_search_operations_.28on_partitioned_ranges.29 "cpp/algorithm")  
| [lower_bound](lower_bound.html "cpp/algorithm/lower bound")  
---  
**upper_bound**  
  
| [equal_range](equal_range.html "cpp/algorithm/equal range")  
---  
[binary_search](binary_search.html "cpp/algorithm/binary search")  
  
[Set operations (on sorted ranges)](../algorithm.html#Set_operations_.28on_sorted_ranges.29 "cpp/algorithm")  
| [includes](includes.html "cpp/algorithm/includes")  
---  
[set_union](set_union.html "cpp/algorithm/set union")  
[set_intersection](set_intersection.html "cpp/algorithm/set intersection")  
  
| [set_difference](set_difference.html "cpp/algorithm/set difference")  
---  
[set_symmetric_difference](set_symmetric_difference.html "cpp/algorithm/set symmetric difference")  
  
  
  
[Merge operations (on sorted ranges)](../algorithm.html#Merge_operations_.28on_sorted_ranges.29 "cpp/algorithm")  
| [merge](merge.html "cpp/algorithm/merge")  
---  
  
| [inplace_merge](inplace_merge.html "cpp/algorithm/inplace merge")  
---  
  
[Heap operations](../algorithm.html#Heap_operations "cpp/algorithm")  
| [push_heap](push_heap.html "cpp/algorithm/push heap")  
---  
[pop_heap](pop_heap.html "cpp/algorithm/pop heap")  
[make_heap](make_heap.html "cpp/algorithm/make heap")  
  
| [sort_heap](sort_heap.html "cpp/algorithm/sort heap")  
---  
[is_heap](is_heap.html "cpp/algorithm/is heap")(C++11)  
[is_heap_until](is_heap_until.html "cpp/algorithm/is heap until")(C++11)  
  
[Minimum/maximum operations](../algorithm.html#Minimum.2Fmaximum_operations "cpp/algorithm")  
| [max](max.html "cpp/algorithm/max")  
---  
[min](min.html "cpp/algorithm/min")  
[minmax](minmax.html "cpp/algorithm/minmax")(C++11)  
[clamp](clamp.html "cpp/algorithm/clamp")(C++17)  
  
| [max_element](max_element.html "cpp/algorithm/max element")  
---  
[min_element](min_element.html "cpp/algorithm/min element")  
[minmax_element](minmax_element.html "cpp/algorithm/minmax element")(C++11)  
  
  
  
[Lexicographical comparison operations](../algorithm.html#Lexicographical_comparison_operations "cpp/algorithm")  
[lexicographical_compare](lexicographical_compare.html "cpp/algorithm/lexicographical compare")  
[lexicographical_compare_three_way](lexicographical_compare_three_way.html "cpp/algorithm/lexicographical compare three way")(C++20)  
[Permutation operations](../algorithm.html#Permutation_operations "cpp/algorithm")  
| [next_permutation](next_permutation.html "cpp/algorithm/next permutation")  
---  
[prev_permutation](prev_permutation.html "cpp/algorithm/prev permutation")  
  
  
  
| [is_permutation](is_permutation.html "cpp/algorithm/is permutation")(C++11)  
---  
  
  
  
  
  
[C library](../algorithm.html#C_library "cpp/algorithm")  
| [qsort](qsort.html "cpp/algorithm/qsort")  
---  
  
| [bsearch](bsearch.html "cpp/algorithm/bsearch")  
---  
  
[Numeric operations](../algorithm.html#Numeric_operations "cpp/algorithm")  
|  | [iota](iota.html "cpp/algorithm/iota")(C++11)  
---  
[inner_product](inner_product.html "cpp/algorithm/inner product")  
[adjacent_difference](adjacent_difference.html "cpp/algorithm/adjacent difference")  
  
| [accumulate](accumulate.html "cpp/algorithm/accumulate")  
---  
[reduce](reduce.html "cpp/algorithm/reduce")(C++17)  
[transform_reduce](transform_reduce.html "cpp/algorithm/transform reduce")(C++17)  
  
|  | [partial_sum](partial_sum.html "cpp/algorithm/partial sum")  
---  
[inclusive_scan](inclusive_scan.html "cpp/algorithm/inclusive scan")(C++17)  
[exclusive_scan](exclusive_scan.html "cpp/algorithm/exclusive scan")(C++17)  
  
| [transform_inclusive_scan](transform_inclusive_scan.html "cpp/algorithm/transform inclusive scan")(C++17)  
---  
[transform_exclusive_scan](transform_exclusive_scan.html "cpp/algorithm/transform exclusive scan")(C++17)  
  
  
  
[Operations on uninitialized memory](../algorithm.html#Operations_on_uninitialized_memory "cpp/algorithm")  
|  | [uninitialized_copy](../memory/uninitialized_copy.html "cpp/memory/uninitialized copy")  
---  
[uninitialized_move](../memory/uninitialized_move.html "cpp/memory/uninitialized move")(C++17)  
[uninitialized_fill](../memory/uninitialized_fill.html "cpp/memory/uninitialized fill")  
  
  
  
| [uninitialized_copy_n](../memory/uninitialized_copy_n.html "cpp/memory/uninitialized copy n")(C++11)  
---  
[uninitialized_move_n](../memory/uninitialized_move_n.html "cpp/memory/uninitialized move n")(C++17)  
[uninitialized_fill_n](../memory/uninitialized_fill_n.html "cpp/memory/uninitialized fill n")  
  
  
  
|  | [destroy](../memory/destroy.html "cpp/memory/destroy")(C++17)  
---  
[destroy_n](../memory/destroy_n.html "cpp/memory/destroy n")(C++17)  
[destroy_at](../memory/destroy_at.html "cpp/memory/destroy at")(C++17)  
[construct_at](../memory/construct_at.html "cpp/memory/construct at")(C++20)  
  
| [uninitialized_default_construct](../memory/uninitialized_default_construct.html "cpp/memory/uninitialized default construct")(C++17)  
---  
[uninitialized_value_construct](../memory/uninitialized_value_construct.html "cpp/memory/uninitialized value construct")(C++17)  
[uninitialized_default_construct_n](../memory/uninitialized_default_construct_n.html "cpp/memory/uninitialized default construct n")(C++17)  
[uninitialized_value_construct_n](../memory/uninitialized_value_construct_n.html "cpp/memory/uninitialized value construct n")(C++17)  
  


Defined in header `[<algorithm>](../header/algorithm.html "cpp/header/algorithm")` |  |   
---|---|---  
| (1) |   
template< class ForwardIt, class T >  
ForwardIt upper_bound( ForwardIt first, ForwardIt last,  
const T& value ); |  | (constexpr since C++20)   
(until C++26)  
template< class ForwardIt, class T = typename [std::iterator_traits](../iterator/iterator_traits.html)  
<ForwardIt>::value_type >  
constexpr ForwardIt upper_bound( ForwardIt first, ForwardIt last,  
const T& value ); |  |  (since C++26)  
| (2) |   
template< class ForwardIt, class T, class Compare >  
ForwardIt upper_bound( ForwardIt first, ForwardIt last,  
const T& value, Compare comp ); |  | (constexpr since C++20)   
(until C++26)  
template< class ForwardIt, class T = typename [std::iterator_traits](../iterator/iterator_traits.html)  
<ForwardIt>::value_type,  
class Compare >  
constexpr ForwardIt upper_bound( ForwardIt first, ForwardIt last,  
const T& value, Compare comp ); |  |  (since C++26)  
| |   
  
Searches for the first element in the partitioned range `[`first`, `last`)` which is ordered after value. 

1) The order is determined by operator<:  Returns the first iterator iter in `[`first`, `last`)` where bool(value < *iter) is true, or last if no such iter exists. If the elements elem of `[`first`, `last`)` are not [partitioned](../algorithm.html#Requirements "cpp/algorithm") with respect to the expression bool(value < elem), the behavior is undefined.  | (until C++20)  
---|---  
Equivalent to std::upper_bound(first, last, value, [std::less](../utility/functional/less.html){}).  | (since C++20)  
  
2) The order is determined by comp:

Returns the first iterator iter in `[`first`, `last`)` where bool(comp(value, *iter)) is true, or last if no such iter exists.

If the elements elem of `[`first`, `last`)` are not [partitioned](../algorithm.html#Requirements "cpp/algorithm") with respect to the expression bool(comp(value, elem)), the behavior is undefined.

## Contents

  * [1 Parameters](upper_bound.html#Parameters)
  * [2 Return value](upper_bound.html#Return_value)
  * [3 Complexity](upper_bound.html#Complexity)
  * [4 Possible implementation](upper_bound.html#Possible_implementation)
  * [5 Notes](upper_bound.html#Notes)
  * [6 Example](upper_bound.html#Example)
  * [7 Defect reports](upper_bound.html#Defect_reports)
  * [8 See also](upper_bound.html#See_also)

  
---  
  
### Parameters

first, last  |  \-  |  the pair of iterators defining the partitioned [range](../iterator.html#Ranges "cpp/iterator") of elements to examine   
---|---|---  
value  |  \-  |  value to compare the elements to   
comp  |  \-  |  binary predicate which returns ​true if the first argument is ordered before the second.   
The signature of the predicate function should be equivalent to the following:  bool pred(const Type1 &a, const Type2 &b); While the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) `Type1` and `Type2` regardless of [value category](../language/value_category.html "cpp/language/value category") (thus, Type1 & is not allowed, nor is Type1 unless for `Type1` a move is equivalent to a copy(since C++11)).  
The type Type1 must be such that an object of type T can be implicitly converted to Type1. The type Type2 must be such that an object of type ForwardIt can be dereferenced and then implicitly converted to Type2. ​   
Type requirements   
-`ForwardIt` must meet the requirements of [LegacyForwardIterator](../named_req/ForwardIterator.html "cpp/named req/ForwardIterator").   
-`Compare` must meet the requirements of [BinaryPredicate](../named_req/BinaryPredicate.html "cpp/named req/BinaryPredicate"). It is not required to satisfy [Compare](../named_req/Compare.html "cpp/named req/Compare").   
  
### Return value

Iterator to the first element of the range `[`first`, `last`)` ordered after value, or last if no such element is found. 

### Complexity

Given \\(\scriptsize N\\)N as [std::distance](../iterator/distance.html)(first, last): 

1) At most \\(\scriptsize \log_{2}(N)+O(1)\\)log2(N)+O(1) comparisons with value using operator<(until C++20)[std::less](../utility/functional/less.html){}(since C++20).

2) At most \\(\scriptsize \log_{2}(N)+O(1)\\)log2(N)+O(1) applications of the comparator comp.

However, if `ForwardIt` is not a [LegacyRandomAccessIterator](../named_req/RandomAccessIterator.html "cpp/named req/RandomAccessIterator"), the number of iterator increments is linear in \\(\scriptsize N\\)N. Notably, [std::map](../container/map.html "cpp/container/map"), [std::multimap](../container/multimap.html "cpp/container/multimap"), [std::set](../container/set.html "cpp/container/set"), and [std::multiset](../container/multiset.html "cpp/container/multiset") iterators are not random access, and so their member `upper_bound` functions should be preferred. 

### Possible implementation

See also the implementations in [libstdc++](https://github.com/gcc-mirror/gcc/blob/d9375e490072d1aae73a93949aa158fcd2a27018/libstdc%2B%2B-v3/include/bits/stl_algo.h#L2028) and [libc++](https://github.com/llvm/llvm-project/blob/8350d9c23d76fb95f42674a1563cbe8c32582dd5/libcxx/include/__algorithm/upper_bound.h#L35). 

[upper_bound (1)](upper_bound.html#Version_1)  
---  
      
    
    template<class ForwardIt, class T = typename [std::iterator_traits](../iterator/iterator_traits.html)<ForwardIt>::value_type>
    ForwardIt upper_bound(ForwardIt first, ForwardIt last, const T& value)
    {
        return std::upper_bound(first, last, value, [std::less](../utility/functional/less.html){});
    }  
  
[upper_bound (2)](upper_bound.html#Version_2)  
      
    
    template<class ForwardIt, class T = typename [std::iterator_traits](../iterator/iterator_traits.html)<ForwardIt>::value_type,
             class Compare>
    ForwardIt upper_bound(ForwardIt first, ForwardIt last, const T& value, Compare comp)
    {
        ForwardIt it;
        typename [std::iterator_traits](../iterator/iterator_traits.html)<ForwardIt>::difference_type count, step;
        count = [std::distance](../iterator/distance.html)(first, last);
     
        while (count > 0)
        {
            it = first; 
            step = count / 2;
            [std::advance](../iterator/advance.html)(it, step);
     
            if (!comp(value, *it))
            {
                first = ++it;
                count -= step + 1;
            } 
            else
                count = step;
        }
     
        return first;
    }  
  
### Notes

Although `std::upper_bound` only requires `[`first`, `last`)` to be partitioned, this algorithm is usually used in the case where `[`first`, `last`)` is sorted, so that the binary search is valid for any value. 

For any iterator iter in `[`first`, `last`)`, `std::upper_bound` requires value < *iter and comp(value, *iter) to be well-formed, while [std::lower_bound](lower_bound.html "cpp/algorithm/lower bound") requires *iter < value and comp(*iter, value) to be well-formed instead. 

[Feature-test](../utility/feature_test.html "cpp/utility/feature test") macro | Value | Std | Feature   
---|---|---|---  
[`__cpp_lib_algorithm_default_value_type`](../experimental/feature_test.html#cpp_lib_algorithm_default_value_type "cpp/feature test") | [`202403`](../compiler_support/26.html#cpp_lib_algorithm_default_value_type_202403 "cpp/compiler support/26") | (C++26) | [List-initialization](../language/list_initialization.html "cpp/language/list initialization") for algorithms ([1,2](upper_bound.html#Version_1))  
  
### Example

Run this code
    
    
    #include <algorithm>
    #include <cassert>
    #include <complex>
    #include <iostream>
    #include <vector>
     
    struct PriceInfo { double price; };
     
    int main()
    {
        const [std::vector](../container/vector.html)<int> data{1, 2, 4, 5, 5, 6};
     
        for (int i = 0; i < 7; ++i)
        {
            // Search first element that is greater than i
            auto upper = std::upper_bound(data.begin(), data.end(), i);
     
            [std::cout](../io/cout.html) << i << " < ";
            upper != data.end()
                ? [std::cout](../io/cout.html) << *upper << " at index " << [std::distance](../iterator/distance.html)(data.begin(), upper)
                : [std::cout](../io/cout.html) << "not found";
            [std::cout](../io/cout.html) << '\n';
        }
     
        [std::vector](../container/vector.html)<PriceInfo> prices{{100.0}, {101.5}, {102.5}, {102.5}, {107.3}};
     
        for (double to_find : {102.5, 110.2})
        {
            auto prc_info = std::upper_bound(prices.begin(), prices.end(), to_find,
                [](double value, const PriceInfo& info)
                {
                    return value < info.price;
                });
     
            prc_info != prices.end()
                ? [std::cout](../io/cout.html) << prc_info->price << " at index " << prc_info - prices.begin()
                : [std::cout](../io/cout.html) << to_find << " not found";
            [std::cout](../io/cout.html) << '\n';
        }
     
        using CD = [std::complex](../numeric/complex.html)<double>;
        [std::vector](../container/vector.html)<CD> nums{{1, 0}, {2, 2}, {2, 1}, {3, 0}, {3, 1}};
        auto cmpz = [](CD x, CD y) { return x.real() < y.real(); };
        #ifdef __cpp_lib_algorithm_default_value_type
            auto it = std::upper_bound(nums.cbegin(), nums.cend(), {2, 0}, cmpz);
        #else
            auto it = std::upper_bound(nums.cbegin(), nums.cend(), CD{2, 0}, cmpz);
        #endif
        [assert](../error/assert.html)((*it == CD{3, 0}));
    }

Output: 
    
    
    0 < 1 at index 0
    1 < 2 at index 1
    2 < 4 at index 2
    3 < 4 at index 2
    4 < 5 at index 3
    5 < 6 at index 5
    6 < not found 
    107.3 at index 4
    110.2 not found

### Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[LWG 270](https://cplusplus.github.io/LWG/issue270) | C++98  | `Compare` was required to satisfy [Compare](../named_req/Compare.html "cpp/named req/Compare") and `T` was required  
to be [LessThanComparable](../named_req/LessThanComparable.html "cpp/named req/LessThanComparable") (strict weak ordering required)  | only a partitioning is required;  
heterogeneous comparisons permitted   
[LWG 384](https://cplusplus.github.io/LWG/issue384) | C++98  | at most \\(\scriptsize \log(N)+1\\)log2(N)+1 comparisons were allowed  | corrected to \\(\scriptsize \log_{2}(N)+O(1)\\)log2(N)+O(1)  
[LWG 577](https://cplusplus.github.io/LWG/issue577) | C++98  | last could not be returned  | allowed   
[LWG 2150](https://cplusplus.github.io/LWG/issue2150) | C++98  | if any iterator iter exists in `[`first`, `last`)` such that  
bool(comp(value, *iter)) is true, `std::upper_bound`  
could return any iterator in `[`iter`, `last`)` | no iterator after  
iter can be returned   
  
### See also

[ equal_range](equal_range.html "cpp/algorithm/equal range") |  returns range of elements matching a specific key   
(function template)   
---|---  
[ lower_bound](lower_bound.html "cpp/algorithm/lower bound") |  returns an iterator to the first element _not less_ than the given value   
(function template)   
[ partition](partition.html "cpp/algorithm/partition") |  divides a range of elements into two groups   
(function template)   
[ partition_point](partition_point.html "cpp/algorithm/partition point")(C++11) |  locates the partition point of a partitioned range   
(function template)   
[ ranges::upper_bound](ranges/upper_bound.html "cpp/algorithm/ranges/upper bound")(C++20) |  returns an iterator to the first element _greater_ than a certain value  
(algorithm function object)  
[ upper_bound](../container/set/upper_bound.html "cpp/container/set/upper bound") |  returns an iterator to the first element _greater_ than the given key   
(public member function of `std::set<Key,Compare,Allocator>`)   
[ upper_bound](../container/multiset/upper_bound.html "cpp/container/multiset/upper bound") |  returns an iterator to the first element _greater_ than the given key   
(public member function of `std::multiset<Key,Compare,Allocator>`) 
  *[Value]: The year/month in which the feature was adopted. The hyperlink under each value opens a compiler support page with entry for given feature.
  *[Std]: Standard in which the feature is introduced; DR means defect report against that revision
