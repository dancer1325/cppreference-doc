
  


[Utilities library](../utility.html "cpp/utility")

| [Language support](../utility.html#Language_support "cpp/utility")  
---  
[Type support](../utility/rtti.html "cpp/types") (basic types, RTTI)  
[Library feature-test macros](../utility/feature_test.html "cpp/utility/feature test") (C++20)  
[Program utilities](../utility/program.html "cpp/utility/program")  
[Variadic functions](../utility/variadic.html "cpp/utility/variadic")  
[initializer_list](../utility/initializer_list.html "cpp/utility/initializer list")(C++11)  
[is_constant_evaluated](is_constant_evaluated.html "cpp/types/is constant evaluated")(C++20)  
[is_within_lifetime](is_within_lifetime.html "cpp/types/is within lifetime")(C++26)  
[source_location](../utility/source_location.html "cpp/utility/source location")(C++20)  
[Coroutine support](../coroutine.html "cpp/coroutine") (C++20)  
[Contract support](../contract.html "cpp/contract") (C++26)  
[Three-way comparison](../utility.html#Three-way_comparison "cpp/utility")  
[three_way_comparablethree_way_comparable_with](../utility/compare/three_way_comparable.html "cpp/utility/compare/three way comparable")(C++20)(C++20)  
[strong_ordering](../utility/compare/strong_ordering.html "cpp/utility/compare/strong ordering")(C++20)  
[weak_ordering](../utility/compare/weak_ordering.html "cpp/utility/compare/weak ordering")(C++20)  
[partial_ordering](../utility/compare/partial_ordering.html "cpp/utility/compare/partial ordering")(C++20)  
[common_comparison_category](../utility/compare/common_comparison_category.html "cpp/utility/compare/common comparison category")(C++20)  
[compare_three_way_result](../utility/compare/compare_three_way_result.html "cpp/utility/compare/compare three way result")(C++20)  
[compare_three_way](../utility/compare/compare_three_way.html "cpp/utility/compare/compare three way")(C++20)  
[strong_order](../utility/compare/strong_order.html "cpp/utility/compare/strong order")(C++20)  
[weak_order](../utility/compare/weak_order.html "cpp/utility/compare/weak order")(C++20)  
[partial_order](../utility/compare/partial_order.html "cpp/utility/compare/partial order")(C++20)  
[compare_strong_order_fallback](../utility/compare/compare_strong_order_fallback.html "cpp/utility/compare/compare strong order fallback")(C++20)  
[compare_weak_order_fallback](../utility/compare/compare_weak_order_fallback.html "cpp/utility/compare/compare weak order fallback")(C++20)  
[compare_partial_order_fallback](../utility/compare/compare_partial_order_fallback.html "cpp/utility/compare/compare partial order fallback")(C++20)` `  
|  | [is_eqis_ltis_lteq](../utility/compare/named_comparison_functions.html "cpp/utility/compare/named comparison functions")(C++20)(C++20)(C++20)` `  
---  
  
| [is_neqis_gtis_gteq](../utility/compare/named_comparison_functions.html "cpp/utility/compare/named comparison functions")(C++20)(C++20)(C++20)  
---  
  
  
  
  
| General utilities  
---  
| [Function objects](../functional.html "cpp/utility/functional")  
---  
[Bit manipulation](../utility/bit.html "cpp/utility/bit") (C++20)  
[C-style bit manipulation](https://en.cppreference.com/mwiki/index.php?title=cpp/utility/stdbit&action=edit&redlink=1 "cpp/utility/stdbit \(page does not exist\)") (C++26)  
[bitset](../utility/bitset.html "cpp/utility/bitset")  
[hash](../utility/hash.html "cpp/utility/hash")(C++11)  
  
[Relational operators](../utility.html#Relational_operators "cpp/utility") (deprecated in C++20)  
|  | [rel_ops::operator!=rel_ops::operator>](../utility/rel_ops/operator_cmp.html "cpp/utility/rel ops/operator cmp")` `  
---  
  
| [rel_ops::operator<=rel_ops::operator>=](../utility/rel_ops/operator_cmp.html "cpp/utility/rel ops/operator cmp")  
---  
  
[Integer comparison functions](../utility.html#Integer_comparison_functions "cpp/utility")  
| [cmp_equalcmp_lesscmp_less_than](../utility/intcmp.html "cpp/utility/intcmp")(C++20)(C++20)(C++20)` `  
---  
  
| [cmp_not_equalcmp_greatercmp_greater_than](../utility/intcmp.html "cpp/utility/intcmp")(C++20)(C++20)(C++20)  
---  
  
[in_range](../utility/in_range.html "cpp/utility/in range")(C++20)  
[Swap](../utility.html#Swap "cpp/utility") and [type operations](../utility.html#Type_operations "cpp/utility")  
| [swap](../utility/swap.html "cpp/algorithm/swap")  
---  
[ranges::swap](../utility/ranges/swap.html "cpp/utility/ranges/swap")(C++20)  
[exchange](../utility/exchange.html "cpp/utility/exchange")(C++14)  
[declval](../utility/declval.html "cpp/utility/declval")(C++11)  
[to_underlying](../utility/to_underlying.html "cpp/utility/to underlying")(C++23)  
  
| [forward](../utility/forward.html "cpp/utility/forward")(C++11)  
---  
[forward_like](../utility/forward_like.html "cpp/utility/forward like")(C++23)  
[move](../utility/move.html "cpp/utility/move")(C++11)  
[move_if_noexcept](../utility/move_if_noexcept.html "cpp/utility/move if noexcept")(C++11)  
[as_const](../utility/as_const.html "cpp/utility/as const")(C++17)  
  
Common vocabulary types  
| [pair](../utility/pair.html "cpp/utility/pair")  
---  
[tuple](../utility/tuple.html "cpp/utility/tuple")(C++11)  
[optional](../utility/optional.html "cpp/utility/optional")(C++17)  
[any](../utility/any.html "cpp/utility/any")(C++17)  
[variant](../utility/variant.html "cpp/utility/variant")(C++17)  
  
| [tuple_size](../utility/tuple_size.html "cpp/utility/tuple size")(C++11)  
---  
[tuple_element](../utility/tuple_element.html "cpp/utility/tuple element")(C++11)  
[apply](../utility/apply.html "cpp/utility/apply")(C++17)  
[make_from_tuple](../utility/make_from_tuple.html "cpp/utility/make from tuple")(C++17)  
[expected](../utility/expected.html "cpp/utility/expected")(C++23)  
  
  
  
  
  
  


[Type support](../utility/rtti.html "cpp/types")

Basic types  
---  
[Fixed width integer types](integer.html "cpp/types/integer") (C++11)  
[Fixed width floating-point types](floating-point.html "cpp/types/floating-point") (C++23)  
| [ptrdiff_t](ptrdiff_t.html "cpp/types/ptrdiff t")  
---  
[size_t](size_t.html "cpp/types/size t")  
[max_align_t](max_align_t.html "cpp/types/max align t")(C++11)  
[byte](byte.html "cpp/types/byte")(C++17)  
  
| [nullptr_t](nullptr_t.html "cpp/types/nullptr t")(C++11)  
---  
[offsetof](offsetof.html "cpp/types/offsetof")  
[NULL](NULL.html "cpp/types/NULL")  
  
  
  
Numeric limits  
[numeric_limits](numeric_limits.html "cpp/types/numeric limits")  
**C numeric limits interface**  
Runtime type information  
| [type_info](type_info.html "cpp/types/type info")  
---  
[type_index](type_index.html "cpp/types/type index")(C++11)  
  
| [bad_typeid](bad_typeid.html "cpp/types/bad typeid")  
---  
[bad_cast](bad_cast.html "cpp/types/bad cast")  
  


See also [std::numeric_limits](numeric_limits.html "cpp/types/numeric limits") interface. 

## Contents

  * [1 Limits of integer types](climits.html#Limits_of_integer_types)
    * [1.1 Limits of core language integer types](climits.html#Limits_of_core_language_integer_types)
    * [1.2 Limits of library type aliases](climits.html#Limits_of_library_type_aliases)
    * [1.3 Notes](climits.html#Notes)
    * [1.4 Example](climits.html#Example)
  * [2 Limits of floating-point types](climits.html#Limits_of_floating-point_types)
    * [2.1 Example](climits.html#Example_2)
  * [3 Defect reports](climits.html#Defect_reports)
  * [4 See also](climits.html#See_also)

  
---  
  
### Limits of integer types

#####  Limits of core language integer types   
  
---  
Defined in header `[<climits>](../header/climits.html "cpp/header/climits")`  
CHAR_BIT |  bit width of byte   
(macro constant)   
MB_LEN_MAX |  maximum number of bytes in a multibyte character   
(macro constant)   
CHAR_MIN |  minimum value of char   
(macro constant)   
CHAR_MAX |  maximum value of char   
(macro constant)   
SCHAR_MINSHRT_MININT_MINLONG_MINLLONG_MIN(C++11) |  minimum value of signed char, short, int, long and long long respectively   
(macro constant)   
SCHAR_MAXSHRT_MAXINT_MAXLONG_MAXLLONG_MAX(C++11) |  maximum value of signed char, short, int, long and long long respectively   
(macro constant)   
UCHAR_MAXUSHRT_MAXUINT_MAXULONG_MAXULLONG_MAX(C++11) |  maximum value of unsigned char, unsigned short, unsigned int,  
unsigned long and unsigned long long respectively   
(macro constant)   
Defined in header `[<cwchar>](../header/cwchar.html "cpp/header/cwchar")`  
Defined in header `[<cstdint>](../header/cstdint.html "cpp/header/cstdint")`  
WCHAR_MIN(C++11) |  minimum value of wchar_t   
(macro constant)   
WCHAR_MAX(C++11) |  maximum value of wchar_t   
(macro constant)   
  
#####  Limits of library type aliases   
  
Defined in header `[<cstdint>](../header/cstdint.html "cpp/header/cstdint")`  
PTRDIFF_MIN(C++11) |  minimum value of [std::ptrdiff_t](ptrdiff_t.html "cpp/types/ptrdiff t")   
(macro constant)   
PTRDIFF_MAX(C++11) |  maximum value of [std::ptrdiff_t](ptrdiff_t.html "cpp/types/ptrdiff t")   
(macro constant)   
SIZE_MAX(C++11) |  maximum value of [std::size_t](size_t.html "cpp/types/size t")   
(macro constant)   
SIG_ATOMIC_MIN(C++11) |  minimum value of [std::sig_atomic_t](../utility/program/sig_atomic_t.html "cpp/utility/program/sig atomic t")   
(macro constant)   
SIG_ATOMIC_MAX(C++11) |  maximum value of [std::sig_atomic_t](../utility/program/sig_atomic_t.html "cpp/utility/program/sig atomic t")   
(macro constant)   
WINT_MIN(C++11) |  minimum value of [`std::wint_t`](../string/wide.html#Types "cpp/string/wide")   
(macro constant)   
WINT_MAX(C++11) |  maximum value of [`std::wint_t`](../string/wide.html#Types "cpp/string/wide")   
(macro constant)   
  
#### Notes

The types of these constants, other than CHAR_BIT and MB_LEN_MAX, are required to match the results of the [integral promotions](../language/implicit_cast.html#Integral_promotion "cpp/language/implicit conversion") as applied to objects of the types they describe: CHAR_MAX may have type int or unsigned int, but never char. Similarly USHRT_MAX may not be of an unsigned type: its type may be int. 

A [freestanding](../freestanding.html "cpp/freestanding") implementation may lack [std::sig_atomic_t](../utility/program/sig_atomic_t.html "cpp/utility/program/sig atomic t") and/or [`std::wint_t`](../string/wide.html#Types "cpp/string/wide") typedef names, in which case the `SIG_ATOMIC_*` and/or `WINT_*` macros are correspondingly absent. 

#### Example

Run this code
    
    
    #include <climits>
    #include <cstdint>
    #include <iomanip>
    #include <iostream>
     
    int main()
    {
        constexpr int w = 14;
        [std::cout](../io/cout.html) << [std::left](../io/manip/left.html);
    #   define COUT(x) std::cout << std::setw(w) << #x << " = " << x << '\n'
     
        COUT( CHAR_BIT       );
        COUT( MB_LEN_MAX     );
        COUT( CHAR_MIN       );
        COUT( CHAR_MAX       );
        COUT( SCHAR_MIN      );
        COUT( SHRT_MIN       );
        COUT( INT_MIN        );
        COUT( LONG_MIN       );
        COUT( LLONG_MIN      );
        COUT( SCHAR_MAX      );
        COUT( SHRT_MAX       );
        COUT( INT_MAX        );
        COUT( LONG_MAX       );
        COUT( LLONG_MAX      );
        COUT( UCHAR_MAX      );
        COUT( USHRT_MAX      );
        COUT( UINT_MAX       );
        COUT( ULONG_MAX      );
        COUT( ULLONG_MAX     );
        COUT( PTRDIFF_MIN    );
        COUT( PTRDIFF_MAX    );
        COUT( SIZE_MAX       );
        COUT( SIG_ATOMIC_MIN );
        COUT( SIG_ATOMIC_MAX );
        COUT( WCHAR_MIN      );
        COUT( WCHAR_MAX      );
        COUT( WINT_MIN       );
        COUT( WINT_MAX       );
    }

Possible output: 
    
    
    CHAR_BIT       = 8
    MB_LEN_MAX     = 16
    CHAR_MIN       = -128
    CHAR_MAX       = 127
    SCHAR_MIN      = -128
    SHRT_MIN       = -32768
    INT_MIN        = -2147483648
    LONG_MIN       = -9223372036854775808
    LLONG_MIN      = -9223372036854775808
    SCHAR_MAX      = 127
    SHRT_MAX       = 32767
    INT_MAX        = 2147483647
    LONG_MAX       = 9223372036854775807
    LLONG_MAX      = 9223372036854775807
    UCHAR_MAX      = 255
    USHRT_MAX      = 65535
    UINT_MAX       = 4294967295
    ULONG_MAX      = 18446744073709551615
    ULLONG_MAX     = 18446744073709551615
    PTRDIFF_MIN    = -9223372036854775808
    PTRDIFF_MAX    = 9223372036854775807
    SIZE_MAX       = 18446744073709551615
    SIG_ATOMIC_MIN = -2147483648
    SIG_ATOMIC_MAX = 2147483647
    WCHAR_MIN      = -2147483648
    WCHAR_MAX      = 2147483647
    WINT_MIN       = 0
    WINT_MAX       = 4294967295

### Limits of floating-point types

Defined in header `[<cfloat>](../header/cfloat.html "cpp/header/cfloat")`  
---  
FLT_RADIX |  the radix (integer base) used by the representation of all three floating-point types   
(macro constant)   
DECIMAL_DIG(C++11) |  conversion from long double to decimal with at least DECIMAL_DIG digits and back to long double is the identity conversion: this is the decimal precision required to serialize/deserialize a long double (see also [std::numeric_limits::max_digits10](numeric_limits/max_digits10.html "cpp/types/numeric limits/max digits10"))   
(macro constant)   
FLT_DECIMAL_DIGDBL_DECIMAL_DIGLDBL_DECIMAL_DIG(C++17) |  conversion from float/double/long double to decimal with at least FLT_DECIMAL_DIG/DBL_DECIMAL_DIG/LDBL_DECIMAL_DIG digits and back is the identity conversion: this is the decimal precision required to serialize/deserialize a floating-point value (see also [std::numeric_limits::max_digits10](numeric_limits/max_digits10.html "cpp/types/numeric limits/max digits10")). Defined to at least 6, 10, and 10 respectively, or 9 for IEEE float and 17 for IEEE double.   
(macro constant)   
FLT_MINDBL_MINLDBL_MIN |  minimum normalized positive value of float, double and long double respectively   
(macro constant)   
FLT_TRUE_MINDBL_TRUE_MINLDBL_TRUE_MIN(C++17) |  minimum positive value of float, double and long double respectively   
(macro constant)   
FLT_MAXDBL_MAXLDBL_MAX |  maximum finite value of float, double and long double respectively   
(macro constant)   
FLT_EPSILONDBL_EPSILONLDBL_EPSILON |  difference between 1.0 and the next representable value for float, double and long double respectively   
(macro constant)   
FLT_DIGDBL_DIGLDBL_DIG |  number of decimal digits that are guaranteed to be preserved in text → float/double/long double → text roundtrip without change due to rounding or overflow (see [std::numeric_limits::digits10](numeric_limits/digits10.html "cpp/types/numeric limits/digits10") for explanation)   
(macro constant)   
FLT_MANT_DIGDBL_MANT_DIGLDBL_MANT_DIG |  number of base FLT_RADIX digits that can be represented without losing precision for float, double and long double respectively   
(macro constant)   
FLT_MIN_EXPDBL_MIN_EXPLDBL_MIN_EXP |  minimum negative integer such that FLT_RADIX raised by power one less than that integer is a normalized float, double and long double respectively   
(macro constant)   
FLT_MIN_10_EXPDBL_MIN_10_EXPLDBL_MIN_10_EXP |  minimum negative integer such that 10 raised to that power is a normalized float, double and long double respectively   
(macro constant)   
FLT_MAX_EXPDBL_MAX_EXPLDBL_MAX_EXP |  maximum positive integer such that FLT_RADIX raised by power one less than that integer is a representable finite float, double and long double respectively   
(macro constant)   
FLT_MAX_10_EXPDBL_MAX_10_EXPLDBL_MAX_10_EXP |  maximum positive integer such that 10 raised to that power is a representable finite float, double and long double respectively   
(macro constant)   
[ FLT_ROUNDS](climits/FLT_ROUNDS.html "cpp/types/climits/FLT ROUNDS") |  default rounding mode of floating-point arithmetic   
(macro constant)   
[ FLT_EVAL_METHOD](climits/FLT_EVAL_METHOD.html "cpp/types/climits/FLT EVAL METHOD")(C++11) |  specifies in what precision all arithmetic operations are done   
(macro constant)   
FLT_HAS_SUBNORMDBL_HAS_SUBNORMLDBL_HAS_SUBNORM(C++17) |  specifies whether the type supports subnormal ([denormal](https://en.wikipedia.org/wiki/Denormal_number "enwiki:Denormal number")) numbers:  
-1 – indeterminable, ​0​ – absent, 1 – present   
(macro constant)   
  
#### Example

Run this code
    
    
    #include <cfloat>
    #include <iomanip>
    #include <iostream>
     
    int main()
    {
        int w = 16;
        [std::cout](../io/cout.html) << [std::left](../io/manip/left.html); // std::cout << std::setprecision(53);
    #   define COUT(x) std::cout << std::setw(w) << #x << " = " << x << '\n'
     
        COUT( FLT_RADIX        );
        COUT( DECIMAL_DIG      );
        COUT( FLT_DECIMAL_DIG  );
        COUT( DBL_DECIMAL_DIG  );
        COUT( LDBL_DECIMAL_DIG );
        COUT( FLT_MIN          );
        COUT( DBL_MIN          );
        COUT( LDBL_MIN         );
        COUT( FLT_TRUE_MIN     );
        COUT( DBL_TRUE_MIN     );
        COUT( LDBL_TRUE_MIN    );
        COUT( FLT_MAX          );
        COUT( DBL_MAX          );
        COUT( LDBL_MAX         );
        COUT( FLT_EPSILON      );
        COUT( DBL_EPSILON      );
        COUT( LDBL_EPSILON     );
        COUT( FLT_DIG          );
        COUT( DBL_DIG          );
        COUT( LDBL_DIG         );
        COUT( FLT_MANT_DIG     );
        COUT( DBL_MANT_DIG     );
        COUT( LDBL_MANT_DIG    );
        COUT( FLT_MIN_EXP      );
        COUT( DBL_MIN_EXP      );
        COUT( LDBL_MIN_EXP     );
        COUT( FLT_MIN_10_EXP   );
        COUT( DBL_MIN_10_EXP   );
        COUT( LDBL_MIN_10_EXP  );
        COUT( FLT_MAX_EXP      );
        COUT( DBL_MAX_EXP      );
        COUT( LDBL_MAX_EXP     );
        COUT( FLT_MAX_10_EXP   );
        COUT( DBL_MAX_10_EXP   );
        COUT( LDBL_MAX_10_EXP  );
        COUT( [FLT_ROUNDS](climits/FLT_ROUNDS.html)       );
        COUT( [FLT_EVAL_METHOD](climits/FLT_EVAL_METHOD.html)  );
        COUT( FLT_HAS_SUBNORM  );
        COUT( DBL_HAS_SUBNORM  );
        COUT( LDBL_HAS_SUBNORM );
    }

Possible output: 
    
    
    FLT_RADIX        = 2
    DECIMAL_DIG      = 21
    FLT_DECIMAL_DIG  = 9
    DBL_DECIMAL_DIG  = 17
    LDBL_DECIMAL_DIG = 21
    FLT_MIN          = 1.17549e-38
    DBL_MIN          = 2.22507e-308
    LDBL_MIN         = 3.3621e-4932
    FLT_TRUE_MIN     = 1.4013e-45
    DBL_TRUE_MIN     = 4.94066e-324
    LDBL_TRUE_MIN    = 3.6452e-4951
    FLT_MAX          = 3.40282e+38
    DBL_MAX          = 1.79769e+308
    LDBL_MAX         = 1.18973e+4932
    FLT_EPSILON      = 1.19209e-07
    DBL_EPSILON      = 2.22045e-16
    LDBL_EPSILON     = 1.0842e-19
    FLT_DIG          = 6
    DBL_DIG          = 15
    LDBL_DIG         = 18
    FLT_MANT_DIG     = 24
    DBL_MANT_DIG     = 53
    LDBL_MANT_DIG    = 64
    FLT_MIN_EXP      = -125
    DBL_MIN_EXP      = -1021
    LDBL_MIN_EXP     = -16381
    FLT_MIN_10_EXP   = -37
    DBL_MIN_10_EXP   = -307
    LDBL_MIN_10_EXP  = -4931
    FLT_MAX_EXP      = 128
    DBL_MAX_EXP      = 1024
    LDBL_MAX_EXP     = 16384
    FLT_MAX_10_EXP   = 38
    DBL_MAX_10_EXP   = 308
    LDBL_MAX_10_EXP  = 4932
    FLT_ROUNDS       = 1
    FLT_EVAL_METHOD  = 0
    FLT_HAS_SUBNORM  = 1
    DBL_HAS_SUBNORM  = 1
    LDBL_HAS_SUBNORM = 1

### Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[LWG 416](https://cplusplus.github.io/LWG/issue416) | C++98  | it was unclear whether the types of the macros in [`<climits>`](../header/climits.html "cpp/header/climits") are guaranteed  
to match the type to which they refer (C++ refers to C, and C says no)  | clarified as not  
guaranteed   
  
### See also

  * [Fixed width integer types](integer.html "cpp/types/integer")
  * [Arithmetic types](../language/types.html "cpp/language/types")
  * [C++ type system overview](../language/type-id.html "cpp/language/type")
  * [Type support (basic types, RTTI, type traits)](../utility/rtti.html "cpp/types")

[C documentation](../../c/types/limits.html "c/types/limits") for Numeric limits  
---
