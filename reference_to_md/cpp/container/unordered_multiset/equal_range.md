[[edit template]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/container/equal_range_unord&action=edit)

[C++](../../../cpp.html "cpp")

[Compiler support](../../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../../freestanding.html "cpp/freestanding")  
[Language](../../language.html "cpp/language")  
[Standard library](../../standard_library.html "cpp/standard library")  
[Standard library headers](../../headers.html "cpp/header")  
[Named requirements](../../iterator/concepts.html "cpp/named req")  
[Feature test macros](../../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../../utility.html#Language_support "cpp/utility")  
[Concepts library](../../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../../error.html "cpp/error")  
[Memory management library](../../memory.html "cpp/memory")  
[Metaprogramming library](../../meta.html "cpp/meta") (C++11)  
[General utilities library](../../utility.html "cpp/utility")  
[Containers library](../../container.html "cpp/container")  
[Iterators library](../../iterator.html "cpp/iterator")  
[Ranges library](../../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../../algorithm.html "cpp/algorithm")  
[Strings library](../../string.html "cpp/string")  
[Text processing library](../../text.html "cpp/text")  
[Numerics library](../../numeric.html "cpp/numeric")  
[Date and time library](../../chrono.html "cpp/chrono")  
[Input/output library](../../io.html "cpp/io")  
[Filesystem library](../../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../../atomic.html "cpp/thread") (C++11)  
[Execution control library](../../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../../experimental.html "cpp/experimental")  
[Symbols index](../../symbol_index.html "cpp/symbol index")  
[External libraries](../../links/libs.html "cpp/links/libs")  
  


[Containers library](../../container.html "cpp/container")

[_node-handle_](../node_handle.html "cpp/container/node handle")(C++17)  
---  
[Sequence](../../container.html#Sequence_containers "cpp/container")  
[array](../array.html "cpp/container/array")(C++11)  
[vector](../vector.html "cpp/container/vector")  
[vector<bool>](../vector_bool.html "cpp/container/vector bool")  
[inplace_vector](../inplace_vector.html "cpp/container/inplace vector")(C++26)  
[hive](https://en.cppreference.com/mwiki/index.php?title=cpp/container/hive&action=edit&redlink=1 "cpp/container/hive \(page does not exist\)")(C++26)  
[deque](../deque.html "cpp/container/deque")  
[forward_list](../forward_list.html "cpp/container/forward list")(C++11)  
[list](../list.html "cpp/container/list")  
[Associative](../../container.html#Associative_containers "cpp/container")  
[set](../set.html "cpp/container/set")  
[multiset](../multiset.html "cpp/container/multiset")  
[map](../map.html "cpp/container/map")  
[multimap](../multimap.html "cpp/container/multimap")  
[Unordered associative](../../container.html#Unordered_associative_containers "cpp/container")  
[unordered_set](../unordered_set.html "cpp/container/unordered set")(C++11)  
[unordered_multiset](../unordered_multiset.html "cpp/container/unordered multiset")(C++11)  
[unordered_map](../unordered_map.html "cpp/container/unordered map")(C++11)  
[unordered_multimap](../unordered_multimap.html "cpp/container/unordered multimap")(C++11)  
[Adaptors](../../container.html#Container_adaptors "cpp/container")  
[stack](../stack.html "cpp/container/stack")  
[queue](../queue.html "cpp/container/queue")  
[priority_queue](../priority_queue.html "cpp/container/priority queue")  
[flat_set](../flat_set.html "cpp/container/flat set")(C++23)  
[flat_multiset](../flat_multiset.html "cpp/container/flat multiset")(C++23)  
[flat_map](../flat_map.html "cpp/container/flat map")(C++23)  
[flat_multimap](../flat_multimap.html "cpp/container/flat multimap")(C++23)  
[Views](../../container.html#Views "cpp/container")  
[span](../span.html "cpp/container/span")(C++20)  
[mdspan](../mdspan.html "cpp/container/mdspan")(C++23)  
Tables  
[Iterator invalidation](../../container.html#Iterator_invalidation "cpp/container")  
[Member function table](../../container.html#Member_function_table "cpp/container")  
[Non-member function table](../../container.html#Non-member_function_table "cpp/container")  
  


`[std::unordered_multiset](../unordered_multiset.html "cpp/container/unordered multiset")`

[Member types](../unordered_multiset.html#Member_types "cpp/container/unordered multiset")  
---  
[Member functions](../unordered_multiset.html#Member_functions "cpp/container/unordered multiset")  
| [unordered_multiset::unordered_multiset](unordered_multiset.html "cpp/container/unordered multiset/unordered multiset")  
---  
[unordered_multiset::~unordered_multiset](~unordered_multiset.html "cpp/container/unordered multiset/~unordered multiset")` `  
[unordered_multiset::operator=](operator=.html "cpp/container/unordered multiset/operator=")  
[unordered_multiset::get_allocator](get_allocator.html "cpp/container/unordered multiset/get allocator")  
[Iterators](../unordered_multiset.html#Iterators "cpp/container/unordered multiset")  
[unordered_multiset::beginunordered_multiset::cbegin](begin.html "cpp/container/unordered multiset/begin")  
[unordered_multiset::endunordered_multiset::cend](end.html "cpp/container/unordered multiset/end")  
[Capacity](../unordered_multiset.html#Capacity "cpp/container/unordered multiset")  
[unordered_multiset::size](size.html "cpp/container/unordered multiset/size")  
[unordered_multiset::max_size](max_size.html "cpp/container/unordered multiset/max size")  
[unordered_multiset::empty](empty.html "cpp/container/unordered multiset/empty")  
[Modifiers](../unordered_multiset.html#Modifiers "cpp/container/unordered multiset")  
[unordered_multiset::clear](clear.html "cpp/container/unordered multiset/clear")  
[unordered_multiset::insert](insert.html "cpp/container/unordered multiset/insert")  
[unordered_multiset::insert_range](insert_range.html "cpp/container/unordered multiset/insert range")(C++23)  
[unordered_multiset::emplace](emplace.html "cpp/container/unordered multiset/emplace")  
[unordered_multiset::emplace_hint](emplace_hint.html "cpp/container/unordered multiset/emplace hint")  
[unordered_multiset::erase](erase.html "cpp/container/unordered multiset/erase")  
[unordered_multiset::swap](swap.html "cpp/container/unordered multiset/swap")  
[unordered_multiset::extract](extract.html "cpp/container/unordered multiset/extract")(C++17)  
[unordered_multiset::merge](merge.html "cpp/container/unordered multiset/merge")(C++17)  
  
| [Lookup](../unordered_multiset.html#Lookup "cpp/container/unordered multiset")  
---  
[unordered_multiset::count](count.html "cpp/container/unordered multiset/count")  
[unordered_multiset::find](find.html "cpp/container/unordered multiset/find")  
[unordered_multiset::contains](contains.html "cpp/container/unordered multiset/contains")(C++20)  
**unordered_multiset::equal_range**  
[Bucket interface](../unordered_multiset.html#Bucket_interface "cpp/container/unordered multiset")  
[unordered_multiset::begin(size_type)unordered_multiset::cbegin(size_type)](begin2.html "cpp/container/unordered multiset/begin2")  
[unordered_multiset::end(size_type)unordered_multiset::cend(size_type)](end2.html "cpp/container/unordered multiset/end2")  
[unordered_multiset::bucket_count](bucket_count.html "cpp/container/unordered multiset/bucket count")  
[unordered_multiset::max_bucket_count](max_bucket_count.html "cpp/container/unordered multiset/max bucket count")  
[unordered_multiset::bucket_size](bucket_size.html "cpp/container/unordered multiset/bucket size")  
[unordered_multiset::bucket](bucket.html "cpp/container/unordered multiset/bucket")  
[Hash policy](../unordered_multiset.html#Hash_policy "cpp/container/unordered multiset")  
[unordered_multiset::load_factor](load_factor.html "cpp/container/unordered multiset/load factor")  
[unordered_multiset::max_load_factor](max_load_factor.html "cpp/container/unordered multiset/max load factor")  
[unordered_multiset::rehash](rehash.html "cpp/container/unordered multiset/rehash")  
[unordered_multiset::reserve](reserve.html "cpp/container/unordered multiset/reserve")  
[Observers](../unordered_multiset.html#Observers "cpp/container/unordered multiset")  
[unordered_multiset::hash_function](hash_function.html "cpp/container/unordered multiset/hash function")  
[unordered_multiset::key_eq](key_eq.html "cpp/container/unordered multiset/key eq")  
  
[Non-member functions](../unordered_multiset.html#Non-member_functions "cpp/container/unordered multiset")  
| [operator==operator!=](operator_cmp.html "cpp/container/unordered multiset/operator cmp")(until C++20)  
---  
  
| [std::swap(std::unordered_multiset)](swap2.html "cpp/container/unordered multiset/swap2")  
---  
[erase_if(std::unordered_multiset)](erase_if.html "cpp/container/unordered multiset/erase if")(C++20)  
  
[Deduction guides](deduction_guides.html "cpp/container/unordered multiset/deduction guides") (C++17)  
  


[std::pair](../../utility/pair.html)<iterator, iterator> equal_range( const Key& key ); |  (1)  |  (since C++11)  
---|---|---  
[std::pair](../../utility/pair.html)<const_iterator, const_iterator> equal_range( const Key& key ) const; |  (2)  |  (since C++11)  
template< class K >  
[std::pair](../../utility/pair.html)<iterator, iterator> equal_range( const K& x ); |  (3)  |  (since C++20)  
template< class K >  
[std::pair](../../utility/pair.html)<const_iterator, const_iterator> equal_range( const K& x ) const; |  (4)  |  (since C++20)  
| |   
  
1,2) Returns a range containing all elements with key key in the container. The range is defined by two iterators, the first pointing to the first element of the wanted range and the second pointing past the last element of the range.

3,4) Returns a range containing all elements in the container with key equivalent to x. This overload participates in overload resolution only if `Hash` and `KeyEqual` are both [transparent](../../functional.html#Transparent_function_objects "cpp/utility/functional"). This assumes that such `Hash` is callable with both `K` and `Key` type, and that the `KeyEqual` is transparent, which, together, allows calling this function without constructing an instance of `Key`.

## Contents

  * [1 Parameters](equal_range.html#Parameters)
  * [2 Return value](equal_range.html#Return_value)
  * [3 Complexity](equal_range.html#Complexity)
  * [4 Notes](equal_range.html#Notes)
  * [5 Example](equal_range.html#Example)
  * [6 See also](equal_range.html#See_also)

  
---  
  
### Parameters

key  |  \-  |  key value to compare the elements to   
---|---|---  
x  |  \-  |  a value of any type that can be transparently compared with a key   
  
### Return value

[std::pair](../../utility/pair.html "cpp/utility/pair") containing a pair of iterators defining the wanted range. If there are no such elements, past-the-end (see [end()](end.html "cpp/container/unordered multiset/end")) iterators are returned as both elements of the pair. 

### Complexity

Average case linear in the number of elements with the key key, worst case linear in the size of the container. 

### Notes

[Feature-test](../../utility/feature_test.html "cpp/utility/feature test") macro | Value | Std | Feature   
---|---|---|---  
[`__cpp_lib_generic_unordered_lookup`](../../experimental/feature_test.html#cpp_lib_generic_unordered_lookup "cpp/feature test") | [`201811L`](../../compiler_support/20.html#cpp_lib_generic_unordered_lookup_201811L "cpp/compiler support/20") | (C++20) | Heterogeneous comparison lookup in [unordered associative containers](../../container.html#Unordered_associative_containers_.28since_C.2B.2B11.29 "cpp/container"), overloads (3,4)  
  
### Example

Estimates the characters frequency for given string.

Run this code
    
    
    #include <iostream>
    #include <iterator>
    #include <string>
    #include <unordered_set>
     
    int main()
    {
        [std::string](../../string/basic_string.html) sentence{"cppreference.com"};
        [std::cout](../../io/cout.html) << "The sentence: " << sentence << '\n';
     
        [std::unordered_multiset](../unordered_multiset.html)<char> sequence;
        for (char x : sentence)
            sequence.insert(x);
     
        [std::cout](../../io/cout.html) << "The sequence: { ";
        for (char x : sequence)
            [std::cout](../../io/cout.html) << x << ' ';
     
        [std::cout](../../io/cout.html) << "}\n" "Symbol:Frequency: ";
        for (auto it = sequence.begin(); it != sequence.end();)
        {
            if (auto [first, last] = sequence.equal_range(*it); first != last)
            {
                [std::cout](../../io/cout.html) << *first << ":" << [std::distance](../../iterator/distance.html)(first, last) << "  ";
                it = last;
            }
            else
                ++it;
        }
    }

Possible output: 
    
    
    The sentence: cppreference.com
    The sequence: { m o c c c p p r r e e e e f n . }
    Symbol:Frequency: m:1  o:1  c:3  p:2  r:2  e:4  f:1  n:1  .:1

### See also

[ find](find.html "cpp/container/unordered multiset/find") |  finds element with specific key   
(public member function)   
---|---  
[ contains](contains.html "cpp/container/unordered multiset/contains")(C++20) |  checks if the container contains element with specific key   
(public member function)   
[ count](count.html "cpp/container/unordered multiset/count") |  returns the number of elements matching specific key   
(public member function)   
[ equal_range](../../algorithm/equal_range.html "cpp/algorithm/equal range") |  returns range of elements matching a specific key   
(function template) 
  *[Value]: The year/month in which the feature was adopted. The hyperlink under each value opens a compiler support page with entry for given feature.
  *[Std]: Standard in which the feature is introduced; DR means defect report against that revision
