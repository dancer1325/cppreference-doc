[[edit template]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/container/operator%3D&action=edit)

[C++](../../../cpp.html "cpp")

[Compiler support](../../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../../freestanding.html "cpp/freestanding")  
[Language](../../language.html "cpp/language")  
[Standard library](../../standard_library.html "cpp/standard library")  
[Standard library headers](../../headers.html "cpp/header")  
[Named requirements](../../iterator/concepts.html "cpp/named req")  
[Feature test macros](../../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../../utility.html#Language_support "cpp/utility")  
[Concepts library](../../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../../error.html "cpp/error")  
[Memory management library](../../memory.html "cpp/memory")  
[Metaprogramming library](../../meta.html "cpp/meta") (C++11)  
[General utilities library](../../utility.html "cpp/utility")  
[Containers library](../../container.html "cpp/container")  
[Iterators library](../../iterator.html "cpp/iterator")  
[Ranges library](../../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../../algorithm.html "cpp/algorithm")  
[Strings library](../../string.html "cpp/string")  
[Text processing library](../../text.html "cpp/text")  
[Numerics library](../../numeric.html "cpp/numeric")  
[Date and time library](../../chrono.html "cpp/chrono")  
[Input/output library](../../io.html "cpp/io")  
[Filesystem library](../../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../../atomic.html "cpp/thread") (C++11)  
[Execution control library](../../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../../experimental.html "cpp/experimental")  
[Symbols index](../../symbol_index.html "cpp/symbol index")  
[External libraries](../../links/libs.html "cpp/links/libs")  
  


[Containers library](../../container.html "cpp/container")

[_node-handle_](../node_handle.html "cpp/container/node handle")(C++17)  
---  
[Sequence](../../container.html#Sequence_containers "cpp/container")  
[array](../array.html "cpp/container/array")(C++11)  
[vector](../vector.html "cpp/container/vector")  
[vector<bool>](../vector_bool.html "cpp/container/vector bool")  
[inplace_vector](../inplace_vector.html "cpp/container/inplace vector")(C++26)  
[hive](https://en.cppreference.com/mwiki/index.php?title=cpp/container/hive&action=edit&redlink=1 "cpp/container/hive \(page does not exist\)")(C++26)  
[deque](../deque.html "cpp/container/deque")  
[forward_list](../forward_list.html "cpp/container/forward list")(C++11)  
[list](../list.html "cpp/container/list")  
[Associative](../../container.html#Associative_containers "cpp/container")  
[set](../set.html "cpp/container/set")  
[multiset](../multiset.html "cpp/container/multiset")  
[map](../map.html "cpp/container/map")  
[multimap](../multimap.html "cpp/container/multimap")  
[Unordered associative](../../container.html#Unordered_associative_containers "cpp/container")  
[unordered_set](../unordered_set.html "cpp/container/unordered set")(C++11)  
[unordered_multiset](../unordered_multiset.html "cpp/container/unordered multiset")(C++11)  
[unordered_map](../unordered_map.html "cpp/container/unordered map")(C++11)  
[unordered_multimap](../unordered_multimap.html "cpp/container/unordered multimap")(C++11)  
[Adaptors](../../container.html#Container_adaptors "cpp/container")  
[stack](../stack.html "cpp/container/stack")  
[queue](../queue.html "cpp/container/queue")  
[priority_queue](../priority_queue.html "cpp/container/priority queue")  
[flat_set](../flat_set.html "cpp/container/flat set")(C++23)  
[flat_multiset](../flat_multiset.html "cpp/container/flat multiset")(C++23)  
[flat_map](../flat_map.html "cpp/container/flat map")(C++23)  
[flat_multimap](../flat_multimap.html "cpp/container/flat multimap")(C++23)  
[Views](../../container.html#Views "cpp/container")  
[span](../span.html "cpp/container/span")(C++20)  
[mdspan](../mdspan.html "cpp/container/mdspan")(C++23)  
Tables  
[Iterator invalidation](../../container.html#Iterator_invalidation "cpp/container")  
[Member function table](../../container.html#Member_function_table "cpp/container")  
[Non-member function table](../../container.html#Non-member_function_table "cpp/container")  
  


`[std::unordered_multiset](../unordered_multiset.html "cpp/container/unordered multiset")`

[Member types](../unordered_multiset.html#Member_types "cpp/container/unordered multiset")  
---  
[Member functions](../unordered_multiset.html#Member_functions "cpp/container/unordered multiset")  
| [unordered_multiset::unordered_multiset](unordered_multiset.html "cpp/container/unordered multiset/unordered multiset")  
---  
[unordered_multiset::~unordered_multiset](~unordered_multiset.html "cpp/container/unordered multiset/~unordered multiset")` `  
**unordered_multiset::operator=**  
[unordered_multiset::get_allocator](get_allocator.html "cpp/container/unordered multiset/get allocator")  
[Iterators](../unordered_multiset.html#Iterators "cpp/container/unordered multiset")  
[unordered_multiset::beginunordered_multiset::cbegin](begin.html "cpp/container/unordered multiset/begin")  
[unordered_multiset::endunordered_multiset::cend](end.html "cpp/container/unordered multiset/end")  
[Capacity](../unordered_multiset.html#Capacity "cpp/container/unordered multiset")  
[unordered_multiset::size](size.html "cpp/container/unordered multiset/size")  
[unordered_multiset::max_size](max_size.html "cpp/container/unordered multiset/max size")  
[unordered_multiset::empty](empty.html "cpp/container/unordered multiset/empty")  
[Modifiers](../unordered_multiset.html#Modifiers "cpp/container/unordered multiset")  
[unordered_multiset::clear](clear.html "cpp/container/unordered multiset/clear")  
[unordered_multiset::insert](insert.html "cpp/container/unordered multiset/insert")  
[unordered_multiset::insert_range](insert_range.html "cpp/container/unordered multiset/insert range")(C++23)  
[unordered_multiset::emplace](emplace.html "cpp/container/unordered multiset/emplace")  
[unordered_multiset::emplace_hint](emplace_hint.html "cpp/container/unordered multiset/emplace hint")  
[unordered_multiset::erase](erase.html "cpp/container/unordered multiset/erase")  
[unordered_multiset::swap](swap.html "cpp/container/unordered multiset/swap")  
[unordered_multiset::extract](extract.html "cpp/container/unordered multiset/extract")(C++17)  
[unordered_multiset::merge](merge.html "cpp/container/unordered multiset/merge")(C++17)  
  
| [Lookup](../unordered_multiset.html#Lookup "cpp/container/unordered multiset")  
---  
[unordered_multiset::count](count.html "cpp/container/unordered multiset/count")  
[unordered_multiset::find](find.html "cpp/container/unordered multiset/find")  
[unordered_multiset::contains](contains.html "cpp/container/unordered multiset/contains")(C++20)  
[unordered_multiset::equal_range](equal_range.html "cpp/container/unordered multiset/equal range")  
[Bucket interface](../unordered_multiset.html#Bucket_interface "cpp/container/unordered multiset")  
[unordered_multiset::begin(size_type)unordered_multiset::cbegin(size_type)](begin2.html "cpp/container/unordered multiset/begin2")  
[unordered_multiset::end(size_type)unordered_multiset::cend(size_type)](end2.html "cpp/container/unordered multiset/end2")  
[unordered_multiset::bucket_count](bucket_count.html "cpp/container/unordered multiset/bucket count")  
[unordered_multiset::max_bucket_count](max_bucket_count.html "cpp/container/unordered multiset/max bucket count")  
[unordered_multiset::bucket_size](bucket_size.html "cpp/container/unordered multiset/bucket size")  
[unordered_multiset::bucket](bucket.html "cpp/container/unordered multiset/bucket")  
[Hash policy](../unordered_multiset.html#Hash_policy "cpp/container/unordered multiset")  
[unordered_multiset::load_factor](load_factor.html "cpp/container/unordered multiset/load factor")  
[unordered_multiset::max_load_factor](max_load_factor.html "cpp/container/unordered multiset/max load factor")  
[unordered_multiset::rehash](rehash.html "cpp/container/unordered multiset/rehash")  
[unordered_multiset::reserve](reserve.html "cpp/container/unordered multiset/reserve")  
[Observers](../unordered_multiset.html#Observers "cpp/container/unordered multiset")  
[unordered_multiset::hash_function](hash_function.html "cpp/container/unordered multiset/hash function")  
[unordered_multiset::key_eq](key_eq.html "cpp/container/unordered multiset/key eq")  
  
[Non-member functions](../unordered_multiset.html#Non-member_functions "cpp/container/unordered multiset")  
| [operator==operator!=](operator_cmp.html "cpp/container/unordered multiset/operator cmp")(until C++20)  
---  
  
| [std::swap(std::unordered_multiset)](swap2.html "cpp/container/unordered multiset/swap2")  
---  
[erase_if(std::unordered_multiset)](erase_if.html "cpp/container/unordered multiset/erase if")(C++20)  
  
[Deduction guides](deduction_guides.html "cpp/container/unordered multiset/deduction guides") (C++17)  
  


unordered_multiset& operator=( const unordered_multiset& other ); |  (1) | (since C++11)   
(constexpr since C++26)  
---|---|---  
| (2) |   
unordered_multiset& operator=( unordered_multiset&& other ); |  | (since C++11)   
(until C++17)  
unordered_multiset& operator=( unordered_multiset&& other )  
noexcept(/* see below */); |  | (since C++17)   
(constexpr since C++26)  
unordered_multiset& operator=( [std::initializer_list](../../utility/initializer_list.html)<value_type> ilist ); |  (3) | (since C++11)   
(constexpr since C++26)  
| |   
  
Replaces the contents of the container. 

Let `traits` be [std::allocator_traits](../../memory/allocator_traits.html)<allocator_type>: 

1) Copy assignment operator. Replaces the contents with a copy of the contents of other.

If traits::propagate_on_container_copy_assignment::value is true, the allocator of *this is replaced by a copy of other. If the allocator of *this after assignment would compare unequal to its old value, the old allocator is used to deallocate the memory, then the new allocator is used to allocate it before copying the elements. Otherwise, the memory owned by *this may be reused when possible. In any case, the elements originally belonging to *this may be either destroyed or replaced by element-wise copy-assignment.

2) Move assignment operator. Replaces the contents with those of other using move semantics (i.e. the data in other is moved from other into this container). other is in a valid but unspecified state afterwards.

If traits::propagate_on_container_move_assignment::value is true, the allocator of *this is replaced by a copy of that of other. If it is false and the allocators of *this and other do not compare equal, *this cannot take ownership of the memory owned by other and must move-assign each element individually, allocating additional memory using its own allocator as needed. In any case, all elements originally belonging to *this are either destroyed or replaced by element-wise move-assignment.

3) Replaces the contents with those identified by initializer list ilist.

## Contents

  * [1 Parameters](operator=.html#Parameters)
  * [2 Return value](operator=.html#Return_value)
  * [3 Complexity](operator=.html#Complexity)
  * [4 Exceptions](operator=.html#Exceptions)
  * [5 Notes](operator=.html#Notes)
  * [6 Example](operator=.html#Example)
  * [7 See also](operator=.html#See_also)

  
---  
  
### Parameters

other  |  \-  |  another container to use as data source   
---|---|---  
ilist  |  \-  |  initializer list to use as data source   
  
### Return value

*this

### Complexity

1) Linear in the size of *this and other.

2) Linear in the size of *this unless the allocators do not compare equal and do not propagate, in which case linear in the size of *this and other.

3) Linear in the size of *this and ilist.

### Exceptions

2) [`noexcept`](../../language/noexcept_spec.html "cpp/language/noexcept spec") specification: noexcept([std::allocator_traits](../../memory/allocator_traits.html)<Allocator>::is_always_equal::value  
&& [std::is_nothrow_move_assignable](../../types/is_move_assignable.html)<Hash>::value  
&& [std::is_nothrow_move_assignable](../../types/is_move_assignable.html)<Pred>::value) | (since C++17)  
---|---  
  
### Notes

After container move assignment (overload ([2](operator=.html#Version_2))), unless element-wise move assignment is forced by incompatible allocators, references, pointers, and iterators (other than the end iterator) to other remain valid, but refer to elements that are now in *this. The current standard makes this guarantee via the blanket statement in [[container.reqmts]/67](https://eel.is/c++draft/container.reqmts#67), and a more direct guarantee is under consideration via [LWG issue 2321](https://cplusplus.github.io/LWG/issue2321). 

### Example

The following code uses operator= to assign one [std::unordered_multiset](../unordered_multiset.html "cpp/container/unordered multiset") to another:

Run this code
    
    
    #include <initializer_list>
    #include <iostream>
    #include <iterator>
    #include <unordered_set>
     
    void print(const auto comment, const auto& container)
    {
        auto size = [std::size](../../iterator/size.html)(container);
        [std::cout](../../io/cout.html) << comment << "{ ";
        for (const auto& element : container)
            [std::cout](../../io/cout.html) << element << (--size ? ", " : " ");
        [std::cout](../../io/cout.html) << "}\n";
    }
     
    int main()
    {
        [std::unordered_multiset](../unordered_multiset.html)<int> x{1, 2, 3}, y, z;
        const auto w = {4, 5, 6, 7};
     
        [std::cout](../../io/cout.html) << "Initially:\n";
        print("x = ", x);
        print("y = ", y);
        print("z = ", z);
     
        [std::cout](../../io/cout.html) << "Copy assignment copies data from x to y:\n";
        y = x;
        print("x = ", x);
        print("y = ", y);
     
        [std::cout](../../io/cout.html) << "Move assignment moves data from x to z, modifying both x and z:\n";
        z = std::move(x);
        print("x = ", x);
        print("z = ", z);
     
        [std::cout](../../io/cout.html) << "Assignment of initializer_list w to z:\n";
        z = w;
        print("w = ", w);
        print("z = ", z);
    }

Possible output: 
    
    
    Initially:
    x = { 3, 2, 1 }
    y = { }
    z = { }
    Copy assignment copies data from x to y:
    x = { 3, 2, 1 }
    y = { 3, 2, 1 }
    Move assignment moves data from x to z, modifying both x and z:
    x = { }
    z = { 3, 2, 1 }
    Assignment of initializer_list w to z:
    w = { 4, 5, 6, 7 }
    z = { 7, 6, 5, 4 }

### See also

[ (constructor)](unordered_multiset.html "cpp/container/unordered multiset/unordered multiset") |  constructs the `unordered_multiset`   
(public member function)   
---|---
