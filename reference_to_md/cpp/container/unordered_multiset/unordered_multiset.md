[[edit template]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/container/constructor_unord&action=edit)

[C++](../../../cpp.html "cpp")

[Compiler support](../../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../../freestanding.html "cpp/freestanding")  
[Language](../../language.html "cpp/language")  
[Standard library](../../standard_library.html "cpp/standard library")  
[Standard library headers](../../headers.html "cpp/header")  
[Named requirements](../../iterator/concepts.html "cpp/named req")  
[Feature test macros](../../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../../utility.html#Language_support "cpp/utility")  
[Concepts library](../../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../../error.html "cpp/error")  
[Memory management library](../../memory.html "cpp/memory")  
[Metaprogramming library](../../meta.html "cpp/meta") (C++11)  
[General utilities library](../../utility.html "cpp/utility")  
[Containers library](../../container.html "cpp/container")  
[Iterators library](../../iterator.html "cpp/iterator")  
[Ranges library](../../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../../algorithm.html "cpp/algorithm")  
[Strings library](../../string.html "cpp/string")  
[Text processing library](../../text.html "cpp/text")  
[Numerics library](../../numeric.html "cpp/numeric")  
[Date and time library](../../chrono.html "cpp/chrono")  
[Input/output library](../../io.html "cpp/io")  
[Filesystem library](../../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../../atomic.html "cpp/thread") (C++11)  
[Execution control library](../../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../../experimental.html "cpp/experimental")  
[Symbols index](../../symbol_index.html "cpp/symbol index")  
[External libraries](../../links/libs.html "cpp/links/libs")  
  


[Containers library](../../container.html "cpp/container")

[_node-handle_](../node_handle.html "cpp/container/node handle")(C++17)  
---  
[Sequence](../../container.html#Sequence_containers "cpp/container")  
[array](../array.html "cpp/container/array")(C++11)  
[vector](../vector.html "cpp/container/vector")  
[vector<bool>](../vector_bool.html "cpp/container/vector bool")  
[inplace_vector](../inplace_vector.html "cpp/container/inplace vector")(C++26)  
[hive](https://en.cppreference.com/mwiki/index.php?title=cpp/container/hive&action=edit&redlink=1 "cpp/container/hive \(page does not exist\)")(C++26)  
[deque](../deque.html "cpp/container/deque")  
[forward_list](../forward_list.html "cpp/container/forward list")(C++11)  
[list](../list.html "cpp/container/list")  
[Associative](../../container.html#Associative_containers "cpp/container")  
[set](../set.html "cpp/container/set")  
[multiset](../multiset.html "cpp/container/multiset")  
[map](../map.html "cpp/container/map")  
[multimap](../multimap.html "cpp/container/multimap")  
[Unordered associative](../../container.html#Unordered_associative_containers "cpp/container")  
[unordered_set](../unordered_set.html "cpp/container/unordered set")(C++11)  
[unordered_multiset](../unordered_multiset.html "cpp/container/unordered multiset")(C++11)  
[unordered_map](../unordered_map.html "cpp/container/unordered map")(C++11)  
[unordered_multimap](../unordered_multimap.html "cpp/container/unordered multimap")(C++11)  
[Adaptors](../../container.html#Container_adaptors "cpp/container")  
[stack](../stack.html "cpp/container/stack")  
[queue](../queue.html "cpp/container/queue")  
[priority_queue](../priority_queue.html "cpp/container/priority queue")  
[flat_set](../flat_set.html "cpp/container/flat set")(C++23)  
[flat_multiset](../flat_multiset.html "cpp/container/flat multiset")(C++23)  
[flat_map](../flat_map.html "cpp/container/flat map")(C++23)  
[flat_multimap](../flat_multimap.html "cpp/container/flat multimap")(C++23)  
[Views](../../container.html#Views "cpp/container")  
[span](../span.html "cpp/container/span")(C++20)  
[mdspan](../mdspan.html "cpp/container/mdspan")(C++23)  
Tables  
[Iterator invalidation](../../container.html#Iterator_invalidation "cpp/container")  
[Member function table](../../container.html#Member_function_table "cpp/container")  
[Non-member function table](../../container.html#Non-member_function_table "cpp/container")  
  


`[std::unordered_multiset](../unordered_multiset.html "cpp/container/unordered multiset")`

[Member types](../unordered_multiset.html#Member_types "cpp/container/unordered multiset")  
---  
[Member functions](../unordered_multiset.html#Member_functions "cpp/container/unordered multiset")  
| **unordered_multiset::unordered_multiset**  
---  
[unordered_multiset::~unordered_multiset](~unordered_multiset.html "cpp/container/unordered multiset/~unordered multiset")` `  
[unordered_multiset::operator=](operator=.html "cpp/container/unordered multiset/operator=")  
[unordered_multiset::get_allocator](get_allocator.html "cpp/container/unordered multiset/get allocator")  
[Iterators](../unordered_multiset.html#Iterators "cpp/container/unordered multiset")  
[unordered_multiset::beginunordered_multiset::cbegin](begin.html "cpp/container/unordered multiset/begin")  
[unordered_multiset::endunordered_multiset::cend](end.html "cpp/container/unordered multiset/end")  
[Capacity](../unordered_multiset.html#Capacity "cpp/container/unordered multiset")  
[unordered_multiset::size](size.html "cpp/container/unordered multiset/size")  
[unordered_multiset::max_size](max_size.html "cpp/container/unordered multiset/max size")  
[unordered_multiset::empty](empty.html "cpp/container/unordered multiset/empty")  
[Modifiers](../unordered_multiset.html#Modifiers "cpp/container/unordered multiset")  
[unordered_multiset::clear](clear.html "cpp/container/unordered multiset/clear")  
[unordered_multiset::insert](insert.html "cpp/container/unordered multiset/insert")  
[unordered_multiset::insert_range](insert_range.html "cpp/container/unordered multiset/insert range")(C++23)  
[unordered_multiset::emplace](emplace.html "cpp/container/unordered multiset/emplace")  
[unordered_multiset::emplace_hint](emplace_hint.html "cpp/container/unordered multiset/emplace hint")  
[unordered_multiset::erase](erase.html "cpp/container/unordered multiset/erase")  
[unordered_multiset::swap](swap.html "cpp/container/unordered multiset/swap")  
[unordered_multiset::extract](extract.html "cpp/container/unordered multiset/extract")(C++17)  
[unordered_multiset::merge](merge.html "cpp/container/unordered multiset/merge")(C++17)  
  
| [Lookup](../unordered_multiset.html#Lookup "cpp/container/unordered multiset")  
---  
[unordered_multiset::count](count.html "cpp/container/unordered multiset/count")  
[unordered_multiset::find](find.html "cpp/container/unordered multiset/find")  
[unordered_multiset::contains](contains.html "cpp/container/unordered multiset/contains")(C++20)  
[unordered_multiset::equal_range](equal_range.html "cpp/container/unordered multiset/equal range")  
[Bucket interface](../unordered_multiset.html#Bucket_interface "cpp/container/unordered multiset")  
[unordered_multiset::begin(size_type)unordered_multiset::cbegin(size_type)](begin2.html "cpp/container/unordered multiset/begin2")  
[unordered_multiset::end(size_type)unordered_multiset::cend(size_type)](end2.html "cpp/container/unordered multiset/end2")  
[unordered_multiset::bucket_count](bucket_count.html "cpp/container/unordered multiset/bucket count")  
[unordered_multiset::max_bucket_count](max_bucket_count.html "cpp/container/unordered multiset/max bucket count")  
[unordered_multiset::bucket_size](bucket_size.html "cpp/container/unordered multiset/bucket size")  
[unordered_multiset::bucket](bucket.html "cpp/container/unordered multiset/bucket")  
[Hash policy](../unordered_multiset.html#Hash_policy "cpp/container/unordered multiset")  
[unordered_multiset::load_factor](load_factor.html "cpp/container/unordered multiset/load factor")  
[unordered_multiset::max_load_factor](max_load_factor.html "cpp/container/unordered multiset/max load factor")  
[unordered_multiset::rehash](rehash.html "cpp/container/unordered multiset/rehash")  
[unordered_multiset::reserve](reserve.html "cpp/container/unordered multiset/reserve")  
[Observers](../unordered_multiset.html#Observers "cpp/container/unordered multiset")  
[unordered_multiset::hash_function](hash_function.html "cpp/container/unordered multiset/hash function")  
[unordered_multiset::key_eq](key_eq.html "cpp/container/unordered multiset/key eq")  
  
[Non-member functions](../unordered_multiset.html#Non-member_functions "cpp/container/unordered multiset")  
| [operator==operator!=](operator_cmp.html "cpp/container/unordered multiset/operator cmp")(until C++20)  
---  
  
| [std::swap(std::unordered_multiset)](swap2.html "cpp/container/unordered multiset/swap2")  
---  
[erase_if(std::unordered_multiset)](erase_if.html "cpp/container/unordered multiset/erase if")(C++20)  
  
[Deduction guides](deduction_guides.html "cpp/container/unordered multiset/deduction guides") (C++17)  
  


| (1) |   
---|---|---  
unordered_multiset()  
: unordered_multiset(size_type(/* unspecified */)) {} |  | (since C++11)   
(until C++20)  
unordered_multiset(); |  |  (since C++20)  
explicit unordered_multiset( size_type bucket_count,  
const Hash& hash = Hash(),  
const key_equal& equal = key_equal(),  
const Allocator& alloc = Allocator() ); |  (2)  |  (since C++11)  
unordered_multiset( size_type bucket_count,  
const Allocator& alloc )  
: unordered_multiset(bucket_count, Hash(), key_equal(), alloc) {} |  (3)  |  (since C++14)  
unordered_multiset( size_type bucket_count,  
const Hash& hash,  
const Allocator& alloc )  
: unordered_multiset(bucket_count, hash, key_equal(), alloc) {} |  (4)  |  (since C++14)  
explicit unordered_multiset( const Allocator& alloc ); |  (5)  |  (since C++11)  
template< class InputIt >  
unordered_multiset( InputIt first, InputIt last,  
size_type bucket_count = /* unspecified */,  
const Hash& hash = Hash(),  
const key_equal& equal = key_equal(),  
const Allocator& alloc = Allocator() ); |  (6)  |  (since C++11)  
template< class InputIt >  
unordered_multiset( InputIt first, InputIt last,  
size_type bucket_count,  
const Allocator& alloc )  
: unordered_multiset(first, last,  
bucket_count, Hash(), key_equal(), alloc) {} |  (7)  |  (since C++14)  
template< class InputIt >  
unordered_multiset( InputIt first, InputIt last,  
size_type bucket_count,  
const Hash& hash,  
const Allocator& alloc )  
: unordered_multiset(first, last,  
bucket_count, hash, key_equal(), alloc) {} |  (8)  |  (since C++14)  
unordered_multiset( const unordered_multiset& other ); |  (9)  |  (since C++11)  
unordered_multiset( const unordered_multiset& other, const Allocator& alloc ); |  (10)  |  (since C++11)  
unordered_multiset( unordered_multiset&& other ); |  (11) | (since C++11)  
unordered_multiset( unordered_multiset&& other, const Allocator& alloc ); |  (12)  |  (since C++11)  
unordered_multiset( [std::initializer_list](../../utility/initializer_list.html)<value_type> init,  
size_type bucket_count = /* unspecified */,  
const Hash& hash = Hash(),  
const key_equal& equal = key_equal(),  
const Allocator& alloc = Allocator() ); |  (13) | (since C++11)  
unordered_multiset( [std::initializer_list](../../utility/initializer_list.html)<value_type> init,  
size_type bucket_count,  
const Allocator& alloc )  
: unordered_multiset(init, bucket_count,  
Hash(), key_equal(), alloc) {} |  (14)  |  (since C++14)  
unordered_multiset( [std::initializer_list](../../utility/initializer_list.html)<value_type> init,  
size_type bucket_count,  
const Hash& hash,  
const Allocator& alloc )  
: unordered_multiset(init, bucket_count,  
hash, key_equal(), alloc) {} |  (15)  |  (since C++14)  
template< [container-compatible-range](../../ranges/to.html)<value_type> R >  
unordered_multiset( [std::from_range_t](../../ranges/from_range.html), R&& rg,  
size_type bucket_count = /* see description */,  
const Hash& hash = Hash(),  
const key_equal& equal = key_equal(),  
const Allocator& alloc = Allocator() ); |  (16) | (since C++23)  
template< [container-compatible-range](../../ranges/to.html)<value_type> R >  
unordered_multiset( [std::from_range_t](../../ranges/from_range.html), R&& rg,  
size_type bucket_count,  
const Allocator& alloc )  
: unordered_multiset([std::from_range](../../ranges/from_range.html), [std::forward](../../utility/forward.html)<R>(rg),  
bucket_count, Hash(), key_equal(), alloc) {} |  (17)  |  (since C++23)  
template< [container-compatible-range](../../ranges/to.html)<value_type> R >  
unordered_multiset( [std::from_range_t](../../ranges/from_range.html), R&& rg,  
size_type bucket_count,  
const Hash& hash,  
const Alloc& alloc )  
: unordered_multiset([std::from_range](../../ranges/from_range.html), [std::forward](../../utility/forward.html)<R>(rg),  
bucket_count, hash, key_equal(), alloc) {} |  (18)  |  (since C++23)  
| |   
  
Constructs new container from a variety of data sources. Optionally uses user supplied bucket_count as a minimal number of buckets to create, hash as the hash function, equal as the function to compare keys and alloc as the allocator. 

1-5) Constructs empty container. Sets [max_load_factor()](max_load_factor.html "cpp/container/unordered multiset/max load factor") to 1.0. For the default constructor, the number of buckets is unspecified.

6-8) Constructs the container with the contents of the range `[`first`, `last`)`. Sets [max_load_factor()](max_load_factor.html "cpp/container/unordered multiset/max load factor") to 1.0. 

9,10) Copy constructor. Constructs the container with the copy of the contents of other, copies the load factor, the predicate, and the hash function as well. If alloc is not provided, allocator is obtained by calling [std::allocator_traits](../../memory/allocator_traits.html)<allocator_type>::select_on_container_copy_construction(other.get_allocator()).  The template parameter `Allocator` is only deduced from the first argument while used in [class template argument deduction](../../language/ctad.html "cpp/language/class template argument deduction").  | (since C++23)  
---|---  
  
11,12) [Move constructor](../../language/move_constructor.html "cpp/language/move constructor"). Constructs the container with the contents of other using move semantics. If alloc is not provided, allocator is obtained by move-construction from the allocator belonging to other.  The template parameter `Allocator` is only deduced from the first argument while used in [class template argument deduction](../../language/ctad.html "cpp/language/class template argument deduction").  | (since C++23)  
---|---  
  
13-15) [Initializer-list constructor](../../language/list_initialization.html "cpp/language/list initialization"). Constructs the container with the contents of the initializer list init, same as unordered_multiset(init.begin(), init.end()).

16-18) Constructs the container with the contents of rg. 

## Contents

  * [1 Parameters](unordered_multiset.html#Parameters)
  * [2 Complexity](unordered_multiset.html#Complexity)
  * [3 Exceptions](unordered_multiset.html#Exceptions)
  * [4 Notes](unordered_multiset.html#Notes)
  * [5 Example](unordered_multiset.html#Example)
  * [6 Defect reports](unordered_multiset.html#Defect_reports)
  * [7 See also](unordered_multiset.html#See_also)

  
---  
  
### Parameters

alloc  |  \-  |  allocator to use for all memory allocations of this container   
---|---|---  
bucket_count  |  \-  |  minimal number of buckets to use on initialization. If it is not specified, an unspecified default value is used   
hash  |  \-  |  hash function to use   
equal  |  \-  |  comparison function to use for all key comparisons of this container   
first, last  |  \-  |  the pair of iterators defining the source [range](../../iterator.html#Ranges "cpp/iterator") of elements to copy   
rg  |  \-  |  a [container compatible range](../../ranges/to.html#container_compatible_range "cpp/ranges/to"), that is, an [`input_range`](../../ranges/input_range.html "cpp/ranges/input range") whose elements are convertible to [`value_type`](../unordered_multiset.html#Member_types "cpp/container/unordered multiset")  
other  |  \-  |  another container to be used as source to initialize the elements of the container with   
init  |  \-  |  initializer list to initialize the elements of the container with   
Type requirements   
-`InputIt` must meet the requirements of [LegacyInputIterator](../../named_req/InputIterator.html "cpp/named req/InputIterator").   
  
### Complexity

1-5) Constant.

6-8) Average case linear (i.e. O(N), where N is [std::distance](../../iterator/distance.html)(first, last)), worst case quadratic, i.e. O(N2).

9,10) Linear in size of other.

11,12) Constant. If alloc is given and alloc != other.get_allocator(), then linear.

13-15) Average case O(N) (N is [std::size](../../iterator/size.html)(init)), worst case O(N2).

16-18) Average case O(N) (N is [ranges::distance](../../iterator/ranges/distance.html)(rg)), worst case O(N2).

### Exceptions

Calls to `Allocator::allocate` may throw. 

### Notes



After container move construction (overload ([11,12](unordered_multiset.html#Version_11))), references, pointers, and iterators (other than the end iterator) to other remain valid, but refer to elements that are now in *this. The current standard makes this guarantee via the blanket statement in [[container.reqmts]/67](https://eel.is/c++draft/container.reqmts#67), and a more direct guarantee is under consideration via [LWG issue 2321](https://cplusplus.github.io/LWG/issue2321). 

Although not formally required until C++23, some implementations have already put the template parameter `Allocator` into [non-deduced contexts](../../language/template_argument_deduction.html#Non-deduced_contexts "cpp/language/template argument deduction") in earlier modes. 

[Feature-test](../../utility/feature_test.html "cpp/utility/feature test") macro | Value | Std | Feature   
---|---|---|---  
[`__cpp_lib_containers_ranges`](../../experimental/feature_test.html#cpp_lib_containers_ranges "cpp/feature test") | [`202202L`](../../compiler_support/23.html#cpp_lib_containers_ranges_202202L "cpp/compiler support/23") | (C++23) | [Ranges-aware](../../ranges/to.html#container_compatible_range "cpp/ranges/to") construction and insertion; overloads ([16-18](unordered_multiset.html#Version_16))  
  
### Example

| This section is incomplete  
Reason: no example   
---|---  
  
### Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[LWG 2193](https://cplusplus.github.io/LWG/issue2193) | C++11  | the default constructor ([1](unordered_multiset.html#Version_1)) was explicit  | made non-explicit   
[LWG 2230](https://cplusplus.github.io/LWG/issue2230) | C++11  | the semantics of overload ([13](unordered_multiset.html#Version_13)) was not specified  | specified   
  
### See also

[ operator=](operator=.html "cpp/container/unordered multiset/operator=") |  assigns values to the container   
(public member function)   
---|---
  *[Value]: The year/month in which the feature was adopted. The hyperlink under each value opens a compiler support page with entry for given feature.
  *[Std]: Standard in which the feature is introduced; DR means defect report against that revision
