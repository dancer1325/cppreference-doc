[[edit template]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/container/extract_assoc&action=edit)

[C++](../../../cpp.html "cpp")

[Compiler support](../../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../../freestanding.html "cpp/freestanding")  
[Language](../../language.html "cpp/language")  
[Standard library](../../standard_library.html "cpp/standard library")  
[Standard library headers](../../headers.html "cpp/header")  
[Named requirements](../../iterator/concepts.html "cpp/named req")  
[Feature test macros](../../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../../utility.html#Language_support "cpp/utility")  
[Concepts library](../../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../../error.html "cpp/error")  
[Memory management library](../../memory.html "cpp/memory")  
[Metaprogramming library](../../meta.html "cpp/meta") (C++11)  
[General utilities library](../../utility.html "cpp/utility")  
[Containers library](../../container.html "cpp/container")  
[Iterators library](../../iterator.html "cpp/iterator")  
[Ranges library](../../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../../algorithm.html "cpp/algorithm")  
[Strings library](../../string.html "cpp/string")  
[Text processing library](../../text.html "cpp/text")  
[Numerics library](../../numeric.html "cpp/numeric")  
[Date and time library](../../chrono.html "cpp/chrono")  
[Input/output library](../../io.html "cpp/io")  
[Filesystem library](../../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../../atomic.html "cpp/thread") (C++11)  
[Execution control library](../../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../../experimental.html "cpp/experimental")  
[Symbols index](../../symbol_index.html "cpp/symbol index")  
[External libraries](../../links/libs.html "cpp/links/libs")  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/navbar_content&action=edit)

[Containers library](../../container.html "cpp/container")

[_node-handle_](../node_handle.html "cpp/container/node handle")(C++17)  
---  
[Sequence](../../container.html#Sequence_containers "cpp/container")  
[array](../array.html "cpp/container/array")(C++11)  
[vector](../vector.html "cpp/container/vector")  
[vector<bool>](../vector_bool.html "cpp/container/vector bool")  
[inplace_vector](../inplace_vector.html "cpp/container/inplace vector")(C++26)  
[hive](https://en.cppreference.com/mwiki/index.php?title=cpp/container/hive&action=edit&redlink=1 "cpp/container/hive \(page does not exist\)")(C++26)  
[deque](../deque.html "cpp/container/deque")  
[forward_list](../forward_list.html "cpp/container/forward list")(C++11)  
[list](../list.html "cpp/container/list")  
[Associative](../../container.html#Associative_containers "cpp/container")  
[set](../set.html "cpp/container/set")  
[multiset](../multiset.html "cpp/container/multiset")  
[map](../map.html "cpp/container/map")  
[multimap](../multimap.html "cpp/container/multimap")  
[Unordered associative](../../container.html#Unordered_associative_containers "cpp/container")  
[unordered_set](../unordered_set.html "cpp/container/unordered set")(C++11)  
[unordered_multiset](../unordered_multiset.html "cpp/container/unordered multiset")(C++11)  
[unordered_map](../unordered_map.html "cpp/container/unordered map")(C++11)  
[unordered_multimap](../unordered_multimap.html "cpp/container/unordered multimap")(C++11)  
[Adaptors](../../container.html#Container_adaptors "cpp/container")  
[stack](../stack.html "cpp/container/stack")  
[queue](../queue.html "cpp/container/queue")  
[priority_queue](../priority_queue.html "cpp/container/priority queue")  
[flat_set](../flat_set.html "cpp/container/flat set")(C++23)  
[flat_multiset](../flat_multiset.html "cpp/container/flat multiset")(C++23)  
[flat_map](../flat_map.html "cpp/container/flat map")(C++23)  
[flat_multimap](../flat_multimap.html "cpp/container/flat multimap")(C++23)  
[Views](../../container.html#Views "cpp/container")  
[span](../span.html "cpp/container/span")(C++20)  
[mdspan](../mdspan.html "cpp/container/mdspan")(C++23)  
Tables  
[Iterator invalidation](../../container.html#Iterator_invalidation "cpp/container")  
[Member function table](../../container.html#Member_function_table "cpp/container")  
[Non-member function table](../../container.html#Non-member_function_table "cpp/container")  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/container/navbar_content&action=edit)

`[std::unordered_multiset](../unordered_multiset.html "cpp/container/unordered multiset")`

[Member types](../unordered_multiset.html#Member_types "cpp/container/unordered multiset")  
---  
[Member functions](../unordered_multiset.html#Member_functions "cpp/container/unordered multiset")  
| [unordered_multiset::unordered_multiset](unordered_multiset.html "cpp/container/unordered multiset/unordered multiset")  
---  
[unordered_multiset::~unordered_multiset](~unordered_multiset.html "cpp/container/unordered multiset/~unordered multiset")` `  
[unordered_multiset::operator=](operator=.html "cpp/container/unordered multiset/operator=")  
[unordered_multiset::get_allocator](get_allocator.html "cpp/container/unordered multiset/get allocator")  
[Iterators](../unordered_multiset.html#Iterators "cpp/container/unordered multiset")  
[unordered_multiset::beginunordered_multiset::cbegin](begin.html "cpp/container/unordered multiset/begin")  
[unordered_multiset::endunordered_multiset::cend](end.html "cpp/container/unordered multiset/end")  
[Capacity](../unordered_multiset.html#Capacity "cpp/container/unordered multiset")  
[unordered_multiset::size](size.html "cpp/container/unordered multiset/size")  
[unordered_multiset::max_size](max_size.html "cpp/container/unordered multiset/max size")  
[unordered_multiset::empty](empty.html "cpp/container/unordered multiset/empty")  
[Modifiers](../unordered_multiset.html#Modifiers "cpp/container/unordered multiset")  
[unordered_multiset::clear](clear.html "cpp/container/unordered multiset/clear")  
[unordered_multiset::insert](insert.html "cpp/container/unordered multiset/insert")  
[unordered_multiset::insert_range](insert_range.html "cpp/container/unordered multiset/insert range")(C++23)  
[unordered_multiset::emplace](emplace.html "cpp/container/unordered multiset/emplace")  
[unordered_multiset::emplace_hint](emplace_hint.html "cpp/container/unordered multiset/emplace hint")  
[unordered_multiset::erase](erase.html "cpp/container/unordered multiset/erase")  
[unordered_multiset::swap](swap.html "cpp/container/unordered multiset/swap")  
**unordered_multiset::extract**(C++17)  
[unordered_multiset::merge](merge.html "cpp/container/unordered multiset/merge")(C++17)  
  
| [Lookup](../unordered_multiset.html#Lookup "cpp/container/unordered multiset")  
---  
[unordered_multiset::count](count.html "cpp/container/unordered multiset/count")  
[unordered_multiset::find](find.html "cpp/container/unordered multiset/find")  
[unordered_multiset::contains](contains.html "cpp/container/unordered multiset/contains")(C++20)  
[unordered_multiset::equal_range](equal_range.html "cpp/container/unordered multiset/equal range")  
[Bucket interface](../unordered_multiset.html#Bucket_interface "cpp/container/unordered multiset")  
[unordered_multiset::begin(size_type)unordered_multiset::cbegin(size_type)](begin2.html "cpp/container/unordered multiset/begin2")  
[unordered_multiset::end(size_type)unordered_multiset::cend(size_type)](end2.html "cpp/container/unordered multiset/end2")  
[unordered_multiset::bucket_count](bucket_count.html "cpp/container/unordered multiset/bucket count")  
[unordered_multiset::max_bucket_count](max_bucket_count.html "cpp/container/unordered multiset/max bucket count")  
[unordered_multiset::bucket_size](bucket_size.html "cpp/container/unordered multiset/bucket size")  
[unordered_multiset::bucket](bucket.html "cpp/container/unordered multiset/bucket")  
[Hash policy](../unordered_multiset.html#Hash_policy "cpp/container/unordered multiset")  
[unordered_multiset::load_factor](load_factor.html "cpp/container/unordered multiset/load factor")  
[unordered_multiset::max_load_factor](max_load_factor.html "cpp/container/unordered multiset/max load factor")  
[unordered_multiset::rehash](rehash.html "cpp/container/unordered multiset/rehash")  
[unordered_multiset::reserve](reserve.html "cpp/container/unordered multiset/reserve")  
[Observers](../unordered_multiset.html#Observers "cpp/container/unordered multiset")  
[unordered_multiset::hash_function](hash_function.html "cpp/container/unordered multiset/hash function")  
[unordered_multiset::key_eq](key_eq.html "cpp/container/unordered multiset/key eq")  
  
[Non-member functions](../unordered_multiset.html#Non-member_functions "cpp/container/unordered multiset")  
| [operator==operator!=](operator_cmp.html "cpp/container/unordered multiset/operator cmp")(until C++20)  
---  
  
| [std::swap(std::unordered_multiset)](swap2.html "cpp/container/unordered multiset/swap2")  
---  
[erase_if(std::unordered_multiset)](erase_if.html "cpp/container/unordered multiset/erase if")(C++20)  
  
[Deduction guides](deduction_guides.html "cpp/container/unordered multiset/deduction guides") (C++17)  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/container/unordered_multiset/navbar_content&action=edit)

node_type extract( const_iterator pos ); |  (1) | (since C++17)   
(constexpr since C++26)  
---|---|---  
node_type extract( const Key& k ); |  (2) | (since C++17)   
(constexpr since C++26)  
template< class K >  
node_type extract( K&& x ); |  (3) | (since C++23)   
(constexpr since C++26)  
| |   
  
1) Unlinks the node that contains the element pointed to by pos and returns a [node handle](../node_handle.html "cpp/container/node handle") that owns it.

2,3) If the container has an element with key equivalent to k or x(since C++23), unlinks the node that contains the first such element from the container and returns a [node handle](../node_handle.html "cpp/container/node handle") that owns it. Otherwise, returns an empty node handle.

3) This overload participates in overload resolution only if `Hash` and `KeyEqual` are both [transparent](../../functional.html#Transparent_function_objects "cpp/utility/functional"), and neither `iterator` nor `const_iterator` is implicitly convertible from `K`. This assumes that such `Hash` is callable with both `K` and `Key` type, and that the `KeyEqual` is transparent, which, together, allows calling this function without constructing an instance of `Key`.

In either case, no elements are copied or moved, only the internal pointers of the container nodes are repointed . 

Extracting a node invalidates only the iterators to the extracted element, and preserves the relative order of the elements that are not erased. Pointers and references to the extracted element remain valid, but cannot be used while element is owned by a node handle: they become usable if the element is inserted into a container. 

## Contents

  * [1 Parameters](extract.html#Parameters)
  * [2 Return value](extract.html#Return_value)
  * [3 Exceptions](extract.html#Exceptions)
  * [4 Complexity](extract.html#Complexity)
  * [5 Notes](extract.html#Notes)
  * [6 Example](extract.html#Example)
  * [7 See also](extract.html#See_also)

  
---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/container/extract_assoc&action=edit&section=T-1 "Template:cpp/container/extract assoc")] Parameters

pos  |  \-  |  a valid iterator into this container   
---|---|---  
k  |  \-  |  a key to identify the node to be extracted   
x  |  \-  |  a value of any type that can be transparently compared with a key identifying the node to be extracted   
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/container/extract_assoc&action=edit&section=T-2 "Template:cpp/container/extract assoc")] Return value

A [node handle](../node_handle.html "cpp/container/node handle") that owns the extracted element, or empty node handle in case the element is not found in (2,3). 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/container/extract_assoc&action=edit&section=T-3 "Template:cpp/container/extract assoc")] Exceptions

1) Throws nothing.

2,3) Any exceptions thrown by the `Hash` and `KeyEqual` object.

### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/container/extract_assoc&action=edit&section=T-4 "Template:cpp/container/extract assoc")] Complexity

1-3) Average case O(1), worst case O([size()](size.html "cpp/container/unordered multiset/size")).

### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/container/extract_assoc&action=edit&section=T-5 "Template:cpp/container/extract assoc")] Notes

extract is the only way to take a move-only object out of a set: 
    
    
    [std::set](../set.html)<move_only_type> s;
    s.emplace(...);
    move_only_type mot = std::move(s.extract(s.begin()).value());

[Feature-test](../../utility/feature_test.html "cpp/utility/feature test") macro | Value | Std | Feature   
---|---|---|---  
[`__cpp_lib_associative_heterogeneous_erasure`](../../experimental/feature_test.html#cpp_lib_associative_heterogeneous_erasure "cpp/feature test") | [`202110L`](../../compiler_support/23.html#cpp_lib_associative_heterogeneous_erasure_202110L "cpp/compiler support/23") | (C++23) | Heterogeneous erasure in [associative containers](../../container.html#Associative_containers "cpp/container") and [unordered associative containers](../../container.html#Unordered_associative_containers "cpp/container"), ([3](extract.html#Version_3))  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/container/extract_assoc&action=edit&section=T-6 "Template:cpp/container/extract assoc")] Example

Run this code
    
    
    #include <algorithm>
    #include <iostream>
    #include <string_view>
    #include <unordered_set>
     
    void print([std::string_view](../../string/basic_string_view.html) comment, const auto& data)
    {
        [std::cout](../../io/cout.html) << comment;
        for (auto datum : data)
            [std::cout](../../io/cout.html) << ' ' << datum;
     
        [std::cout](../../io/cout.html) << '\n';
    }
     
    int main()
    {
        [std::unordered_multiset](../unordered_multiset.html)<int> cont{1, 2, 3};
     
        print("Start:", cont);
     
        // Extract node handle and change key
        auto nh = cont.extract(1);
        nh.value() = 4;
     
        print("After extract and before insert:", cont);
     
        // Insert node handle back
        cont.insert(std::move(nh));
     
        print("End:", cont);
    }

Possible output: 
    
    
    Start: 1 2 3
    After extract and before insert: 2 3
    End: 2 3 4

### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/container/extract_assoc&action=edit&section=T-7 "Template:cpp/container/extract assoc")] See also

[ merge](merge.html "cpp/container/unordered multiset/merge")(C++17) |  splices nodes from another container   
(public member function) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/container/dsc_merge&action=edit)  
---|---  
[ insert](insert.html "cpp/container/unordered multiset/insert") |  inserts elements or nodes(since C++17)   
(public member function) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/container/dsc_insert&action=edit)  
[ erase](erase.html "cpp/container/unordered multiset/erase") |  erases elements   
(public member function) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/container/dsc_erase&action=edit)
  *[Value]: The year/month in which the feature was adopted. The hyperlink under each value opens a compiler support page with entry for given feature.
  *[Std]: Standard in which the feature is introduced; DR means defect report against that revision
