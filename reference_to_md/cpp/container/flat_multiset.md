
  


[Containers library](../container.html "cpp/container")

[_node-handle_](node_handle.html "cpp/container/node handle")(C++17)  
---  
[Sequence](../container.html#Sequence_containers "cpp/container")  
[array](array.html "cpp/container/array")(C++11)  
[vector](vector.html "cpp/container/vector")  
[vector<bool>](vector_bool.html "cpp/container/vector bool")  
[inplace_vector](inplace_vector.html "cpp/container/inplace vector")(C++26)  
[hive](https://en.cppreference.com/mwiki/index.php?title=cpp/container/hive&action=edit&redlink=1 "cpp/container/hive \(page does not exist\)")(C++26)  
[deque](deque.html "cpp/container/deque")  
[forward_list](forward_list.html "cpp/container/forward list")(C++11)  
[list](list.html "cpp/container/list")  
[Associative](../container.html#Associative_containers "cpp/container")  
[set](set.html "cpp/container/set")  
[multiset](multiset.html "cpp/container/multiset")  
[map](map.html "cpp/container/map")  
[multimap](multimap.html "cpp/container/multimap")  
[Unordered associative](../container.html#Unordered_associative_containers "cpp/container")  
[unordered_set](unordered_set.html "cpp/container/unordered set")(C++11)  
[unordered_multiset](unordered_multiset.html "cpp/container/unordered multiset")(C++11)  
[unordered_map](unordered_map.html "cpp/container/unordered map")(C++11)  
[unordered_multimap](unordered_multimap.html "cpp/container/unordered multimap")(C++11)  
[Adaptors](../container.html#Container_adaptors "cpp/container")  
[stack](stack.html "cpp/container/stack")  
[queue](queue.html "cpp/container/queue")  
[priority_queue](priority_queue.html "cpp/container/priority queue")  
[flat_set](flat_set.html "cpp/container/flat set")(C++23)  
**flat_multiset**(C++23)  
[flat_map](flat_map.html "cpp/container/flat map")(C++23)  
[flat_multimap](flat_multimap.html "cpp/container/flat multimap")(C++23)  
[Views](../container.html#Views "cpp/container")  
[span](span.html "cpp/container/span")(C++20)  
[mdspan](mdspan.html "cpp/container/mdspan")(C++23)  
Tables  
[Iterator invalidation](../container.html#Iterator_invalidation "cpp/container")  
[Member function table](../container.html#Member_function_table "cpp/container")  
[Non-member function table](../container.html#Non-member_function_table "cpp/container")  
  


**`std::flat_multiset`**

[Member types](flat_multiset.html#Member_types "cpp/container/flat multiset")  
---  
[Member functions](flat_multiset.html#Member_functions "cpp/container/flat multiset")  
|  | [flat_multiset::flat_multiset](flat_multiset/flat_multiset.html "cpp/container/flat multiset/flat multiset")` `  
---  
[flat_multiset::operator=](flat_multiset/operator=.html "cpp/container/flat multiset/operator=")  
[Iterators](flat_multiset.html#Iterators "cpp/container/flat multiset")  
[flat_multiset::beginflat_multiset::cbegin](flat_multiset/begin.html "cpp/container/flat multiset/begin")  
[flat_multiset::endflat_multiset::cend](flat_multiset/end.html "cpp/container/flat multiset/end")  
[flat_multiset::rbeginflat_multiset::crbegin](flat_multiset/rbegin.html "cpp/container/flat multiset/rbegin")  
[flat_multiset::rendflat_multiset::crend](flat_multiset/rend.html "cpp/container/flat multiset/rend")  
[Capacity](flat_multiset.html#Capacity "cpp/container/flat multiset")  
[flat_multiset::size](flat_multiset/size.html "cpp/container/flat multiset/size")  
[flat_multiset::max_size](flat_multiset/max_size.html "cpp/container/flat multiset/max size")  
[flat_multiset::empty](flat_multiset/empty.html "cpp/container/flat multiset/empty")  
[Observers](flat_multiset.html#Observers "cpp/container/flat multiset")  
[flat_multiset::key_comp](flat_multiset/key_comp.html "cpp/container/flat multiset/key comp")  
[flat_multiset::value_comp](flat_multiset/value_comp.html "cpp/container/flat multiset/value comp")  
  
| [Modifiers](flat_multiset.html#Modifiers "cpp/container/flat multiset")  
---  
[flat_multiset::clear](flat_multiset/clear.html "cpp/container/flat multiset/clear")  
[flat_multiset::insert](flat_multiset/insert.html "cpp/container/flat multiset/insert")  
[flat_multiset::insert_range](flat_multiset/insert_range.html "cpp/container/flat multiset/insert range")  
[flat_multiset::emplace](flat_multiset/emplace.html "cpp/container/flat multiset/emplace")  
[flat_multiset::emplace_hint](flat_multiset/emplace_hint.html "cpp/container/flat multiset/emplace hint")  
[flat_multiset::erase](flat_multiset/erase.html "cpp/container/flat multiset/erase")  
[flat_multiset::swap](flat_multiset/swap.html "cpp/container/flat multiset/swap")  
[flat_multiset::extract](flat_multiset/extract.html "cpp/container/flat multiset/extract")  
[flat_multiset::replace](flat_multiset/replace.html "cpp/container/flat multiset/replace")  
[Lookup](flat_multiset.html#Lookup "cpp/container/flat multiset")  
[flat_multiset::count](flat_multiset/count.html "cpp/container/flat multiset/count")  
[flat_multiset::find](flat_multiset/find.html "cpp/container/flat multiset/find")  
[flat_multiset::contains](flat_multiset/contains.html "cpp/container/flat multiset/contains")  
[flat_multiset::equal_range](flat_multiset/equal_range.html "cpp/container/flat multiset/equal range")  
[flat_multiset::lower_bound](flat_multiset/lower_bound.html "cpp/container/flat multiset/lower bound")  
[flat_multiset::upper_bound](flat_multiset/upper_bound.html "cpp/container/flat multiset/upper bound")  
  
[Non-member functions](flat_multiset.html#Non-member_functions "cpp/container/flat multiset")  
|  | [swap(std::flat_multiset)](flat_multiset/swap2.html "cpp/container/flat multiset/swap2")  
---  
[erase_if(std::flat_multiset)](flat_multiset/erase_if.html "cpp/container/flat multiset/erase if")` `  
  
| [operator==operator<=>](flat_multiset/operator_cmp.html "cpp/container/flat multiset/operator cmp")  
---  
  
[Helper classes](flat_multiset.html#Helper_classes "cpp/container/flat multiset")  
| [uses_allocator<std::flat_multiset>](flat_multiset/uses_allocator.html "cpp/container/flat multiset/uses allocator")  
---  
  
[Tags](flat_multiset.html#Tags "cpp/container/flat multiset")  
|  | [sorted_equivalent](sorted_equivalent.html "cpp/container/sorted equivalent")` `  
---  
  
| [sorted_equivalent_t](sorted_equivalent.html "cpp/container/sorted equivalent")  
---  
  
[Deduction guides](flat_multiset/deduction_guides.html "cpp/container/flat multiset/deduction guides")  
  


Defined in header `[<flat_set>](../header/flat_set.html "cpp/header/flat set")` |  |   
---|---|---  
template<  
class Key,  
class Compare = [std::less](../utility/functional/less.html)<Key>,  
class KeyContainer = [std::vector](vector.html)<Key>  
> class flat_multiset; |  |  (since C++23)  
| |   
  
The flat multiset is a [container adaptor](../container.html#Container_adaptors "cpp/container") that gives the functionality of an associative container that stores a sorted set of objects of type `Key`. Unlike std::flat_set, multiple keys with equivalent values are allowed. Sorting is done using the key comparison function `Compare`. 

The class template `flat_multiset` acts as a wrapper to the underlying sorted container passed as object of type `KeyContainer`. 

Everywhere the standard library uses the [Compare](../named_req/Compare.html "cpp/named req/Compare") requirements, uniqueness is determined by using the equivalence relation. Informally, two objects a and b are considered equivalent if neither compares less than the other: !comp(a, b) && !comp(b, a). 

  
`std::flat_multiset` meets the requirements of [Container](../named_req/Container.html "cpp/named req/Container"), [ReversibleContainer](../named_req/ReversibleContainer.html "cpp/named req/ReversibleContainer"), [optional container requirements](../named_req/Container.html#Optional_container_requirements "cpp/named req/Container"), and all requirements of [AssociativeContainer](../named_req/AssociativeContainer.html "cpp/named req/AssociativeContainer") (including logarithmic search complexity), except that: 

  * requirements related to nodes are not applicable, 
  * iterator invalidation requirements differ, 
  * the complexity of insertion and erasure operations is linear. 



A flat multiset supports most [AssociativeContainer](../named_req/AssociativeContainer.html "cpp/named req/AssociativeContainer")'s operations that use equal keys. 

All member functions of `std::flat_multiset` are constexpr: it is possible to create and use `std::flat_multiset` objects in the evaluation of a constant expression.However, `std::flat_multiset` objects generally cannot be constexpr, because any dynamically allocated storage must be released in the same evaluation of constant expression. | (since C++26)  
---|---  
  
## Contents

  * [1 Iterator invalidation](flat_multiset.html#Iterator_invalidation)
  * [2 Template parameters](flat_multiset.html#Template_parameters)
  * [3 Member types](flat_multiset.html#Member_types)
  * [4 Member objects](flat_multiset.html#Member_objects)
  * [5 Member functions](flat_multiset.html#Member_functions)
    * [5.1 Iterators](flat_multiset.html#Iterators)
    * [5.2 Capacity](flat_multiset.html#Capacity)
    * [5.3 Modifiers](flat_multiset.html#Modifiers)
    * [5.4 Lookup](flat_multiset.html#Lookup)
    * [5.5 Observers](flat_multiset.html#Observers)
  * [6 Non-member functions](flat_multiset.html#Non-member_functions)
  * [7 Helper classes](flat_multiset.html#Helper_classes)
  * [8 Tags](flat_multiset.html#Tags)
  * [9 Deduction guides](flat_multiset.html#Deduction_guides)
  * [10 Notes](flat_multiset.html#Notes)
  * [11 Example](flat_multiset.html#Example)
  * [12 See also](flat_multiset.html#See_also)

  
---  
  
### Iterator invalidation

| This section is incomplete   
---|---  
  
### Template parameters

Key  |  \-  |  The type of the stored elements. The program is ill-formed if `Key` is not the same type as `KeyContainer::value_type`.   
---|---|---  
Compare  |  \-  |  A [Compare](../named_req/Compare.html "cpp/named req/Compare") type providing a strict weak ordering.   
KeyContainer  |  \-  |  The type of the underlying [SequenceContainer](../named_req/SequenceContainer.html "cpp/named req/SequenceContainer") to store the elements. The iterators of such container should satisfy [LegacyRandomAccessIterator](../named_req/RandomAccessIterator.html "cpp/named req/RandomAccessIterator") or model [`random_access_iterator`](../iterator/random_access_iterator.html "cpp/iterator/random access iterator"). The standard containers [std::vector](vector.html "cpp/container/vector") and [std::deque](deque.html "cpp/container/deque") satisfy these requirements.   
  
### Member types

Type  |  Definition   
---|---  
`container_type` |  `Key``Container`  
`key_type` |  `Key`  
`value_type` |  `Key`  
`key_compare` |  `Compare`  
`value_compare` |  `Compare`  
`reference` |  value_type&  
`const_reference` |  const value_type&  
`size_type` |  typename KeyContainer::size_type  
`difference_type` |  typename KeyContainer::difference_type  
`iterator` |  implementation-defined [LegacyRandomAccessIterator](../named_req/RandomAccessIterator.html "cpp/named req/RandomAccessIterator"), [ConstexprIterator](../named_req/ConstexprIterator.html "cpp/named req/ConstexprIterator")(since C++26) and [`random_access_iterator`](../iterator/random_access_iterator.html "cpp/iterator/random access iterator") to `value_type`  
`const_iterator` |  implementation-defined [LegacyRandomAccessIterator](../named_req/RandomAccessIterator.html "cpp/named req/RandomAccessIterator"), [ConstexprIterator](../named_req/ConstexprIterator.html "cpp/named req/ConstexprIterator")(since C++26) and [`random_access_iterator`](../iterator/random_access_iterator.html "cpp/iterator/random access iterator") to const value_type  
`reverse_iterator` |  [std::reverse_iterator](../iterator/reverse_iterator.html)<iterator>  
`const_reverse_iterator` |  [std::reverse_iterator](../iterator/reverse_iterator.html)<const_iterator>  
  
### Member objects

Member  |  Description   
---|---  
`container_type` `_c_` (private) |  the adapted container  
(exposition-only member object*)  
`key_compare` `_compare_` (private) |  the comparison function object  
(exposition-only member object*)  
  
### Member functions

[ (constructor)](flat_multiset/flat_multiset.html "cpp/container/flat multiset/flat multiset") |  constructs the `flat_multiset`   
(public member function)   
---|---  
(destructor)(implicitly declared) |  destroys every element of the container adaptor   
(public member function)  
[ operator=](flat_multiset/operator=.html "cpp/container/flat multiset/operator=") |  assigns values to the container adaptor   
(public member function)   
  
#####  Iterators   
  
[ begincbegin](flat_multiset/begin.html "cpp/container/flat multiset/begin") |  returns an iterator to the beginning   
(public member function)   
[ endcend](flat_multiset/end.html "cpp/container/flat multiset/end") |  returns an iterator to the end   
(public member function)   
[ rbegincrbegin](flat_multiset/rbegin.html "cpp/container/flat multiset/rbegin") |  returns a reverse iterator to the beginning   
(public member function)   
[ rendcrend](flat_multiset/rend.html "cpp/container/flat multiset/rend") |  returns a reverse iterator to the end   
(public member function)   
  
#####  Capacity   
  
[ empty](flat_multiset/empty.html "cpp/container/flat multiset/empty") |  checks whether the container adaptor is empty   
(public member function)   
[ size](flat_multiset/size.html "cpp/container/flat multiset/size") |  returns the number of elements   
(public member function)   
[ max_size](flat_multiset/max_size.html "cpp/container/flat multiset/max size") |  returns the maximum possible number of elements   
(public member function)   
  
#####  Modifiers   
  
[ emplace](flat_multiset/emplace.html "cpp/container/flat multiset/emplace") |  constructs element in-place   
(public member function)   
[ emplace_hint](flat_multiset/emplace_hint.html "cpp/container/flat multiset/emplace hint") |  constructs elements in-place using a hint   
(public member function)   
[ insert](flat_multiset/insert.html "cpp/container/flat multiset/insert") |  inserts elements   
(public member function)   
[ insert_range](flat_multiset/insert_range.html "cpp/container/flat multiset/insert range") |  inserts a range of elements   
(public member function)   
[ extract](flat_multiset/extract.html "cpp/container/flat multiset/extract") |  extracts the underlying container   
(public member function)   
[ replace](flat_multiset/replace.html "cpp/container/flat multiset/replace") |  replaces the underlying container   
(public member function)   
[ erase](flat_multiset/erase.html "cpp/container/flat multiset/erase") |  erases elements   
(public member function)   
[ swap](flat_multiset/swap.html "cpp/container/flat multiset/swap") |  swaps the contents   
(public member function)   
[ clear](flat_multiset/clear.html "cpp/container/flat multiset/clear") |  clears the contents   
(public member function)   
  
#####  Lookup   
  
[ find](flat_multiset/find.html "cpp/container/flat multiset/find") |  finds element with specific key   
(public member function)   
[ count](flat_multiset/count.html "cpp/container/flat multiset/count") |  returns the number of elements matching specific key   
(public member function)   
[ contains](flat_multiset/contains.html "cpp/container/flat multiset/contains") |  checks if the container contains element with specific key   
(public member function)   
[ lower_bound](flat_multiset/lower_bound.html "cpp/container/flat multiset/lower bound") |  returns an iterator to the first element _not less_ than the given key   
(public member function)   
[ upper_bound](flat_multiset/upper_bound.html "cpp/container/flat multiset/upper bound") |  returns an iterator to the first element _greater_ than the given key   
(public member function)   
[ equal_range](flat_multiset/equal_range.html "cpp/container/flat multiset/equal range") |  returns range of elements matching a specific key   
(public member function)   
  
#####  Observers   
  
[ key_comp](flat_multiset/key_comp.html "cpp/container/flat multiset/key comp") |  returns the function that compares keys   
(public member function)   
[ value_comp](flat_multiset/value_comp.html "cpp/container/flat multiset/value comp") |  returns the function that compares keys in objects of type `value_type`   
(public member function)   
  
### Non-member functions

[ operator==operator<=>](flat_multiset/operator_cmp.html "cpp/container/flat multiset/operator cmp")(C++23) |  lexicographically compares the values of two `flat_multiset`s   
(function template)   
---|---  
[ std::swap(std::flat_multiset)](flat_multiset/swap2.html "cpp/container/flat multiset/swap2")(C++23) |  specializes the [std::swap](../utility/swap.html "cpp/algorithm/swap") algorithm   
(function template)   
[ erase_if(std::flat_multiset)](flat_multiset/erase_if.html "cpp/container/flat multiset/erase if")(C++23) |  erases all elements satisfying specific criteria   
(function template)   
  
### Helper classes

[ std::uses_allocator<std::flat_multiset>](flat_multiset/uses_allocator.html "cpp/container/flat multiset/uses allocator")(C++23) |  specializes the [std::uses_allocator](../memory/uses_allocator.html "cpp/memory/uses allocator") type trait   
(class template specialization)   
---|---  
  
### Tags

[ sorted_equivalentsorted_equivalent_t](sorted_equivalent.html "cpp/container/sorted equivalent")(C++23) |  indicates that elements of a range are sorted (uniqueness is not required)  
(tag)  
---|---  
  
### [Deduction guides](flat_multiset/deduction_guides.html "cpp/container/flat multiset/deduction guides")

### Notes

The member types `iterator` and `const_iterator` may be aliases to the same type. This means defining a pair of function overloads using the two types as parameter types may violate the [One Definition Rule](../language/definition.html#One_Definition_Rule "cpp/language/definition"). Since `iterator` is convertible to `const_iterator`, a single function with a `const_iterator` as parameter type will work instead. 

[Feature-test](../utility/feature_test.html "cpp/utility/feature test") macro  | Value | Std | Feature   
---|---|---|---  
[`__cpp_lib_flat_set`](../experimental/feature_test.html#cpp_lib_flat_set "cpp/feature test") | [`202207L`](../compiler_support/23.html#cpp_lib_flat_set_202207L "cpp/compiler support/23") | (C++23) | std::flat_set and `std::flat_multiset`  
[`__cpp_lib_constexpr_flat_set`](../experimental/feature_test.html#cpp_lib_constexpr_flat_set "cpp/feature test") | [`202502L`](../compiler_support/26.html#cpp_lib_constexpr_flat_set_202502L "cpp/compiler support/26") | (C++26) | constexpr `std::flat_multiset`  
  
### Example

| This section is incomplete  
Reason: no example   
---|---  
  
### See also

[ flat_set](flat_set.html "cpp/container/flat set")(C++23) |  adapts a container to provide a collection of unique keys, sorted by keys   
(class template)   
---|---  
[ multiset](multiset.html "cpp/container/multiset") |  collection of keys, sorted by keys   
(class template)   
[ unordered_multiset](unordered_multiset.html "cpp/container/unordered multiset")(C++11) |  collection of keys, hashed by keys   
(class template) 
  *[Value]: The year/month in which the feature was adopted. The hyperlink under each value opens a compiler support page with entry for given feature.
  *[Std]: Standard in which the feature is introduced; DR means defect report against that revision
