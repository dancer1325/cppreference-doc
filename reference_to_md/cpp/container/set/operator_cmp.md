[[edit template]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/container/operator_cmp&action=edit)

[C++](../../../cpp.html "cpp")

[Compiler support](../../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../../freestanding.html "cpp/freestanding")  
[Language](../../language.html "cpp/language")  
[Standard library](../../standard_library.html "cpp/standard library")  
[Standard library headers](../../headers.html "cpp/header")  
[Named requirements](../../iterator/concepts.html "cpp/named req")  
[Feature test macros](../../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../../utility.html#Language_support "cpp/utility")  
[Concepts library](../../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../../error.html "cpp/error")  
[Memory management library](../../memory.html "cpp/memory")  
[Metaprogramming library](../../meta.html "cpp/meta") (C++11)  
[General utilities library](../../utility.html "cpp/utility")  
[Containers library](../../container.html "cpp/container")  
[Iterators library](../../iterator.html "cpp/iterator")  
[Ranges library](../../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../../algorithm.html "cpp/algorithm")  
[Strings library](../../string.html "cpp/string")  
[Text processing library](../../text.html "cpp/text")  
[Numerics library](../../numeric.html "cpp/numeric")  
[Date and time library](../../chrono.html "cpp/chrono")  
[Input/output library](../../io.html "cpp/io")  
[Filesystem library](../../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../../atomic.html "cpp/thread") (C++11)  
[Execution control library](../../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../../experimental.html "cpp/experimental")  
[Symbols index](../../symbol_index.html "cpp/symbol index")  
[External libraries](../../links/libs.html "cpp/links/libs")  
  


[Containers library](../../container.html "cpp/container")

[_node-handle_](../node_handle.html "cpp/container/node handle")(C++17)  
---  
[Sequence](../../container.html#Sequence_containers "cpp/container")  
[array](../array.html "cpp/container/array")(C++11)  
[vector](../vector.html "cpp/container/vector")  
[vector<bool>](../vector_bool.html "cpp/container/vector bool")  
[inplace_vector](../inplace_vector.html "cpp/container/inplace vector")(C++26)  
[hive](https://en.cppreference.com/mwiki/index.php?title=cpp/container/hive&action=edit&redlink=1 "cpp/container/hive \(page does not exist\)")(C++26)  
[deque](../deque.html "cpp/container/deque")  
[forward_list](../forward_list.html "cpp/container/forward list")(C++11)  
[list](../list.html "cpp/container/list")  
[Associative](../../container.html#Associative_containers "cpp/container")  
[set](../set.html "cpp/container/set")  
[multiset](../multiset.html "cpp/container/multiset")  
[map](../map.html "cpp/container/map")  
[multimap](../multimap.html "cpp/container/multimap")  
[Unordered associative](../../container.html#Unordered_associative_containers "cpp/container")  
[unordered_set](../unordered_set.html "cpp/container/unordered set")(C++11)  
[unordered_multiset](../unordered_multiset.html "cpp/container/unordered multiset")(C++11)  
[unordered_map](../unordered_map.html "cpp/container/unordered map")(C++11)  
[unordered_multimap](../unordered_multimap.html "cpp/container/unordered multimap")(C++11)  
[Adaptors](../../container.html#Container_adaptors "cpp/container")  
[stack](../stack.html "cpp/container/stack")  
[queue](../queue.html "cpp/container/queue")  
[priority_queue](../priority_queue.html "cpp/container/priority queue")  
[flat_set](../flat_set.html "cpp/container/flat set")(C++23)  
[flat_multiset](../flat_multiset.html "cpp/container/flat multiset")(C++23)  
[flat_map](../flat_map.html "cpp/container/flat map")(C++23)  
[flat_multimap](../flat_multimap.html "cpp/container/flat multimap")(C++23)  
[Views](../../container.html#Views "cpp/container")  
[span](../span.html "cpp/container/span")(C++20)  
[mdspan](../mdspan.html "cpp/container/mdspan")(C++23)  
Tables  
[Iterator invalidation](../../container.html#Iterator_invalidation "cpp/container")  
[Member function table](../../container.html#Member_function_table "cpp/container")  
[Non-member function table](../../container.html#Non-member_function_table "cpp/container")  
  


[`std::set`](../set.html "cpp/container/set")

[Member functions](../set.html#Member_functions "cpp/container/set")  
---  
|  | [set::set](set.html "cpp/container/set/set")  
---  
[set::~set](~set.html "cpp/container/set/~set")` `  
  
| [set::operator=](operator=.html "cpp/container/set/operator=")  
---  
[set::get_allocator](get_allocator.html "cpp/container/set/get allocator")  
  
|  | [Iterators](../set.html#Iterators "cpp/container/set")  
---  
[set::beginset::cbegin](begin.html "cpp/container/set/begin")(C++11)  
[set::endset::cend](end.html "cpp/container/set/end")(C++11)  
[set::rbeginset::crbegin](rbegin.html "cpp/container/set/rbegin")(C++11)` `  
[set::rendset::crend](rend.html "cpp/container/set/rend")(C++11)  
[Capacity](../set.html#Capacity "cpp/container/set")  
[set::size](size.html "cpp/container/set/size")  
[set::max_size](max_size.html "cpp/container/set/max size")  
[set::empty](empty.html "cpp/container/set/empty")  
[Observers](../set.html#Observers "cpp/container/set")  
[set::key_comp](key_comp.html "cpp/container/set/key comp")  
[set::value_comp](value_comp.html "cpp/container/set/value comp")  
  
| [Modifiers](../set.html#Modifiers "cpp/container/set")  
---  
[set::clear](clear.html "cpp/container/set/clear")  
[set::erase](erase.html "cpp/container/set/erase")  
[set::swap](swap.html "cpp/container/set/swap")  
[set::extract](extract.html "cpp/container/set/extract")(C++17)  
[set::merge](merge.html "cpp/container/set/merge")(C++17)  
[set::insert](insert.html "cpp/container/set/insert")  
[set::insert_range](insert_range.html "cpp/container/set/insert range")(C++23)  
[set::emplace](emplace.html "cpp/container/set/emplace")(C++11)  
[set::emplace_hint](emplace_hint.html "cpp/container/set/emplace hint")(C++11)  
[Lookup](../set.html#Lookup "cpp/container/set")  
[set::count](count.html "cpp/container/set/count")  
[set::find](find.html "cpp/container/set/find")  
[set::contains](contains.html "cpp/container/set/contains")(C++20)` `  
[set::equal_range](equal_range.html "cpp/container/set/equal range")  
[set::lower_bound](lower_bound.html "cpp/container/set/lower bound")  
[set::upper_bound](upper_bound.html "cpp/container/set/upper bound")  
  
[Non-member functions](../set.html#Non-member_functions "cpp/container/set")  
|  | **operator== operator<=>**(C++20)  
---  
[std::swap(std::set)](swap2.html "cpp/container/set/swap2")  
[erase_if(std::set)](erase_if.html "cpp/container/set/erase if")(C++20)` `  
  
  
  
| **operator!= operator<operator>operator<=operator>=**(until C++20)(until C++20)(until C++20)(until C++20)(until C++20)  
---  
  
[Deduction guides](deduction_guides.html "cpp/container/set/deduction guides")(C++17)  
  


Defined in header `[<set>](../../header/set.html "cpp/header/set")` |  |   
---|---|---  
template< class Key, class Compare, class Alloc >  
bool operator==( const [std::set](../set.html)<Key, Compare, Alloc>& lhs,  
const [std::set](../set.html)<Key, Compare, Alloc>& rhs ); |  (1) | (constexpr since C++26)  
template< class Key, class Compare, class Alloc >  
bool operator!=( const [std::set](../set.html)<Key, Compare, Alloc>& lhs,  
const [std::set](../set.html)<Key, Compare, Alloc>& rhs ); |  (2)  |  (until C++20)  
template< class Key, class Compare, class Alloc >  
bool operator< ( const [std::set](../set.html)<Key, Compare, Alloc>& lhs,  
const [std::set](../set.html)<Key, Compare, Alloc>& rhs ); |  (3)  |  (until C++20)  
template< class Key, class Compare, class Alloc >  
bool operator<=( const [std::set](../set.html)<Key, Compare, Alloc>& lhs,  
const [std::set](../set.html)<Key, Compare, Alloc>& rhs ); |  (4)  |  (until C++20)  
template< class Key, class Compare, class Alloc >  
bool operator> ( const [std::set](../set.html)<Key, Compare, Alloc>& lhs,  
const [std::set](../set.html)<Key, Compare, Alloc>& rhs ); |  (5)  |  (until C++20)  
template< class Key, class Compare, class Alloc >  
bool operator>=( const [std::set](../set.html)<Key, Compare, Alloc>& lhs,  
const [std::set](../set.html)<Key, Compare, Alloc>& rhs ); |  (6)  |  (until C++20)  
template< class Key, class Compare, class Alloc >  
/* see below */  
operator<=>( const [std::set](../set.html)<Key, Compare, Alloc>& lhs,  
const [std::set](../set.html)<Key, Compare, Alloc>& rhs ); |  (7) | (since C++20)   
(constexpr since C++26)  
| |   
  
Compares the contents of two `set`s. 

Let `value_type` be the value type of `set` (i.e., typename set::value_type): 

1,2) Checks if the contents of lhs and rhs are equal, that is, they have the same number of elements and each element in lhs compares equal with the element in rhs at the same position.

Equivalent to:  return [std::distance](../../iterator/distance.html)(lhs.begin(), lhs.end())  
== [std::distance](../../iterator/distance.html)(rhs.begin(), rhs.end())  
&& [std::equal](../../algorithm/equal.html)(lhs.begin(), lhs.end(), rhs.begin()); | (until C++14)  
---|---  
return [std::equal](../../algorithm/equal.html)(lhs.begin(), lhs.end(), rhs.begin(), rhs.end()); | (since C++14)  
  
If `value_type` is not [EqualityComparable](../../named_req/EqualityComparable.html "cpp/named req/EqualityComparable"), the behavior is undefined.

3-7) Compares the contents of lhs and rhs lexicographically.

3-6) Equivalent to return [std::lexicographical_compare](../../algorithm/lexicographical_compare.html)(lhs.begin(), lhs.end(),  
rhs.begin(), rhs.end());.

If any of the following conditions is satisfied, the behavior is undefined: 

  * `value_type` is not [LessThanComparable](../../named_req/LessThanComparable.html "cpp/named req/LessThanComparable"). 
  * operator< does not establish [total order](https://en.wikipedia.org/wiki/Total_order "enwiki:Total order").



7) Equivalent to return [std::lexicographical_compare_three_way](../../algorithm/lexicographical_compare_three_way.html)(lhs.begin(), lhs.end(),  
` `rhs.begin(), rhs.end(),  
` `[` _synth-three-way_`](../../standard_library/synth-three-way.html "cpp/standard library/synth-three-way")).

The return type is the return type of [`_synth-three-way_`](../../standard_library/synth-three-way.html "cpp/standard library/synth-three-way") (i.e., [`_synth-three-way-result_`](../../standard_library/synth-three-way.html "cpp/standard library/synth-three-way") ﻿<value_type>).

If any of the following conditions is satisfied, the behavior is undefined: 

  * `T` does not model [`three_way_comparable`](../../utility/compare/three_way_comparable.html "cpp/utility/compare/three way comparable"). 
  * operator< is not defined for values of type (possibly const-qualified) `value_type`. 
  * operator< does not establish [total order](https://en.wikipedia.org/wiki/Total_order "enwiki:Total order").



The `<`, `<=`, `>`, `>=`, and `!=` operators are [synthesized](../../language/operators.html#Comparison_operators "cpp/language/operators") from operator<=> and operator== respectively.  | (since C++20)  
---|---  
  
## Contents

  * [1 Parameters](operator_cmp.html#Parameters)
  * [2 Return value](operator_cmp.html#Return_value)
  * [3 Complexity](operator_cmp.html#Complexity)
  * [4 Notes](operator_cmp.html#Notes)
  * [5 Example](operator_cmp.html#Example)
  * [6 Defect reports](operator_cmp.html#Defect_reports)

  
---  
  
### Parameters

lhs, rhs  |  \-  |  `set`s whose contents to compare   
---|---|---  
  
### Return value

Operator  | lhs and rhs  
are equal  | lhs is  
lexicographically greater  | rhs is  
lexicographically greater   
---|---|---|---  
operator== | true | false  
operator!= | false | true  
operator< | false | false | true  
operator<= | true  
operator> | false | true | false  
operator>= | true  
operator<=> |  a value equal to ​0​ | a value greater then ​0​ | a value less than ​0​  
  
### Complexity

1,2) Constant if lhs and rhs are of different size, otherwise linear in the size of the `set`.

3-7) Linear in the size of the `set`.

### Notes

The relational operators are defined in terms of `value_type`'s operator<.  | (until C++20)  
---|---  
The relational operators are not defined. The rewritten candidate operator<=> will be selected by overload resolution. operator<=> uses `value_type`'s operator<=> if possible, or `value_type`'s operator< otherwise. Notably, if the `value_type` does not itself provide operator<=>, but is implicitly convertible to a three-way comparable type, that conversion will be used instead of operator<.  | (since C++20)  
  
These non-member comparison operators do not use `Compare` to compare elements. 

### Example

Run this code
    
    
    #include <cassert>
    #include <compare>
    #include <set>
     
    int main()
    {
        const [std::set](../set.html)
            a{1, 2, 3},
            b{1, 2, 3},
            c{7, 8, 9, 10};
     
        [assert](../../error/assert.html)
        (""
            "Compare equal containers:" &&
            (a != b) == false &&
            (a == b) == true &&
            (a < b) == false &&
            (a <= b) == true &&
            (a > b) == false &&
            (a >= b) == true &&
            (a <=> b) != std::weak_ordering::less &&
            (a <=> b) != std::weak_ordering::greater &&
            (a <=> b) == std::weak_ordering::equivalent &&
            (a <=> b) >= 0 &&
            (a <=> b) <= 0 &&
            (a <=> b) == 0 &&
     
            "Compare non equal containers:" &&
            (a != c) == true &&
            (a == c) == false &&
            (a < c) == true &&
            (a <= c) == true &&
            (a > c) == false &&
            (a >= c) == false &&
            (a <=> c) == std::weak_ordering::less &&
            (a <=> c) != std::weak_ordering::equivalent &&
            (a <=> c) != std::weak_ordering::greater &&
            (a <=> c) < 0 &&
            (a <=> c) != 0 &&
            (a <=> c) <= 0 &&
        "");
    }

### Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[LWG 3431](https://cplusplus.github.io/LWG/issue3431) | C++20  | operator<=> did not require `T`  
to model [`three_way_comparable`](../../utility/compare/three_way_comparable.html "cpp/utility/compare/three way comparable") | requires 
