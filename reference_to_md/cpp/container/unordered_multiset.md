[C++](../../cpp.html "cpp")

[Compiler support](../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../freestanding.html "cpp/freestanding")  
[Language](../language.html "cpp/language")  
[Standard library](../standard_library.html "cpp/standard library")  
[Standard library headers](../headers.html "cpp/header")  
[Named requirements](../iterator/concepts.html "cpp/named req")  
[Feature test macros](../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../utility.html#Language_support "cpp/utility")  
[Concepts library](../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../error.html "cpp/error")  
[Memory management library](../memory.html "cpp/memory")  
[Metaprogramming library](../meta.html "cpp/meta") (C++11)  
[General utilities library](../utility.html "cpp/utility")  
[Containers library](../container.html "cpp/container")  
[Iterators library](../iterator.html "cpp/iterator")  
[Ranges library](../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../algorithm.html "cpp/algorithm")  
[Strings library](../string.html "cpp/string")  
[Text processing library](../text.html "cpp/text")  
[Numerics library](../numeric.html "cpp/numeric")  
[Date and time library](../chrono.html "cpp/chrono")  
[Input/output library](../io.html "cpp/io")  
[Filesystem library](../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../atomic.html "cpp/thread") (C++11)  
[Execution control library](../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../experimental.html "cpp/experimental")  
[Symbols index](../symbol_index.html "cpp/symbol index")  
[External libraries](../links/libs.html "cpp/links/libs")  
  


[Containers library](../container.html "cpp/container")

[_node-handle_](node_handle.html "cpp/container/node handle")(C++17)  
---  
[Sequence](../container.html#Sequence_containers "cpp/container")  
[array](array.html "cpp/container/array")(C++11)  
[vector](vector.html "cpp/container/vector")  
[vector<bool>](vector_bool.html "cpp/container/vector bool")  
[inplace_vector](inplace_vector.html "cpp/container/inplace vector")(C++26)  
[hive](https://en.cppreference.com/mwiki/index.php?title=cpp/container/hive&action=edit&redlink=1 "cpp/container/hive \(page does not exist\)")(C++26)  
[deque](deque.html "cpp/container/deque")  
[forward_list](forward_list.html "cpp/container/forward list")(C++11)  
[list](list.html "cpp/container/list")  
[Associative](../container.html#Associative_containers "cpp/container")  
[set](set.html "cpp/container/set")  
[multiset](multiset.html "cpp/container/multiset")  
[map](map.html "cpp/container/map")  
[multimap](multimap.html "cpp/container/multimap")  
[Unordered associative](../container.html#Unordered_associative_containers "cpp/container")  
[unordered_set](unordered_set.html "cpp/container/unordered set")(C++11)  
**unordered_multiset**(C++11)  
[unordered_map](unordered_map.html "cpp/container/unordered map")(C++11)  
[unordered_multimap](unordered_multimap.html "cpp/container/unordered multimap")(C++11)  
[Adaptors](../container.html#Container_adaptors "cpp/container")  
[stack](stack.html "cpp/container/stack")  
[queue](queue.html "cpp/container/queue")  
[priority_queue](priority_queue.html "cpp/container/priority queue")  
[flat_set](flat_set.html "cpp/container/flat set")(C++23)  
[flat_multiset](flat_multiset.html "cpp/container/flat multiset")(C++23)  
[flat_map](flat_map.html "cpp/container/flat map")(C++23)  
[flat_multimap](flat_multimap.html "cpp/container/flat multimap")(C++23)  
[Views](../container.html#Views "cpp/container")  
[span](span.html "cpp/container/span")(C++20)  
[mdspan](mdspan.html "cpp/container/mdspan")(C++23)  
Tables  
[Iterator invalidation](../container.html#Iterator_invalidation "cpp/container")  
[Member function table](../container.html#Member_function_table "cpp/container")  
[Non-member function table](../container.html#Non-member_function_table "cpp/container")  
  


`**std::unordered_multiset**`

[Member types](unordered_multiset.html#Member_types "cpp/container/unordered multiset")  
---  
[Member functions](unordered_multiset.html#Member_functions "cpp/container/unordered multiset")  
| [unordered_multiset::unordered_multiset](unordered_multiset/unordered_multiset.html "cpp/container/unordered multiset/unordered multiset")  
---  
[unordered_multiset::~unordered_multiset](unordered_multiset/~unordered_multiset.html "cpp/container/unordered multiset/~unordered multiset")` `  
[unordered_multiset::operator=](unordered_multiset/operator=.html "cpp/container/unordered multiset/operator=")  
[unordered_multiset::get_allocator](unordered_multiset/get_allocator.html "cpp/container/unordered multiset/get allocator")  
[Iterators](unordered_multiset.html#Iterators "cpp/container/unordered multiset")  
[unordered_multiset::beginunordered_multiset::cbegin](unordered_multiset/begin.html "cpp/container/unordered multiset/begin")  
[unordered_multiset::endunordered_multiset::cend](unordered_multiset/end.html "cpp/container/unordered multiset/end")  
[Capacity](unordered_multiset.html#Capacity "cpp/container/unordered multiset")  
[unordered_multiset::size](unordered_multiset/size.html "cpp/container/unordered multiset/size")  
[unordered_multiset::max_size](unordered_multiset/max_size.html "cpp/container/unordered multiset/max size")  
[unordered_multiset::empty](unordered_multiset/empty.html "cpp/container/unordered multiset/empty")  
[Modifiers](unordered_multiset.html#Modifiers "cpp/container/unordered multiset")  
[unordered_multiset::clear](unordered_multiset/clear.html "cpp/container/unordered multiset/clear")  
[unordered_multiset::insert](unordered_multiset/insert.html "cpp/container/unordered multiset/insert")  
[unordered_multiset::insert_range](unordered_multiset/insert_range.html "cpp/container/unordered multiset/insert range")(C++23)  
[unordered_multiset::emplace](unordered_multiset/emplace.html "cpp/container/unordered multiset/emplace")  
[unordered_multiset::emplace_hint](unordered_multiset/emplace_hint.html "cpp/container/unordered multiset/emplace hint")  
[unordered_multiset::erase](unordered_multiset/erase.html "cpp/container/unordered multiset/erase")  
[unordered_multiset::swap](unordered_multiset/swap.html "cpp/container/unordered multiset/swap")  
[unordered_multiset::extract](unordered_multiset/extract.html "cpp/container/unordered multiset/extract")(C++17)  
[unordered_multiset::merge](unordered_multiset/merge.html "cpp/container/unordered multiset/merge")(C++17)  
  
| [Lookup](unordered_multiset.html#Lookup "cpp/container/unordered multiset")  
---  
[unordered_multiset::count](unordered_multiset/count.html "cpp/container/unordered multiset/count")  
[unordered_multiset::find](unordered_multiset/find.html "cpp/container/unordered multiset/find")  
[unordered_multiset::contains](unordered_multiset/contains.html "cpp/container/unordered multiset/contains")(C++20)  
[unordered_multiset::equal_range](unordered_multiset/equal_range.html "cpp/container/unordered multiset/equal range")  
[Bucket interface](unordered_multiset.html#Bucket_interface "cpp/container/unordered multiset")  
[unordered_multiset::begin(size_type)unordered_multiset::cbegin(size_type)](unordered_multiset/begin2.html "cpp/container/unordered multiset/begin2")  
[unordered_multiset::end(size_type)unordered_multiset::cend(size_type)](unordered_multiset/end2.html "cpp/container/unordered multiset/end2")  
[unordered_multiset::bucket_count](unordered_multiset/bucket_count.html "cpp/container/unordered multiset/bucket count")  
[unordered_multiset::max_bucket_count](unordered_multiset/max_bucket_count.html "cpp/container/unordered multiset/max bucket count")  
[unordered_multiset::bucket_size](unordered_multiset/bucket_size.html "cpp/container/unordered multiset/bucket size")  
[unordered_multiset::bucket](unordered_multiset/bucket.html "cpp/container/unordered multiset/bucket")  
[Hash policy](unordered_multiset.html#Hash_policy "cpp/container/unordered multiset")  
[unordered_multiset::load_factor](unordered_multiset/load_factor.html "cpp/container/unordered multiset/load factor")  
[unordered_multiset::max_load_factor](unordered_multiset/max_load_factor.html "cpp/container/unordered multiset/max load factor")  
[unordered_multiset::rehash](unordered_multiset/rehash.html "cpp/container/unordered multiset/rehash")  
[unordered_multiset::reserve](unordered_multiset/reserve.html "cpp/container/unordered multiset/reserve")  
[Observers](unordered_multiset.html#Observers "cpp/container/unordered multiset")  
[unordered_multiset::hash_function](unordered_multiset/hash_function.html "cpp/container/unordered multiset/hash function")  
[unordered_multiset::key_eq](unordered_multiset/key_eq.html "cpp/container/unordered multiset/key eq")  
  
[Non-member functions](unordered_multiset.html#Non-member_functions "cpp/container/unordered multiset")  
| [operator==operator!=](unordered_multiset/operator_cmp.html "cpp/container/unordered multiset/operator cmp")(until C++20)  
---  
  
| [std::swap(std::unordered_multiset)](unordered_multiset/swap2.html "cpp/container/unordered multiset/swap2")  
---  
[erase_if(std::unordered_multiset)](unordered_multiset/erase_if.html "cpp/container/unordered multiset/erase if")(C++20)  
  
[Deduction guides](unordered_multiset/deduction_guides.html "cpp/container/unordered multiset/deduction guides") (C++17)  
  


Defined in header `[<unordered_set>](../header/unordered_set.html "cpp/header/unordered set")` |  |   
---|---|---  
template<  
class Key,  
class Hash = [std::hash](../utility/hash.html)<Key>,  
class KeyEqual = [std::equal_to](../utility/functional/equal_to.html)<Key>,  
class Allocator = [std::allocator](../memory/allocator.html)<Key>  
> class unordered_multiset; |  (1)  |  (since C++11)  
namespace pmr {  
template<  
class Key,  
class Hash = [std::hash](../utility/hash.html)<Key>,  
class Pred = [std::equal_to](../utility/functional/equal_to.html)<Key>  
> using unordered_multiset = std::unordered_multiset<Key, Hash, Pred,  
[std::pmr::polymorphic_allocator](../memory/polymorphic_allocator.html)<Key>>;  
} |  (2)  |  (since C++17)  
| |   
  
`std::unordered_multiset` is an associative container that contains set of possibly non-unique objects of type Key. Search, insertion, and removal have average constant-time complexity. 

Internally, the elements are not sorted in any particular order, but organized into buckets. Which bucket an element is placed into depends entirely on the hash of its value. This allows fast access to individual elements, since once hash is computed, it refers to the exact bucket the element is placed into. 

The iteration order of this container is not required to be stable (so, for example, [std::equal](../algorithm/equal.html "cpp/algorithm/equal") cannot be used to compare two `std::unordered_multiset`s), except that every group of elements whose keys compare _equivalent_ (compare equal with [key_eq()](unordered_multiset/key_eq.html "cpp/container/unordered multiset/key eq") as the comparator) forms a contiguous subrange in the iteration order, also accessible with [equal_range()](unordered_multiset/equal_range.html "cpp/container/unordered multiset/equal range"). 

`std::unordered_multiset` meets the requirements of [Container](../named_req/Container.html "cpp/named req/Container"), [AllocatorAwareContainer](../named_req/AllocatorAwareContainer.html "cpp/named req/AllocatorAwareContainer"), [UnorderedAssociativeContainer](../named_req/UnorderedAssociativeContainer.html "cpp/named req/UnorderedAssociativeContainer"). 

All member functions of `std::unordered_multiset` are constexpr: it is possible to create and use `std::unordered_multiset` objects in the evaluation of a constant expression.However, `std::unordered_multiset` objects generally cannot be constexpr, because any dynamically allocated storage must be released in the same evaluation of constant expression. | (since C++26)  
---|---  
  
## Contents

  * [1 Template parameters](unordered_multiset.html#Template_parameters)
  * [2 Member types](unordered_multiset.html#Member_types)
  * [3 Member functions](unordered_multiset.html#Member_functions)
    * [3.1 Iterators](unordered_multiset.html#Iterators)
    * [3.2 Capacity](unordered_multiset.html#Capacity)
    * [3.3 Modifiers](unordered_multiset.html#Modifiers)
    * [3.4 Lookup](unordered_multiset.html#Lookup)
    * [3.5 Bucket interface](unordered_multiset.html#Bucket_interface)
    * [3.6 Hash policy](unordered_multiset.html#Hash_policy)
    * [3.7 Observers](unordered_multiset.html#Observers)
  * [4 Non-member functions](unordered_multiset.html#Non-member_functions)
  * [5 Deduction guides](unordered_multiset.html#Deduction_guides)
  * [6 Notes](unordered_multiset.html#Notes)
  * [7 Example](unordered_multiset.html#Example)
  * [8 Defect reports](unordered_multiset.html#Defect_reports)
  * [9 See also](unordered_multiset.html#See_also)

  
---  
  
### Template parameters

| This section is incomplete  
Reason: Add descriptions of the template parameters.   
---|---  
  
### Member types

Type  |  Definition   
---|---  
`key_type` |  `Key`  
`value_type` |  `Key`  
`size_type` |  Unsigned integer type (usually [std::size_t](../types/size_t.html "cpp/types/size t"))  
`difference_type` |  Signed integer type (usually [std::ptrdiff_t](../types/ptrdiff_t.html "cpp/types/ptrdiff t"))  
`hasher` |  `Hash`  
`key_equal` |  `KeyEqual`  
`allocator_type` |  `Allocator`  
`reference` |  value_type&  
`const_reference` |  const value_type&  
`pointer` |  [std::allocator_traits](../memory/allocator_traits.html)<Allocator>::pointer  
`const_pointer` |  [std::allocator_traits](../memory/allocator_traits.html)<Allocator>::const_pointer  
`iterator` |  Constant [LegacyForwardIterator](../named_req/ForwardIterator.html "cpp/named req/ForwardIterator") and [ConstexprIterator](../named_req/ConstexprIterator.html "cpp/named req/ConstexprIterator")(since C++26) to `value_type`  
`const_iterator` |  [LegacyForwardIterator](../named_req/ForwardIterator.html "cpp/named req/ForwardIterator") and [ConstexprIterator](../named_req/ConstexprIterator.html "cpp/named req/ConstexprIterator")(since C++26) to const value_type  
`local_iterator` |  An iterator type whose category, value, difference, pointer and  
reference types are the same as `iterator`. This iterator  
can be used to iterate through a single bucket but not across buckets  
`const_local_iterator` |  An iterator type whose category, value, difference, pointer and  
reference types are the same as `const_iterator`. This iterator  
can be used to iterate through a single bucket but not across buckets  
`node_type` (since C++17) |  a specialization of [node handle](node_handle.html "cpp/container/node handle") representing a container node  
  
### Member functions

[ (constructor)](unordered_multiset/unordered_multiset.html "cpp/container/unordered multiset/unordered multiset") |  constructs the `unordered_multiset`   
(public member function)   
---|---  
[ (destructor)](unordered_multiset/~unordered_multiset.html "cpp/container/unordered multiset/~unordered multiset") |  destructs the `unordered_multiset`   
(public member function)   
[ operator=](unordered_multiset/operator=.html "cpp/container/unordered multiset/operator=") |  assigns values to the container   
(public member function)   
[ get_allocator](unordered_multiset/get_allocator.html "cpp/container/unordered multiset/get allocator") |  returns the associated allocator   
(public member function)   
  
#####  Iterators   
  
[ begincbegin](unordered_multiset/begin.html "cpp/container/unordered multiset/begin") |  returns an iterator to the beginning   
(public member function)   
[ endcend](unordered_multiset/end.html "cpp/container/unordered multiset/end") |  returns an iterator to the end   
(public member function)   
  
#####  Capacity   
  
[ empty](unordered_multiset/empty.html "cpp/container/unordered multiset/empty") |  checks whether the container is empty   
(public member function)   
[ size](unordered_multiset/size.html "cpp/container/unordered multiset/size") |  returns the number of elements   
(public member function)   
[ max_size](unordered_multiset/max_size.html "cpp/container/unordered multiset/max size") |  returns the maximum possible number of elements   
(public member function)   
  
#####  Modifiers   
  
[ clear](unordered_multiset/clear.html "cpp/container/unordered multiset/clear") |  clears the contents   
(public member function)   
[ insert](unordered_multiset/insert.html "cpp/container/unordered multiset/insert") |  inserts elements or nodes(since C++17)   
(public member function)   
[ insert_range](unordered_multiset/insert_range.html "cpp/container/unordered multiset/insert range")(C++23) |  inserts a range of elements   
(public member function)   
[ emplace](unordered_multiset/emplace.html "cpp/container/unordered multiset/emplace") |  constructs element in-place   
(public member function)   
[ emplace_hint](unordered_multiset/emplace_hint.html "cpp/container/unordered multiset/emplace hint") |  constructs elements in-place using a hint   
(public member function)   
[ erase](unordered_multiset/erase.html "cpp/container/unordered multiset/erase") |  erases elements   
(public member function)   
[ swap](unordered_multiset/swap.html "cpp/container/unordered multiset/swap") |  swaps the contents   
(public member function)   
[ extract](unordered_multiset/extract.html "cpp/container/unordered multiset/extract")(C++17) |  extracts nodes from the container   
(public member function)   
[ merge](unordered_multiset/merge.html "cpp/container/unordered multiset/merge")(C++17) |  splices nodes from another container   
(public member function)   
  
#####  Lookup   
  
[ count](unordered_multiset/count.html "cpp/container/unordered multiset/count") |  returns the number of elements matching specific key   
(public member function)   
[ find](unordered_multiset/find.html "cpp/container/unordered multiset/find") |  finds element with specific key   
(public member function)   
[ contains](unordered_multiset/contains.html "cpp/container/unordered multiset/contains")(C++20) |  checks if the container contains element with specific key   
(public member function)   
[ equal_range](unordered_multiset/equal_range.html "cpp/container/unordered multiset/equal range") |  returns range of elements matching a specific key   
(public member function)   
  
#####  Bucket interface   
  
[ begin(size_type)cbegin(size_type)](unordered_multiset/begin2.html "cpp/container/unordered multiset/begin2") |  returns an iterator to the beginning of the specified bucket   
(public member function) &action=edit)  
[ end(size_type)cend(size_type)](unordered_multiset/end2.html "cpp/container/unordered multiset/end2") |  returns an iterator to the end of the specified bucket   
(public member function) &action=edit)  
[ bucket_count](unordered_multiset/bucket_count.html "cpp/container/unordered multiset/bucket count") |  returns the number of buckets   
(public member function)   
[ max_bucket_count](unordered_multiset/max_bucket_count.html "cpp/container/unordered multiset/max bucket count") |  returns the maximum number of buckets   
(public member function)   
[ bucket_size](unordered_multiset/bucket_size.html "cpp/container/unordered multiset/bucket size") |  returns the number of elements in specific bucket   
(public member function)   
[ bucket](unordered_multiset/bucket.html "cpp/container/unordered multiset/bucket") |  returns the bucket for specific key   
(public member function)   
  
#####  Hash policy   
  
[ load_factor](unordered_multiset/load_factor.html "cpp/container/unordered multiset/load factor") |  returns average number of elements per bucket   
(public member function)   
[ max_load_factor](unordered_multiset/max_load_factor.html "cpp/container/unordered multiset/max load factor") |  manages maximum average number of elements per bucket   
(public member function)   
[ rehash](unordered_multiset/rehash.html "cpp/container/unordered multiset/rehash") |  reserves at least the specified number of buckets and regenerates the hash table   
(public member function)   
[ reserve](unordered_multiset/reserve.html "cpp/container/unordered multiset/reserve") |  reserves space for at least the specified number of elements and regenerates the hash table   
(public member function)   
  
#####  Observers   
  
[ hash_function](unordered_multiset/hash_function.html "cpp/container/unordered multiset/hash function") |  returns function used to hash the keys   
(public member function)   
[ key_eq](unordered_multiset/key_eq.html "cpp/container/unordered multiset/key eq") |  returns the function used to compare keys for equality   
(public member function)   
  
### Non-member functions

[ operator==operator!=](unordered_multiset/operator_cmp.html "cpp/container/unordered multiset/operator cmp")(C++11)(C++11)(removed in C++20) |  compares the values in the unordered_multiset   
(function template)   
---|---  
[ std::swap(std::unordered_multiset)](unordered_multiset/swap2.html "cpp/container/unordered multiset/swap2")(C++11) |  specializes the [std::swap](../utility/swap.html "cpp/algorithm/swap") algorithm   
(function template)   
[ erase_if(std::unordered_multiset)](unordered_multiset/erase_if.html "cpp/container/unordered multiset/erase if")(C++20) |  erases all elements satisfying specific criteria   
(function template)   
  
###  [Deduction guides](unordered_multiset/deduction_guides.html "cpp/container/unordered multiset/deduction guides")

| (since C++17)  
---|---  
  
### Notes

The member types `iterator` and `const_iterator` may be aliases to the same type. This means defining a pair of function overloads using the two types as parameter types may violate the [One Definition Rule](../language/definition.html#One_Definition_Rule "cpp/language/definition"). Since `iterator` is convertible to `const_iterator`, a single function with a `const_iterator` as parameter type will work instead. 

[Feature-test](../utility/feature_test.html "cpp/utility/feature test") macro  | Value | Std | Feature   
---|---|---|---  
[`__cpp_lib_containers_ranges`](../experimental/feature_test.html#cpp_lib_containers_ranges "cpp/feature test") | [`202202L`](../compiler_support/23.html#cpp_lib_containers_ranges_202202L "cpp/compiler support/23") | (C++23) | Ranges construction and insertion for containers   
[`__cpp_lib_constexpr_unordered_set`](../experimental/feature_test.html#cpp_lib_constexpr_unordered_set "cpp/feature test") | [`202502L`](../compiler_support/26.html#cpp_lib_constexpr_unordered_set_202502L "cpp/compiler support/26") | (C++26) | constexpr `std::unordered_muliset`  
  
### Example

| This section is incomplete  
Reason: no example   
---|---  
  
### Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[LWG 2050](https://cplusplus.github.io/LWG/issue2050) | C++11  | the definitions of `reference`, `const_reference`, `pointer`  
and `const_pointer` were based on `allocator_type` | based on `value_type` and  
[std::allocator_traits](../memory/allocator_traits.html "cpp/memory/allocator traits")  
  
### See also

[ unordered_set](unordered_set.html "cpp/container/unordered set")(C++11) |  collection of unique keys, hashed by keys   
(class template)   
---|---  
[ multiset](multiset.html "cpp/container/multiset") |  collection of keys, sorted by keys   
(class template)   
[ flat_multiset](flat_multiset.html "cpp/container/flat multiset")(C++23) |  adapts a container to provide a collection of keys, sorted by keys   
(class template) 
  *[Value]: The year/month in which the feature was adopted. The hyperlink under each value opens a compiler support page with entry for given feature.
  *[Std]: Standard in which the feature is introduced; DR means defect report against that revision
