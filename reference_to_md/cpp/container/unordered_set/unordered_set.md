[[edit template]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/container/constructor_unord&action=edit)

[C++](../../../cpp.html "cpp")

[Compiler support](../../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../../freestanding.html "cpp/freestanding")  
[Language](../../language.html "cpp/language")  
[Standard library](../../standard_library.html "cpp/standard library")  
[Standard library headers](../../headers.html "cpp/header")  
[Named requirements](../../iterator/concepts.html "cpp/named req")  
[Feature test macros](../../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../../utility.html#Language_support "cpp/utility")  
[Concepts library](../../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../../error.html "cpp/error")  
[Memory management library](../../memory.html "cpp/memory")  
[Metaprogramming library](../../meta.html "cpp/meta") (C++11)  
[General utilities library](../../utility.html "cpp/utility")  
[Containers library](../../container.html "cpp/container")  
[Iterators library](../../iterator.html "cpp/iterator")  
[Ranges library](../../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../../algorithm.html "cpp/algorithm")  
[Strings library](../../string.html "cpp/string")  
[Text processing library](../../text.html "cpp/text")  
[Numerics library](../../numeric.html "cpp/numeric")  
[Date and time library](../../chrono.html "cpp/chrono")  
[Input/output library](../../io.html "cpp/io")  
[Filesystem library](../../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../../atomic.html "cpp/thread") (C++11)  
[Execution control library](../../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../../experimental.html "cpp/experimental")  
[Symbols index](../../symbol_index.html "cpp/symbol index")  
[External libraries](../../links/libs.html "cpp/links/libs")  
  


[Containers library](../../container.html "cpp/container")

[_node-handle_](../node_handle.html "cpp/container/node handle")(C++17)  
---  
[Sequence](../../container.html#Sequence_containers "cpp/container")  
[array](../array.html "cpp/container/array")(C++11)  
[vector](../vector.html "cpp/container/vector")  
[vector<bool>](../vector_bool.html "cpp/container/vector bool")  
[inplace_vector](../inplace_vector.html "cpp/container/inplace vector")(C++26)  
[hive](https://en.cppreference.com/mwiki/index.php?title=cpp/container/hive&action=edit&redlink=1 "cpp/container/hive \(page does not exist\)")(C++26)  
[deque](../deque.html "cpp/container/deque")  
[forward_list](../forward_list.html "cpp/container/forward list")(C++11)  
[list](../list.html "cpp/container/list")  
[Associative](../../container.html#Associative_containers "cpp/container")  
[set](../set.html "cpp/container/set")  
[multiset](../multiset.html "cpp/container/multiset")  
[map](../map.html "cpp/container/map")  
[multimap](../multimap.html "cpp/container/multimap")  
[Unordered associative](../../container.html#Unordered_associative_containers "cpp/container")  
[unordered_set](../unordered_set.html "cpp/container/unordered set")(C++11)  
[unordered_multiset](../unordered_multiset.html "cpp/container/unordered multiset")(C++11)  
[unordered_map](../unordered_map.html "cpp/container/unordered map")(C++11)  
[unordered_multimap](../unordered_multimap.html "cpp/container/unordered multimap")(C++11)  
[Adaptors](../../container.html#Container_adaptors "cpp/container")  
[stack](../stack.html "cpp/container/stack")  
[queue](../queue.html "cpp/container/queue")  
[priority_queue](../priority_queue.html "cpp/container/priority queue")  
[flat_set](../flat_set.html "cpp/container/flat set")(C++23)  
[flat_multiset](../flat_multiset.html "cpp/container/flat multiset")(C++23)  
[flat_map](../flat_map.html "cpp/container/flat map")(C++23)  
[flat_multimap](../flat_multimap.html "cpp/container/flat multimap")(C++23)  
[Views](../../container.html#Views "cpp/container")  
[span](../span.html "cpp/container/span")(C++20)  
[mdspan](../mdspan.html "cpp/container/mdspan")(C++23)  
Tables  
[Iterator invalidation](../../container.html#Iterator_invalidation "cpp/container")  
[Member function table](../../container.html#Member_function_table "cpp/container")  
[Non-member function table](../../container.html#Non-member_function_table "cpp/container")  
  


`[std::unordered_set](../unordered_set.html "cpp/container/unordered set")`

[Member types](../unordered_set.html#Member_types "cpp/container/unordered set")  
---  
[Member functions](../unordered_set.html#Member_functions "cpp/container/unordered set")  
| **unordered_set::unordered_set**  
---  
[unordered_set::~unordered_set](~unordered_set.html "cpp/container/unordered set/~unordered set")  
[unordered_set::operator=](operator=.html "cpp/container/unordered set/operator=")  
[unordered_set::get_allocator](get_allocator.html "cpp/container/unordered set/get allocator")  
[Iterators](../unordered_set.html#Iterators "cpp/container/unordered set")  
[unordered_set::beginunordered_set::cbegin](begin.html "cpp/container/unordered set/begin")  
[unordered_set::endunordered_set::cend](end.html "cpp/container/unordered set/end")  
[Capacity](../unordered_set.html#Capacity "cpp/container/unordered set")  
[unordered_set::size](size.html "cpp/container/unordered set/size")  
[unordered_set::max_size](max_size.html "cpp/container/unordered set/max size")  
[unordered_set::empty](empty.html "cpp/container/unordered set/empty")  
[Modifiers](../unordered_set.html#Modifiers "cpp/container/unordered set")  
[unordered_set::clear](clear.html "cpp/container/unordered set/clear")  
[unordered_set::erase](erase.html "cpp/container/unordered set/erase")  
[unordered_set::swap](swap.html "cpp/container/unordered set/swap")  
[unordered_set::extract](extract.html "cpp/container/unordered set/extract")(C++17)  
[unordered_set::merge](merge.html "cpp/container/unordered set/merge")(C++17)  
[unordered_set::insert](insert.html "cpp/container/unordered set/insert")  
[unordered_set::insert_range](insert_range.html "cpp/container/unordered set/insert range")(C++23)` `  
[unordered_set::emplace](emplace.html "cpp/container/unordered set/emplace")  
[unordered_set::emplace_hint](emplace_hint.html "cpp/container/unordered set/emplace hint")  
  
| [Lookup](../unordered_set.html#Lookup "cpp/container/unordered set")  
---  
[unordered_set::count](count.html "cpp/container/unordered set/count")  
[unordered_set::find](find.html "cpp/container/unordered set/find")  
[unordered_set::contains](contains.html "cpp/container/unordered set/contains")(C++20)  
[unordered_set::equal_range](equal_range.html "cpp/container/unordered set/equal range")  
[Bucket interface](../unordered_set.html#Bucket_interface "cpp/container/unordered set")  
[unordered_set::begin(size_type)unordered_set::cbegin(size_type)](begin2.html "cpp/container/unordered set/begin2")  
[unordered_set::end(size_type)unordered_set::cend(size_type)](end2.html "cpp/container/unordered set/end2")  
[unordered_set::bucket_count](bucket_count.html "cpp/container/unordered set/bucket count")  
[unordered_set::max_bucket_count](max_bucket_count.html "cpp/container/unordered set/max bucket count")  
[unordered_set::bucket_size](bucket_size.html "cpp/container/unordered set/bucket size")  
[unordered_set::bucket](bucket.html "cpp/container/unordered set/bucket")  
[Hash policy](../unordered_set.html#Hash_policy "cpp/container/unordered set")  
[unordered_set::load_factor](load_factor.html "cpp/container/unordered set/load factor")  
[unordered_set::max_load_factor](max_load_factor.html "cpp/container/unordered set/max load factor")  
[unordered_set::rehash](rehash.html "cpp/container/unordered set/rehash")  
[unordered_set::reserve](reserve.html "cpp/container/unordered set/reserve")  
[Observers](../unordered_set.html#Observers "cpp/container/unordered set")  
[unordered_set::hash_function](hash_function.html "cpp/container/unordered set/hash function")  
[unordered_set::key_eq](key_eq.html "cpp/container/unordered set/key eq")  
  
  
  
[Non-member functions](../unordered_set.html#Non-member_functions "cpp/container/unordered set")  
| [operator==operator!=](operator_cmp.html "cpp/container/unordered set/operator cmp")(until C++20)  
---  
  
| [std::swap(std::unordered_set)](swap2.html "cpp/container/unordered set/swap2")  
---  
[erase_if(std::unordered_set)](erase_if.html "cpp/container/unordered set/erase if")(C++20)  
  
[Deduction guides](deduction_guides.html "cpp/container/unordered set/deduction guides") (C++17)  
  


| (1) |   
---|---|---  
unordered_set()  
: unordered_set(size_type(/* unspecified */)) {} |  | (since C++11)   
(until C++20)  
unordered_set(); |  |  (since C++20)  
explicit unordered_set( size_type bucket_count,  
const Hash& hash = Hash(),  
const key_equal& equal = key_equal(),  
const Allocator& alloc = Allocator() ); |  (2)  |  (since C++11)  
unordered_set( size_type bucket_count,  
const Allocator& alloc )  
: unordered_set(bucket_count, Hash(), key_equal(), alloc) {} |  (3)  |  (since C++14)  
unordered_set( size_type bucket_count,  
const Hash& hash,  
const Allocator& alloc )  
: unordered_set(bucket_count, hash, key_equal(), alloc) {} |  (4)  |  (since C++14)  
explicit unordered_set( const Allocator& alloc ); |  (5)  |  (since C++11)  
template< class InputIt >  
unordered_set( InputIt first, InputIt last,  
size_type bucket_count = /* unspecified */,  
const Hash& hash = Hash(),  
const key_equal& equal = key_equal(),  
const Allocator& alloc = Allocator() ); |  (6)  |  (since C++11)  
template< class InputIt >  
unordered_set( InputIt first, InputIt last,  
size_type bucket_count,  
const Allocator& alloc )  
: unordered_set(first, last,  
bucket_count, Hash(), key_equal(), alloc) {} |  (7)  |  (since C++14)  
template< class InputIt >  
unordered_set( InputIt first, InputIt last,  
size_type bucket_count,  
const Hash& hash,  
const Allocator& alloc )  
: unordered_set(first, last,  
bucket_count, hash, key_equal(), alloc) {} |  (8)  |  (since C++14)  
unordered_set( const unordered_set& other ); |  (9)  |  (since C++11)  
unordered_set( const unordered_set& other, const Allocator& alloc ); |  (10)  |  (since C++11)  
unordered_set( unordered_set&& other ); |  (11) | (since C++11)  
unordered_set( unordered_set&& other, const Allocator& alloc ); |  (12)  |  (since C++11)  
unordered_set( [std::initializer_list](../../utility/initializer_list.html)<value_type> init,  
size_type bucket_count = /* unspecified */,  
const Hash& hash = Hash(),  
const key_equal& equal = key_equal(),  
const Allocator& alloc = Allocator() ); |  (13) | (since C++11)  
unordered_set( [std::initializer_list](../../utility/initializer_list.html)<value_type> init,  
size_type bucket_count,  
const Allocator& alloc )  
: unordered_set(init, bucket_count,  
Hash(), key_equal(), alloc) {} |  (14)  |  (since C++14)  
unordered_set( [std::initializer_list](../../utility/initializer_list.html)<value_type> init,  
size_type bucket_count,  
const Hash& hash,  
const Allocator& alloc )  
: unordered_set(init, bucket_count,  
hash, key_equal(), alloc) {} |  (15)  |  (since C++14)  
template< [container-compatible-range](../../ranges/to.html)<value_type> R >  
unordered_set( [std::from_range_t](../../ranges/from_range.html), R&& rg,  
size_type bucket_count = /* see description */,  
const Hash& hash = Hash(),  
const key_equal& equal = key_equal(),  
const Allocator& alloc = Allocator() ); |  (16) | (since C++23)  
template< [container-compatible-range](../../ranges/to.html)<value_type> R >  
unordered_set( [std::from_range_t](../../ranges/from_range.html), R&& rg,  
size_type bucket_count,  
const Allocator& alloc )  
: unordered_set([std::from_range](../../ranges/from_range.html), [std::forward](../../utility/forward.html)<R>(rg),  
bucket_count, Hash(), key_equal(), alloc) {} |  (17)  |  (since C++23)  
template< [container-compatible-range](../../ranges/to.html)<value_type> R >  
unordered_set( [std::from_range_t](../../ranges/from_range.html), R&& rg,  
size_type bucket_count,  
const Hash& hash,  
const Alloc& alloc )  
: unordered_set([std::from_range](../../ranges/from_range.html), [std::forward](../../utility/forward.html)<R>(rg),  
bucket_count, hash, key_equal(), alloc) {} |  (18)  |  (since C++23)  
| |   
  
Constructs new container from a variety of data sources. Optionally uses user supplied bucket_count as a minimal number of buckets to create, hash as the hash function, equal as the function to compare keys and alloc as the allocator. 

1-5) Constructs empty container. Sets [max_load_factor()](max_load_factor.html "cpp/container/unordered set/max load factor") to 1.0. For the default constructor, the number of buckets is unspecified.

6-8) Constructs the container with the contents of the range `[`first`, `last`)`. Sets [max_load_factor()](max_load_factor.html "cpp/container/unordered set/max load factor") to 1.0. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted (pending [LWG2844](https://cplusplus.github.io/LWG/issue2844)).

9,10) Copy constructor. Constructs the container with the copy of the contents of other, copies the load factor, the predicate, and the hash function as well. If alloc is not provided, allocator is obtained by calling [std::allocator_traits](../../memory/allocator_traits.html)<allocator_type>::select_on_container_copy_construction(other.get_allocator()).  The template parameter `Allocator` is only deduced from the first argument while used in [class template argument deduction](../../language/ctad.html "cpp/language/class template argument deduction").  | (since C++23)  
---|---  
  
11,12) [Move constructor](../../language/move_constructor.html "cpp/language/move constructor"). Constructs the container with the contents of other using move semantics. If alloc is not provided, allocator is obtained by move-construction from the allocator belonging to other.  The template parameter `Allocator` is only deduced from the first argument while used in [class template argument deduction](../../language/ctad.html "cpp/language/class template argument deduction").  | (since C++23)  
---|---  
  
13-15) [Initializer-list constructor](../../language/list_initialization.html "cpp/language/list initialization"). Constructs the container with the contents of the initializer list init, same as unordered_set(init.begin(), init.end()).

16-18) Constructs the container with the contents of rg. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted (pending [LWG2844](https://cplusplus.github.io/LWG/issue2844)).

## Contents

  * [1 Parameters](unordered_set.html#Parameters)
  * [2 Complexity](unordered_set.html#Complexity)
  * [3 Exceptions](unordered_set.html#Exceptions)
  * [4 Notes](unordered_set.html#Notes)
  * [5 Example](unordered_set.html#Example)
  * [6 Defect reports](unordered_set.html#Defect_reports)
  * [7 See also](unordered_set.html#See_also)

  
---  
  
### Parameters

alloc  |  \-  |  allocator to use for all memory allocations of this container   
---|---|---  
bucket_count  |  \-  |  minimal number of buckets to use on initialization. If it is not specified, an unspecified default value is used   
hash  |  \-  |  hash function to use   
equal  |  \-  |  comparison function to use for all key comparisons of this container   
first, last  |  \-  |  the pair of iterators defining the source [range](../../iterator.html#Ranges "cpp/iterator") of elements to copy   
rg  |  \-  |  a [container compatible range](../../ranges/to.html#container_compatible_range "cpp/ranges/to"), that is, an [`input_range`](../../ranges/input_range.html "cpp/ranges/input range") whose elements are convertible to [`value_type`](../unordered_set.html#Member_types "cpp/container/unordered set")  
other  |  \-  |  another container to be used as source to initialize the elements of the container with   
init  |  \-  |  initializer list to initialize the elements of the container with   
Type requirements   
-`InputIt` must meet the requirements of [LegacyInputIterator](../../named_req/InputIterator.html "cpp/named req/InputIterator").   
  
### Complexity

1-5) Constant.

6-8) Average case linear (i.e. O(N), where N is [std::distance](../../iterator/distance.html)(first, last)), worst case quadratic, i.e. O(N2).

9,10) Linear in size of other.

11,12) Constant. If alloc is given and alloc != other.get_allocator(), then linear.

13-15) Average case O(N) (N is [std::size](../../iterator/size.html)(init)), worst case O(N2).

16-18) Average case O(N) (N is [ranges::distance](../../iterator/ranges/distance.html)(rg)), worst case O(N2).

### Exceptions

Calls to `Allocator::allocate` may throw. 

### Notes



After container move construction (overload ([11,12](unordered_set.html#Version_11))), references, pointers, and iterators (other than the end iterator) to other remain valid, but refer to elements that are now in *this. The current standard makes this guarantee via the blanket statement in [[container.reqmts]/67](https://eel.is/c++draft/container.reqmts#67), and a more direct guarantee is under consideration via [LWG issue 2321](https://cplusplus.github.io/LWG/issue2321). 

Although not formally required until C++23, some implementations have already put the template parameter `Allocator` into [non-deduced contexts](../../language/template_argument_deduction.html#Non-deduced_contexts "cpp/language/template argument deduction") in earlier modes. 

[Feature-test](../../utility/feature_test.html "cpp/utility/feature test") macro | Value | Std | Feature   
---|---|---|---  
[`__cpp_lib_containers_ranges`](../../experimental/feature_test.html#cpp_lib_containers_ranges "cpp/feature test") | [`202202L`](../../compiler_support/23.html#cpp_lib_containers_ranges_202202L "cpp/compiler support/23") | (C++23) | [Ranges-aware](../../ranges/to.html#container_compatible_range "cpp/ranges/to") construction and insertion; overloads ([16-18](unordered_set.html#Version_16))  
  
### Example

| This section is incomplete  
Reason: no example   
---|---  
  
### Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[LWG 2193](https://cplusplus.github.io/LWG/issue2193) | C++11  | the default constructor ([1](unordered_set.html#Version_1)) was explicit  | made non-explicit   
[LWG 2230](https://cplusplus.github.io/LWG/issue2230) | C++11  | the semantics of overload ([13](unordered_set.html#Version_13)) was not specified  | specified   
  
### See also

[ operator=](operator=.html "cpp/container/unordered set/operator=") |  assigns values to the container   
(public member function)   
---|---
  *[Value]: The year/month in which the feature was adopted. The hyperlink under each value opens a compiler support page with entry for given feature.
  *[Std]: Standard in which the feature is introduced; DR means defect report against that revision
