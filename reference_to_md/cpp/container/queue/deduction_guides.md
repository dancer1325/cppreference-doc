[[edit template]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/container/ad_deduction_guides&action=edit)

[C++](../../../cpp.html "cpp")

[Compiler support](../../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../../freestanding.html "cpp/freestanding")  
[Language](../../language.html "cpp/language")  
[Standard library](../../standard_library.html "cpp/standard library")  
[Standard library headers](../../headers.html "cpp/header")  
[Named requirements](../../iterator/concepts.html "cpp/named req")  
[Feature test macros](../../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../../utility.html#Language_support "cpp/utility")  
[Concepts library](../../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../../error.html "cpp/error")  
[Memory management library](../../memory.html "cpp/memory")  
[Metaprogramming library](../../meta.html "cpp/meta") (C++11)  
[General utilities library](../../utility.html "cpp/utility")  
[Containers library](../../container.html "cpp/container")  
[Iterators library](../../iterator.html "cpp/iterator")  
[Ranges library](../../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../../algorithm.html "cpp/algorithm")  
[Strings library](../../string.html "cpp/string")  
[Text processing library](../../text.html "cpp/text")  
[Numerics library](../../numeric.html "cpp/numeric")  
[Date and time library](../../chrono.html "cpp/chrono")  
[Input/output library](../../io.html "cpp/io")  
[Filesystem library](../../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../../atomic.html "cpp/thread") (C++11)  
[Execution control library](../../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../../experimental.html "cpp/experimental")  
[Symbols index](../../symbol_index.html "cpp/symbol index")  
[External libraries](../../links/libs.html "cpp/links/libs")  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/navbar_content&action=edit)

[Containers library](../../container.html "cpp/container")

[_node-handle_](../node_handle.html "cpp/container/node handle")(C++17)  
---  
[Sequence](../../container.html#Sequence_containers "cpp/container")  
[array](../array.html "cpp/container/array")(C++11)  
[vector](../vector.html "cpp/container/vector")  
[vector<bool>](../vector_bool.html "cpp/container/vector bool")  
[inplace_vector](../inplace_vector.html "cpp/container/inplace vector")(C++26)  
[hive](https://en.cppreference.com/mwiki/index.php?title=cpp/container/hive&action=edit&redlink=1 "cpp/container/hive \(page does not exist\)")(C++26)  
[deque](../deque.html "cpp/container/deque")  
[forward_list](../forward_list.html "cpp/container/forward list")(C++11)  
[list](../list.html "cpp/container/list")  
[Associative](../../container.html#Associative_containers "cpp/container")  
[set](../set.html "cpp/container/set")  
[multiset](../multiset.html "cpp/container/multiset")  
[map](../map.html "cpp/container/map")  
[multimap](../multimap.html "cpp/container/multimap")  
[Unordered associative](../../container.html#Unordered_associative_containers "cpp/container")  
[unordered_set](../unordered_set.html "cpp/container/unordered set")(C++11)  
[unordered_multiset](../unordered_multiset.html "cpp/container/unordered multiset")(C++11)  
[unordered_map](../unordered_map.html "cpp/container/unordered map")(C++11)  
[unordered_multimap](../unordered_multimap.html "cpp/container/unordered multimap")(C++11)  
[Adaptors](../../container.html#Container_adaptors "cpp/container")  
[stack](../stack.html "cpp/container/stack")  
[queue](../queue.html "cpp/container/queue")  
[priority_queue](../priority_queue.html "cpp/container/priority queue")  
[flat_set](../flat_set.html "cpp/container/flat set")(C++23)  
[flat_multiset](../flat_multiset.html "cpp/container/flat multiset")(C++23)  
[flat_map](../flat_map.html "cpp/container/flat map")(C++23)  
[flat_multimap](../flat_multimap.html "cpp/container/flat multimap")(C++23)  
[Views](../../container.html#Views "cpp/container")  
[span](../span.html "cpp/container/span")(C++20)  
[mdspan](../mdspan.html "cpp/container/mdspan")(C++23)  
Tables  
[Iterator invalidation](../../container.html#Iterator_invalidation "cpp/container")  
[Member function table](../../container.html#Member_function_table "cpp/container")  
[Non-member function table](../../container.html#Non-member_function_table "cpp/container")  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/container/navbar_content&action=edit)

`[std::queue](../queue.html "cpp/container/queue")`

[Member functions](../queue.html#Member_functions "cpp/container/queue")  
---  
[queue::queue](queue.html "cpp/container/queue/queue")  
[queue::~queue](~queue.html "cpp/container/queue/~queue")  
[queue::operator=](operator=.html "cpp/container/queue/operator=")  
[Element access](../queue.html#Element_access "cpp/container/queue")  
[queue::front](front.html "cpp/container/queue/front")  
[queue::back](back.html "cpp/container/queue/back")  
[Capacity](../queue.html#Capacity "cpp/container/queue")  
[queue::empty](empty.html "cpp/container/queue/empty")  
[queue::size](size.html "cpp/container/queue/size")  
[Modifiers](../queue.html#Modifiers "cpp/container/queue")  
[queue::push](push.html "cpp/container/queue/push")  
[queue::push_range](push_range.html "cpp/container/queue/push range")(C++23)  
[queue::emplace](emplace.html "cpp/container/queue/emplace")(C++11)  
[queue::pop](pop.html "cpp/container/queue/pop")  
[queue::swap](swap.html "cpp/container/queue/swap")(C++11)  
[Non-member functions](../queue.html#Non-member_functions "cpp/container/queue")  
[swap(std::queue)](swap2.html "cpp/container/queue/swap2")(C++11)  
[operator==operator!=operator<operator>operator<=operator>=operator<=>](operator_cmp.html "cpp/container/queue/operator cmp")(C++20)  
[Helper classes](../queue.html#Helper_classes "cpp/container/queue")  
[uses_allocator<std::queue>](uses_allocator.html "cpp/container/queue/uses allocator")(C++11)  
[formatter<std::queue>](formatter.html "cpp/container/queue/formatter")(C++23)  
**Deduction guides**(C++17)  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/container/queue/navbar_content&action=edit)

Defined in header `[<queue>](../../header/queue.html "cpp/header/queue")` |  |   
---|---|---  
template< class Container >  
queue( Container )  
-> queue<typename Container::value_type, Container>; |  (1)  |  (since C++17)  
template< class Container, class Alloc >  
queue( Container, Alloc )  
-> queue<typename Container::value_type, Container>; |  (2)  |  (since C++17)  
template< class InputIt >  
queue( InputIt, InputIt )  
-> queue<typename [std::iterator_traits](../../iterator/iterator_traits.html)<InputIt>::value_type>; |  (3)  |  (since C++23)  
template< class InputIt, class Alloc >  
queue( InputIt, InputIt, Alloc )  
-> queue<typename [std::iterator_traits](../../iterator/iterator_traits.html)<InputIt>::value_type,  
[std::deque](../deque.html)<typename [std::iterator_traits](../../iterator/iterator_traits.html)<InputIt>::value_type, Alloc>>; |  (4)  |  (since C++23)  
template< [ranges::input_range](../../ranges/input_range.html) R >  
queue( [std::from_range_t](../../ranges/from_range.html), R&& )  
-> queue<[ranges::range_value_t](../../ranges/range_size_t.html)<R>>; |  (5)  |  (since C++23)  
template< [ranges::input_range](../../ranges/input_range.html) R, class Allocator >  
queue( [std::from_range_t](../../ranges/from_range.html), R&&, Allocator )  
-> queue<[ranges::range_value_t](../../ranges/range_size_t.html)<R>,  
[std::deque](../deque.html)<[ranges::range_value_t](../../ranges/range_size_t.html)<R>, Allocator>>; |  (6)  |  (since C++23)  
| |   
  
These [deduction guides](../../language/ctad.html "cpp/language/class template argument deduction") are provided for `queue` to allow deduction from underlying container type. 

1) Deduces underlying container type from the argument.

2) Same as (1), except that the allocator is provided.

3) Deduces the element type from the iterator, using [std::deque](../deque.html)<typename [std::iterator_traits](../../iterator/iterator_traits.html)<InputIt>::value_type> as the underlying container type.

4) Same as (3), except that the allocator is provided.

5) Deduces the element type from a [`std::from_range_t`](../../ranges/from_range.html "cpp/ranges/from range") tag and an [input_range](../../ranges/input_range.html "cpp/ranges/input range").

6) Same as (5), except that the allocator is provided.

These overloads participate in overload resolution only if 

  * `InputIt` (if exists) satisfies [LegacyInputIterator](../../named_req/InputIterator.html "cpp/named req/InputIterator"), 
  * `Container` (if exists) does not satisfy [Allocator](../../named_req/Allocator.html "cpp/named req/Allocator"), 
  * for (3)(until C++23)(4)(since C++23), `Alloc` satisfies [Allocator](../../named_req/Allocator.html "cpp/named req/Allocator"), and 
  * [std::uses_allocator_v](../../memory/uses_allocator.html)<Container, Alloc> is true if both `Container` and `Alloc` exist. 



Note: the extent to which the library determines that a type does not satisfy [LegacyInputIterator](../../named_req/InputIterator.html "cpp/named req/InputIterator") is unspecified, except that as a minimum integral types do not qualify as input iterators. Likewise, the extent to which it determines that a type does not satisfy [Allocator](../../named_req/Allocator.html "cpp/named req/Allocator") is unspecified, except that as a minimum the member type `Alloc::value_type` must exist and the expression [std::declval](../../utility/declval.html)<Alloc&>().allocate([std::size_t](../../types/size_t.html){}) must be well-formed when treated as an unevaluated operand. 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/container/ad_deduction_guides&action=edit&section=T-1 "Template:cpp/container/ad deduction guides")] Notes

[Feature-test](../../utility/feature_test.html "cpp/utility/feature test") macro  | Value | Std | Feature   
---|---|---|---  
[`__cpp_lib_adaptor_iterator_pair_constructor`](../../experimental/feature_test.html#cpp_lib_adaptor_iterator_pair_constructor "cpp/feature test") | [`202106L`](../../compiler_support/23.html#cpp_lib_adaptor_iterator_pair_constructor_202106L "cpp/compiler support/23") | (C++23) | Iterator pair constructors for [std::queue](../queue.html "cpp/container/queue") and [std::stack](../stack.html "cpp/container/stack"); overloads (2) and (4)  
[`__cpp_lib_containers_ranges`](../../experimental/feature_test.html#cpp_lib_containers_ranges "cpp/feature test") | [`202202L`](../../compiler_support/23.html#cpp_lib_containers_ranges_202202L "cpp/compiler support/23") | (C++23) | [Ranges-aware](../../ranges/to.html#container_compatible_range "cpp/ranges/to") construction and insertion; overloads (5) and (6)  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/container/ad_deduction_guides&action=edit&section=T-2 "Template:cpp/container/ad deduction guides")] Example

Run this code
    
    
    #include <queue>
    #include <vector>
    Â 
    int main()
    {
        [std::vector](../vector.html)<int> v = {1, 2, 3, 4};
        [std::queue](../queue.html) s{v}; // guide #1 deduces std::queue<int, vector<int>>
    }
  *[Value]: The year/month in which the feature was adopted. The hyperlink under each value opens a compiler support page with entry for given feature.
  *[Std]: Standard in which the feature is introduced; DR means defect report against that revision
