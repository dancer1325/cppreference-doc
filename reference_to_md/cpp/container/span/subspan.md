[C++](../../../cpp.html "cpp")

[Compiler support](../../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../../freestanding.html "cpp/freestanding")  
[Language](../../language.html "cpp/language")  
[Standard library](../../standard_library.html "cpp/standard library")  
[Standard library headers](../../headers.html "cpp/header")  
[Named requirements](../../iterator/concepts.html "cpp/named req")  
[Feature test macros](../../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../../utility.html#Language_support "cpp/utility")  
[Concepts library](../../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../../error.html "cpp/error")  
[Memory management library](../../memory.html "cpp/memory")  
[Metaprogramming library](../../meta.html "cpp/meta") (C++11)  
[General utilities library](../../utility.html "cpp/utility")  
[Containers library](../../container.html "cpp/container")  
[Iterators library](../../iterator.html "cpp/iterator")  
[Ranges library](../../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../../algorithm.html "cpp/algorithm")  
[Strings library](../../string.html "cpp/string")  
[Text processing library](../../text.html "cpp/text")  
[Numerics library](../../numeric.html "cpp/numeric")  
[Date and time library](../../chrono.html "cpp/chrono")  
[Input/output library](../../io.html "cpp/io")  
[Filesystem library](../../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../../atomic.html "cpp/thread") (C++11)  
[Execution control library](../../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../../experimental.html "cpp/experimental")  
[Symbols index](../../symbol_index.html "cpp/symbol index")  
[External libraries](../../links/libs.html "cpp/links/libs")  
  


[Containers library](../../container.html "cpp/container")

[_node-handle_](../node_handle.html "cpp/container/node handle")(C++17)  
---  
[Sequence](../../container.html#Sequence_containers "cpp/container")  
[array](../array.html "cpp/container/array")(C++11)  
[vector](../vector.html "cpp/container/vector")  
[vector<bool>](../vector_bool.html "cpp/container/vector bool")  
[inplace_vector](../inplace_vector.html "cpp/container/inplace vector")(C++26)  
[hive](https://en.cppreference.com/mwiki/index.php?title=cpp/container/hive&action=edit&redlink=1 "cpp/container/hive \(page does not exist\)")(C++26)  
[deque](../deque.html "cpp/container/deque")  
[forward_list](../forward_list.html "cpp/container/forward list")(C++11)  
[list](../list.html "cpp/container/list")  
[Associative](../../container.html#Associative_containers "cpp/container")  
[set](../set.html "cpp/container/set")  
[multiset](../multiset.html "cpp/container/multiset")  
[map](../map.html "cpp/container/map")  
[multimap](../multimap.html "cpp/container/multimap")  
[Unordered associative](../../container.html#Unordered_associative_containers "cpp/container")  
[unordered_set](../unordered_set.html "cpp/container/unordered set")(C++11)  
[unordered_multiset](../unordered_multiset.html "cpp/container/unordered multiset")(C++11)  
[unordered_map](../unordered_map.html "cpp/container/unordered map")(C++11)  
[unordered_multimap](../unordered_multimap.html "cpp/container/unordered multimap")(C++11)  
[Adaptors](../../container.html#Container_adaptors "cpp/container")  
[stack](../stack.html "cpp/container/stack")  
[queue](../queue.html "cpp/container/queue")  
[priority_queue](../priority_queue.html "cpp/container/priority queue")  
[flat_set](../flat_set.html "cpp/container/flat set")(C++23)  
[flat_multiset](../flat_multiset.html "cpp/container/flat multiset")(C++23)  
[flat_map](../flat_map.html "cpp/container/flat map")(C++23)  
[flat_multimap](../flat_multimap.html "cpp/container/flat multimap")(C++23)  
[Views](../../container.html#Views "cpp/container")  
[span](../span.html "cpp/container/span")(C++20)  
[mdspan](../mdspan.html "cpp/container/mdspan")(C++23)  
Tables  
[Iterator invalidation](../../container.html#Iterator_invalidation "cpp/container")  
[Member function table](../../container.html#Member_function_table "cpp/container")  
[Non-member function table](../../container.html#Non-member_function_table "cpp/container")  
  


[`std::span`](../span.html "cpp/container/span")

[Member functions](../span.html#Member_functions "cpp/container/span")  
---  
[span::span](span.html "cpp/container/span/span")  
[span::operator=](operator=.html "cpp/container/span/operator=")  
[Element access](../span.html#Element_access "cpp/container/span")  
[span::front](front.html "cpp/container/span/front")  
[span::back](back.html "cpp/container/span/back")  
[span::at](at.html "cpp/container/span/at")(C++26)  
[span::operator[]](operator_at.html "cpp/container/span/operator at")  
[span::data](data.html "cpp/container/span/data")  
[Iterators](../span.html#Iterators "cpp/container/span")  
[span::beginspan::cbegin](begin.html "cpp/container/span/begin")(C++23)  
[span::endspan::cend](end.html "cpp/container/span/end")(C++23)  
[span::rbeginspan::crbegin](rbegin.html "cpp/container/span/rbegin")(C++23)  
[span::rendspan::crend](rend.html "cpp/container/span/rend")(C++23)  
[Observers](../span.html#Observers "cpp/container/span")  
[span::empty](empty.html "cpp/container/span/empty")  
[span::size](size.html "cpp/container/span/size")  
[span::size_bytes](size_bytes.html "cpp/container/span/size bytes")  
[Subviews](../span.html#Subviews "cpp/container/span")  
[span::first](first.html "cpp/container/span/first")  
[span::last](last.html "cpp/container/span/last")  
**span::subspan**  
[Non-member functions](../span.html#Non-member_functions "cpp/container/span")  
[as_bytesas_writable_bytes](as_bytes.html "cpp/container/span/as bytes")  
[Non-member constant](../span.html#Non-member_constant "cpp/container/span")  
[dynamic_extent](dynamic_extent.html "cpp/container/span/dynamic extent")  
[Deduction guides](deduction_guides.html "cpp/container/span/deduction guides")  
  


template< [std::size_t](../../types/size_t.html) Offset,  
[std::size_t](../../types/size_t.html) Count = [std::dynamic_extent](dynamic_extent.html) >  
constexpr [std::span](../span.html)<element_type, /* see below */>  
subspan() const; |  (1)  |  (since C++20)  
---|---|---  
constexpr [std::span](../span.html)<element_type, [std::dynamic_extent](dynamic_extent.html)>  
subspan( size_type offset,  
size_type count = [std::dynamic_extent](dynamic_extent.html) ) const; |  (2)  |  (since C++20)  
| |   
  
Obtains a subview over some consecutive elements of this span, the elements to be included are determined by an element count and an offset. 

1) The element count and offset are provided as template arguments, and the subview has a dynamic extent only if both Count and Offset are [std::dynamic_extent](dynamic_extent.html). 

  * If Count is [std::dynamic_extent](dynamic_extent.html), the subview contains all elements starting from the Offsetth. 
  * Otherwise, the subview contains Count elements starting from the Offsetth.



Denote the second template argument of the return type as FinalExtent, it is defined as Count != [std::dynamic_extent](dynamic_extent.html)  
? Count  
: (Extent != [std::dynamic_extent](dynamic_extent.html)  
? Extent - Offset  
: [std::dynamic_extent](dynamic_extent.html)).

If Offset <= Extent && (Count == [std::dynamic_extent](dynamic_extent.html) || Count <= Extent - Offset) is false, the program is ill-formed.

If Offset <= size() && (Count == [std::dynamic_extent](dynamic_extent.html) || Count <= size() - Offset) is false, the behavior is undefined.  | (until C++26)  
---|---  
If Offset <= size() && (Count == [std::dynamic_extent](dynamic_extent.html) || Count <= size() - Offset) is false: 

  * If the implementation is [hardened](../../standard_library.html#Standard_library_hardening "cpp/standard library"), a [contract violation](../../language/contracts.html "cpp/language/contracts") occurs. Moreover, if the contract-violation handler returns under “observe” evaluation semantic, the behavior is undefined. 
  * If the implementation is not hardened, the behavior is undefined. 

| (since C++26)  
  
  


2) The element count and offset are provided as function arguments, and the subview always has a dynamic extent. 

  * If count is [std::dynamic_extent](dynamic_extent.html), the subview contains all elements starting from the offsetth. 
  * Otherwise, the subview contains count elements starting from the offsetth.



If offset <= size() && (count == [std::dynamic_extent](dynamic_extent.html) || count <= size() - offset) is false, the behavior is undefined.  | (until C++26)  
---|---  
If offset <= size() && (count == [std::dynamic_extent](dynamic_extent.html) || count <= size() - offset) is false: 

  * If the implementation is [hardened](../../standard_library.html#Standard_library_hardening "cpp/standard library"), a [contract violation](../../language/contracts.html "cpp/language/contracts") occurs. Moreover, if the contract-violation handler returns under “observe” evaluation semantic, the behavior is undefined. 
  * If the implementation is not hardened, the behavior is undefined. 

| (since C++26)  
  
### Return value

1) [std::span](../span.html)<element_type, FinalExtent>  
(data() + Offset, Count != [std::dynamic_extent](dynamic_extent.html) ? Count : size() - Offset))

2) [std::span](../span.html)<element_type, [std::dynamic_extent](dynamic_extent.html)>  
(data() + offset, count != [std::dynamic_extent](dynamic_extent.html) ? count : size() - offset))

### Example

Run this code
    
    
    #include <algorithm>
    #include <cstdio>
    #include <numeric>
    #include <ranges>
    #include <span>
     
    void display([std::span](../span.html)<const char> abc)
    {
        const auto columns{20U};
        const auto rows{abc.size() - columns + 1};
     
        for (auto offset{0U}; offset < rows; ++offset)
        {
            std::[ranges::for_each](../../algorithm/ranges/for_each.html)(abc.subspan(offset, columns), [std::putchar](../../io/c/putchar.html));
            [std::puts](../../io/c/puts.html)("");
        }
    }
     
    int main()
    {
        char abc[26];
        std::[ranges::iota](../../algorithm/ranges/iota.html)(abc, 'A');
        display(abc);
    }

Output: 
    
    
    ABCDEFGHIJKLMNOPQRST
    BCDEFGHIJKLMNOPQRSTU
    CDEFGHIJKLMNOPQRSTUV
    DEFGHIJKLMNOPQRSTUVW
    EFGHIJKLMNOPQRSTUVWX
    FGHIJKLMNOPQRSTUVWXY
    GHIJKLMNOPQRSTUVWXYZ

### See also

[ first](first.html "cpp/container/span/first") |  obtains a subspan consisting of the first `N` elements of the sequence   
(public member function)   
---|---  
[ last](last.html "cpp/container/span/last") |  obtains a subspan consisting of the last `N` elements of the sequence   
(public member function) 
