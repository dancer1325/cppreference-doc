
  


[Containers library](../container.html "cpp/container")

[_node-handle_](node_handle.html "cpp/container/node handle")(C++17)  
---  
[Sequence](../container.html#Sequence_containers "cpp/container")  
[array](array.html "cpp/container/array")(C++11)  
[vector](vector.html "cpp/container/vector")  
[vector<bool>](vector_bool.html "cpp/container/vector bool")  
[inplace_vector](inplace_vector.html "cpp/container/inplace vector")(C++26)  
[hive](https://en.cppreference.com/mwiki/index.php?title=cpp/container/hive&action=edit&redlink=1 "cpp/container/hive \(page does not exist\)")(C++26)  
[deque](deque.html "cpp/container/deque")  
[forward_list](forward_list.html "cpp/container/forward list")(C++11)  
[list](list.html "cpp/container/list")  
[Associative](../container.html#Associative_containers "cpp/container")  
[set](set.html "cpp/container/set")  
**multiset**  
[map](map.html "cpp/container/map")  
[multimap](multimap.html "cpp/container/multimap")  
[Unordered associative](../container.html#Unordered_associative_containers "cpp/container")  
[unordered_set](unordered_set.html "cpp/container/unordered set")(C++11)  
[unordered_multiset](unordered_multiset.html "cpp/container/unordered multiset")(C++11)  
[unordered_map](unordered_map.html "cpp/container/unordered map")(C++11)  
[unordered_multimap](unordered_multimap.html "cpp/container/unordered multimap")(C++11)  
[Adaptors](../container.html#Container_adaptors "cpp/container")  
[stack](stack.html "cpp/container/stack")  
[queue](queue.html "cpp/container/queue")  
[priority_queue](priority_queue.html "cpp/container/priority queue")  
[flat_set](flat_set.html "cpp/container/flat set")(C++23)  
[flat_multiset](flat_multiset.html "cpp/container/flat multiset")(C++23)  
[flat_map](flat_map.html "cpp/container/flat map")(C++23)  
[flat_multimap](flat_multimap.html "cpp/container/flat multimap")(C++23)  
[Views](../container.html#Views "cpp/container")  
[span](span.html "cpp/container/span")(C++20)  
[mdspan](mdspan.html "cpp/container/mdspan")(C++23)  
Tables  
[Iterator invalidation](../container.html#Iterator_invalidation "cpp/container")  
[Member function table](../container.html#Member_function_table "cpp/container")  
[Non-member function table](../container.html#Non-member_function_table "cpp/container")  
  


**`std::multiset`**

[Member functions](multiset.html#Member_functions "cpp/container/multiset")  
---  
|  | [multiset::multiset](multiset/multiset.html "cpp/container/multiset/multiset")  
---  
[multiset::~multiset](multiset/~multiset.html "cpp/container/multiset/~multiset")` `  
  
| [multiset::operator=](multiset/operator=.html "cpp/container/multiset/operator=")  
---  
[multiset::get_allocator](multiset/get_allocator.html "cpp/container/multiset/get allocator")  
  
|  | [Iterators](multiset.html#Iterators "cpp/container/multiset")  
---  
[multiset::beginmultiset::cbegin](multiset/begin.html "cpp/container/multiset/begin")(C++11)  
[multiset::endmultiset::cend](multiset/end.html "cpp/container/multiset/end")(C++11)  
[multiset::rbeginmultiset::crbegin](multiset/rbegin.html "cpp/container/multiset/rbegin")(C++11)` `  
[multiset::rendmultiset::crend](multiset/rend.html "cpp/container/multiset/rend")(C++11)  
[Capacity](multiset.html#Capacity "cpp/container/multiset")  
[multiset::size](multiset/size.html "cpp/container/multiset/size")  
[multiset::max_size](multiset/max_size.html "cpp/container/multiset/max size")  
[multiset::empty](multiset/empty.html "cpp/container/multiset/empty")  
[Observers](multiset.html#Observers "cpp/container/multiset")  
[multiset::key_comp](multiset/key_comp.html "cpp/container/multiset/key comp")  
[multiset::value_comp](multiset/value_comp.html "cpp/container/multiset/value comp")  
  
| [Modifiers](multiset.html#Modifiers "cpp/container/multiset")  
---  
[multiset::clear](multiset/clear.html "cpp/container/multiset/clear")  
[multiset::erase](multiset/erase.html "cpp/container/multiset/erase")  
[multiset::swap](multiset/swap.html "cpp/container/multiset/swap")  
[multiset::extract](multiset/extract.html "cpp/container/multiset/extract")(C++17)  
[multiset::merge](multiset/merge.html "cpp/container/multiset/merge")(C++17)  
[multiset::insert](multiset/insert.html "cpp/container/multiset/insert")  
[multiset::insert_range](multiset/insert_range.html "cpp/container/multiset/insert range")(C++23)  
[multiset::emplace](multiset/emplace.html "cpp/container/multiset/emplace")(C++11)  
[multiset::emplace_hint](multiset/emplace_hint.html "cpp/container/multiset/emplace hint")(C++11)  
[Lookup](multiset.html#Lookup "cpp/container/multiset")  
[multiset::count](multiset/count.html "cpp/container/multiset/count")  
[multiset::find](multiset/find.html "cpp/container/multiset/find")  
[multiset::contains](multiset/contains.html "cpp/container/multiset/contains")(C++20)  
[multiset::equal_range](multiset/equal_range.html "cpp/container/multiset/equal range")  
[multiset::lower_bound](multiset/lower_bound.html "cpp/container/multiset/lower bound")  
[multiset::upper_bound](multiset/upper_bound.html "cpp/container/multiset/upper bound")  
  
[Non-member functions](multiset.html#Non-member_functions "cpp/container/multiset")  
|  | [std::swap(std::multiset)](multiset/swap2.html "cpp/container/multiset/swap2")  
---  
[erase_if(std::multiset)](multiset/erase_if.html "cpp/container/multiset/erase if")(C++20)` `  
[operator==operator<=>](multiset/operator_cmp.html "cpp/container/multiset/operator cmp")(C++20)  
  
  
  
| [operator!=operator<operator>operator<=operator>=](multiset/operator_cmp.html "cpp/container/multiset/operator cmp")(until C++20)(until C++20)(until C++20)(until C++20)(until C++20)  
---  
  
[Deduction guides](multiset/deduction_guides.html "cpp/container/multiset/deduction guides")(C++17)  
  


Defined in header `[<set>](../header/set.html "cpp/header/set")` |  |   
---|---|---  
template<  
class Key,  
class Compare = [std::less](../utility/functional/less.html)<Key>,  
class Allocator = [std::allocator](../memory/allocator.html)<Key>  
> class multiset; |  (1)  |   
namespace pmr {  
template<  
class Key,  
class Compare = [std::less](../utility/functional/less.html)<Key>  
> using multiset = std::multiset<Key, Compare, [std::pmr::polymorphic_allocator](../memory/polymorphic_allocator.html)<Key>>;  
} |  (2)  |  (since C++17)  
| |   
  
`std::multiset` is an associative container that contains a sorted set of objects of type Key. Unlike set, multiple keys with equivalent values are allowed. Sorting is done using the key comparison function Compare. Search, insertion, and removal operations have logarithmic complexity. 

Everywhere the standard library uses the [Compare](../named_req/Compare.html "cpp/named req/Compare") requirements, equivalence is determined by using the equivalence relation as described on [Compare](../named_req/Compare.html "cpp/named req/Compare"). In imprecise terms, two objects a and b are considered equivalent if neither compares less than the other: !comp(a, b) && !comp(b, a). 

The order of the elements that compare equivalent is the order of insertion and does not change.  | (since C++11)  
---|---  
  
`std::multiset` meets the requirements of [Container](../named_req/Container.html "cpp/named req/Container"), [AllocatorAwareContainer](../named_req/AllocatorAwareContainer.html "cpp/named req/AllocatorAwareContainer"), [AssociativeContainer](../named_req/AssociativeContainer.html "cpp/named req/AssociativeContainer") and [ReversibleContainer](../named_req/ReversibleContainer.html "cpp/named req/ReversibleContainer"). 

All member functions of `std::multiset` are constexpr: it is possible to create and use `std::multiset` objects in the evaluation of a constant expression.However, `std::multiset` objects generally cannot be constexpr, because any dynamically allocated storage must be released in the same evaluation of constant expression. | (since C++26)  
---|---  
  
## Contents

  * [1 Template parameters](multiset.html#Template_parameters)
  * [2 Member types](multiset.html#Member_types)
  * [3 Member functions](multiset.html#Member_functions)
    * [3.1 Iterators](multiset.html#Iterators)
    * [3.2 Capacity](multiset.html#Capacity)
    * [3.3 Modifiers](multiset.html#Modifiers)
    * [3.4 Lookup](multiset.html#Lookup)
    * [3.5 Observers](multiset.html#Observers)
  * [4 Non-member functions](multiset.html#Non-member_functions)
  * [5 Deduction guides](multiset.html#Deduction_guides)
  * [6 Notes](multiset.html#Notes)
  * [7 Example](multiset.html#Example)
  * [8 Defect reports](multiset.html#Defect_reports)
  * [9 See also](multiset.html#See_also)

  
---  
  
### Template parameters

| This section is incomplete  
Reason: Add descriptions of the template parameters.   
---|---  
  
### Member types

Type  |  Definition   
---|---  
`key_type` |  `Key`  
`value_type` |  `Key`  
`size_type` |  Unsigned integer type (usually [std::size_t](../types/size_t.html "cpp/types/size t"))  
`difference_type` |  Signed integer type (usually [std::ptrdiff_t](../types/ptrdiff_t.html "cpp/types/ptrdiff t"))  
`key_compare` |  `Compare`  
`value_compare` |  `Compare`  
`allocator_type` |  `Allocator`  
`reference` |  value_type&  
`const_reference` |  const value_type&  
`pointer` |  |  `Allocator::pointer` | (until C++11)  
---|---  
[std::allocator_traits](../memory/allocator_traits.html)<Allocator>::pointer | (since C++11)  
  
`const_pointer` |  |  `Allocator::const_pointer` | (until C++11)  
---|---  
[std::allocator_traits](../memory/allocator_traits.html)<Allocator>::const_pointer | (since C++11)  
  
`iterator` |  Constant [LegacyBidirectionalIterator](../named_req/BidirectionalIterator.html "cpp/named req/BidirectionalIterator") and [ConstexprIterator](../named_req/ConstexprIterator.html "cpp/named req/ConstexprIterator")(since C++26) to `value_type`  
`const_iterator` |  [LegacyBidirectionalIterator](../named_req/BidirectionalIterator.html "cpp/named req/BidirectionalIterator") and [ConstexprIterator](../named_req/ConstexprIterator.html "cpp/named req/ConstexprIterator")(since C++26) to const value_type  
`reverse_iterator` |  [std::reverse_iterator](../iterator/reverse_iterator.html)<iterator>  
`const_reverse_iterator` |  [std::reverse_iterator](../iterator/reverse_iterator.html)<const_iterator>  
`node_type` (since C++17) |  a specialization of [node handle](node_handle.html "cpp/container/node handle") representing a container node  
  
### Member functions

[ (constructor)](multiset/multiset.html "cpp/container/multiset/multiset") |  constructs the `multiset`   
(public member function)   
---|---  
[ (destructor)](multiset/~multiset.html "cpp/container/multiset/~multiset") |  destructs the `multiset`   
(public member function)   
[ operator=](multiset/operator=.html "cpp/container/multiset/operator=") |  assigns values to the container   
(public member function)   
[ get_allocator](multiset/get_allocator.html "cpp/container/multiset/get allocator") |  returns the associated allocator   
(public member function)   
  
#####  Iterators   
  
[ begincbegin](multiset/begin.html "cpp/container/multiset/begin")(C++11) |  returns an iterator to the beginning   
(public member function)   
[ endcend](multiset/end.html "cpp/container/multiset/end")(C++11) |  returns an iterator to the end   
(public member function)   
[ rbegincrbegin](multiset/rbegin.html "cpp/container/multiset/rbegin")(C++11) |  returns a reverse iterator to the beginning   
(public member function)   
[ rendcrend](multiset/rend.html "cpp/container/multiset/rend")(C++11) |  returns a reverse iterator to the end   
(public member function)   
  
#####  Capacity   
  
[ empty](multiset/empty.html "cpp/container/multiset/empty") |  checks whether the container is empty   
(public member function)   
[ size](multiset/size.html "cpp/container/multiset/size") |  returns the number of elements   
(public member function)   
[ max_size](multiset/max_size.html "cpp/container/multiset/max size") |  returns the maximum possible number of elements   
(public member function)   
  
#####  Modifiers   
  
[ clear](multiset/clear.html "cpp/container/multiset/clear") |  clears the contents   
(public member function)   
[ insert](multiset/insert.html "cpp/container/multiset/insert") |  inserts elements or nodes(since C++17)   
(public member function)   
[ insert_range](multiset/insert_range.html "cpp/container/multiset/insert range")(C++23) |  inserts a range of elements   
(public member function)   
[ emplace](multiset/emplace.html "cpp/container/multiset/emplace")(C++11) |  constructs element in-place   
(public member function)   
[ emplace_hint](multiset/emplace_hint.html "cpp/container/multiset/emplace hint")(C++11) |  constructs elements in-place using a hint   
(public member function)   
[ erase](multiset/erase.html "cpp/container/multiset/erase") |  erases elements   
(public member function)   
[ swap](multiset/swap.html "cpp/container/multiset/swap") |  swaps the contents   
(public member function)   
[ extract](multiset/extract.html "cpp/container/multiset/extract")(C++17) |  extracts nodes from the container   
(public member function)   
[ merge](multiset/merge.html "cpp/container/multiset/merge")(C++17) |  splices nodes from another container   
(public member function)   
  
#####  Lookup   
  
[ count](multiset/count.html "cpp/container/multiset/count") |  returns the number of elements matching specific key   
(public member function)   
[ find](multiset/find.html "cpp/container/multiset/find") |  finds element with specific key   
(public member function)   
[ contains](multiset/contains.html "cpp/container/multiset/contains")(C++20) |  checks if the container contains element with specific key   
(public member function)   
[ equal_range](multiset/equal_range.html "cpp/container/multiset/equal range") |  returns range of elements matching a specific key   
(public member function)   
[ lower_bound](multiset/lower_bound.html "cpp/container/multiset/lower bound") |  returns an iterator to the first element _not less_ than the given key   
(public member function)   
[ upper_bound](multiset/upper_bound.html "cpp/container/multiset/upper bound") |  returns an iterator to the first element _greater_ than the given key   
(public member function)   
  
#####  Observers   
  
[ key_comp](multiset/key_comp.html "cpp/container/multiset/key comp") |  returns the function that compares keys   
(public member function)   
[ value_comp](multiset/value_comp.html "cpp/container/multiset/value comp") |  returns the function that compares keys in objects of type `value_type`   
(public member function)   
  
### Non-member functions

[ operator==operator!=operator<operator<=operator>operator>=operator<=>](multiset/operator_cmp.html "cpp/container/multiset/operator cmp")(removed in C++20)(removed in C++20)(removed in C++20)(removed in C++20)(removed in C++20)(C++20) |  lexicographically compares the values of two `multiset`s   
(function template)   
---|---  
[ std::swap(std::multiset)](multiset/swap2.html "cpp/container/multiset/swap2") |  specializes the [std::swap](../utility/swap.html "cpp/algorithm/swap") algorithm   
(function template)   
[ erase_if(std::multiset)](multiset/erase_if.html "cpp/container/multiset/erase if")(C++20) |  erases all elements satisfying specific criteria   
(function template)   
  
###  [Deduction guides](multiset/deduction_guides.html "cpp/container/multiset/deduction guides")

| (since C++17)  
---|---  
  
### Notes

The member types `iterator` and `const_iterator` may be aliases to the same type. This means defining a pair of function overloads using the two types as parameter types may violate the [One Definition Rule](../language/definition.html#One_Definition_Rule "cpp/language/definition"). Since `iterator` is convertible to `const_iterator`, a single function with a `const_iterator` as parameter type will work instead. 

[Feature-test](../utility/feature_test.html "cpp/utility/feature test") macro  | Value | Std | Feature   
---|---|---|---  
[`__cpp_lib_containers_ranges`](../experimental/feature_test.html#cpp_lib_containers_ranges "cpp/feature test") | [`202202L`](../compiler_support/23.html#cpp_lib_containers_ranges_202202L "cpp/compiler support/23") | (C++23) | Ranges construction and insertion for containers   
[`__cpp_lib_constexpr_set`](../experimental/feature_test.html#cpp_lib_constexpr_set "cpp/feature test") | [`202502L`](../compiler_support/26.html#cpp_lib_constexpr_set_202502L "cpp/compiler support/26") | (C++26) | constexpr `std::multiset`  
  
### Example

| This section is incomplete  
Reason: no example   
---|---  
  
### Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[LWG 103](https://cplusplus.github.io/LWG/issue103) | C++98  | iterator allows modification of keys  | iterator made constant   
[LWG 230](https://cplusplus.github.io/LWG/issue230) | C++98  | `Key` was not required to be [CopyConstructible](../named_req/CopyConstructible.html "cpp/named req/CopyConstructible")  
(a key of type `Key` might not be able to be constructed)  | `Key` is also required to  
be [CopyConstructible](../named_req/CopyConstructible.html "cpp/named req/CopyConstructible")  
  
### See also

[ set](set.html "cpp/container/set") |  collection of unique keys, sorted by keys   
(class template)   
---|---  
[ unordered_multiset](unordered_multiset.html "cpp/container/unordered multiset")(C++11) |  collection of keys, hashed by keys   
(class template)   
[ flat_multiset](flat_multiset.html "cpp/container/flat multiset")(C++23) |  adapts a container to provide a collection of keys, sorted by keys   
(class template) 
  *[Value]: The year/month in which the feature was adopted. The hyperlink under each value opens a compiler support page with entry for given feature.
  *[Std]: Standard in which the feature is introduced; DR means defect report against that revision
