
  


[Containers library](../container.html "cpp/container")

[_node-handle_](node_handle.html "cpp/container/node handle")(C++17)  
---  
[Sequence](../container.html#Sequence_containers "cpp/container")  
[array](array.html "cpp/container/array")(C++11)  
[vector](vector.html "cpp/container/vector")  
[vector<bool>](vector_bool.html "cpp/container/vector bool")  
[inplace_vector](inplace_vector.html "cpp/container/inplace vector")(C++26)  
[hive](https://en.cppreference.com/mwiki/index.php?title=cpp/container/hive&action=edit&redlink=1 "cpp/container/hive \(page does not exist\)")(C++26)  
[deque](deque.html "cpp/container/deque")  
[forward_list](forward_list.html "cpp/container/forward list")(C++11)  
[list](list.html "cpp/container/list")  
[Associative](../container.html#Associative_containers "cpp/container")  
[set](set.html "cpp/container/set")  
[multiset](multiset.html "cpp/container/multiset")  
[map](map.html "cpp/container/map")  
[multimap](multimap.html "cpp/container/multimap")  
[Unordered associative](../container.html#Unordered_associative_containers "cpp/container")  
**unordered_set**(C++11)  
[unordered_multiset](unordered_multiset.html "cpp/container/unordered multiset")(C++11)  
[unordered_map](unordered_map.html "cpp/container/unordered map")(C++11)  
[unordered_multimap](unordered_multimap.html "cpp/container/unordered multimap")(C++11)  
[Adaptors](../container.html#Container_adaptors "cpp/container")  
[stack](stack.html "cpp/container/stack")  
[queue](queue.html "cpp/container/queue")  
[priority_queue](priority_queue.html "cpp/container/priority queue")  
[flat_set](flat_set.html "cpp/container/flat set")(C++23)  
[flat_multiset](flat_multiset.html "cpp/container/flat multiset")(C++23)  
[flat_map](flat_map.html "cpp/container/flat map")(C++23)  
[flat_multimap](flat_multimap.html "cpp/container/flat multimap")(C++23)  
[Views](../container.html#Views "cpp/container")  
[span](span.html "cpp/container/span")(C++20)  
[mdspan](mdspan.html "cpp/container/mdspan")(C++23)  
Tables  
[Iterator invalidation](../container.html#Iterator_invalidation "cpp/container")  
[Member function table](../container.html#Member_function_table "cpp/container")  
[Non-member function table](../container.html#Non-member_function_table "cpp/container")  
  


`**std::unordered_set**`

[Member types](unordered_set.html#Member_types "cpp/container/unordered set")  
---  
[Member functions](unordered_set.html#Member_functions "cpp/container/unordered set")  
| [unordered_set::unordered_set](unordered_set/unordered_set.html "cpp/container/unordered set/unordered set")  
---  
[unordered_set::~unordered_set](unordered_set/~unordered_set.html "cpp/container/unordered set/~unordered set")  
[unordered_set::operator=](unordered_set/operator=.html "cpp/container/unordered set/operator=")  
[unordered_set::get_allocator](unordered_set/get_allocator.html "cpp/container/unordered set/get allocator")  
[Iterators](unordered_set.html#Iterators "cpp/container/unordered set")  
[unordered_set::beginunordered_set::cbegin](unordered_set/begin.html "cpp/container/unordered set/begin")  
[unordered_set::endunordered_set::cend](unordered_set/end.html "cpp/container/unordered set/end")  
[Capacity](unordered_set.html#Capacity "cpp/container/unordered set")  
[unordered_set::size](unordered_set/size.html "cpp/container/unordered set/size")  
[unordered_set::max_size](unordered_set/max_size.html "cpp/container/unordered set/max size")  
[unordered_set::empty](unordered_set/empty.html "cpp/container/unordered set/empty")  
[Modifiers](unordered_set.html#Modifiers "cpp/container/unordered set")  
[unordered_set::clear](unordered_set/clear.html "cpp/container/unordered set/clear")  
[unordered_set::erase](unordered_set/erase.html "cpp/container/unordered set/erase")  
[unordered_set::swap](unordered_set/swap.html "cpp/container/unordered set/swap")  
[unordered_set::extract](unordered_set/extract.html "cpp/container/unordered set/extract")(C++17)  
[unordered_set::merge](unordered_set/merge.html "cpp/container/unordered set/merge")(C++17)  
[unordered_set::insert](unordered_set/insert.html "cpp/container/unordered set/insert")  
[unordered_set::insert_range](unordered_set/insert_range.html "cpp/container/unordered set/insert range")(C++23)` `  
[unordered_set::emplace](unordered_set/emplace.html "cpp/container/unordered set/emplace")  
[unordered_set::emplace_hint](unordered_set/emplace_hint.html "cpp/container/unordered set/emplace hint")  
  
| [Lookup](unordered_set.html#Lookup "cpp/container/unordered set")  
---  
[unordered_set::count](unordered_set/count.html "cpp/container/unordered set/count")  
[unordered_set::find](unordered_set/find.html "cpp/container/unordered set/find")  
[unordered_set::contains](unordered_set/contains.html "cpp/container/unordered set/contains")(C++20)  
[unordered_set::equal_range](unordered_set/equal_range.html "cpp/container/unordered set/equal range")  
[Bucket interface](unordered_set.html#Bucket_interface "cpp/container/unordered set")  
[unordered_set::begin(size_type)unordered_set::cbegin(size_type)](unordered_set/begin2.html "cpp/container/unordered set/begin2")  
[unordered_set::end(size_type)unordered_set::cend(size_type)](unordered_set/end2.html "cpp/container/unordered set/end2")  
[unordered_set::bucket_count](unordered_set/bucket_count.html "cpp/container/unordered set/bucket count")  
[unordered_set::max_bucket_count](unordered_set/max_bucket_count.html "cpp/container/unordered set/max bucket count")  
[unordered_set::bucket_size](unordered_set/bucket_size.html "cpp/container/unordered set/bucket size")  
[unordered_set::bucket](unordered_set/bucket.html "cpp/container/unordered set/bucket")  
[Hash policy](unordered_set.html#Hash_policy "cpp/container/unordered set")  
[unordered_set::load_factor](unordered_set/load_factor.html "cpp/container/unordered set/load factor")  
[unordered_set::max_load_factor](unordered_set/max_load_factor.html "cpp/container/unordered set/max load factor")  
[unordered_set::rehash](unordered_set/rehash.html "cpp/container/unordered set/rehash")  
[unordered_set::reserve](unordered_set/reserve.html "cpp/container/unordered set/reserve")  
[Observers](unordered_set.html#Observers "cpp/container/unordered set")  
[unordered_set::hash_function](unordered_set/hash_function.html "cpp/container/unordered set/hash function")  
[unordered_set::key_eq](unordered_set/key_eq.html "cpp/container/unordered set/key eq")  
  
  
  
[Non-member functions](unordered_set.html#Non-member_functions "cpp/container/unordered set")  
| [operator==operator!=](unordered_set/operator_cmp.html "cpp/container/unordered set/operator cmp")(until C++20)  
---  
  
| [std::swap(std::unordered_set)](unordered_set/swap2.html "cpp/container/unordered set/swap2")  
---  
[erase_if(std::unordered_set)](unordered_set/erase_if.html "cpp/container/unordered set/erase if")(C++20)  
  
[Deduction guides](unordered_set/deduction_guides.html "cpp/container/unordered set/deduction guides") (C++17)  
  


Defined in header `[<unordered_set>](../header/unordered_set.html "cpp/header/unordered set")` |  |   
---|---|---  
template<  
class Key,  
class Hash = [std::hash](../utility/hash.html)<Key>,  
class KeyEqual = [std::equal_to](../utility/functional/equal_to.html)<Key>,  
class Allocator = [std::allocator](../memory/allocator.html)<Key>  
> class unordered_set; |  (1)  |  (since C++11)  
namespace pmr {  
template<  
class Key,  
class Hash = [std::hash](../utility/hash.html)<Key>,  
class Pred = [std::equal_to](../utility/functional/equal_to.html)<Key>  
> using unordered_set = std::unordered_set<Key, Hash, Pred,  
[std::pmr::polymorphic_allocator](../memory/polymorphic_allocator.html)<Key>>;  
} |  (2)  |  (since C++17)  
| |   
  
`std::unordered_set` is an associative container that contains a set of unique objects of type `Key`. Search, insertion, and removal have average constant-time complexity. 

Internally, the elements are not sorted in any particular order, but organized into buckets. Which bucket an element is placed into depends entirely on the hash of its value. This allows fast access to individual elements, since once a hash is computed, it refers to the exact bucket the element is placed into. 

Container elements may not be modified (even by non const iterators) since modification could change an element's hash and corrupt the container. 

`std::unordered_set` meets the requirements of [Container](../named_req/Container.html "cpp/named req/Container"), [AllocatorAwareContainer](../named_req/AllocatorAwareContainer.html "cpp/named req/AllocatorAwareContainer"), [UnorderedAssociativeContainer](../named_req/UnorderedAssociativeContainer.html "cpp/named req/UnorderedAssociativeContainer"). 

All member functions of `std::unordered_set` are constexpr: it is possible to create and use `std::unordered_set` objects in the evaluation of a constant expression.However, `std::unordered_set` objects generally cannot be constexpr, because any dynamically allocated storage must be released in the same evaluation of constant expression. | (since C++26)  
---|---  
  
## Contents

  * [1 Iterator invalidation](unordered_set.html#Iterator_invalidation)
    * [1.1 Notes](unordered_set.html#Notes)
  * [2 Template parameters](unordered_set.html#Template_parameters)
  * [3 Member types](unordered_set.html#Member_types)
  * [4 Member functions](unordered_set.html#Member_functions)
    * [4.1 Iterators](unordered_set.html#Iterators)
    * [4.2 Capacity](unordered_set.html#Capacity)
    * [4.3 Modifiers](unordered_set.html#Modifiers)
    * [4.4 Lookup](unordered_set.html#Lookup)
    * [4.5 Bucket interface](unordered_set.html#Bucket_interface)
    * [4.6 Hash policy](unordered_set.html#Hash_policy)
    * [4.7 Observers](unordered_set.html#Observers)
  * [5 Non-member functions](unordered_set.html#Non-member_functions)
  * [6 Deduction guides](unordered_set.html#Deduction_guides)
  * [7 Notes](unordered_set.html#Notes_2)
  * [8 Example](unordered_set.html#Example)
  * [9 Defect reports](unordered_set.html#Defect_reports)
  * [10 See also](unordered_set.html#See_also)

  
---  
  
### Iterator invalidation

Operations  | Invalidated   
---|---  
All read only operations, [swap](unordered_set/swap.html "cpp/container/unordered set/swap"), [std::swap](../utility/swap.html "cpp/algorithm/swap") | Never   
[clear](unordered_set/clear.html "cpp/container/unordered set/clear"), [rehash](unordered_set/rehash.html "cpp/container/unordered set/rehash"), [reserve](unordered_set/reserve.html "cpp/container/unordered set/reserve"), [operator=](unordered_set/operator=.html "cpp/container/unordered set/operator=") | Always   
[insert](unordered_set/insert.html "cpp/container/unordered set/insert"), [emplace](unordered_set/emplace.html "cpp/container/unordered set/emplace"), [emplace_hint](unordered_set/emplace_hint.html "cpp/container/unordered set/emplace hint") | Only if causes rehash   
[erase](unordered_set/erase.html "cpp/container/unordered set/erase") | Only to the element erased   
  
#### Notes

  * The swap functions do not invalidate any of the iterators inside the container, but they do invalidate the iterator marking the end of the swap region. 


  * References and pointers to data stored in the container are only invalidated by erasing that element, even when the corresponding iterator is invalidated. 


  * After container move assignment, unless elementwise move assignment is forced by incompatible allocators, references, pointers, and iterators (other than the past-the-end iterator) to moved-from container remain valid, but refer to elements that are now in *this. 



### Template parameters

| This section is incomplete  
Reason: Add descriptions of the template parameters.   
---|---  
  
### Member types

Type  |  Definition   
---|---  
`key_type` |  `Key`  
`value_type` |  `Key`  
`size_type` |  Unsigned integer type (usually [std::size_t](../types/size_t.html "cpp/types/size t"))  
`difference_type` |  Signed integer type (usually [std::ptrdiff_t](../types/ptrdiff_t.html "cpp/types/ptrdiff t"))  
`hasher` |  `Hash`  
`key_equal` |  `KeyEqual`  
`allocator_type` |  `Allocator`  
`reference` |  value_type&  
`const_reference` |  const value_type&  
`pointer` |  [std::allocator_traits](../memory/allocator_traits.html)<Allocator>::pointer  
`const_pointer` |  [std::allocator_traits](../memory/allocator_traits.html)<Allocator>::const_pointer  
`iterator` |  Constant [LegacyForwardIterator](../named_req/ForwardIterator.html "cpp/named req/ForwardIterator") and [ConstexprIterator](../named_req/ConstexprIterator.html "cpp/named req/ConstexprIterator")(since C++26) to `value_type`  
`const_iterator` |  [LegacyForwardIterator](../named_req/ForwardIterator.html "cpp/named req/ForwardIterator") and [ConstexprIterator](../named_req/ConstexprIterator.html "cpp/named req/ConstexprIterator")(since C++26) to const value_type  
`local_iterator` |  An iterator type whose category, value, difference, pointer and  
reference types are the same as `iterator`. This iterator  
can be used to iterate through a single bucket but not across buckets  
`const_local_iterator` |  An iterator type whose category, value, difference, pointer and  
reference types are the same as `const_iterator`. This iterator  
can be used to iterate through a single bucket but not across buckets  
`node_type` (since C++17) |  a specialization of [node handle](node_handle.html "cpp/container/node handle") representing a container node  
`insert_return_type` (since C++17) |  type describing the result of inserting a `node_type`, a specialization of  
template<class Iter, class NodeType>  
struct /*unspecified*/  
{  
Iter position;  
bool inserted;  
NodeType node;  
};  
instantiated with template arguments `iterator` and `node_type`.  
  
### Member functions

[ (constructor)](unordered_set/unordered_set.html "cpp/container/unordered set/unordered set") |  constructs the `unordered_set`   
(public member function)   
---|---  
[ (destructor)](unordered_set/~unordered_set.html "cpp/container/unordered set/~unordered set") |  destructs the `unordered_set`   
(public member function)   
[ operator=](unordered_set/operator=.html "cpp/container/unordered set/operator=") |  assigns values to the container   
(public member function)   
[ get_allocator](unordered_set/get_allocator.html "cpp/container/unordered set/get allocator") |  returns the associated allocator   
(public member function)   
  
#####  Iterators   
  
[ begincbegin](unordered_set/begin.html "cpp/container/unordered set/begin") |  returns an iterator to the beginning   
(public member function)   
[ endcend](unordered_set/end.html "cpp/container/unordered set/end") |  returns an iterator to the end   
(public member function)   
  
#####  Capacity   
  
[ empty](unordered_set/empty.html "cpp/container/unordered set/empty") |  checks whether the container is empty   
(public member function)   
[ size](unordered_set/size.html "cpp/container/unordered set/size") |  returns the number of elements   
(public member function)   
[ max_size](unordered_set/max_size.html "cpp/container/unordered set/max size") |  returns the maximum possible number of elements   
(public member function)   
  
#####  Modifiers   
  
[ clear](unordered_set/clear.html "cpp/container/unordered set/clear") |  clears the contents   
(public member function)   
[ insert](unordered_set/insert.html "cpp/container/unordered set/insert") |  inserts elements or nodes(since C++17)   
(public member function)   
[ insert_range](unordered_set/insert_range.html "cpp/container/unordered set/insert range")(C++23) |  inserts a range of elements   
(public member function)   
[ emplace](unordered_set/emplace.html "cpp/container/unordered set/emplace") |  constructs element in-place   
(public member function)   
[ emplace_hint](unordered_set/emplace_hint.html "cpp/container/unordered set/emplace hint") |  constructs elements in-place using a hint   
(public member function)   
[ erase](unordered_set/erase.html "cpp/container/unordered set/erase") |  erases elements   
(public member function)   
[ swap](unordered_set/swap.html "cpp/container/unordered set/swap") |  swaps the contents   
(public member function)   
[ extract](unordered_set/extract.html "cpp/container/unordered set/extract")(C++17) |  extracts nodes from the container   
(public member function)   
[ merge](unordered_set/merge.html "cpp/container/unordered set/merge")(C++17) |  splices nodes from another container   
(public member function)   
  
#####  Lookup   
  
[ count](unordered_set/count.html "cpp/container/unordered set/count") |  returns the number of elements matching specific key   
(public member function)   
[ find](unordered_set/find.html "cpp/container/unordered set/find") |  finds element with specific key   
(public member function)   
[ contains](unordered_set/contains.html "cpp/container/unordered set/contains")(C++20) |  checks if the container contains element with specific key   
(public member function)   
[ equal_range](unordered_set/equal_range.html "cpp/container/unordered set/equal range") |  returns range of elements matching a specific key   
(public member function)   
  
#####  Bucket interface   
  
[ begin(size_type)cbegin(size_type)](unordered_set/begin2.html "cpp/container/unordered set/begin2") |  returns an iterator to the beginning of the specified bucket   
(public member function) &action=edit)  
[ end(size_type)cend(size_type)](unordered_set/end2.html "cpp/container/unordered set/end2") |  returns an iterator to the end of the specified bucket   
(public member function) &action=edit)  
[ bucket_count](unordered_set/bucket_count.html "cpp/container/unordered set/bucket count") |  returns the number of buckets   
(public member function)   
[ max_bucket_count](unordered_set/max_bucket_count.html "cpp/container/unordered set/max bucket count") |  returns the maximum number of buckets   
(public member function)   
[ bucket_size](unordered_set/bucket_size.html "cpp/container/unordered set/bucket size") |  returns the number of elements in specific bucket   
(public member function)   
[ bucket](unordered_set/bucket.html "cpp/container/unordered set/bucket") |  returns the bucket for specific key   
(public member function)   
  
#####  Hash policy   
  
[ load_factor](unordered_set/load_factor.html "cpp/container/unordered set/load factor") |  returns average number of elements per bucket   
(public member function)   
[ max_load_factor](unordered_set/max_load_factor.html "cpp/container/unordered set/max load factor") |  manages maximum average number of elements per bucket   
(public member function)   
[ rehash](unordered_set/rehash.html "cpp/container/unordered set/rehash") |  reserves at least the specified number of buckets and regenerates the hash table   
(public member function)   
[ reserve](unordered_set/reserve.html "cpp/container/unordered set/reserve") |  reserves space for at least the specified number of elements and regenerates the hash table   
(public member function)   
  
#####  Observers   
  
[ hash_function](unordered_set/hash_function.html "cpp/container/unordered set/hash function") |  returns function used to hash the keys   
(public member function)   
[ key_eq](unordered_set/key_eq.html "cpp/container/unordered set/key eq") |  returns the function used to compare keys for equality   
(public member function)   
  
### Non-member functions

[ operator==operator!=](unordered_set/operator_cmp.html "cpp/container/unordered set/operator cmp")(C++11)(C++11)(removed in C++20) |  compares the values in the unordered_set   
(function template)   
---|---  
[ std::swap(std::unordered_set)](unordered_set/swap2.html "cpp/container/unordered set/swap2")(C++11) |  specializes the [std::swap](../utility/swap.html "cpp/algorithm/swap") algorithm   
(function template)   
[ erase_if(std::unordered_set)](unordered_set/erase_if.html "cpp/container/unordered set/erase if")(C++20) |  erases all elements satisfying specific criteria   
(function template)   
  
###  [Deduction guides](unordered_set/deduction_guides.html "cpp/container/unordered set/deduction guides")

| (since C++17)  
---|---  
  
### Notes

The member types `iterator` and `const_iterator` may be aliases to the same type. This means defining a pair of function overloads using the two types as parameter types may violate the [One Definition Rule](../language/definition.html#One_Definition_Rule "cpp/language/definition"). Since `iterator` is convertible to `const_iterator`, a single function with a `const_iterator` as parameter type will work instead. 

[Feature-test](../utility/feature_test.html "cpp/utility/feature test") macro  | Value | Std | Feature   
---|---|---|---  
[`__cpp_lib_containers_ranges`](../experimental/feature_test.html#cpp_lib_containers_ranges "cpp/feature test") | [`202202L`](../compiler_support/23.html#cpp_lib_containers_ranges_202202L "cpp/compiler support/23") | (C++23) | Ranges construction and insertion for containers   
[`__cpp_lib_constexpr_unordered_set`](../experimental/feature_test.html#cpp_lib_constexpr_unordered_set "cpp/feature test") | [`202502L`](../compiler_support/26.html#cpp_lib_constexpr_unordered_set_202502L "cpp/compiler support/26") | (C++26) | constexpr `std::unordered_set`  
  
### Example

Run this code
    
    
    #include <iostream>
    #include <unordered_set>
     
    void print(const auto& set)
    {
        for (const auto& elem : set)
            [std::cout](../io/cout.html) << elem << ' ';
        [std::cout](../io/cout.html) << '\n';
    }
     
    int main()
    {
        std::unordered_set<int> mySet{2, 7, 1, 8, 2, 8}; // creates a set of ints
        print(mySet);
     
        mySet.insert(5); // puts an element 5 in the set
        print(mySet);
     
        if (auto iter = mySet.find(5); iter != mySet.end())
            mySet.erase(iter); // removes an element pointed to by iter
        print(mySet);
     
        mySet.erase(7); // removes an element 7
        print(mySet);
    }

Possible output: 
    
    
    8 1 7 2
    5 8 1 7 2
    8 1 7 2
    8 1 2

### Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[LWG 2050](https://cplusplus.github.io/LWG/issue2050) | C++11  | the definitions of `reference`, `const_reference`, `pointer`  
and `const_pointer` were based on `allocator_type` | based on `value_type` and  
[std::allocator_traits](../memory/allocator_traits.html "cpp/memory/allocator traits")  
  
### See also

[ unordered_multiset](unordered_multiset.html "cpp/container/unordered multiset")(C++11) |  collection of keys, hashed by keys   
(class template)   
---|---  
[ set](set.html "cpp/container/set") |  collection of unique keys, sorted by keys   
(class template)   
[ flat_set](flat_set.html "cpp/container/flat set")(C++23) |  adapts a container to provide a collection of unique keys, sorted by keys   
(class template) 
  *[Value]: The year/month in which the feature was adopted. The hyperlink under each value opens a compiler support page with entry for given feature.
  *[Std]: Standard in which the feature is introduced; DR means defect report against that revision
