
  


[Containers library](../container.html "cpp/container")

[_node-handle_](node_handle.html "cpp/container/node handle")(C++17)  
---  
[Sequence](../container.html#Sequence_containers "cpp/container")  
[array](array.html "cpp/container/array")(C++11)  
[vector](vector.html "cpp/container/vector")  
[vector<bool>](vector_bool.html "cpp/container/vector bool")  
[inplace_vector](inplace_vector.html "cpp/container/inplace vector")(C++26)  
[hive](https://en.cppreference.com/mwiki/index.php?title=cpp/container/hive&action=edit&redlink=1 "cpp/container/hive \(page does not exist\)")(C++26)  
[deque](deque.html "cpp/container/deque")  
[forward_list](forward_list.html "cpp/container/forward list")(C++11)  
[list](list.html "cpp/container/list")  
[Associative](../container.html#Associative_containers "cpp/container")  
[set](set.html "cpp/container/set")  
[multiset](multiset.html "cpp/container/multiset")  
[map](map.html "cpp/container/map")  
[multimap](multimap.html "cpp/container/multimap")  
[Unordered associative](../container.html#Unordered_associative_containers "cpp/container")  
[unordered_set](unordered_set.html "cpp/container/unordered set")(C++11)  
[unordered_multiset](unordered_multiset.html "cpp/container/unordered multiset")(C++11)  
**unordered_map**(C++11)  
[unordered_multimap](unordered_multimap.html "cpp/container/unordered multimap")(C++11)  
[Adaptors](../container.html#Container_adaptors "cpp/container")  
[stack](stack.html "cpp/container/stack")  
[queue](queue.html "cpp/container/queue")  
[priority_queue](priority_queue.html "cpp/container/priority queue")  
[flat_set](flat_set.html "cpp/container/flat set")(C++23)  
[flat_multiset](flat_multiset.html "cpp/container/flat multiset")(C++23)  
[flat_map](flat_map.html "cpp/container/flat map")(C++23)  
[flat_multimap](flat_multimap.html "cpp/container/flat multimap")(C++23)  
[Views](../container.html#Views "cpp/container")  
[span](span.html "cpp/container/span")(C++20)  
[mdspan](mdspan.html "cpp/container/mdspan")(C++23)  
Tables  
[Iterator invalidation](../container.html#Iterator_invalidation "cpp/container")  
[Member function table](../container.html#Member_function_table "cpp/container")  
[Non-member function table](../container.html#Non-member_function_table "cpp/container")  
  


**`std::unordered_map`**

[Member types](unordered_map.html#Member_types "cpp/container/unordered map")  
---  
[Member functions](unordered_map.html#Member_functions "cpp/container/unordered map")  
| [unordered_map::unordered_map](unordered_map/unordered_map.html "cpp/container/unordered map/unordered map")  
---  
[unordered_map::~unordered_map](unordered_map/~unordered_map.html "cpp/container/unordered map/~unordered map")  
[unordered_map::operator=](unordered_map/operator=.html "cpp/container/unordered map/operator=")  
[unordered_map::get_allocator](unordered_map/get_allocator.html "cpp/container/unordered map/get allocator")  
[Iterators](unordered_map.html#Iterators "cpp/container/unordered map")  
[unordered_map::beginunordered_map::cbegin](unordered_map/begin.html "cpp/container/unordered map/begin")  
[unordered_map::endunordered_map::cend](unordered_map/end.html "cpp/container/unordered map/end")  
[Capacity](unordered_map.html#Capacity "cpp/container/unordered map")  
[unordered_map::size](unordered_map/size.html "cpp/container/unordered map/size")  
[unordered_map::max_size](unordered_map/max_size.html "cpp/container/unordered map/max size")  
[unordered_map::empty](unordered_map/empty.html "cpp/container/unordered map/empty")  
[Modifiers](unordered_map.html#Modifiers "cpp/container/unordered map")  
[unordered_map::clear](unordered_map/clear.html "cpp/container/unordered map/clear")  
[unordered_map::erase](unordered_map/erase.html "cpp/container/unordered map/erase")  
[unordered_map::swap](unordered_map/swap.html "cpp/container/unordered map/swap")  
[unordered_map::extract](unordered_map/extract.html "cpp/container/unordered map/extract")(C++17)  
[unordered_map::merge](unordered_map/merge.html "cpp/container/unordered map/merge")(C++17)  
[unordered_map::insert](unordered_map/insert.html "cpp/container/unordered map/insert")  
[unordered_map::insert_range](unordered_map/insert_range.html "cpp/container/unordered map/insert range")(C++23)  
[unordered_map::insert_or_assign](unordered_map/insert_or_assign.html "cpp/container/unordered map/insert or assign")(C++17)` `  
[unordered_map::emplace](unordered_map/emplace.html "cpp/container/unordered map/emplace")  
[unordered_map::emplace_hint](unordered_map/emplace_hint.html "cpp/container/unordered map/emplace hint")  
[unordered_map::try_emplace](unordered_map/try_emplace.html "cpp/container/unordered map/try emplace")(C++17)  
  
| [Lookup](unordered_map.html#Lookup "cpp/container/unordered map")  
---  
[unordered_map::at](unordered_map/at.html "cpp/container/unordered map/at")  
[unordered_map::operator[]](unordered_map/operator_at.html "cpp/container/unordered map/operator at")  
[unordered_map::count](unordered_map/count.html "cpp/container/unordered map/count")  
[unordered_map::find](unordered_map/find.html "cpp/container/unordered map/find")  
[unordered_map::contains](unordered_map/contains.html "cpp/container/unordered map/contains")(C++20)  
[unordered_map::equal_range](unordered_map/equal_range.html "cpp/container/unordered map/equal range")  
[Bucket interface](unordered_map.html#Bucket_interface "cpp/container/unordered map")  
[unordered_map::begin(size_type)unordered_map::cbegin(size_type)](unordered_map/begin2.html "cpp/container/unordered map/begin2")  
[unordered_map::end(size_type)unordered_map::cend(size_type)](unordered_map/end2.html "cpp/container/unordered map/end2")  
[unordered_map::bucket_count](unordered_map/bucket_count.html "cpp/container/unordered map/bucket count")  
[unordered_map::max_bucket_count](unordered_map/max_bucket_count.html "cpp/container/unordered map/max bucket count")  
[unordered_map::bucket_size](unordered_map/bucket_size.html "cpp/container/unordered map/bucket size")  
[unordered_map::bucket](unordered_map/bucket.html "cpp/container/unordered map/bucket")  
[Hash policy](unordered_map.html#Hash_policy "cpp/container/unordered map")  
[unordered_map::load_factor](unordered_map/load_factor.html "cpp/container/unordered map/load factor")  
[unordered_map::max_load_factor](unordered_map/max_load_factor.html "cpp/container/unordered map/max load factor")  
[unordered_map::rehash](unordered_map/rehash.html "cpp/container/unordered map/rehash")  
[unordered_map::reserve](unordered_map/reserve.html "cpp/container/unordered map/reserve")  
[Observers](unordered_map.html#Observers "cpp/container/unordered map")  
[unordered_map::hash_function](unordered_map/hash_function.html "cpp/container/unordered map/hash function")  
[unordered_map::key_eq](unordered_map/key_eq.html "cpp/container/unordered map/key eq")  
  
[Non-member functions](unordered_map.html#Non-member_functions "cpp/container/unordered map")  
| [operator==operator!=](unordered_map/operator_cmp.html "cpp/container/unordered map/operator cmp")(until C++20)  
---  
  
| [std::swap(std::unordered_map)](unordered_map/swap2.html "cpp/container/unordered map/swap2")  
---  
[erase_if(std::unordered_map)](unordered_map/erase_if.html "cpp/container/unordered map/erase if")(C++20)  
  
[Deduction guides](unordered_map/deduction_guides.html "cpp/container/unordered map/deduction guides")(C++17)  
  


Defined in header `[<unordered_map>](../header/unordered_map.html "cpp/header/unordered map")` |  |   
---|---|---  
template<  
class Key,  
class T,  
class Hash = [std::hash](../utility/hash.html)<Key>,  
class KeyEqual = [std::equal_to](../utility/functional/equal_to.html)<Key>,  
class Allocator = [std::allocator](../memory/allocator.html)<[std::pair](../utility/pair.html)<const Key, T>>  
> class unordered_map; |  (1)  |  (since C++11)  
namespace pmr {  
template<  
class Key,  
class T,  
class Hash = [std::hash](../utility/hash.html)<Key>,  
class KeyEqual = [std::equal_to](../utility/functional/equal_to.html)<Key>  
> using unordered_map =  
std::unordered_map<Key, T, Hash, KeyEqual,  
[std::pmr::polymorphic_allocator](../memory/polymorphic_allocator.html)<[std::pair](../utility/pair.html)<const Key, T>>>;  
} |  (2)  |  (since C++17)  
| |   
  
`std::unordered_map` is an associative container that contains key-value pairs with unique keys. Search, insertion, and removal of elements have average constant-time complexity. 

Internally, the elements are not sorted in any particular order, but organized into buckets. Which bucket an element is placed into depends entirely on the hash of its key. Keys with the same hash code appear in the same bucket. This allows fast access to individual elements, since once the hash is computed, it refers to the bucket containing the element. 

Two keys are considered _equivalent_ if the map's key equality predicate returns true when passed those keys. If two keys are equivalent, the hash function must return the same value for both keys. 

`std::unordered_map` meets the requirements of [Container](../named_req/Container.html "cpp/named req/Container"), [AllocatorAwareContainer](../named_req/AllocatorAwareContainer.html "cpp/named req/AllocatorAwareContainer"), [UnorderedAssociativeContainer](../named_req/UnorderedAssociativeContainer.html "cpp/named req/UnorderedAssociativeContainer"). 

All member functions of `std::unordered_map` are constexpr: it is possible to create and use `std::unordered_map` objects in the evaluation of a constant expression.However, `std::unordered_map` objects generally cannot be constexpr, because any dynamically allocated storage must be released in the same evaluation of constant expression. | (since C++26)  
---|---  
  
## Contents

  * [1 Iterator invalidation](unordered_map.html#Iterator_invalidation)
    * [1.1 Notes](unordered_map.html#Notes)
  * [2 Template parameters](unordered_map.html#Template_parameters)
  * [3 Member types](unordered_map.html#Member_types)
  * [4 Member functions](unordered_map.html#Member_functions)
    * [4.1 Iterators](unordered_map.html#Iterators)
    * [4.2 Capacity](unordered_map.html#Capacity)
    * [4.3 Modifiers](unordered_map.html#Modifiers)
    * [4.4 Lookup](unordered_map.html#Lookup)
    * [4.5 Bucket interface](unordered_map.html#Bucket_interface)
    * [4.6 Hash policy](unordered_map.html#Hash_policy)
    * [4.7 Observers](unordered_map.html#Observers)
  * [5 Non-member functions](unordered_map.html#Non-member_functions)
  * [6 Deduction guides](unordered_map.html#Deduction_guides)
  * [7 Notes](unordered_map.html#Notes_2)
  * [8 Example](unordered_map.html#Example)
  * [9 Defect reports](unordered_map.html#Defect_reports)
  * [10 See also](unordered_map.html#See_also)

  
---  
  
### Iterator invalidation

Operations  | Invalidated   
---|---  
All read only operations, [swap](unordered_map/swap.html "cpp/container/unordered map/swap"), [std::swap](../utility/swap.html "cpp/algorithm/swap") | Never   
[clear](unordered_map/clear.html "cpp/container/unordered map/clear"), [rehash](unordered_map/rehash.html "cpp/container/unordered map/rehash"), [reserve](unordered_map/reserve.html "cpp/container/unordered map/reserve"), [operator=](unordered_map/operator=.html "cpp/container/unordered map/operator=") | Always   
[insert](unordered_map/insert.html "cpp/container/unordered map/insert"), [emplace](unordered_map/emplace.html "cpp/container/unordered map/emplace"), [emplace_hint](unordered_map/emplace_hint.html "cpp/container/unordered map/emplace hint"), [operator[]](unordered_map/operator_at.html "cpp/container/unordered map/operator at") | Only if causes rehash   
[erase](unordered_map/erase.html "cpp/container/unordered map/erase") | Only to the element erased   
  
#### Notes

  * The swap functions do not invalidate any of the iterators inside the container, but they do invalidate the iterator marking the end of the swap region. 


  * References and pointers to either key or data stored in the container are only invalidated by erasing that element, even when the corresponding iterator is invalidated. 



### Template parameters

| This section is incomplete  
Reason: Add descriptions of the template parameters.   
---|---  
  
### Member types

Type  |  Definition   
---|---  
`key_type` |  `Key`  
`mapped_type` |  `T`  
`value_type` |  [std::pair](../utility/pair.html)<const Key, T>  
`size_type` |  Unsigned integer type (usually [std::size_t](../types/size_t.html "cpp/types/size t"))  
`difference_type` |  Signed integer type (usually [std::ptrdiff_t](../types/ptrdiff_t.html "cpp/types/ptrdiff t"))  
`hasher` |  `Hash`  
`key_equal` |  `KeyEqual`  
`allocator_type` |  `Allocator`  
`reference` |  value_type&  
`const_reference` |  const value_type&  
`pointer` |  [std::allocator_traits](../memory/allocator_traits.html)<Allocator>::pointer  
`const_pointer` |  [std::allocator_traits](../memory/allocator_traits.html)<Allocator>::const_pointer  
`iterator` |  [LegacyForwardIterator](../named_req/ForwardIterator.html "cpp/named req/ForwardIterator") and [ConstexprIterator](../named_req/ConstexprIterator.html "cpp/named req/ConstexprIterator")(since C++26) to `value_type`  
`const_iterator` |  [LegacyForwardIterator](../named_req/ForwardIterator.html "cpp/named req/ForwardIterator") and [ConstexprIterator](../named_req/ConstexprIterator.html "cpp/named req/ConstexprIterator")(since C++26) to const value_type  
`local_iterator` |  An iterator type whose category, value, difference, pointer and  
reference types are the same as `iterator`. This iterator  
can be used to iterate through a single bucket but not across buckets  
`const_local_iterator` |  An iterator type whose category, value, difference, pointer and  
reference types are the same as `const_iterator`. This iterator  
can be used to iterate through a single bucket but not across buckets  
`node_type` (since C++17) |  a specialization of [node handle](node_handle.html "cpp/container/node handle") representing a container node  
`insert_return_type` (since C++17) |  type describing the result of inserting a `node_type`, a specialization of  
template<class Iter, class NodeType>  
struct /*unspecified*/  
{  
Iter position;  
bool inserted;  
NodeType node;  
};  
instantiated with template arguments `iterator` and `node_type`.  
  
### Member functions

[ (constructor)](unordered_map/unordered_map.html "cpp/container/unordered map/unordered map") |  constructs the `unordered_map`   
(public member function)   
---|---  
[ (destructor)](unordered_map/~unordered_map.html "cpp/container/unordered map/~unordered map") |  destructs the `unordered_map`   
(public member function)   
[ operator=](unordered_map/operator=.html "cpp/container/unordered map/operator=") |  assigns values to the container   
(public member function)   
[ get_allocator](unordered_map/get_allocator.html "cpp/container/unordered map/get allocator") |  returns the associated allocator   
(public member function)   
  
#####  Iterators   
  
[ begincbegin](unordered_map/begin.html "cpp/container/unordered map/begin") |  returns an iterator to the beginning   
(public member function)   
[ endcend](unordered_map/end.html "cpp/container/unordered map/end") |  returns an iterator to the end   
(public member function)   
  
#####  Capacity   
  
[ empty](unordered_map/empty.html "cpp/container/unordered map/empty") |  checks whether the container is empty   
(public member function)   
[ size](unordered_map/size.html "cpp/container/unordered map/size") |  returns the number of elements   
(public member function)   
[ max_size](unordered_map/max_size.html "cpp/container/unordered map/max size") |  returns the maximum possible number of elements   
(public member function)   
  
#####  Modifiers   
  
[ clear](unordered_map/clear.html "cpp/container/unordered map/clear") |  clears the contents   
(public member function)   
[ insert](unordered_map/insert.html "cpp/container/unordered map/insert") |  inserts elements or nodes(since C++17)   
(public member function)   
[ insert_range](unordered_map/insert_range.html "cpp/container/unordered map/insert range")(C++23) |  inserts a range of elements   
(public member function)   
[ insert_or_assign](unordered_map/insert_or_assign.html "cpp/container/unordered map/insert or assign")(C++17) |  inserts an element or assigns to the current element if the key already exists   
(public member function)   
[ emplace](unordered_map/emplace.html "cpp/container/unordered map/emplace") |  constructs element in-place   
(public member function)   
[ emplace_hint](unordered_map/emplace_hint.html "cpp/container/unordered map/emplace hint") |  constructs elements in-place using a hint   
(public member function)   
[ try_emplace](unordered_map/try_emplace.html "cpp/container/unordered map/try emplace")(C++17) |  inserts in-place if the key does not exist, does nothing if the key exists   
(public member function)   
[ erase](unordered_map/erase.html "cpp/container/unordered map/erase") |  erases elements   
(public member function)   
[ swap](unordered_map/swap.html "cpp/container/unordered map/swap") |  swaps the contents   
(public member function)   
[ extract](unordered_map/extract.html "cpp/container/unordered map/extract")(C++17) |  extracts nodes from the container   
(public member function)   
[ merge](unordered_map/merge.html "cpp/container/unordered map/merge")(C++17) |  splices nodes from another container   
(public member function)   
  
#####  Lookup   
  
[ at](unordered_map/at.html "cpp/container/unordered map/at") |  access specified element with bounds checking   
(public member function)   
[ operator[]](unordered_map/operator_at.html "cpp/container/unordered map/operator at") |  access or insert specified element   
(public member function)   
[ count](unordered_map/count.html "cpp/container/unordered map/count") |  returns the number of elements matching specific key   
(public member function)   
[ find](unordered_map/find.html "cpp/container/unordered map/find") |  finds element with specific key   
(public member function)   
[ contains](unordered_map/contains.html "cpp/container/unordered map/contains")(C++20) |  checks if the container contains element with specific key   
(public member function)   
[ equal_range](unordered_map/equal_range.html "cpp/container/unordered map/equal range") |  returns range of elements matching a specific key   
(public member function)   
  
#####  Bucket interface   
  
[ begin(size_type)cbegin(size_type)](unordered_map/begin2.html "cpp/container/unordered map/begin2") |  returns an iterator to the beginning of the specified bucket   
(public member function) &action=edit)  
[ end(size_type)cend(size_type)](unordered_map/end2.html "cpp/container/unordered map/end2") |  returns an iterator to the end of the specified bucket   
(public member function) &action=edit)  
[ bucket_count](unordered_map/bucket_count.html "cpp/container/unordered map/bucket count") |  returns the number of buckets   
(public member function)   
[ max_bucket_count](unordered_map/max_bucket_count.html "cpp/container/unordered map/max bucket count") |  returns the maximum number of buckets   
(public member function)   
[ bucket_size](unordered_map/bucket_size.html "cpp/container/unordered map/bucket size") |  returns the number of elements in specific bucket   
(public member function)   
[ bucket](unordered_map/bucket.html "cpp/container/unordered map/bucket") |  returns the bucket for specific key   
(public member function)   
  
#####  Hash policy   
  
[ load_factor](unordered_map/load_factor.html "cpp/container/unordered map/load factor") |  returns average number of elements per bucket   
(public member function)   
[ max_load_factor](unordered_map/max_load_factor.html "cpp/container/unordered map/max load factor") |  manages maximum average number of elements per bucket   
(public member function)   
[ rehash](unordered_map/rehash.html "cpp/container/unordered map/rehash") |  reserves at least the specified number of buckets and regenerates the hash table   
(public member function)   
[ reserve](unordered_map/reserve.html "cpp/container/unordered map/reserve") |  reserves space for at least the specified number of elements and regenerates the hash table   
(public member function)   
  
#####  Observers   
  
[ hash_function](unordered_map/hash_function.html "cpp/container/unordered map/hash function") |  returns function used to hash the keys   
(public member function)   
[ key_eq](unordered_map/key_eq.html "cpp/container/unordered map/key eq") |  returns the function used to compare keys for equality   
(public member function)   
  
### Non-member functions

[ operator==operator!=](unordered_map/operator_cmp.html "cpp/container/unordered map/operator cmp")(C++11)(C++11)(removed in C++20) |  compares the values in the unordered_map   
(function template)   
---|---  
[ std::swap(std::unordered_map)](unordered_map/swap2.html "cpp/container/unordered map/swap2")(C++11) |  specializes the [std::swap](../utility/swap.html "cpp/algorithm/swap") algorithm   
(function template)   
[ erase_if(std::unordered_map)](unordered_map/erase_if.html "cpp/container/unordered map/erase if")(C++20) |  erases all elements satisfying specific criteria   
(function template)   
  
###  [Deduction guides](unordered_map/deduction_guides.html "cpp/container/unordered map/deduction guides")

| (since C++17)  
---|---  
  
### Notes

[Feature-test](../utility/feature_test.html "cpp/utility/feature test") macro  | Value | Std | Feature   
---|---|---|---  
[`__cpp_lib_containers_ranges`](../experimental/feature_test.html#cpp_lib_containers_ranges "cpp/feature test") | [`202202L`](../compiler_support/23.html#cpp_lib_containers_ranges_202202L "cpp/compiler support/23") | (C++23) | Ranges construction and insertion for containers   
[`__cpp_lib_constexpr_unordered_map`](../experimental/feature_test.html#cpp_lib_constexpr_unordered_map "cpp/feature test") | [`202502L`](../compiler_support/26.html#cpp_lib_constexpr_unordered_map_202502L "cpp/compiler support/26") | (C++26) | constexpr `std::unordered_map`  
  
### Example

Run this code
    
    
    #include <iostream>
    #include <string>
    #include <unordered_map>
     
    int main()
    {
        // Create an unordered_map of three strings (that map to strings)
        std::unordered_map<[std::string](../string/basic_string.html), [std::string](../string/basic_string.html)> u =
        {
            {"RED", "#FF0000"},
            {"GREEN", "#00FF00"},
            {"BLUE", "#0000FF"}
        };
     
        // Helper lambda function to print key-value pairs
        auto print_key_value = [](const auto& key, const auto& value)
        {
            [std::cout](../io/cout.html) << "Key:[" << key << "] Value:[" << value << "]\n";
        };
     
        [std::cout](../io/cout.html) << "Iterate and print key-value pairs of unordered_map, being\n"
                     "explicit with their types:\n";
        for (const [std::pair](../utility/pair.html)<const [std::string](../string/basic_string.html), [std::string](../string/basic_string.html)>& n : u)
            print_key_value(n.first, n.second);
     
        [std::cout](../io/cout.html) << "\nIterate and print key-value pairs using C++17 structured binding:\n";
        for (const auto& [key, value] : u)
            print_key_value(key, value);
     
        // Add two new entries to the unordered_map
        u["BLACK"] = "#000000";
        u["WHITE"] = "#FFFFFF";
     
        [std::cout](../io/cout.html) << "\nOutput values by key:\n"
                     "The HEX of color RED is:[" << u["RED"] << "]\n"
                     "The HEX of color BLACK is:[" << u["BLACK"] << "]\n\n";
     
        [std::cout](../io/cout.html) << "Use operator[] with non-existent key to insert a new key-value pair:\n";
        print_key_value("new_key", u["new_key"]);
     
        [std::cout](../io/cout.html) << "\nIterate and print key-value pairs, using `auto`;\n"
                     "new_key is now one of the keys in the map:\n";
        for (const auto& n : u)
            print_key_value(n.first, n.second);
    }

Possible output: 
    
    
    Iterate and print key-value pairs of unordered_map, being
    explicit with their types:
    Key:[BLUE] Value:[#0000FF]
    Key:[GREEN] Value:[#00FF00]
    Key:[RED] Value:[#FF0000]
     
    Iterate and print key-value pairs using C++17 structured binding:
    Key:[BLUE] Value:[#0000FF]
    Key:[GREEN] Value:[#00FF00]
    Key:[RED] Value:[#FF0000]
     
    Output values by key:
    The HEX of color RED is:[#FF0000]
    The HEX of color BLACK is:[#000000]
     
    Use operator[] with non-existent key to insert a new key-value pair:
    Key:[new_key] Value:[]
     
    Iterate and print key-value pairs, using `auto`;
    new_key is now one of the keys in the map:
    Key:[new_key] Value:[]
    Key:[WHITE] Value:[#FFFFFF]
    Key:[BLACK] Value:[#000000]
    Key:[BLUE] Value:[#0000FF]
    Key:[GREEN] Value:[#00FF00]
    Key:[RED] Value:[#FF0000]

### Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[LWG 2050](https://cplusplus.github.io/LWG/issue2050) | C++11  | the definitions of `reference`, `const_reference`, `pointer`  
and `const_pointer` were based on `allocator_type` | based on `value_type` and  
[std::allocator_traits](../memory/allocator_traits.html "cpp/memory/allocator traits")  
  
### See also

[ unordered_multimap](unordered_multimap.html "cpp/container/unordered multimap")(C++11) |  collection of key-value pairs, hashed by keys   
(class template)   
---|---  
[ map](map.html "cpp/container/map") |  collection of key-value pairs, sorted by keys, keys are unique   
(class template)   
[ flat_map](flat_map.html "cpp/container/flat map")(C++23) |  adapts two containers to provide a collection of key-value pairs, sorted by unique keys   
(class template) 
  *[Value]: The year/month in which the feature was adopted. The hyperlink under each value opens a compiler support page with entry for given feature.
  *[Std]: Standard in which the feature is introduced; DR means defect report against that revision
