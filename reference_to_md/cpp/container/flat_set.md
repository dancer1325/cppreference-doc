[C++](../../cpp.html "cpp")

[Compiler support](../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../freestanding.html "cpp/freestanding")  
[Language](../language.html "cpp/language")  
[Standard library](../standard_library.html "cpp/standard library")  
[Standard library headers](../headers.html "cpp/header")  
[Named requirements](../iterator/concepts.html "cpp/named req")  
[Feature test macros](../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../utility.html#Language_support "cpp/utility")  
[Concepts library](../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../error.html "cpp/error")  
[Memory management library](../memory.html "cpp/memory")  
[Metaprogramming library](../meta.html "cpp/meta") (C++11)  
[General utilities library](../utility.html "cpp/utility")  
[Containers library](../container.html "cpp/container")  
[Iterators library](../iterator.html "cpp/iterator")  
[Ranges library](../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../algorithm.html "cpp/algorithm")  
[Strings library](../string.html "cpp/string")  
[Text processing library](../text.html "cpp/text")  
[Numerics library](../numeric.html "cpp/numeric")  
[Date and time library](../chrono.html "cpp/chrono")  
[Input/output library](../io.html "cpp/io")  
[Filesystem library](../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../atomic.html "cpp/thread") (C++11)  
[Execution control library](../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../experimental.html "cpp/experimental")  
[Symbols index](../symbol_index.html "cpp/symbol index")  
[External libraries](../links/libs.html "cpp/links/libs")  
  


[Containers library](../container.html "cpp/container")

[_node-handle_](node_handle.html "cpp/container/node handle")(C++17)  
---  
[Sequence](../container.html#Sequence_containers "cpp/container")  
[array](array.html "cpp/container/array")(C++11)  
[vector](vector.html "cpp/container/vector")  
[vector<bool>](vector_bool.html "cpp/container/vector bool")  
[inplace_vector](inplace_vector.html "cpp/container/inplace vector")(C++26)  
[hive](https://en.cppreference.com/mwiki/index.php?title=cpp/container/hive&action=edit&redlink=1 "cpp/container/hive \(page does not exist\)")(C++26)  
[deque](deque.html "cpp/container/deque")  
[forward_list](forward_list.html "cpp/container/forward list")(C++11)  
[list](list.html "cpp/container/list")  
[Associative](../container.html#Associative_containers "cpp/container")  
[set](set.html "cpp/container/set")  
[multiset](multiset.html "cpp/container/multiset")  
[map](map.html "cpp/container/map")  
[multimap](multimap.html "cpp/container/multimap")  
[Unordered associative](../container.html#Unordered_associative_containers "cpp/container")  
[unordered_set](unordered_set.html "cpp/container/unordered set")(C++11)  
[unordered_multiset](unordered_multiset.html "cpp/container/unordered multiset")(C++11)  
[unordered_map](unordered_map.html "cpp/container/unordered map")(C++11)  
[unordered_multimap](unordered_multimap.html "cpp/container/unordered multimap")(C++11)  
[Adaptors](../container.html#Container_adaptors "cpp/container")  
[stack](stack.html "cpp/container/stack")  
[queue](queue.html "cpp/container/queue")  
[priority_queue](priority_queue.html "cpp/container/priority queue")  
**flat_set**(C++23)  
[flat_multiset](flat_multiset.html "cpp/container/flat multiset")(C++23)  
[flat_map](flat_map.html "cpp/container/flat map")(C++23)  
[flat_multimap](flat_multimap.html "cpp/container/flat multimap")(C++23)  
[Views](../container.html#Views "cpp/container")  
[span](span.html "cpp/container/span")(C++20)  
[mdspan](mdspan.html "cpp/container/mdspan")(C++23)  
Tables  
[Iterator invalidation](../container.html#Iterator_invalidation "cpp/container")  
[Member function table](../container.html#Member_function_table "cpp/container")  
[Non-member function table](../container.html#Non-member_function_table "cpp/container")  
  


**`std::flat_set`**

[Member types](flat_set.html#Member_types "cpp/container/flat set")  
---  
[Member functions](flat_set.html#Member_functions "cpp/container/flat set")  
|  | [flat_set::flat_set](flat_set/flat_set.html "cpp/container/flat set/flat set")  
---  
[flat_set::operator=](flat_set/operator=.html "cpp/container/flat set/operator=")  
[Iterators](flat_set.html#Iterators "cpp/container/flat set")  
[flat_set::beginflat_set::cbegin](flat_set/begin.html "cpp/container/flat set/begin")  
[flat_set::endflat_set::cend](flat_set/end.html "cpp/container/flat set/end")  
[flat_set::rbeginflat_set::crbegin](flat_set/rbegin.html "cpp/container/flat set/rbegin")  
[flat_set::rendflat_set::crend](flat_set/rend.html "cpp/container/flat set/rend")  
[Capacity](flat_set.html#Capacity "cpp/container/flat set")  
[flat_set::size](flat_set/size.html "cpp/container/flat set/size")  
[flat_set::max_size](flat_set/max_size.html "cpp/container/flat set/max size")  
[flat_set::empty](flat_set/empty.html "cpp/container/flat set/empty")  
[Observers](flat_set.html#Observers "cpp/container/flat set")  
[flat_set::key_comp](flat_set/key_comp.html "cpp/container/flat set/key comp")  
[flat_set::value_comp](flat_set/value_comp.html "cpp/container/flat set/value comp")  
  
| [Modifiers](flat_set.html#Modifiers "cpp/container/flat set")  
---  
[flat_set::clear](flat_set/clear.html "cpp/container/flat set/clear")  
[flat_set::insert](flat_set/insert.html "cpp/container/flat set/insert")  
[flat_set::insert_range](flat_set/insert_range.html "cpp/container/flat set/insert range")  
[flat_set::emplace](flat_set/emplace.html "cpp/container/flat set/emplace")  
[flat_set::emplace_hint](flat_set/emplace_hint.html "cpp/container/flat set/emplace hint")  
[flat_set::erase](flat_set/erase.html "cpp/container/flat set/erase")  
[flat_set::swap](flat_set/swap.html "cpp/container/flat set/swap")  
[flat_set::extract](flat_set/extract.html "cpp/container/flat set/extract")  
[flat_set::replace](flat_set/replace.html "cpp/container/flat set/replace")  
[Lookup](flat_set.html#Lookup "cpp/container/flat set")  
[flat_set::count](flat_set/count.html "cpp/container/flat set/count")  
[flat_set::find](flat_set/find.html "cpp/container/flat set/find")  
[flat_set::contains](flat_set/contains.html "cpp/container/flat set/contains")  
[flat_set::equal_range](flat_set/equal_range.html "cpp/container/flat set/equal range")  
[flat_set::lower_bound](flat_set/lower_bound.html "cpp/container/flat set/lower bound")  
[flat_set::upper_bound](flat_set/upper_bound.html "cpp/container/flat set/upper bound")  
  
[Non-member functions](flat_set.html#Non-member_functions "cpp/container/flat set")  
| [operator==operator<=>](flat_set/operator_cmp.html "cpp/container/flat set/operator cmp")  
---  
  
| [swap(std::flat_set)](flat_set/swap2.html "cpp/container/flat set/swap2")  
---  
[erase_if(std::flat_set)](flat_set/erase_if.html "cpp/container/flat set/erase if")  
  
[Helper classes](flat_set.html#Helper_classes "cpp/container/flat set")  
[uses_allocator<std::flat_set>](flat_set/uses_allocator.html "cpp/container/flat set/uses allocator")  
[Tags](flat_set.html#Tags "cpp/container/flat set")  
|  | [sorted_unique](sorted_unique.html "cpp/container/sorted unique")` `  
---  
  
| [sorted_unique_t](sorted_unique.html "cpp/container/sorted unique")  
---  
  
[Deduction guides](flat_set/deduction_guides.html "cpp/container/flat set/deduction guides")  
  


Defined in header `[<flat_set>](../header/flat_set.html "cpp/header/flat set")` |  |   
---|---|---  
template<  
class Key,  
class Compare = [std::less](../utility/functional/less.html)<Key>,  
class KeyContainer = [std::vector](vector.html)<Key>  
> class flat_set; |  |  (since C++23)  
| |   
  
The flat set is a [container adaptor](../container.html#Container_adaptors "cpp/container") that gives the functionality of an associative container that stores a sorted set of unique objects of type `Key`. Sorting is done using the key comparison function `Compare`. 

The class template `flat_set` acts as a wrapper to the underlying sorted container passed as object of type `KeyContainer`. 

Everywhere the standard library uses the [Compare](../named_req/Compare.html "cpp/named req/Compare") requirements, uniqueness is determined by using the equivalence relation. Informally, two objects a and b are considered equivalent if neither compares less than the other: !comp(a, b) && !comp(b, a). 

`std::flat_set` meets the requirements of [Container](../named_req/Container.html "cpp/named req/Container"), [ReversibleContainer](../named_req/ReversibleContainer.html "cpp/named req/ReversibleContainer"), [optional container requirements](../named_req/Container.html#Optional_container_requirements "cpp/named req/Container"), and all requirements of [AssociativeContainer](../named_req/AssociativeContainer.html "cpp/named req/AssociativeContainer") (including logarithmic search complexity), except that: 

  * requirements related to nodes are not applicable, 
  * iterator invalidation requirements differ, 
  * the complexity of insertion and erasure operations is linear. 



A flat set supports most [AssociativeContainer](../named_req/AssociativeContainer.html "cpp/named req/AssociativeContainer")'s operations that use unique keys. 

All member functions of `std::flat_set` are constexpr: it is possible to create and use `std::flat_set` objects in the evaluation of a constant expression.However, `std::flat_set` objects generally cannot be constexpr, because any dynamically allocated storage must be released in the same evaluation of constant expression. | (since C++26)  
---|---  
  
## Contents

  * [1 Iterator invalidation](flat_set.html#Iterator_invalidation)
  * [2 Template parameters](flat_set.html#Template_parameters)
  * [3 Member types](flat_set.html#Member_types)
  * [4 Member objects](flat_set.html#Member_objects)
  * [5 Member functions](flat_set.html#Member_functions)
    * [5.1 Iterators](flat_set.html#Iterators)
    * [5.2 Capacity](flat_set.html#Capacity)
    * [5.3 Modifiers](flat_set.html#Modifiers)
    * [5.4 Lookup](flat_set.html#Lookup)
    * [5.5 Observers](flat_set.html#Observers)
  * [6 Non-member functions](flat_set.html#Non-member_functions)
  * [7 Helper classes](flat_set.html#Helper_classes)
  * [8 Tags](flat_set.html#Tags)
  * [9 Deduction guides](flat_set.html#Deduction_guides)
  * [10 Notes](flat_set.html#Notes)
  * [11 Example](flat_set.html#Example)
  * [12 See also](flat_set.html#See_also)

  
---  
  
### Iterator invalidation

| This section is incomplete   
---|---  
  
### Template parameters

Key  |  \-  |  The type of the stored elements. The program is ill-formed if `Key` is not the same type as `KeyContainer::value_type`.   
---|---|---  
Compare  |  \-  |  A [Compare](../named_req/Compare.html "cpp/named req/Compare") type providing a strict weak ordering.   
KeyContainer  |  \-  |  The type of the underlying [SequenceContainer](../named_req/SequenceContainer.html "cpp/named req/SequenceContainer") to store the elements. The iterators of such container should satisfy [LegacyRandomAccessIterator](../named_req/RandomAccessIterator.html "cpp/named req/RandomAccessIterator") or model [`random_access_iterator`](../iterator/random_access_iterator.html "cpp/iterator/random access iterator"). The standard containers [std::vector](vector.html "cpp/container/vector") and [std::deque](deque.html "cpp/container/deque") satisfy these requirements.   
  
### Member types

Type  |  Definition   
---|---  
`container_type` |  `Key``Container`  
`key_type` |  `Key`  
`value_type` |  `Key`  
`key_compare` |  `Compare`  
`value_compare` |  `Compare`  
`reference` |  value_type&  
`const_reference` |  const value_type&  
`size_type` |  typename KeyContainer::size_type  
`difference_type` |  typename KeyContainer::difference_type  
`iterator` |  implementation-defined [LegacyRandomAccessIterator](../named_req/RandomAccessIterator.html "cpp/named req/RandomAccessIterator"), [ConstexprIterator](../named_req/ConstexprIterator.html "cpp/named req/ConstexprIterator")(since C++26) and [`random_access_iterator`](../iterator/random_access_iterator.html "cpp/iterator/random access iterator") to `value_type`  
`const_iterator` |  implementation-defined [LegacyRandomAccessIterator](../named_req/RandomAccessIterator.html "cpp/named req/RandomAccessIterator"), [ConstexprIterator](../named_req/ConstexprIterator.html "cpp/named req/ConstexprIterator")(since C++26) and [`random_access_iterator`](../iterator/random_access_iterator.html "cpp/iterator/random access iterator") to const value_type  
`reverse_iterator` |  [std::reverse_iterator](../iterator/reverse_iterator.html)<iterator>  
`const_reverse_iterator` |  [std::reverse_iterator](../iterator/reverse_iterator.html)<const_iterator>  
  
### Member objects

Member  |  Description   
---|---  
`container_type` `_c_` (private) |  the adapted container  
(exposition-only member object*)  
`key_compare` `_compare_` (private) |  the comparison function object  
(exposition-only member object*)  
  
### Member functions

[ (constructor)](flat_set/flat_set.html "cpp/container/flat set/flat set") |  constructs the `flat_set`   
(public member function)   
---|---  
(destructor)(implicitly declared) |  destroys every element of the container adaptor   
(public member function)  
[ operator=](flat_set/operator=.html "cpp/container/flat set/operator=") |  assigns values to the container adaptor   
(public member function)   
  
#####  Iterators   
  
[ begincbegin](flat_set/begin.html "cpp/container/flat set/begin") |  returns an iterator to the beginning   
(public member function)   
[ endcend](flat_set/end.html "cpp/container/flat set/end") |  returns an iterator to the end   
(public member function)   
[ rbegincrbegin](flat_set/rbegin.html "cpp/container/flat set/rbegin") |  returns a reverse iterator to the beginning   
(public member function)   
[ rendcrend](flat_set/rend.html "cpp/container/flat set/rend") |  returns a reverse iterator to the end   
(public member function)   
  
#####  Capacity   
  
[ empty](flat_set/empty.html "cpp/container/flat set/empty") |  checks whether the container adaptor is empty   
(public member function)   
[ size](flat_set/size.html "cpp/container/flat set/size") |  returns the number of elements   
(public member function)   
[ max_size](flat_set/max_size.html "cpp/container/flat set/max size") |  returns the maximum possible number of elements   
(public member function)   
  
#####  Modifiers   
  
[ emplace](flat_set/emplace.html "cpp/container/flat set/emplace") |  constructs element in-place   
(public member function)   
[ emplace_hint](flat_set/emplace_hint.html "cpp/container/flat set/emplace hint") |  constructs elements in-place using a hint   
(public member function)   
[ insert](flat_set/insert.html "cpp/container/flat set/insert") |  inserts elements   
(public member function)   
[ insert_range](flat_set/insert_range.html "cpp/container/flat set/insert range") |  inserts a range of elements   
(public member function)   
[ extract](flat_set/extract.html "cpp/container/flat set/extract") |  extracts the underlying container   
(public member function)   
[ replace](flat_set/replace.html "cpp/container/flat set/replace") |  replaces the underlying container   
(public member function)   
[ erase](flat_set/erase.html "cpp/container/flat set/erase") |  erases elements   
(public member function)   
[ swap](flat_set/swap.html "cpp/container/flat set/swap") |  swaps the contents   
(public member function)   
[ clear](flat_set/clear.html "cpp/container/flat set/clear") |  clears the contents   
(public member function)   
  
#####  Lookup   
  
[ find](flat_set/find.html "cpp/container/flat set/find") |  finds element with specific key   
(public member function)   
[ count](flat_set/count.html "cpp/container/flat set/count") |  returns the number of elements matching specific key   
(public member function)   
[ contains](flat_set/contains.html "cpp/container/flat set/contains") |  checks if the container contains element with specific key   
(public member function)   
[ lower_bound](flat_set/lower_bound.html "cpp/container/flat set/lower bound") |  returns an iterator to the first element _not less_ than the given key   
(public member function)   
[ upper_bound](flat_set/upper_bound.html "cpp/container/flat set/upper bound") |  returns an iterator to the first element _greater_ than the given key   
(public member function)   
[ equal_range](flat_set/equal_range.html "cpp/container/flat set/equal range") |  returns range of elements matching a specific key   
(public member function)   
  
#####  Observers   
  
[ key_comp](flat_set/key_comp.html "cpp/container/flat set/key comp") |  returns the function that compares keys   
(public member function)   
[ value_comp](flat_set/value_comp.html "cpp/container/flat set/value comp") |  returns the function that compares keys in objects of type `value_type`   
(public member function)   
  
### Non-member functions

[ operator==operator<=>](flat_set/operator_cmp.html "cpp/container/flat set/operator cmp")(C++23) |  lexicographically compares the values of two `flat_set`s   
(function template)   
---|---  
[ std::swap(std::flat_set)](flat_set/swap2.html "cpp/container/flat set/swap2")(C++23) |  specializes the [std::swap](../utility/swap.html "cpp/algorithm/swap") algorithm   
(function template)   
[ erase_if(std::flat_set)](flat_set/erase_if.html "cpp/container/flat set/erase if")(C++23) |  erases all elements satisfying specific criteria   
(function template)   
  
### Helper classes

[ std::uses_allocator<std::flat_set>](flat_set/uses_allocator.html "cpp/container/flat set/uses allocator")(C++23) |  specializes the [std::uses_allocator](../memory/uses_allocator.html "cpp/memory/uses allocator") type trait   
(class template specialization)   
---|---  
  
### Tags

[ sorted_uniquesorted_unique_t](sorted_unique.html "cpp/container/sorted unique")(C++23) |  indicates that elements of a range are sorted and unique  
(tag)  
---|---  
  
### [Deduction guides](flat_set/deduction_guides.html "cpp/container/flat set/deduction guides")

### Notes

The member types `iterator` and `const_iterator` may be aliases to the same type. This means defining a pair of function overloads using the two types as parameter types may violate the [One Definition Rule](../language/definition.html#One_Definition_Rule "cpp/language/definition"). Since `iterator` is convertible to `const_iterator`, a single function with a `const_iterator` as parameter type will work instead. 

Some advantages of flat set over other standard [container adaptors](../container.html#Container_adaptors "cpp/container") are: 

  * Potentially faster lookup (even though search operations have logarithmic complexity). 
  * Much faster iteration: [random access iterators](../iterator/random_access_iterator.html "cpp/iterator/random access iterator") instead of [bidirectional iterators](../iterator/bidirectional_iterator.html "cpp/iterator/bidirectional iterator"). 
  * Less memory consumption for small objects (and for big objects if KeyContainer::shrink_to_fit() is available). 
  * Better cache performance (depending on `KeyContainer`, keys are stored in a contiguous block(s) of memory). 



Some disadvantages of flat set are: 

  * Non-stable iterators (iterators are invalidated when inserting and erasing elements). 
  * Non-copyable and non-movable type values can not be stored. 
  * Weaker exception safety (copy/move constructors can throw when shifting values in erasures and insertions). 
  * Slower (i.e., linear) insertion and erasure, especially for non-movable types. 

[Feature-test](../utility/feature_test.html "cpp/utility/feature test") macro  | Value | Std | Feature   
---|---|---|---  
[`__cpp_lib_flat_set`](../experimental/feature_test.html#cpp_lib_flat_set "cpp/feature test") | [`202207L`](../compiler_support/23.html#cpp_lib_flat_set_202207L "cpp/compiler support/23") | (C++23) | `std::flat_set` and std::flat_multiset  
[`__cpp_lib_constexpr_flat_set`](../experimental/feature_test.html#cpp_lib_constexpr_flat_set "cpp/feature test") | [`202502L`](../compiler_support/26.html#cpp_lib_constexpr_flat_set_202502L "cpp/compiler support/26") | (C++26) | constexpr `std::flat_set`  
  
### Example

| This section is incomplete  
Reason: no example   
---|---  
  
### See also

[ flat_multiset](flat_multiset.html "cpp/container/flat multiset")(C++23) |  adapts a container to provide a collection of keys, sorted by keys   
(class template)   
---|---  
[ set](set.html "cpp/container/set") |  collection of unique keys, sorted by keys   
(class template)   
[ unordered_set](unordered_set.html "cpp/container/unordered set")(C++11) |  collection of unique keys, hashed by keys   
(class template) 
  *[Value]: The year/month in which the feature was adopted. The hyperlink under each value opens a compiler support page with entry for given feature.
  *[Std]: Standard in which the feature is introduced; DR means defect report against that revision
