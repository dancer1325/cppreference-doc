[C++](../../cpp.html "cpp")

[Compiler support](../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../freestanding.html "cpp/freestanding")  
[Language](../language.html "cpp/language")  
[Standard library](../standard_library.html "cpp/standard library")  
[Standard library headers](../headers.html "cpp/header")  
[Named requirements](../iterator/concepts.html "cpp/named req")  
[Feature test macros](../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../utility.html#Language_support "cpp/utility")  
[Concepts library](../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../error.html "cpp/error")  
[Memory management library](../memory.html "cpp/memory")  
[Metaprogramming library](../meta.html "cpp/meta") (C++11)  
[General utilities library](../utility.html "cpp/utility")  
[Containers library](../container.html "cpp/container")  
[Iterators library](../iterator.html "cpp/iterator")  
[Ranges library](../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../algorithm.html "cpp/algorithm")  
[Strings library](../string.html "cpp/string")  
[Text processing library](../text.html "cpp/text")  
[Numerics library](../numeric.html "cpp/numeric")  
[Date and time library](../chrono.html "cpp/chrono")  
[Input/output library](../io.html "cpp/io")  
[Filesystem library](../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../atomic.html "cpp/thread") (C++11)  
[Execution control library](../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../experimental.html "cpp/experimental")  
[Symbols index](../symbol_index.html "cpp/symbol index")  
[External libraries](../links/libs.html "cpp/links/libs")  
  


[Containers library](../container.html "cpp/container")

[_node-handle_](node_handle.html "cpp/container/node handle")(C++17)  
---  
[Sequence](../container.html#Sequence_containers "cpp/container")  
[array](array.html "cpp/container/array")(C++11)  
[vector](vector.html "cpp/container/vector")  
[vector<bool>](vector_bool.html "cpp/container/vector bool")  
[inplace_vector](inplace_vector.html "cpp/container/inplace vector")(C++26)  
[hive](https://en.cppreference.com/mwiki/index.php?title=cpp/container/hive&action=edit&redlink=1 "cpp/container/hive \(page does not exist\)")(C++26)  
[deque](deque.html "cpp/container/deque")  
[forward_list](forward_list.html "cpp/container/forward list")(C++11)  
[list](list.html "cpp/container/list")  
[Associative](../container.html#Associative_containers "cpp/container")  
[set](set.html "cpp/container/set")  
[multiset](multiset.html "cpp/container/multiset")  
[map](map.html "cpp/container/map")  
[multimap](multimap.html "cpp/container/multimap")  
[Unordered associative](../container.html#Unordered_associative_containers "cpp/container")  
[unordered_set](unordered_set.html "cpp/container/unordered set")(C++11)  
[unordered_multiset](unordered_multiset.html "cpp/container/unordered multiset")(C++11)  
[unordered_map](unordered_map.html "cpp/container/unordered map")(C++11)  
[unordered_multimap](unordered_multimap.html "cpp/container/unordered multimap")(C++11)  
[Adaptors](../container.html#Container_adaptors "cpp/container")  
[stack](stack.html "cpp/container/stack")  
[queue](queue.html "cpp/container/queue")  
[priority_queue](priority_queue.html "cpp/container/priority queue")  
[flat_set](flat_set.html "cpp/container/flat set")(C++23)  
[flat_multiset](flat_multiset.html "cpp/container/flat multiset")(C++23)  
**flat_map**(C++23)  
[flat_multimap](flat_multimap.html "cpp/container/flat multimap")(C++23)  
[Views](../container.html#Views "cpp/container")  
[span](span.html "cpp/container/span")(C++20)  
[mdspan](mdspan.html "cpp/container/mdspan")(C++23)  
Tables  
[Iterator invalidation](../container.html#Iterator_invalidation "cpp/container")  
[Member function table](../container.html#Member_function_table "cpp/container")  
[Non-member function table](../container.html#Non-member_function_table "cpp/container")  
  


**`std::flat_map`**

[Member types](flat_map.html#Member_types "cpp/container/flat map")  
---  
[Member functions](flat_map.html#Member_functions "cpp/container/flat map")  
|  | [flat_map::flat_map](flat_map/flat_map.html "cpp/container/flat map/flat map")  
---  
[flat_map::operator=](flat_map/operator=.html "cpp/container/flat map/operator=")  
[Element access](flat_map.html#Element_access "cpp/container/flat map")  
[flat_map::at](flat_map/at.html "cpp/container/flat map/at")  
[flat_map::operator[]](flat_map/operator_at.html "cpp/container/flat map/operator at")  
[Iterators](flat_map.html#Iterators "cpp/container/flat map")  
[flat_map::beginflat_map::cbegin](flat_map/begin.html "cpp/container/flat map/begin")  
[flat_map::endflat_map::cend](flat_map/end.html "cpp/container/flat map/end")  
[flat_map::rbeginflat_map::crbegin](flat_map/rbegin.html "cpp/container/flat map/rbegin")  
[flat_map::rendflat_map::crend](flat_map/rend.html "cpp/container/flat map/rend")  
[Lookup](flat_map.html#Lookup "cpp/container/flat map")  
[flat_map::count](flat_map/count.html "cpp/container/flat map/count")  
[flat_map::find](flat_map/find.html "cpp/container/flat map/find")  
[flat_map::contains](flat_map/contains.html "cpp/container/flat map/contains")  
[flat_map::equal_range](flat_map/equal_range.html "cpp/container/flat map/equal range")` `  
[flat_map::lower_bound](flat_map/lower_bound.html "cpp/container/flat map/lower bound")  
[flat_map::upper_bound](flat_map/upper_bound.html "cpp/container/flat map/upper bound")  
  
| [Capacity](flat_map.html#Capacity "cpp/container/flat map")  
---  
[flat_map::size](flat_map/size.html "cpp/container/flat map/size")  
[flat_map::max_size](flat_map/max_size.html "cpp/container/flat map/max size")  
[flat_map::empty](flat_map/empty.html "cpp/container/flat map/empty")  
[Modifiers](flat_map.html#Modifiers "cpp/container/flat map")  
[flat_map::clear](flat_map/clear.html "cpp/container/flat map/clear")  
[flat_map::erase](flat_map/erase.html "cpp/container/flat map/erase")  
[flat_map::swap](flat_map/swap.html "cpp/container/flat map/swap")  
[flat_map::emplace](flat_map/emplace.html "cpp/container/flat map/emplace")  
[flat_map::extract](flat_map/extract.html "cpp/container/flat map/extract")  
[flat_map::replace](flat_map/replace.html "cpp/container/flat map/replace")  
[flat_map::insert](flat_map/insert.html "cpp/container/flat map/insert")  
[flat_map::insert_range](flat_map/insert_range.html "cpp/container/flat map/insert range")  
[flat_map::insert_or_assign](flat_map/insert_or_assign.html "cpp/container/flat map/insert or assign")  
[flat_map::emplace_hint](flat_map/emplace_hint.html "cpp/container/flat map/emplace hint")  
[flat_map::try_emplace](flat_map/try_emplace.html "cpp/container/flat map/try emplace")  
[Observers](flat_map.html#Observers "cpp/container/flat map")  
[flat_map::key_comp](flat_map/key_comp.html "cpp/container/flat map/key comp")  
[flat_map::keys](flat_map/keys.html "cpp/container/flat map/keys")  
[flat_map::value_comp](flat_map/value_comp.html "cpp/container/flat map/value comp")  
[flat_map::values](flat_map/values.html "cpp/container/flat map/values")  
  
[Non-member functions](flat_map.html#Non-member_functions "cpp/container/flat map")  
|  | [operator==operator<=>](flat_map/operator_cmp.html "cpp/container/flat map/operator cmp")` `  
---  
  
| [swap(std::flat_map)](flat_map/swap2.html "cpp/container/flat map/swap2")  
---  
[erase_if(std::flat_map)](flat_map/erase_if.html "cpp/container/flat map/erase if")  
  
[Helper classes](flat_map.html#Helper_classes "cpp/container/flat map")  
|  | [uses_allocator<std::flat_map>](flat_map/uses_allocator.html "cpp/container/flat map/uses allocator")  
---  
  
[Tags](flat_map.html#Tags "cpp/container/flat map")  
|  | [sorted_unique](sorted_unique.html "cpp/container/sorted unique")` `  
---  
  
| [sorted_unique_t](sorted_unique.html "cpp/container/sorted unique")  
---  
  
[Deduction guides](flat_map/deduction_guides.html "cpp/container/flat map/deduction guides")  
  


Defined in header `[<flat_map>](../header/flat_map.html "cpp/header/flat map")` |  |   
---|---|---  
template<  
class Key,  
class T,  
class Compare = [std::less](../utility/functional/less.html)<Key>,  
class KeyContainer = [std::vector](vector.html)<Key>,  
class MappedContainer = [std::vector](vector.html)<T>  
> class flat_map; |  |  (since C++23)  
| |   
  
The flat map is a [container adaptor](../container.html#Container_adaptors "cpp/container") that gives the functionality of an associative container that contains key-value pairs with unique keys. Keys are sorted by using the comparison function `Compare`. 

The class template `flat_map` acts as a wrapper to the two underlying containers, passed as objects of type `KeyContainer` and `MappedContainer` respectively. The first container is sorted, and for each key its corresponding value is in the second container at the same index (offset). The number of elements in both containers is the same. 

Everywhere the standard library uses the [Compare](../named_req/Compare.html "cpp/named req/Compare") requirements, uniqueness is determined by using the equivalence relation. Informally, two objects a and b are considered equivalent if neither compares less than the other: !comp(a, b) && !comp(b, a). 

`std::flat_map` meets the requirements of [Container](../named_req/Container.html "cpp/named req/Container"), [ReversibleContainer](../named_req/ReversibleContainer.html "cpp/named req/ReversibleContainer"), [optional container requirements](../named_req/Container.html#Optional_container_requirements "cpp/named req/Container"), and all requirements of [AssociativeContainer](../named_req/AssociativeContainer.html "cpp/named req/AssociativeContainer") (including logarithmic search complexity), except that: 

  * requirements related to nodes are not applicable, 
  * iterator invalidation requirements differ, 
  * the complexity of insertion and erasure operations is linear. 



A flat map supports most [AssociativeContainer](../named_req/AssociativeContainer.html "cpp/named req/AssociativeContainer")'s operations that use unique keys. 

All member functions of `std::flat_map` are constexpr: it is possible to create and use `std::flat_map` objects in the evaluation of a constant expression.However, `std::flat_map` objects generally cannot be constexpr, because any dynamically allocated storage must be released in the same evaluation of constant expression. | (since C++26)  
---|---  
  
## Contents

  * [1 Iterator invalidation](flat_map.html#Iterator_invalidation)
  * [2 Template parameters](flat_map.html#Template_parameters)
  * [3 Member types](flat_map.html#Member_types)
  * [4 Member classes](flat_map.html#Member_classes)
  * [5 Member objects](flat_map.html#Member_objects)
  * [6 Member functions](flat_map.html#Member_functions)
    * [6.1 Element access](flat_map.html#Element_access)
    * [6.2 Iterators](flat_map.html#Iterators)
    * [6.3 Capacity](flat_map.html#Capacity)
    * [6.4 Modifiers](flat_map.html#Modifiers)
    * [6.5 Lookup](flat_map.html#Lookup)
    * [6.6 Observers](flat_map.html#Observers)
  * [7 Non-member functions](flat_map.html#Non-member_functions)
  * [8 Helper classes](flat_map.html#Helper_classes)
  * [9 Tags](flat_map.html#Tags)
  * [10 Deduction guides](flat_map.html#Deduction_guides)
  * [11 Notes](flat_map.html#Notes)
  * [12 Example](flat_map.html#Example)
  * [13 See also](flat_map.html#See_also)

  
---  
  
### Iterator invalidation

| This section is incomplete   
---|---  
  
### Template parameters

Key  |  \-  |  The type of the keys. The program is ill-formed if `Key` is not the same type as `KeyContainer::value_type`.   
---|---|---  
T  |  \-  |  The type of mapped values. The program is ill-formed if `T` is not the same type as `MappedContainer::value_type`.   
Compare  |  \-  |  A [Compare](../named_req/Compare.html "cpp/named req/Compare") type providing a strict weak ordering.   
KeyContainer  
MappedContainer  |  \-  |  The types of the underlying [SequenceContainer](../named_req/SequenceContainer.html "cpp/named req/SequenceContainer") to store keys and mapped values correspondingly. The iterators of such containers should satisfy [LegacyRandomAccessIterator](../named_req/RandomAccessIterator.html "cpp/named req/RandomAccessIterator") or model [`random_access_iterator`](../iterator/random_access_iterator.html "cpp/iterator/random access iterator"). Invocations of their member functions `size` and `max_size` should not exit via an exception. The standard containers [std::vector](vector.html "cpp/container/vector") and [std::deque](deque.html "cpp/container/deque") satisfy these requirements.   
  
### Member types

Type  |  Definition   
---|---  
`key_container_type` |  `KeyContainer`  
`mapped_container_type` |  `MappedContainer`  
`key_type` |  `Key`  
`mapped_type` |  `T`  
`value_type` |  [std::pair](../utility/pair.html)<key_type, mapped_type>  
`key_compare` |  `Compare`  
`reference` |  [std::pair](../utility/pair.html)<const key_type&, mapped_type&>  
`const_reference` |  [std::pair](../utility/pair.html)<const key_type&, const mapped_type&>  
`size_type` |  [std::size_t](../types/size_t.html "cpp/types/size t")  
`difference_type` |  [std::ptrdiff_t](../types/ptrdiff_t.html "cpp/types/ptrdiff t")  
`iterator` |  implementation-defined [LegacyInputIterator](../named_req/InputIterator.html "cpp/named req/InputIterator"), [ConstexprIterator](../named_req/ConstexprIterator.html "cpp/named req/ConstexprIterator")(since C++26) and [`random_access_iterator`](../iterator/random_access_iterator.html "cpp/iterator/random access iterator") to `value_type`  
`const_iterator` |  implementation-defined [LegacyInputIterator](../named_req/InputIterator.html "cpp/named req/InputIterator"), [ConstexprIterator](../named_req/ConstexprIterator.html "cpp/named req/ConstexprIterator")(since C++26) and [`random_access_iterator`](../iterator/random_access_iterator.html "cpp/iterator/random access iterator") to const value_type  
`reverse_iterator` |  [std::reverse_iterator](../iterator/reverse_iterator.html)<iterator>  
`const_reverse_iterator` |  [std::reverse_iterator](../iterator/reverse_iterator.html)<const_iterator>  
`containers` |  type describing the underlying containers  
struct containers  
{  
key_container_type keys;  
mapped_container_type values;  
};  
  
### Member classes

[ value_compare](flat_map/value_compare.html "cpp/container/flat map/value compare") |  compares objects of type `value_type`   
(class)   
---|---  
  
### Member objects

Member  |  Description   
---|---  
`containers` `_c_` (private) |  the adapted containers  
(exposition-only member object*)  
`key_compare` `_compare_` (private) |  the comparison function object  
(exposition-only member object*)  
  
### Member functions

[ (constructor)](flat_map/flat_map.html "cpp/container/flat map/flat map") |  constructs the `flat_map`   
(public member function)   
---|---  
(destructor)(implicitly declared) |  destroys every element of the container adaptor   
(public member function)  
[ operator=](flat_map/operator=.html "cpp/container/flat map/operator=") |  assigns values to the container adaptor   
(public member function)   
  
#####  Element access   
  
[ at](flat_map/at.html "cpp/container/flat map/at") |  access specified element with bounds checking   
(public member function)   
[ operator[]](flat_map/operator_at.html "cpp/container/flat map/operator at") |  access or insert specified element   
(public member function)   
  
#####  Iterators   
  
[ begincbegin](flat_map/begin.html "cpp/container/flat map/begin") |  returns an iterator to the beginning   
(public member function)   
[ endcend](flat_map/end.html "cpp/container/flat map/end") |  returns an iterator to the end   
(public member function)   
[ rbegincrbegin](flat_map/rbegin.html "cpp/container/flat map/rbegin") |  returns a reverse iterator to the beginning   
(public member function)   
[ rendcrend](flat_map/rend.html "cpp/container/flat map/rend") |  returns a reverse iterator to the end   
(public member function)   
  
#####  Capacity   
  
[ empty](flat_map/empty.html "cpp/container/flat map/empty") |  checks whether the container adaptor is empty   
(public member function)   
[ size](flat_map/size.html "cpp/container/flat map/size") |  returns the number of elements   
(public member function)   
[ max_size](flat_map/max_size.html "cpp/container/flat map/max size") |  returns the maximum possible number of elements   
(public member function)   
  
#####  Modifiers   
  
[ emplace](flat_map/emplace.html "cpp/container/flat map/emplace") |  constructs element in-place   
(public member function)   
[ emplace_hint](flat_map/emplace_hint.html "cpp/container/flat map/emplace hint") |  constructs elements in-place using a hint   
(public member function)   
[ try_emplace](flat_map/try_emplace.html "cpp/container/flat map/try emplace") |  inserts in-place if the key does not exist, does nothing if the key exists   
(public member function)   
[ insert](flat_map/insert.html "cpp/container/flat map/insert") |  inserts elements   
(public member function)   
[ insert_range](flat_map/insert_range.html "cpp/container/flat map/insert range") |  inserts a range of elements   
(public member function)   
[ insert_or_assign](flat_map/insert_or_assign.html "cpp/container/flat map/insert or assign") |  inserts an element or assigns to the current element if the key already exists   
(public member function)   
[ extract](flat_map/extract.html "cpp/container/flat map/extract") |  extracts the underlying containers   
(public member function)   
[ replace](flat_map/replace.html "cpp/container/flat map/replace") |  replaces the underlying containers   
(public member function)   
[ erase](flat_map/erase.html "cpp/container/flat map/erase") |  erases elements   
(public member function)   
[ swap](flat_map/swap.html "cpp/container/flat map/swap") |  swaps the contents   
(public member function)   
[ clear](flat_map/clear.html "cpp/container/flat map/clear") |  clears the contents   
(public member function)   
  
#####  Lookup   
  
[ find](flat_map/find.html "cpp/container/flat map/find") |  finds element with specific key   
(public member function)   
[ count](flat_map/count.html "cpp/container/flat map/count") |  returns the number of elements matching specific key   
(public member function)   
[ contains](flat_map/contains.html "cpp/container/flat map/contains") |  checks if the container contains element with specific key   
(public member function)   
[ lower_bound](flat_map/lower_bound.html "cpp/container/flat map/lower bound") |  returns an iterator to the first element _not less_ than the given key   
(public member function)   
[ upper_bound](flat_map/upper_bound.html "cpp/container/flat map/upper bound") |  returns an iterator to the first element _greater_ than the given key   
(public member function)   
[ equal_range](flat_map/equal_range.html "cpp/container/flat map/equal range") |  returns range of elements matching a specific key   
(public member function)   
  
#####  Observers   
  
[ key_comp](flat_map/key_comp.html "cpp/container/flat map/key comp") |  returns the function that compares keys   
(public member function)   
[ value_comp](flat_map/value_comp.html "cpp/container/flat map/value comp") |  returns the function that compares keys in objects of type `value_type`   
(public member function)   
[ keys](flat_map/keys.html "cpp/container/flat map/keys") |  direct access to the underlying keys container   
(public member function)   
[ values](flat_map/values.html "cpp/container/flat map/values") |  direct access to the underlying values container   
(public member function)   
  
### Non-member functions

[ operator==operator<=>](flat_map/operator_cmp.html "cpp/container/flat map/operator cmp")(C++23) |  lexicographically compares the values of two `flat_map`s   
(function template)   
---|---  
[ std::swap(std::flat_map)](flat_map/swap2.html "cpp/container/flat map/swap2")(C++23) |  specializes the [std::swap](../utility/swap.html "cpp/algorithm/swap") algorithm   
(function template)   
[ erase_if(std::flat_map)](flat_map/erase_if.html "cpp/container/flat map/erase if")(C++23) |  erases all elements satisfying specific criteria   
(function template)   
  
### Helper classes

[ std::uses_allocator<std::flat_map>](flat_map/uses_allocator.html "cpp/container/flat map/uses allocator")(C++23) |  specializes the [std::uses_allocator](../memory/uses_allocator.html "cpp/memory/uses allocator") type trait   
(class template specialization)   
---|---  
  
### Tags

[ sorted_uniquesorted_unique_t](sorted_unique.html "cpp/container/sorted unique")(C++23) |  indicates that elements of a range are sorted and unique  
(tag)  
---|---  
  
### [Deduction guides](flat_map/deduction_guides.html "cpp/container/flat map/deduction guides")

### Notes

The member types `iterator` and `const_iterator` may be aliases to the same type. This means defining a pair of function overloads using the two types as parameter types may violate the [One Definition Rule](../language/definition.html#One_Definition_Rule "cpp/language/definition"). Since `iterator` is convertible to `const_iterator`, a single function with a `const_iterator` as parameter type will work instead. 

[Feature-test](../utility/feature_test.html "cpp/utility/feature test") macro  | Value | Std | Feature   
---|---|---|---  
[`__cpp_lib_flat_map`](../experimental/feature_test.html#cpp_lib_flat_map "cpp/feature test") | [`202207L`](../compiler_support/23.html#cpp_lib_flat_map_202207L "cpp/compiler support/23") | (C++23) | `std::flat_map` and std::flat_multimap  
[`__cpp_lib_constexpr_flat_map`](../experimental/feature_test.html#cpp_lib_constexpr_flat_map "cpp/feature test") | [`202502L`](../compiler_support/26.html#cpp_lib_constexpr_flat_map_202502L "cpp/compiler support/26") | (C++26) | constexpr `std::flat_map`  
  
### Example

| This section is incomplete  
Reason: no example   
---|---  
  
### See also

[ flat_multimap](flat_multimap.html "cpp/container/flat multimap")(C++23) |  adapts two containers to provide a collection of key-value pairs, sorted by keys   
(class template)   
---|---  
[ map](map.html "cpp/container/map") |  collection of key-value pairs, sorted by keys, keys are unique   
(class template)   
[ unordered_map](unordered_map.html "cpp/container/unordered map")(C++11) |  collection of key-value pairs, hashed by keys, keys are unique   
(class template) 
  *[Value]: The year/month in which the feature was adopted. The hyperlink under each value opens a compiler support page with entry for given feature.
  *[Std]: Standard in which the feature is introduced; DR means defect report against that revision
