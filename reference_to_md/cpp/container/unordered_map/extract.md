[[edit template]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/container/extract_assoc&action=edit)

[C++](../../../cpp.html "cpp")

[Compiler support](../../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../../freestanding.html "cpp/freestanding")  
[Language](../../language.html "cpp/language")  
[Standard library](../../standard_library.html "cpp/standard library")  
[Standard library headers](../../headers.html "cpp/header")  
[Named requirements](../../iterator/concepts.html "cpp/named req")  
[Feature test macros](../../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../../utility.html#Language_support "cpp/utility")  
[Concepts library](../../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../../error.html "cpp/error")  
[Memory management library](../../memory.html "cpp/memory")  
[Metaprogramming library](../../meta.html "cpp/meta") (C++11)  
[General utilities library](../../utility.html "cpp/utility")  
[Containers library](../../container.html "cpp/container")  
[Iterators library](../../iterator.html "cpp/iterator")  
[Ranges library](../../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../../algorithm.html "cpp/algorithm")  
[Strings library](../../string.html "cpp/string")  
[Text processing library](../../text.html "cpp/text")  
[Numerics library](../../numeric.html "cpp/numeric")  
[Date and time library](../../chrono.html "cpp/chrono")  
[Input/output library](../../io.html "cpp/io")  
[Filesystem library](../../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../../atomic.html "cpp/thread") (C++11)  
[Execution control library](../../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../../experimental.html "cpp/experimental")  
[Symbols index](../../symbol_index.html "cpp/symbol index")  
[External libraries](../../links/libs.html "cpp/links/libs")  
  


[Containers library](../../container.html "cpp/container")

[_node-handle_](../node_handle.html "cpp/container/node handle")(C++17)  
---  
[Sequence](../../container.html#Sequence_containers "cpp/container")  
[array](../array.html "cpp/container/array")(C++11)  
[vector](../vector.html "cpp/container/vector")  
[vector<bool>](../vector_bool.html "cpp/container/vector bool")  
[inplace_vector](../inplace_vector.html "cpp/container/inplace vector")(C++26)  
[hive](https://en.cppreference.com/mwiki/index.php?title=cpp/container/hive&action=edit&redlink=1 "cpp/container/hive \(page does not exist\)")(C++26)  
[deque](../deque.html "cpp/container/deque")  
[forward_list](../forward_list.html "cpp/container/forward list")(C++11)  
[list](../list.html "cpp/container/list")  
[Associative](../../container.html#Associative_containers "cpp/container")  
[set](../set.html "cpp/container/set")  
[multiset](../multiset.html "cpp/container/multiset")  
[map](../map.html "cpp/container/map")  
[multimap](../multimap.html "cpp/container/multimap")  
[Unordered associative](../../container.html#Unordered_associative_containers "cpp/container")  
[unordered_set](../unordered_set.html "cpp/container/unordered set")(C++11)  
[unordered_multiset](../unordered_multiset.html "cpp/container/unordered multiset")(C++11)  
[unordered_map](../unordered_map.html "cpp/container/unordered map")(C++11)  
[unordered_multimap](../unordered_multimap.html "cpp/container/unordered multimap")(C++11)  
[Adaptors](../../container.html#Container_adaptors "cpp/container")  
[stack](../stack.html "cpp/container/stack")  
[queue](../queue.html "cpp/container/queue")  
[priority_queue](../priority_queue.html "cpp/container/priority queue")  
[flat_set](../flat_set.html "cpp/container/flat set")(C++23)  
[flat_multiset](../flat_multiset.html "cpp/container/flat multiset")(C++23)  
[flat_map](../flat_map.html "cpp/container/flat map")(C++23)  
[flat_multimap](../flat_multimap.html "cpp/container/flat multimap")(C++23)  
[Views](../../container.html#Views "cpp/container")  
[span](../span.html "cpp/container/span")(C++20)  
[mdspan](../mdspan.html "cpp/container/mdspan")(C++23)  
Tables  
[Iterator invalidation](../../container.html#Iterator_invalidation "cpp/container")  
[Member function table](../../container.html#Member_function_table "cpp/container")  
[Non-member function table](../../container.html#Non-member_function_table "cpp/container")  
  


[`std::unordered_map`](../unordered_map.html "cpp/container/unordered map")

[Member types](../unordered_map.html#Member_types "cpp/container/unordered map")  
---  
[Member functions](../unordered_map.html#Member_functions "cpp/container/unordered map")  
| [unordered_map::unordered_map](unordered_map.html "cpp/container/unordered map/unordered map")  
---  
[unordered_map::~unordered_map](~unordered_map.html "cpp/container/unordered map/~unordered map")  
[unordered_map::operator=](operator=.html "cpp/container/unordered map/operator=")  
[unordered_map::get_allocator](get_allocator.html "cpp/container/unordered map/get allocator")  
[Iterators](../unordered_map.html#Iterators "cpp/container/unordered map")  
[unordered_map::beginunordered_map::cbegin](begin.html "cpp/container/unordered map/begin")  
[unordered_map::endunordered_map::cend](end.html "cpp/container/unordered map/end")  
[Capacity](../unordered_map.html#Capacity "cpp/container/unordered map")  
[unordered_map::size](size.html "cpp/container/unordered map/size")  
[unordered_map::max_size](max_size.html "cpp/container/unordered map/max size")  
[unordered_map::empty](empty.html "cpp/container/unordered map/empty")  
[Modifiers](../unordered_map.html#Modifiers "cpp/container/unordered map")  
[unordered_map::clear](clear.html "cpp/container/unordered map/clear")  
[unordered_map::erase](erase.html "cpp/container/unordered map/erase")  
[unordered_map::swap](swap.html "cpp/container/unordered map/swap")  
**unordered_map::extract**(C++17)  
[unordered_map::merge](merge.html "cpp/container/unordered map/merge")(C++17)  
[unordered_map::insert](insert.html "cpp/container/unordered map/insert")  
[unordered_map::insert_range](insert_range.html "cpp/container/unordered map/insert range")(C++23)  
[unordered_map::insert_or_assign](insert_or_assign.html "cpp/container/unordered map/insert or assign")(C++17)` `  
[unordered_map::emplace](emplace.html "cpp/container/unordered map/emplace")  
[unordered_map::emplace_hint](emplace_hint.html "cpp/container/unordered map/emplace hint")  
[unordered_map::try_emplace](try_emplace.html "cpp/container/unordered map/try emplace")(C++17)  
  
| [Lookup](../unordered_map.html#Lookup "cpp/container/unordered map")  
---  
[unordered_map::at](at.html "cpp/container/unordered map/at")  
[unordered_map::operator[]](operator_at.html "cpp/container/unordered map/operator at")  
[unordered_map::count](count.html "cpp/container/unordered map/count")  
[unordered_map::find](find.html "cpp/container/unordered map/find")  
[unordered_map::contains](contains.html "cpp/container/unordered map/contains")(C++20)  
[unordered_map::equal_range](equal_range.html "cpp/container/unordered map/equal range")  
[Bucket interface](../unordered_map.html#Bucket_interface "cpp/container/unordered map")  
[unordered_map::begin(size_type)unordered_map::cbegin(size_type)](begin2.html "cpp/container/unordered map/begin2")  
[unordered_map::end(size_type)unordered_map::cend(size_type)](end2.html "cpp/container/unordered map/end2")  
[unordered_map::bucket_count](bucket_count.html "cpp/container/unordered map/bucket count")  
[unordered_map::max_bucket_count](max_bucket_count.html "cpp/container/unordered map/max bucket count")  
[unordered_map::bucket_size](bucket_size.html "cpp/container/unordered map/bucket size")  
[unordered_map::bucket](bucket.html "cpp/container/unordered map/bucket")  
[Hash policy](../unordered_map.html#Hash_policy "cpp/container/unordered map")  
[unordered_map::load_factor](load_factor.html "cpp/container/unordered map/load factor")  
[unordered_map::max_load_factor](max_load_factor.html "cpp/container/unordered map/max load factor")  
[unordered_map::rehash](rehash.html "cpp/container/unordered map/rehash")  
[unordered_map::reserve](reserve.html "cpp/container/unordered map/reserve")  
[Observers](../unordered_map.html#Observers "cpp/container/unordered map")  
[unordered_map::hash_function](hash_function.html "cpp/container/unordered map/hash function")  
[unordered_map::key_eq](key_eq.html "cpp/container/unordered map/key eq")  
  
[Non-member functions](../unordered_map.html#Non-member_functions "cpp/container/unordered map")  
| [operator==operator!=](operator_cmp.html "cpp/container/unordered map/operator cmp")(until C++20)  
---  
  
| [std::swap(std::unordered_map)](swap2.html "cpp/container/unordered map/swap2")  
---  
[erase_if(std::unordered_map)](erase_if.html "cpp/container/unordered map/erase if")(C++20)  
  
[Deduction guides](deduction_guides.html "cpp/container/unordered map/deduction guides")(C++17)  
  


node_type extract( const_iterator pos ); |  (1) | (since C++17)   
(constexpr since C++26)  
---|---|---  
node_type extract( const Key& k ); |  (2) | (since C++17)   
(constexpr since C++26)  
template< class K >  
node_type extract( K&& x ); |  (3) | (since C++23)   
(constexpr since C++26)  
| |   
  
1) Unlinks the node that contains the element pointed to by pos and returns a [node handle](../node_handle.html "cpp/container/node handle") that owns it.

2,3) If the container has an element with key equivalent to k or x(since C++23), unlinks the node that contains that element from the container and returns a [node handle](../node_handle.html "cpp/container/node handle") that owns it. Otherwise, returns an empty node handle.

3) This overload participates in overload resolution only if `Hash` and `KeyEqual` are both [transparent](../../functional.html#Transparent_function_objects "cpp/utility/functional"), and neither `iterator` nor `const_iterator` is implicitly convertible from `K`. This assumes that such `Hash` is callable with both `K` and `Key` type, and that the `KeyEqual` is transparent, which, together, allows calling this function without constructing an instance of `Key`.

In either case, no elements are copied or moved, only the internal pointers of the container nodes are repointed . 

Extracting a node invalidates only the iterators to the extracted element, and preserves the relative order of the elements that are not erased. Pointers and references to the extracted element remain valid, but cannot be used while element is owned by a node handle: they become usable if the element is inserted into a container. 

## Contents

  * [1 Parameters](extract.html#Parameters)
  * [2 Return value](extract.html#Return_value)
  * [3 Exceptions](extract.html#Exceptions)
  * [4 Complexity](extract.html#Complexity)
  * [5 Notes](extract.html#Notes)
  * [6 Example](extract.html#Example)
  * [7 See also](extract.html#See_also)

  
---  
  
### Parameters

pos  |  \-  |  a valid iterator into this container   
---|---|---  
k  |  \-  |  a key to identify the node to be extracted   
x  |  \-  |  a value of any type that can be transparently compared with a key identifying the node to be extracted   
  
### Return value

A [node handle](../node_handle.html "cpp/container/node handle") that owns the extracted element, or empty node handle in case the element is not found in (2,3). 

### Exceptions

1) Throws nothing.

2,3) Any exceptions thrown by the `Hash` and `KeyEqual` object.

### Complexity

1-3) Average case O(1), worst case O([size()](size.html "cpp/container/unordered map/size")).

### Notes

extract is the only way to change a key of a map element without reallocation: 
    
    
    [std::map](../map.html)<int, [std::string](../../string/basic_string.html)> m{{1, "mango"}, {2, "papaya"}, {3, "guava"}};
    auto nh = m.extract(2);
    nh.key() = 4;
    m.insert(std::move(nh));
    // m == {{1, "mango"}, {3, "guava"}, {4, "papaya"}}

[Feature-test](../../utility/feature_test.html "cpp/utility/feature test") macro | Value | Std | Feature   
---|---|---|---  
[`__cpp_lib_associative_heterogeneous_erasure`](../../experimental/feature_test.html#cpp_lib_associative_heterogeneous_erasure "cpp/feature test") | [`202110L`](../../compiler_support/23.html#cpp_lib_associative_heterogeneous_erasure_202110L "cpp/compiler support/23") | (C++23) | Heterogeneous erasure in [associative containers](../../container.html#Associative_containers "cpp/container") and [unordered associative containers](../../container.html#Unordered_associative_containers "cpp/container"), ([3](extract.html#Version_3))  
  
### Example

Run this code
    
    
    #include <algorithm>
    #include <iostream>
    #include <string_view>
    #include <unordered_map>
     
    void print([std::string_view](../../string/basic_string_view.html) comment, const auto& data)
    {
        [std::cout](../../io/cout.html) << comment;
        for (auto [k, v] : data)
            [std::cout](../../io/cout.html) << ' ' << k << '(' << v << ')';
     
        [std::cout](../../io/cout.html) << '\n';
    }
     
    int main()
    {
        [std::unordered_map](../unordered_map.html)<int, char> cont{{1, 'a'}, {2, 'b'}, {3, 'c'}};
     
        print("Start:", cont);
     
        // Extract node handle and change key
        auto nh = cont.extract(1);
        nh.key() = 4;
     
        print("After extract and before insert:", cont);
     
        // Insert node handle back
        cont.insert(std::move(nh));
     
        print("End:", cont);
    }

Possible output: 
    
    
    Start: 1(a) 2(b) 3(c)
    After extract and before insert: 2(b) 3(c)
    End: 2(b) 3(c) 4(a)

### See also

[ merge](merge.html "cpp/container/unordered map/merge")(C++17) |  splices nodes from another container   
(public member function)   
---|---  
[ insert](insert.html "cpp/container/unordered map/insert") |  inserts elements or nodes(since C++17)   
(public member function)   
[ erase](erase.html "cpp/container/unordered map/erase") |  erases elements   
(public member function) 
  *[Value]: The year/month in which the feature was adopted. The hyperlink under each value opens a compiler support page with entry for given feature.
  *[Std]: Standard in which the feature is introduced; DR means defect report against that revision
