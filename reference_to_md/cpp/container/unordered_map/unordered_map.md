[[edit template]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/container/constructor_unord&action=edit)

[C++](../../../cpp.html "cpp")

[Compiler support](../../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../../freestanding.html "cpp/freestanding")  
[Language](../../language.html "cpp/language")  
[Standard library](../../standard_library.html "cpp/standard library")  
[Standard library headers](../../headers.html "cpp/header")  
[Named requirements](../../iterator/concepts.html "cpp/named req")  
[Feature test macros](../../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../../utility.html#Language_support "cpp/utility")  
[Concepts library](../../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../../error.html "cpp/error")  
[Memory management library](../../memory.html "cpp/memory")  
[Metaprogramming library](../../meta.html "cpp/meta") (C++11)  
[General utilities library](../../utility.html "cpp/utility")  
[Containers library](../../container.html "cpp/container")  
[Iterators library](../../iterator.html "cpp/iterator")  
[Ranges library](../../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../../algorithm.html "cpp/algorithm")  
[Strings library](../../string.html "cpp/string")  
[Text processing library](../../text.html "cpp/text")  
[Numerics library](../../numeric.html "cpp/numeric")  
[Date and time library](../../chrono.html "cpp/chrono")  
[Input/output library](../../io.html "cpp/io")  
[Filesystem library](../../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../../atomic.html "cpp/thread") (C++11)  
[Execution control library](../../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../../experimental.html "cpp/experimental")  
[Symbols index](../../symbol_index.html "cpp/symbol index")  
[External libraries](../../links/libs.html "cpp/links/libs")  
  


[Containers library](../../container.html "cpp/container")

[_node-handle_](../node_handle.html "cpp/container/node handle")(C++17)  
---  
[Sequence](../../container.html#Sequence_containers "cpp/container")  
[array](../array.html "cpp/container/array")(C++11)  
[vector](../vector.html "cpp/container/vector")  
[vector<bool>](../vector_bool.html "cpp/container/vector bool")  
[inplace_vector](../inplace_vector.html "cpp/container/inplace vector")(C++26)  
[hive](https://en.cppreference.com/mwiki/index.php?title=cpp/container/hive&action=edit&redlink=1 "cpp/container/hive \(page does not exist\)")(C++26)  
[deque](../deque.html "cpp/container/deque")  
[forward_list](../forward_list.html "cpp/container/forward list")(C++11)  
[list](../list.html "cpp/container/list")  
[Associative](../../container.html#Associative_containers "cpp/container")  
[set](../set.html "cpp/container/set")  
[multiset](../multiset.html "cpp/container/multiset")  
[map](../map.html "cpp/container/map")  
[multimap](../multimap.html "cpp/container/multimap")  
[Unordered associative](../../container.html#Unordered_associative_containers "cpp/container")  
[unordered_set](../unordered_set.html "cpp/container/unordered set")(C++11)  
[unordered_multiset](../unordered_multiset.html "cpp/container/unordered multiset")(C++11)  
[unordered_map](../unordered_map.html "cpp/container/unordered map")(C++11)  
[unordered_multimap](../unordered_multimap.html "cpp/container/unordered multimap")(C++11)  
[Adaptors](../../container.html#Container_adaptors "cpp/container")  
[stack](../stack.html "cpp/container/stack")  
[queue](../queue.html "cpp/container/queue")  
[priority_queue](../priority_queue.html "cpp/container/priority queue")  
[flat_set](../flat_set.html "cpp/container/flat set")(C++23)  
[flat_multiset](../flat_multiset.html "cpp/container/flat multiset")(C++23)  
[flat_map](../flat_map.html "cpp/container/flat map")(C++23)  
[flat_multimap](../flat_multimap.html "cpp/container/flat multimap")(C++23)  
[Views](../../container.html#Views "cpp/container")  
[span](../span.html "cpp/container/span")(C++20)  
[mdspan](../mdspan.html "cpp/container/mdspan")(C++23)  
Tables  
[Iterator invalidation](../../container.html#Iterator_invalidation "cpp/container")  
[Member function table](../../container.html#Member_function_table "cpp/container")  
[Non-member function table](../../container.html#Non-member_function_table "cpp/container")  
  


[`std::unordered_map`](../unordered_map.html "cpp/container/unordered map")

[Member types](../unordered_map.html#Member_types "cpp/container/unordered map")  
---  
[Member functions](../unordered_map.html#Member_functions "cpp/container/unordered map")  
| **unordered_map::unordered_map**  
---  
[unordered_map::~unordered_map](~unordered_map.html "cpp/container/unordered map/~unordered map")  
[unordered_map::operator=](operator=.html "cpp/container/unordered map/operator=")  
[unordered_map::get_allocator](get_allocator.html "cpp/container/unordered map/get allocator")  
[Iterators](../unordered_map.html#Iterators "cpp/container/unordered map")  
[unordered_map::beginunordered_map::cbegin](begin.html "cpp/container/unordered map/begin")  
[unordered_map::endunordered_map::cend](end.html "cpp/container/unordered map/end")  
[Capacity](../unordered_map.html#Capacity "cpp/container/unordered map")  
[unordered_map::size](size.html "cpp/container/unordered map/size")  
[unordered_map::max_size](max_size.html "cpp/container/unordered map/max size")  
[unordered_map::empty](empty.html "cpp/container/unordered map/empty")  
[Modifiers](../unordered_map.html#Modifiers "cpp/container/unordered map")  
[unordered_map::clear](clear.html "cpp/container/unordered map/clear")  
[unordered_map::erase](erase.html "cpp/container/unordered map/erase")  
[unordered_map::swap](swap.html "cpp/container/unordered map/swap")  
[unordered_map::extract](extract.html "cpp/container/unordered map/extract")(C++17)  
[unordered_map::merge](merge.html "cpp/container/unordered map/merge")(C++17)  
[unordered_map::insert](insert.html "cpp/container/unordered map/insert")  
[unordered_map::insert_range](insert_range.html "cpp/container/unordered map/insert range")(C++23)  
[unordered_map::insert_or_assign](insert_or_assign.html "cpp/container/unordered map/insert or assign")(C++17)` `  
[unordered_map::emplace](emplace.html "cpp/container/unordered map/emplace")  
[unordered_map::emplace_hint](emplace_hint.html "cpp/container/unordered map/emplace hint")  
[unordered_map::try_emplace](try_emplace.html "cpp/container/unordered map/try emplace")(C++17)  
  
| [Lookup](../unordered_map.html#Lookup "cpp/container/unordered map")  
---  
[unordered_map::at](at.html "cpp/container/unordered map/at")  
[unordered_map::operator[]](operator_at.html "cpp/container/unordered map/operator at")  
[unordered_map::count](count.html "cpp/container/unordered map/count")  
[unordered_map::find](find.html "cpp/container/unordered map/find")  
[unordered_map::contains](contains.html "cpp/container/unordered map/contains")(C++20)  
[unordered_map::equal_range](equal_range.html "cpp/container/unordered map/equal range")  
[Bucket interface](../unordered_map.html#Bucket_interface "cpp/container/unordered map")  
[unordered_map::begin(size_type)unordered_map::cbegin(size_type)](begin2.html "cpp/container/unordered map/begin2")  
[unordered_map::end(size_type)unordered_map::cend(size_type)](end2.html "cpp/container/unordered map/end2")  
[unordered_map::bucket_count](bucket_count.html "cpp/container/unordered map/bucket count")  
[unordered_map::max_bucket_count](max_bucket_count.html "cpp/container/unordered map/max bucket count")  
[unordered_map::bucket_size](bucket_size.html "cpp/container/unordered map/bucket size")  
[unordered_map::bucket](bucket.html "cpp/container/unordered map/bucket")  
[Hash policy](../unordered_map.html#Hash_policy "cpp/container/unordered map")  
[unordered_map::load_factor](load_factor.html "cpp/container/unordered map/load factor")  
[unordered_map::max_load_factor](max_load_factor.html "cpp/container/unordered map/max load factor")  
[unordered_map::rehash](rehash.html "cpp/container/unordered map/rehash")  
[unordered_map::reserve](reserve.html "cpp/container/unordered map/reserve")  
[Observers](../unordered_map.html#Observers "cpp/container/unordered map")  
[unordered_map::hash_function](hash_function.html "cpp/container/unordered map/hash function")  
[unordered_map::key_eq](key_eq.html "cpp/container/unordered map/key eq")  
  
[Non-member functions](../unordered_map.html#Non-member_functions "cpp/container/unordered map")  
| [operator==operator!=](operator_cmp.html "cpp/container/unordered map/operator cmp")(until C++20)  
---  
  
| [std::swap(std::unordered_map)](swap2.html "cpp/container/unordered map/swap2")  
---  
[erase_if(std::unordered_map)](erase_if.html "cpp/container/unordered map/erase if")(C++20)  
  
[Deduction guides](deduction_guides.html "cpp/container/unordered map/deduction guides")(C++17)  
  


| (1) |   
---|---|---  
unordered_map()  
: unordered_map(size_type(/* unspecified */)) {} |  | (since C++11)   
(until C++20)  
unordered_map(); |  |  (since C++20)  
explicit unordered_map( size_type bucket_count,  
const Hash& hash = Hash(),  
const key_equal& equal = key_equal(),  
const Allocator& alloc = Allocator() ); |  (2)  |  (since C++11)  
unordered_map( size_type bucket_count,  
const Allocator& alloc )  
: unordered_map(bucket_count, Hash(), key_equal(), alloc) {} |  (3)  |  (since C++14)  
unordered_map( size_type bucket_count,  
const Hash& hash,  
const Allocator& alloc )  
: unordered_map(bucket_count, hash, key_equal(), alloc) {} |  (4)  |  (since C++14)  
explicit unordered_map( const Allocator& alloc ); |  (5)  |  (since C++11)  
template< class InputIt >  
unordered_map( InputIt first, InputIt last,  
size_type bucket_count = /* unspecified */,  
const Hash& hash = Hash(),  
const key_equal& equal = key_equal(),  
const Allocator& alloc = Allocator() ); |  (6)  |  (since C++11)  
template< class InputIt >  
unordered_map( InputIt first, InputIt last,  
size_type bucket_count,  
const Allocator& alloc )  
: unordered_map(first, last,  
bucket_count, Hash(), key_equal(), alloc) {} |  (7)  |  (since C++14)  
template< class InputIt >  
unordered_map( InputIt first, InputIt last,  
size_type bucket_count,  
const Hash& hash,  
const Allocator& alloc )  
: unordered_map(first, last,  
bucket_count, hash, key_equal(), alloc) {} |  (8)  |  (since C++14)  
unordered_map( const unordered_map& other ); |  (9)  |  (since C++11)  
unordered_map( const unordered_map& other, const Allocator& alloc ); |  (10)  |  (since C++11)  
unordered_map( unordered_map&& other ); |  (11) | (since C++11)  
unordered_map( unordered_map&& other, const Allocator& alloc ); |  (12)  |  (since C++11)  
unordered_map( [std::initializer_list](../../utility/initializer_list.html)<value_type> init,  
size_type bucket_count = /* unspecified */,  
const Hash& hash = Hash(),  
const key_equal& equal = key_equal(),  
const Allocator& alloc = Allocator() ); |  (13) | (since C++11)  
unordered_map( [std::initializer_list](../../utility/initializer_list.html)<value_type> init,  
size_type bucket_count,  
const Allocator& alloc )  
: unordered_map(init, bucket_count,  
Hash(), key_equal(), alloc) {} |  (14)  |  (since C++14)  
unordered_map( [std::initializer_list](../../utility/initializer_list.html)<value_type> init,  
size_type bucket_count,  
const Hash& hash,  
const Allocator& alloc )  
: unordered_map(init, bucket_count,  
hash, key_equal(), alloc) {} |  (15)  |  (since C++14)  
template< [container-compatible-range](../../ranges/to.html)<value_type> R >  
unordered_map( [std::from_range_t](../../ranges/from_range.html), R&& rg,  
size_type bucket_count = /* see description */,  
const Hash& hash = Hash(),  
const key_equal& equal = key_equal(),  
const Allocator& alloc = Allocator() ); |  (16) | (since C++23)  
template< [container-compatible-range](../../ranges/to.html)<value_type> R >  
unordered_map( [std::from_range_t](../../ranges/from_range.html), R&& rg,  
size_type bucket_count,  
const Allocator& alloc )  
: unordered_map([std::from_range](../../ranges/from_range.html), [std::forward](../../utility/forward.html)<R>(rg),  
bucket_count, Hash(), key_equal(), alloc) {} |  (17)  |  (since C++23)  
template< [container-compatible-range](../../ranges/to.html)<value_type> R >  
unordered_map( [std::from_range_t](../../ranges/from_range.html), R&& rg,  
size_type bucket_count,  
const Hash& hash,  
const Alloc& alloc )  
: unordered_map([std::from_range](../../ranges/from_range.html), [std::forward](../../utility/forward.html)<R>(rg),  
bucket_count, hash, key_equal(), alloc) {} |  (18)  |  (since C++23)  
| |   
  
Constructs new container from a variety of data sources. Optionally uses user supplied bucket_count as a minimal number of buckets to create, hash as the hash function, equal as the function to compare keys and alloc as the allocator. 

1-5) Constructs empty container. Sets [max_load_factor()](max_load_factor.html "cpp/container/unordered map/max load factor") to 1.0. For the default constructor, the number of buckets is unspecified.

6-8) Constructs the container with the contents of the range `[`first`, `last`)`. Sets [max_load_factor()](max_load_factor.html "cpp/container/unordered map/max load factor") to 1.0. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted (pending [LWG2844](https://cplusplus.github.io/LWG/issue2844)).

9,10) Copy constructor. Constructs the container with the copy of the contents of other, copies the load factor, the predicate, and the hash function as well. If alloc is not provided, allocator is obtained by calling [std::allocator_traits](../../memory/allocator_traits.html)<allocator_type>::select_on_container_copy_construction(other.get_allocator()).  The template parameter `Allocator` is only deduced from the first argument while used in [class template argument deduction](../../language/ctad.html "cpp/language/class template argument deduction").  | (since C++23)  
---|---  
  
11,12) [Move constructor](../../language/move_constructor.html "cpp/language/move constructor"). Constructs the container with the contents of other using move semantics. If alloc is not provided, allocator is obtained by move-construction from the allocator belonging to other.  The template parameter `Allocator` is only deduced from the first argument while used in [class template argument deduction](../../language/ctad.html "cpp/language/class template argument deduction").  | (since C++23)  
---|---  
  
13-15) [Initializer-list constructor](../../language/list_initialization.html "cpp/language/list initialization"). Constructs the container with the contents of the initializer list init, same as unordered_map(init.begin(), init.end()).

16-18) Constructs the container with the contents of rg. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted (pending [LWG2844](https://cplusplus.github.io/LWG/issue2844)).

## Contents

  * [1 Parameters](unordered_map.html#Parameters)
  * [2 Complexity](unordered_map.html#Complexity)
  * [3 Exceptions](unordered_map.html#Exceptions)
  * [4 Notes](unordered_map.html#Notes)
  * [5 Example](unordered_map.html#Example)
  * [6 Defect reports](unordered_map.html#Defect_reports)
  * [7 See also](unordered_map.html#See_also)

  
---  
  
### Parameters

alloc  |  \-  |  allocator to use for all memory allocations of this container   
---|---|---  
bucket_count  |  \-  |  minimal number of buckets to use on initialization. If it is not specified, an unspecified default value is used   
hash  |  \-  |  hash function to use   
equal  |  \-  |  comparison function to use for all key comparisons of this container   
first, last  |  \-  |  the pair of iterators defining the source [range](../../iterator.html#Ranges "cpp/iterator") of elements to copy   
rg  |  \-  |  a [container compatible range](../../ranges/to.html#container_compatible_range "cpp/ranges/to"), that is, an [`input_range`](../../ranges/input_range.html "cpp/ranges/input range") whose elements are convertible to [`value_type`](../unordered_map.html#Member_types "cpp/container/unordered map")  
other  |  \-  |  another container to be used as source to initialize the elements of the container with   
init  |  \-  |  initializer list to initialize the elements of the container with   
Type requirements   
-`InputIt` must meet the requirements of [LegacyInputIterator](../../named_req/InputIterator.html "cpp/named req/InputIterator").   
  
### Complexity

1-5) Constant.

6-8) Average case linear (i.e. O(N), where N is [std::distance](../../iterator/distance.html)(first, last)), worst case quadratic, i.e. O(N2).

9,10) Linear in size of other.

11,12) Constant. If alloc is given and alloc != other.get_allocator(), then linear.

13-15) Average case O(N) (N is [std::size](../../iterator/size.html)(init)), worst case O(N2).

16-18) Average case O(N) (N is [ranges::distance](../../iterator/ranges/distance.html)(rg)), worst case O(N2).

### Exceptions

Calls to `Allocator::allocate` may throw. 

### Notes



After container move construction (overload ([11,12](unordered_map.html#Version_11))), references, pointers, and iterators (other than the end iterator) to other remain valid, but refer to elements that are now in *this. The current standard makes this guarantee via the blanket statement in [[container.reqmts]/67](https://eel.is/c++draft/container.reqmts#67), and a more direct guarantee is under consideration via [LWG issue 2321](https://cplusplus.github.io/LWG/issue2321). 

Although not formally required until C++23, some implementations have already put the template parameter `Allocator` into [non-deduced contexts](../../language/template_argument_deduction.html#Non-deduced_contexts "cpp/language/template argument deduction") in earlier modes. 

[Feature-test](../../utility/feature_test.html "cpp/utility/feature test") macro | Value | Std | Feature   
---|---|---|---  
[`__cpp_lib_containers_ranges`](../../experimental/feature_test.html#cpp_lib_containers_ranges "cpp/feature test") | [`202202L`](../../compiler_support/23.html#cpp_lib_containers_ranges_202202L "cpp/compiler support/23") | (C++23) | [Ranges-aware](../../ranges/to.html#container_compatible_range "cpp/ranges/to") construction and insertion; overloads ([16-18](unordered_map.html#Version_16))  
  
### Example

Run this code
    
    
    #include <bitset>
    #include <string>
    #include <unordered_map>
    #include <utility>
    #include <vector>
     
    struct Key
    {
        [std::string](../../string/basic_string.html) first;
        [std::string](../../string/basic_string.html) second;
    };
     
    struct KeyHash
    {
        [std::size_t](../../types/size_t.html) operator()(const Key& k) const
        {
            return [std::hash](../../utility/hash.html)<[std::string](../../string/basic_string.html)>()(k.first) ^
                ([std::hash](../../utility/hash.html)<[std::string](../../string/basic_string.html)>()(k.second) << 1);
        }
    };
     
    struct KeyEqual
    {
        bool operator()(const Key& lhs, const Key& rhs) const
        {
            return lhs.first == rhs.first && lhs.second == rhs.second;
        }
    };
     
    struct Foo
    {
        Foo(int val_) : val(val_) {}
        int val;
        bool operator==(const Foo &rhs) const { return val == rhs.val; }
    };
     
    template<>
    struct [std::hash](../../utility/hash.html)<Foo>
    {
        [std::size_t](../../types/size_t.html) operator()(const Foo &f) const
        {
            return [std::hash](../../utility/hash.html)<int>{}(f.val);
        }
    };
     
    int main()
    {
        // default constructor: empty map
        [std::unordered_map](../unordered_map.html)<[std::string](../../string/basic_string.html), [std::string](../../string/basic_string.html)> m1;
     
        // list constructor
        [std::unordered_map](../unordered_map.html)<int, [std::string](../../string/basic_string.html)> m2 =
        {
            {1, "foo"},
            {3, "bar"},
            {2, "baz"}
        };
     
        // copy constructor
        [std::unordered_map](../unordered_map.html)<int, [std::string](../../string/basic_string.html)> m3 = m2;
     
        // move constructor
        [std::unordered_map](../unordered_map.html)<int, [std::string](../../string/basic_string.html)> m4 = std::move(m2);
     
        // range constructor
        [std::vector](../vector.html)<[std::pair](../../utility/pair.html)<[std::bitset](../../utility/bitset.html)<8>, int>> v = {{0x12, 1}, {0x01,-1}};
        [std::unordered_map](../unordered_map.html)<[std::bitset](../../utility/bitset.html)<8>, double> m5(v.begin(), v.end());
     
        // Option 1 for a constructor with a custom Key type
        // Define the KeyHash and KeyEqual structs and use them in the template
        [std::unordered_map](../unordered_map.html)<Key, [std::string](../../string/basic_string.html), KeyHash, KeyEqual> m6 =
        {
            {{"John", "Doe"}, "example"},
            {{"Mary", "Sue"}, "another"}
        };
     
        // Option 2 for a constructor with a custom Key type.
        // Define a const == operator for the class/struct and specialize std::hash
        // structure in the std namespace
        [std::unordered_map](../unordered_map.html)<Foo, [std::string](../../string/basic_string.html)> m7 =
        {
            {Foo(1), "One"}, {2, "Two"}, {3, "Three"}
        };
     
        // Option 3: Use lambdas
        // Note that the initial bucket count has to be passed to the constructor
        struct Goo { int val; };
        auto hash = [](const Goo &g){ return [std::hash](../../utility/hash.html)<int>{}(g.val); };
        auto comp = [](const Goo &l, const Goo &r){ return l.val == r.val; };
        [std::unordered_map](../unordered_map.html)<Goo, double, decltype(hash), decltype(comp)> m8(10, hash, comp);
    }

### Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[LWG 2193](https://cplusplus.github.io/LWG/issue2193) | C++11  | the default constructor ([1](unordered_map.html#Version_1)) was explicit  | made non-explicit   
[LWG 2230](https://cplusplus.github.io/LWG/issue2230) | C++11  | the semantics of overload ([13](unordered_map.html#Version_13)) was not specified  | specified   
  
### See also

[ operator=](operator=.html "cpp/container/unordered map/operator=") |  assigns values to the container   
(public member function)   
---|---
  *[Value]: The year/month in which the feature was adopted. The hyperlink under each value opens a compiler support page with entry for given feature.
  *[Std]: Standard in which the feature is introduced; DR means defect report against that revision
