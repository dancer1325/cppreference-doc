[C++](../../cpp.html "cpp")

[Compiler support](../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../freestanding.html "cpp/freestanding")  
[Language](../language.html "cpp/language")  
[Standard library](../standard_library.html "cpp/standard library")  
[Standard library headers](../headers.html "cpp/header")  
[Named requirements](../iterator/concepts.html "cpp/named req")  
[Feature test macros](../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../utility.html#Language_support "cpp/utility")  
[Concepts library](../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../error.html "cpp/error")  
[Memory management library](../memory.html "cpp/memory")  
[Metaprogramming library](../meta.html "cpp/meta") (C++11)  
[General utilities library](../utility.html "cpp/utility")  
[Containers library](../container.html "cpp/container")  
[Iterators library](../iterator.html "cpp/iterator")  
[Ranges library](../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../algorithm.html "cpp/algorithm")  
[Strings library](../string.html "cpp/string")  
[Text processing library](../text.html "cpp/text")  
[Numerics library](../numeric.html "cpp/numeric")  
[Date and time library](../chrono.html "cpp/chrono")  
[Input/output library](../io.html "cpp/io")  
[Filesystem library](../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../atomic.html "cpp/thread") (C++11)  
[Execution control library](../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../experimental.html "cpp/experimental")  
[Symbols index](../symbol_index.html "cpp/symbol index")  
[External libraries](../links/libs.html "cpp/links/libs")  
  


[Containers library](../container.html "cpp/container")

[_node-handle_](node_handle.html "cpp/container/node handle")(C++17)  
---  
[Sequence](../container.html#Sequence_containers "cpp/container")  
[array](array.html "cpp/container/array")(C++11)  
[vector](vector.html "cpp/container/vector")  
[vector<bool>](vector_bool.html "cpp/container/vector bool")  
[inplace_vector](inplace_vector.html "cpp/container/inplace vector")(C++26)  
[hive](https://en.cppreference.com/mwiki/index.php?title=cpp/container/hive&action=edit&redlink=1 "cpp/container/hive \(page does not exist\)")(C++26)  
[deque](deque.html "cpp/container/deque")  
[forward_list](forward_list.html "cpp/container/forward list")(C++11)  
[list](list.html "cpp/container/list")  
[Associative](../container.html#Associative_containers "cpp/container")  
[set](set.html "cpp/container/set")  
[multiset](multiset.html "cpp/container/multiset")  
[map](map.html "cpp/container/map")  
[multimap](multimap.html "cpp/container/multimap")  
[Unordered associative](../container.html#Unordered_associative_containers "cpp/container")  
[unordered_set](unordered_set.html "cpp/container/unordered set")(C++11)  
[unordered_multiset](unordered_multiset.html "cpp/container/unordered multiset")(C++11)  
[unordered_map](unordered_map.html "cpp/container/unordered map")(C++11)  
[unordered_multimap](unordered_multimap.html "cpp/container/unordered multimap")(C++11)  
[Adaptors](../container.html#Container_adaptors "cpp/container")  
[stack](stack.html "cpp/container/stack")  
[queue](queue.html "cpp/container/queue")  
[priority_queue](priority_queue.html "cpp/container/priority queue")  
[flat_set](flat_set.html "cpp/container/flat set")(C++23)  
[flat_multiset](flat_multiset.html "cpp/container/flat multiset")(C++23)  
[flat_map](flat_map.html "cpp/container/flat map")(C++23)  
**flat_multimap**(C++23)  
[Views](../container.html#Views "cpp/container")  
[span](span.html "cpp/container/span")(C++20)  
[mdspan](mdspan.html "cpp/container/mdspan")(C++23)  
Tables  
[Iterator invalidation](../container.html#Iterator_invalidation "cpp/container")  
[Member function table](../container.html#Member_function_table "cpp/container")  
[Non-member function table](../container.html#Non-member_function_table "cpp/container")  
  


**`std::flat_multimap`**

[Member types](flat_multimap.html#Member_types "cpp/container/flat multimap")  
---  
[Member functions](flat_multimap.html#Member_functions "cpp/container/flat multimap")  
|  | [flat_multimap::flat_multimap](flat_multimap/flat_multimap.html "cpp/container/flat multimap/flat multimap")` `  
---  
[flat_multimap::operator=](flat_multimap/operator=.html "cpp/container/flat multimap/operator=")  
[Modifiers](flat_multimap.html#Modifiers "cpp/container/flat multimap")  
[flat_multimap::clear](flat_multimap/clear.html "cpp/container/flat multimap/clear")  
[flat_multimap::erase](flat_multimap/erase.html "cpp/container/flat multimap/erase")  
[flat_multimap::swap](flat_multimap/swap.html "cpp/container/flat multimap/swap")  
[flat_multimap::extract](flat_multimap/extract.html "cpp/container/flat multimap/extract")  
[flat_multimap::replace](flat_multimap/replace.html "cpp/container/flat multimap/replace")  
[flat_multimap::insert](flat_multimap/insert.html "cpp/container/flat multimap/insert")  
[flat_multimap::insert_range](flat_multimap/insert_range.html "cpp/container/flat multimap/insert range")  
[flat_multimap::emplace](flat_multimap/emplace.html "cpp/container/flat multimap/emplace")  
[flat_multimap::emplace_hint](flat_multimap/emplace_hint.html "cpp/container/flat multimap/emplace hint")  
[Lookup](flat_multimap.html#Lookup "cpp/container/flat multimap")  
[flat_multimap::count](flat_multimap/count.html "cpp/container/flat multimap/count")  
[flat_multimap::find](flat_multimap/find.html "cpp/container/flat multimap/find")  
[flat_multimap::contains](flat_multimap/contains.html "cpp/container/flat multimap/contains")  
[flat_multimap::equal_range](flat_multimap/equal_range.html "cpp/container/flat multimap/equal range")  
[flat_multimap::lower_bound](flat_multimap/lower_bound.html "cpp/container/flat multimap/lower bound")  
[flat_multimap::upper_bound](flat_multimap/upper_bound.html "cpp/container/flat multimap/upper bound")  
  
| [Iterators](flat_multimap.html#Iterators "cpp/container/flat multimap")  
---  
[flat_multimap::beginflat_multimap::cbegin](flat_multimap/begin.html "cpp/container/flat multimap/begin")  
[flat_multimap::endflat_multimap::cend](flat_multimap/end.html "cpp/container/flat multimap/end")  
[flat_multimap::rbeginflat_multimap::crbegin](flat_multimap/rbegin.html "cpp/container/flat multimap/rbegin")  
[flat_multimap::rendflat_multimap::crend](flat_multimap/rend.html "cpp/container/flat multimap/rend")  
[Capacity](flat_multimap.html#Capacity "cpp/container/flat multimap")  
[flat_multimap::size](flat_multimap/size.html "cpp/container/flat multimap/size")  
[flat_multimap::max_size](flat_multimap/max_size.html "cpp/container/flat multimap/max size")  
[flat_multimap::empty](flat_multimap/empty.html "cpp/container/flat multimap/empty")  
[Observers](flat_multimap.html#Observers "cpp/container/flat multimap")  
[flat_multimap::key_comp](flat_multimap/key_comp.html "cpp/container/flat multimap/key comp")  
[flat_multimap::keys](flat_multimap/keys.html "cpp/container/flat multimap/keys")  
[flat_multimap::value_comp](flat_multimap/value_comp.html "cpp/container/flat multimap/value comp")  
[flat_multimap::values](flat_multimap/values.html "cpp/container/flat multimap/values")  
  
[Non-member functions](flat_multimap.html#Non-member_functions "cpp/container/flat multimap")  
|  | [swap(std::flat_multimap)](flat_multimap/swap2.html "cpp/container/flat multimap/swap2")  
---  
[erase_if(std::flat_multimap)](flat_multimap/erase_if.html "cpp/container/flat multimap/erase if")` `  
  
| [operator==operator<=>](flat_multimap/operator_cmp.html "cpp/container/flat multimap/operator cmp")  
---  
  
[Helper classes](flat_multimap.html#Helper_classes "cpp/container/flat multimap")  
|  | [uses_allocator<std::flat_multimap>](flat_multimap/uses_allocator.html "cpp/container/flat multimap/uses allocator")  
---  
  
[Tags](flat_multimap.html#Tags "cpp/container/flat multimap")  
|  | [sorted_equivalent](sorted_equivalent.html "cpp/container/sorted equivalent")` `  
---  
  
| [sorted_equivalent_t](sorted_equivalent.html "cpp/container/sorted equivalent")  
---  
  
[Deduction guides](flat_multimap/deduction_guides.html "cpp/container/flat multimap/deduction guides")  
  


Defined in header `[<flat_map>](../header/flat_map.html "cpp/header/flat map")` |  |   
---|---|---  
template<  
class Key,  
class T,  
class Compare = [std::less](../utility/functional/less.html)<Key>,  
class KeyContainer = [std::vector](vector.html)<Key>,  
class MappedContainer = [std::vector](vector.html)<T>  
> class flat_multimap; |  |  (since C++23)  
| |   
  
The flat multimap is a [container adaptor](../container.html#Container_adaptors "cpp/container") that gives the functionality of an associative container that contains key-value pairs, while permitting multiple entries with the same key value. Keys are sorted by using the comparison function `Compare`. 

The class template `flat_multimap` acts as a wrapper to the two underlying containers, passed as objects of type `KeyContainer` and `MappedContainer` respectively. The first container is sorted, and for each key its corresponding value is in the second container at the same index (offset). The number of elements in both containers is the same. 

Everywhere the standard library uses the [Compare](../named_req/Compare.html "cpp/named req/Compare") requirements, uniqueness is determined by using the equivalence relation. Informally, two objects a and b are considered equivalent if neither compares less than the other: !comp(a, b) && !comp(b, a). 

  
`std::flat_multimap` meets the requirements of [Container](../named_req/Container.html "cpp/named req/Container"), [ReversibleContainer](../named_req/ReversibleContainer.html "cpp/named req/ReversibleContainer"), [optional container requirements](../named_req/Container.html#Optional_container_requirements "cpp/named req/Container"), and all requirements of [AssociativeContainer](../named_req/AssociativeContainer.html "cpp/named req/AssociativeContainer") (including logarithmic search complexity), except that: 

  * requirements related to nodes are not applicable, 
  * iterator invalidation requirements differ, 
  * the complexity of insertion and erasure operations is linear. 



A flat multimap supports most of [AssociativeContainer](../named_req/AssociativeContainer.html "cpp/named req/AssociativeContainer")'s operations that use equal keys. 

All member functions of `std::flat_multimap` are constexpr: it is possible to create and use `std::flat_multimap` objects in the evaluation of a constant expression.However, `std::flat_multimap` objects generally cannot be constexpr, because any dynamically allocated storage must be released in the same evaluation of constant expression. | (since C++26)  
---|---  
  
## Contents

  * [1 Iterator invalidation](flat_multimap.html#Iterator_invalidation)
  * [2 Template parameters](flat_multimap.html#Template_parameters)
  * [3 Member types](flat_multimap.html#Member_types)
  * [4 Member classes](flat_multimap.html#Member_classes)
  * [5 Member objects](flat_multimap.html#Member_objects)
  * [6 Member functions](flat_multimap.html#Member_functions)
    * [6.1 Iterators](flat_multimap.html#Iterators)
    * [6.2 Capacity](flat_multimap.html#Capacity)
    * [6.3 Modifiers](flat_multimap.html#Modifiers)
    * [6.4 Lookup](flat_multimap.html#Lookup)
    * [6.5 Observers](flat_multimap.html#Observers)
  * [7 Non-member functions](flat_multimap.html#Non-member_functions)
  * [8 Helper classes](flat_multimap.html#Helper_classes)
  * [9 Tags](flat_multimap.html#Tags)
  * [10 Deduction guides](flat_multimap.html#Deduction_guides)
  * [11 Notes](flat_multimap.html#Notes)
  * [12 Example](flat_multimap.html#Example)
  * [13 See also](flat_multimap.html#See_also)

  
---  
  
### Iterator invalidation

| This section is incomplete   
---|---  
  
### Template parameters

Key  |  \-  |  The type of the keys. The program is ill-formed if `Key` is not the same type as `KeyContainer::value_type`.   
---|---|---  
T  |  \-  |  The type of mapped values. The program is ill-formed if `T` is not the same type as `MappedContainer::value_type`.   
Compare  |  \-  |  A [Compare](../named_req/Compare.html "cpp/named req/Compare") type providing a strict weak ordering.   
KeyContainer  
MappedContainer  |  \-  |  The types of the underlying [SequenceContainer](../named_req/SequenceContainer.html "cpp/named req/SequenceContainer") to store keys and mapped values correspondingly. The iterators of such containers should satisfy [LegacyRandomAccessIterator](../named_req/RandomAccessIterator.html "cpp/named req/RandomAccessIterator") or model [`random_access_iterator`](../iterator/random_access_iterator.html "cpp/iterator/random access iterator"). Invocations of their member functions `size` and `max_size` should not exit via an exception. The standard containers [std::vector](vector.html "cpp/container/vector") and [std::deque](deque.html "cpp/container/deque") satisfy these requirements.   
  
### Member types

Type  |  Definition   
---|---  
`key_container_type` |  `KeyContainer`  
`mapped_container_type` |  `MappedContainer`  
`key_type` |  `Key`  
`mapped_type` |  `T`  
`value_type` |  [std::pair](../utility/pair.html)<key_type, mapped_type>  
`key_compare` |  `Compare`  
`reference` |  [std::pair](../utility/pair.html)<const key_type&, mapped_type&>  
`const_reference` |  [std::pair](../utility/pair.html)<const key_type&, const mapped_type&>  
`size_type` |  [std::size_t](../types/size_t.html "cpp/types/size t")  
`difference_type` |  [std::ptrdiff_t](../types/ptrdiff_t.html "cpp/types/ptrdiff t")  
`iterator` |  implementation-defined [LegacyInputIterator](../named_req/InputIterator.html "cpp/named req/InputIterator"), [ConstexprIterator](../named_req/ConstexprIterator.html "cpp/named req/ConstexprIterator")(since C++26) and [`random_access_iterator`](../iterator/random_access_iterator.html "cpp/iterator/random access iterator") to `value_type`  
`const_iterator` |  implementation-defined [LegacyInputIterator](../named_req/InputIterator.html "cpp/named req/InputIterator"), [ConstexprIterator](../named_req/ConstexprIterator.html "cpp/named req/ConstexprIterator")(since C++26) and [`random_access_iterator`](../iterator/random_access_iterator.html "cpp/iterator/random access iterator") to const value_type  
`reverse_iterator` |  [std::reverse_iterator](../iterator/reverse_iterator.html)<iterator>  
`const_reverse_iterator` |  [std::reverse_iterator](../iterator/reverse_iterator.html)<const_iterator>  
`containers` |  type describing the underlying containers  
struct containers  
{  
key_container_type keys;  
mapped_container_type values;  
};  
  
### Member classes

[ value_compare](flat_multimap/value_compare.html "cpp/container/flat multimap/value compare") |  compares objects of type `value_type`   
(class)   
---|---  
  
### Member objects

Member  |  Description   
---|---  
`containers` `_c_` (private) |  the adapted containers  
(exposition-only member object*)  
`key_compare` `_compare_` (private) |  the comparison function object  
(exposition-only member object*)  
  
### Member functions

[ (constructor)](flat_multimap/flat_multimap.html "cpp/container/flat multimap/flat multimap") |  constructs the `flat_multimap`   
(public member function)   
---|---  
(destructor)(implicitly declared) |  destroys every element of the container adaptor   
(public member function)  
[ operator=](flat_multimap/operator=.html "cpp/container/flat multimap/operator=") |  assigns values to the container adaptor   
(public member function)   
  
#####  Iterators   
  
[ begincbegin](flat_multimap/begin.html "cpp/container/flat multimap/begin") |  returns an iterator to the beginning   
(public member function)   
[ endcend](flat_multimap/end.html "cpp/container/flat multimap/end") |  returns an iterator to the end   
(public member function)   
[ rbegincrbegin](flat_multimap/rbegin.html "cpp/container/flat multimap/rbegin") |  returns a reverse iterator to the beginning   
(public member function)   
[ rendcrend](flat_multimap/rend.html "cpp/container/flat multimap/rend") |  returns a reverse iterator to the end   
(public member function)   
  
#####  Capacity   
  
[ empty](flat_multimap/empty.html "cpp/container/flat multimap/empty") |  checks whether the container adaptor is empty   
(public member function)   
[ size](flat_multimap/size.html "cpp/container/flat multimap/size") |  returns the number of elements   
(public member function)   
[ max_size](flat_multimap/max_size.html "cpp/container/flat multimap/max size") |  returns the maximum possible number of elements   
(public member function)   
  
#####  Modifiers   
  
[ emplace](flat_multimap/emplace.html "cpp/container/flat multimap/emplace") |  constructs element in-place   
(public member function)   
[ emplace_hint](flat_multimap/emplace_hint.html "cpp/container/flat multimap/emplace hint") |  constructs elements in-place using a hint   
(public member function)   
[ insert](flat_multimap/insert.html "cpp/container/flat multimap/insert") |  inserts elements   
(public member function)   
[ insert_range](flat_multimap/insert_range.html "cpp/container/flat multimap/insert range") |  inserts a range of elements   
(public member function)   
[ extract](flat_multimap/extract.html "cpp/container/flat multimap/extract") |  extracts the underlying containers   
(public member function)   
[ replace](flat_multimap/replace.html "cpp/container/flat multimap/replace") |  replaces the underlying containers   
(public member function)   
[ erase](flat_multimap/erase.html "cpp/container/flat multimap/erase") |  erases elements   
(public member function)   
[ swap](flat_multimap/swap.html "cpp/container/flat multimap/swap") |  swaps the contents   
(public member function)   
[ clear](flat_multimap/clear.html "cpp/container/flat multimap/clear") |  clears the contents   
(public member function)   
  
#####  Lookup   
  
[ find](flat_multimap/find.html "cpp/container/flat multimap/find") |  finds element with specific key   
(public member function)   
[ count](flat_multimap/count.html "cpp/container/flat multimap/count") |  returns the number of elements matching specific key   
(public member function)   
[ contains](flat_multimap/contains.html "cpp/container/flat multimap/contains") |  checks if the container contains element with specific key   
(public member function)   
[ lower_bound](flat_multimap/lower_bound.html "cpp/container/flat multimap/lower bound") |  returns an iterator to the first element _not less_ than the given key   
(public member function)   
[ upper_bound](flat_multimap/upper_bound.html "cpp/container/flat multimap/upper bound") |  returns an iterator to the first element _greater_ than the given key   
(public member function)   
[ equal_range](flat_multimap/equal_range.html "cpp/container/flat multimap/equal range") |  returns range of elements matching a specific key   
(public member function)   
  
#####  Observers   
  
[ key_comp](flat_multimap/key_comp.html "cpp/container/flat multimap/key comp") |  returns the function that compares keys   
(public member function)   
[ value_comp](flat_multimap/value_comp.html "cpp/container/flat multimap/value comp") |  returns the function that compares keys in objects of type `value_type`   
(public member function)   
[ keys](flat_multimap/keys.html "cpp/container/flat multimap/keys") |  direct access to the underlying keys container   
(public member function)   
[ values](flat_multimap/values.html "cpp/container/flat multimap/values") |  direct access to the underlying values container   
(public member function)   
  
### Non-member functions

[ operator==operator<=>](flat_multimap/operator_cmp.html "cpp/container/flat multimap/operator cmp")(C++23) |  lexicographically compares the values of two `flat_multimap`s   
(function template)   
---|---  
[ std::swap(std::flat_multimap)](flat_multimap/swap2.html "cpp/container/flat multimap/swap2")(C++23) |  specializes the [std::swap](../utility/swap.html "cpp/algorithm/swap") algorithm   
(function template)   
[ erase_if(std::flat_multimap)](flat_multimap/erase_if.html "cpp/container/flat multimap/erase if")(C++23) |  erases all elements satisfying specific criteria   
(function template)   
  
### Helper classes

[ std::uses_allocator<std::flat_multimap>](flat_multimap/uses_allocator.html "cpp/container/flat multimap/uses allocator")(C++23) |  specializes the [std::uses_allocator](../memory/uses_allocator.html "cpp/memory/uses allocator") type trait   
(class template specialization)   
---|---  
  
### Tags

[ sorted_equivalentsorted_equivalent_t](sorted_equivalent.html "cpp/container/sorted equivalent")(C++23) |  indicates that elements of a range are sorted (uniqueness is not required)  
(tag)  
---|---  
  
### [Deduction guides](flat_multimap/deduction_guides.html "cpp/container/flat multimap/deduction guides")

### Notes

The member types `iterator` and `const_iterator` may be aliases to the same type. This means defining a pair of function overloads using the two types as parameter types may violate the [One Definition Rule](../language/definition.html#One_Definition_Rule "cpp/language/definition"). Since `iterator` is convertible to `const_iterator`, a single function with a `const_iterator` as parameter type will work instead. 

[Feature-test](../utility/feature_test.html "cpp/utility/feature test") macro  | Value | Std | Feature   
---|---|---|---  
[`__cpp_lib_flat_map`](../experimental/feature_test.html#cpp_lib_flat_map "cpp/feature test") | [`202207L`](../compiler_support/23.html#cpp_lib_flat_map_202207L "cpp/compiler support/23") | (C++23) | std::flat_map and `std::flat_multimap`  
[`__cpp_lib_constexpr_flat_map`](../experimental/feature_test.html#cpp_lib_constexpr_flat_map "cpp/feature test") | [`202502L`](../compiler_support/26.html#cpp_lib_constexpr_flat_map_202502L "cpp/compiler support/26") | (C++26) | constexpr `std::flat_multimap`  
  
### Example

| This section is incomplete  
Reason: no example   
---|---  
  
### See also

[ flat_map](flat_map.html "cpp/container/flat map")(C++23) |  adapts two containers to provide a collection of key-value pairs, sorted by unique keys   
(class template)   
---|---  
[ multimap](multimap.html "cpp/container/multimap") |  collection of key-value pairs, sorted by keys   
(class template)   
[ unordered_multimap](unordered_multimap.html "cpp/container/unordered multimap")(C++11) |  collection of key-value pairs, hashed by keys   
(class template) 
  *[Value]: The year/month in which the feature was adopted. The hyperlink under each value opens a compiler support page with entry for given feature.
  *[Std]: Standard in which the feature is introduced; DR means defect report against that revision
