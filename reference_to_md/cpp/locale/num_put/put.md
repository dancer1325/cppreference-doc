[C++](../../../cpp.html "cpp")

[Compiler support](../../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../../freestanding.html "cpp/freestanding")  
[Language](../../language.html "cpp/language")  
[Standard library](../../standard_library.html "cpp/standard library")  
[Standard library headers](../../headers.html "cpp/header")  
[Named requirements](../../iterator/concepts.html "cpp/named req")  
[Feature test macros](../../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../../utility.html#Language_support "cpp/utility")  
[Concepts library](../../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../../error.html "cpp/error")  
[Memory management library](../../memory.html "cpp/memory")  
[Metaprogramming library](../../meta.html "cpp/meta") (C++11)  
[General utilities library](../../utility.html "cpp/utility")  
[Containers library](../../container.html "cpp/container")  
[Iterators library](../../iterator.html "cpp/iterator")  
[Ranges library](../../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../../algorithm.html "cpp/algorithm")  
[Strings library](../../string.html "cpp/string")  
[Text processing library](../../text.html "cpp/text")  
[Numerics library](../../numeric.html "cpp/numeric")  
[Date and time library](../../chrono.html "cpp/chrono")  
[Input/output library](../../io.html "cpp/io")  
[Filesystem library](../../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../../atomic.html "cpp/thread") (C++11)  
[Execution control library](../../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../../experimental.html "cpp/experimental")  
[Symbols index](../../symbol_index.html "cpp/symbol index")  
[External libraries](../../links/libs.html "cpp/links/libs")  
  


[Text processing library](../../text.html "cpp/text")

[Localization library](../../locale.html "cpp/locale")  
---  
[Regular expressions library](../../regex.html "cpp/regex") (C++11)  
[Formatting library](../../utility/format.html "cpp/utility/format") (C++20)  
[Null-terminated sequence utilities](../../text.html#Null-terminated_sequence_utilities "cpp/text")  
[Byte strings](../../string/byte.html "cpp/string/byte")  
[Multibyte strings](../../string/multibyte.html "cpp/string/multibyte")  
[Wide strings](../../string/wide.html "cpp/string/wide")  
[Primitive numeric conversions](../../text.html#Primitive_numeric_conversions "cpp/text")  
| [to_chars](../../utility/to_chars.html "cpp/utility/to chars")(C++17)  
---  
[to_chars_result](../../utility/to_chars_result.html "cpp/utility/to chars result")(C++17)  
[from_chars](../../utility/from_chars.html "cpp/utility/from chars")(C++17)  
[from_chars_result](../../utility/from_chars_result.html "cpp/utility/from chars result")(C++17)  
[chars_format](../../utility/chars_format.html "cpp/utility/chars format")(C++17)  
  
[Text encoding identifications](../../text.html#Text_encoding_identifications "cpp/text")  
| [text_encoding](../text_encoding.html "cpp/text/text encoding")(C++26)  
---  
  


[Localization library](../../locale.html "cpp/locale")

| [Locales and facets](../../locale.html#Locales_and_facets "cpp/locale")` `  
---  
[Locales](../../locale.html#Locales "cpp/locale")  
[has_facet](../has_facet.html "cpp/locale/has facet")  
[use_facet](../use_facet.html "cpp/locale/use facet")  
[locale](../locale.html "cpp/locale/locale")  
[Facet category  
base classes](../../locale.html#Facet_category_base_classes "cpp/locale")  
[ctype_base](../ctype_base.html "cpp/locale/ctype base")  
[codecvt_base](../codecvt_base.html "cpp/locale/codecvt base")  
[messages_base](../messages_base.html "cpp/locale/messages base")  
[time_base](../time_base.html "cpp/locale/time base")  
[money_base](../money_base.html "cpp/locale/money base")  
[ctype facets](../../locale.html#ctype_facets "cpp/locale")  
[ctype](../ctype.html "cpp/locale/ctype")  
[ctype<char>](../ctype_char.html "cpp/locale/ctype char")  
[ctype_byname](../ctype_byname.html "cpp/locale/ctype byname")  
[codecvt](../codecvt.html "cpp/locale/codecvt")  
[codecvt_byname](../codecvt_byname.html "cpp/locale/codecvt byname")  
[numeric facets](../../locale.html#numeric_facets "cpp/locale")  
[num_get](../num_get.html "cpp/locale/num get")  
[num_put](../num_put.html "cpp/locale/num put")  
[numpunct](../numpunct.html "cpp/locale/numpunct")  
[numpunct_byname](../numpunct_byname.html "cpp/locale/numpunct byname")  
[collate facets](../../locale.html#collate_facets "cpp/locale")  
[collate](../collate.html "cpp/locale/collate")  
[collate_byname](../collate_byname.html "cpp/locale/collate byname")  
[time facets](../../locale.html#time_facets "cpp/locale")  
[time_get](../time_get.html "cpp/locale/time get")  
[time_put](../time_put.html "cpp/locale/time put")  
[time_get_byname](../time_get_byname.html "cpp/locale/time get byname")  
[time_put_byname](../time_put_byname.html "cpp/locale/time put byname")  
  
| [monetary facets](../../locale.html#monetary_facets "cpp/locale")  
---  
[money_get](../money_get.html "cpp/locale/money get")  
[money_put](../money_put.html "cpp/locale/money put")  
[moneypunct](../moneypunct.html "cpp/locale/moneypunct")  
[moneypunct_byname](../moneypunct_byname.html "cpp/locale/moneypunct byname")  
[messages facets](../../locale.html#messages_facets "cpp/locale")  
[messages](../messages.html "cpp/locale/messages")  
[messages_byname](../messages_byname.html "cpp/locale/messages byname")  
[Character classification and conversion](../../locale.html#Character_classification_and_conversion "cpp/locale")  
[Character classification](../../locale.html#Character_classification "cpp/locale")  
|  | [isspace](../isspace.html "cpp/locale/isspace")` `  
---  
[iscntrl](../iscntrl.html "cpp/locale/iscntrl")  
[isupper](../isupper.html "cpp/locale/isupper")  
  
| [islower](../islower.html "cpp/locale/islower")` `  
---  
[isalpha](../isalpha.html "cpp/locale/isalpha")  
[ispunct](../ispunct.html "cpp/locale/ispunct")  
  
| [isdigit](../isdigit.html "cpp/locale/isdigit")` `  
---  
[isxdigit](../isxdigit.html "cpp/locale/isxdigit")  
[isalnum](../isalnum.html "cpp/locale/isalnum")  
  
| [isblank](../isblank.html "cpp/locale/isblank")(C++11)  
---  
[isprint](../isprint.html "cpp/locale/isprint")  
[isgraph](../isgraph.html "cpp/locale/isgraph")  
  
[Character conversions](../../locale.html#Character_conversions "cpp/locale")  
|  | [toupper](../toupper.html "cpp/locale/toupper")` `  
---  
  
| [tolower](../tolower.html "cpp/locale/tolower")  
---  
  
[String and stream conversions](../../locale.html#String_and_stream_conversions "cpp/locale")  
[wstring_convert](../wstring_convert.html "cpp/locale/wstring convert")(C++11/17/26*)  
[wbuffer_convert](../wbuffer_convert.html "cpp/locale/wbuffer convert")(C++11/17/26*)  
[Unicode conversion facets](../../locale.html#Locale-independent_unicode_conversion_facets "cpp/locale")  
[codecvt_utf8](../codecvt_utf8.html "cpp/locale/codecvt utf8")(C++11/17/26*)  
[codecvt_utf16](../codecvt_utf16.html "cpp/locale/codecvt utf16")(C++11/17/26*)  
[codecvt_utf8_utf16](../codecvt_utf8_utf16.html "cpp/locale/codecvt utf8 utf16")(C++11/17/26*)  
[codecvt_mode](../codecvt_mode.html "cpp/locale/codecvt mode")(C++11/17/26*)  
[C library locales](../../locale.html#C_library_locales "cpp/locale")  
|  | [LC_ALLLC_COLLATELC_CTYPELC_MONETARYLC_NUMERICLC_TIME](../LC_categories.html "cpp/locale/LC categories")` `  
---  
  
| [setlocale](../setlocale.html "cpp/locale/setlocale")  
---  
[localeconv](../localeconv.html "cpp/locale/localeconv")  
[lconv](../lconv.html "cpp/locale/lconv")  
  
  
  
  
  
  
  


[`std::num_put`](../num_put.html "cpp/locale/num put")

Member functions  
---  
[num_put::num_put](num_put.html "cpp/locale/num put/num put")  
[num_put::~num_put](~num_put.html "cpp/locale/num put/~num put")  
**num_put::put num_put::do_put**  
  


Defined in header `[<locale>](../../header/locale.html "cpp/header/locale")` |  |   
---|---|---  
| (1) |   
public:  
iter_type put( iter_type out, [std::ios_base](../../io/ios_base.html)& str,  
char_type fill, bool val ) const; |  |   
iter_type put( iter_type out, [std::ios_base](../../io/ios_base.html)& str,  
char_type fill, long val ) const; |  |   
iter_type put( iter_type out, [std::ios_base](../../io/ios_base.html)& str,  
char_type fill, long long val ) const; |  |  (since C++11)  
iter_type put( iter_type out, [std::ios_base](../../io/ios_base.html)& str,  
char_type fill, unsigned long val ) const; |  |   
iter_type put( iter_type out, [std::ios_base](../../io/ios_base.html)& str,  
char_type fill, unsigned long long val ) const; |  |  (since C++11)  
iter_type put( iter_type out, [std::ios_base](../../io/ios_base.html)& str,  
char_type fill, double val ) const; |  |   
iter_type put( iter_type out, [std::ios_base](../../io/ios_base.html)& str,  
char_type fill, long double val ) const; |  |   
iter_type put( iter_type out, [std::ios_base](../../io/ios_base.html)& str,  
char_type fill, const void* val ) const; |  |   
| (2) |   
protected:  
virtual iter_type do_put( iter_type out, [std::ios_base](../../io/ios_base.html)& str,  
char_type fill, bool val ) const; |  |   
virtual iter_type do_put( iter_type out, [std::ios_base](../../io/ios_base.html)& str,  
char_type fill, long val ) const; |  |   
virtual iter_type do_put( iter_type out, [std::ios_base](../../io/ios_base.html)& str,  
char_type fill, long long val ) const; |  |  (since C++11)  
virtual iter_type do_put( iter_type out, [std::ios_base](../../io/ios_base.html)& str,  
char_type fill, unsigned long val ) const; |  |   
virtual iter_type do_put( iter_type out, [std::ios_base](../../io/ios_base.html)& str,  
char_type fill, unsigned long long val ) const; |  |  (since C++11)  
virtual iter_type do_put( iter_type out, [std::ios_base](../../io/ios_base.html)& str,  
char_type fill, double val ) const; |  |   
virtual iter_type do_put( iter_type out, [std::ios_base](../../io/ios_base.html)& str,  
char_type fill, long double val ) const; |  |   
virtual iter_type do_put( iter_type out, [std::ios_base](../../io/ios_base.html)& str,  
char_type fill, const void* val ) const; |  |   
| |   
  
1) Public member function, calls the protected virtual member function `do_put` of the most derived class.

2) Writes characters to the output sequence out which represent the value of val, formatted as requested by the formatting flags str.flags() and the [std::numpunct](../numpunct.html "cpp/locale/numpunct") and [std::ctype](../ctype.html "cpp/locale/ctype") facets of the locale imbued in the stream str. This function is called by all formatted output stream operators, such as [std::cout](../../io/cout.html) << n;.

Conversion occurs in four stages: 

## Contents

  * [1 Stage 1: conversion specifier selection](put.html#Stage_1:_conversion_specifier_selection)
  * [2 Stage 2: locale-specific conversion](put.html#Stage_2:_locale-specific_conversion)
  * [3 Stage 3: padding](put.html#Stage_3:_padding)
  * [4 Stage 4: output](put.html#Stage_4:_output)
  * [5 Parameters](put.html#Parameters)
  * [6 Return value](put.html#Return_value)
  * [7 Notes](put.html#Notes)
  * [8 Example](put.html#Example)
  * [9 Defect reports](put.html#Defect_reports)
  * [10 See also](put.html#See_also)

  
---  
  
#### Stage 1: conversion specifier selection

  * I/O format flags are obtained, as if by 



     fmtflags basefield = (str.flags() & [std::ios_base::basefield](../../io/ios_base/fmtflags.html));
     fmtflags uppercase = (str.flags() & [std::ios_base::uppercase](../../io/ios_base/fmtflags.html));
     fmtflags floatfield = (str.flags() & [std::ios_base::floatfield](../../io/ios_base/fmtflags.html));
     fmtflags showpos = (str.flags() & [std::ios_base::showpos](../../io/ios_base/fmtflags.html));
     fmtflags showbase = (str.flags() & [std::ios_base::showbase](../../io/ios_base/fmtflags.html));
     fmtflags showpoint = (str.flags() & [std::ios_base::showpoint](../../io/ios_base/fmtflags.html));

  * If the type of val is bool: 
    * If boolalpha == 0, then converts val to type int and performs integer output. 
    * If boolalpha != 0, obtains [std::use_facet](../use_facet.html)<[std::numpunct](../numpunct.html)<CharT>>(str.getloc()).truename() if val == true or [std::use_facet](../use_facet.html)<[std::numpunct](../numpunct.html)<CharT>>(str.getloc()).falsename() if val == false, and outputs each successive character c of that string to out with *out++ = c. No further processing is done in this case, the function returns out. 
  * If the type of val is an integer type, the first applicable choice of the following is selected: 
    * If basefield == oct, will use conversion specifier %o. 
    * If basefield == hex && !uppercase, will use conversion specifier %x. 
    * If basefield == hex, will use conversion specifier %X. 
    * If the type of val is signed, will use conversion specifier %d. 
    * If the type of val is unsigned, will use conversion specifier %u. 
  * For integer types, length modifier is added to the conversion specification if necessary: l for long and unsigned long, ll for long long and unsigned long long(since C++11). 
  * If the type of val is a floating-point type, the first applicable choice of the following is selected: 



    

  * If floatfield == [std::ios_base::fixed](../../io/ios_base/fmtflags.html), will use conversion specifier %f. 


| (until C++11)  
---|---  
  
    

  * If floatfield == [std::ios_base::fixed](../../io/ios_base/fmtflags.html) && !uppercase, will use conversion specifier %f. 
  * If floatfield == [std::ios_base::fixed](../../io/ios_base/fmtflags.html), will use conversion specifier %F. 


| (since C++11)  
  
    

  * If floatfield == [std::ios_base::scientific](../../io/ios_base/fmtflags.html) && !uppercase, will use conversion specifier %e. 
  * If floatfield == [std::ios_base::scientific](../../io/ios_base/fmtflags.html), will use conversion specifier %E. 



    

  * If floatfield == ([std::ios_base::fixed](../../io/ios_base/fmtflags.html) | [std::ios_base::scientific](../../io/ios_base/fmtflags.html)) && !uppercase, will use conversion specifier %a. 
  * If floatfield == ([std::ios_base::fixed](../../io/ios_base/fmtflags.html) | [std::ios_base::scientific](../../io/ios_base/fmtflags.html)), will use conversion specifier %A. 


| (since C++11)  
---|---  
  
    

  * If !uppercase, will use conversion specifier %g. 
  * Otherwise, will use conversion specifier %G. 


     Also: 

  * If the type of val is long double, the length modifier L is added to the conversion specifier. 
  * If the type of val is a floating-point type and floatfield != (ios_base::fixed | ios_base::scientific)(since C++11), the precision modifier is added and set to str.precision(). Otherwise, no precision is specified. 



  * For both integer and floating-point types, if showpos is set, the modifier + is prepended. 
  * For integer types, if showbase is set, the modifier # is prepended. 
  * For floating-point types, if showpoint is set, the modifier # is prepended. 
  * If the type of val is void*, will use conversion specifier %p
  * A narrow character string is created as if by a call to [std::printf](../../io/c/fprintf.html)(spec, val) in the "C" locale, where spec is the chosen conversion specifier. 



#### Stage 2: locale-specific conversion

  * Every character c obtained in Stage 1, other than the decimal point '.', is converted to `CharT` by calling [std::use_facet](../use_facet.html)<[std::ctype](../ctype.html)<CharT>>(str.getloc()).widen(c). 
  * For arithmetic types, the thousands separator character, obtained from [std::use_facet](../use_facet.html)<[std::numpunct](../numpunct.html)<CharT>>(str.getloc()).thousands_sep(), is inserted into the sequence according to the grouping rules provided by [std::use_facet](../use_facet.html)<[std::numpunct](../numpunct.html)<CharT>>(str.getloc()).grouping(). 
  * Decimal point characters ('.') are replaced by [std::use_facet](../use_facet.html)<[std::numpunct](../numpunct.html)<CharT>>(str.getloc()).decimal_point(). 



#### Stage 3: padding

  * The adjustment flag is obtained as if by std::fmtflags adjustfield = (flags & ([std::ios_base::adjustfield](../../io/ios_base/fmtflags.html))) and examined to identify padding location, as follows: 
    * If adjustfield == [std::ios_base::left](../../io/ios_base/fmtflags.html), will pad after. 
    * If adjustfield == [std::ios_base::right](../../io/ios_base/fmtflags.html), will pad before. 
    * If adjustfield == [std::ios_base::internal](../../io/ios_base/fmtflags.html) and a sign character occurs in the representation, will pad after the sign. 
    * If adjustfield == [std::ios_base::internal](../../io/ios_base/fmtflags.html) and Stage 1 representation began with 0x or 0X, will pad after the x or X. 
    * Otherwise, will pad before. 
  * If str.width() is non-zero (e.g. [std::setw](../../io/manip/setw.html "cpp/io/manip/setw") was just used) and the number of `CharT`'s after Stage 2 is less than str.width(), then copies of the fill character are inserted at the position indicated by padding to bring the length of the sequence to str.width(). 



In any case, str.width(0) is called to cancel the effects of [std::setw](../../io/manip/setw.html "cpp/io/manip/setw"). 

#### Stage 4: output

Every successive character c from the sequence of `CharT`'s from Stage 3 is output as if by *out++ = c. 

### Parameters

out  |  \-  |  iterator pointing to the first character to be overwritten   
---|---|---  
str  |  \-  |  stream to retrieve the formatting information from   
fill  |  \-  |  padding character used when the results needs to be padded to the field width   
val  |  \-  |  value to convert to string and output   
  
### Return value

out

### Notes

The leading zero generated by the conversion specification #o (resulting from the combination of [std::showbase](../../io/manip/showbase.html "cpp/io/manip/showbase") and [std::oct](../../io/manip/hex.html "cpp/io/manip/hex") for example) is not counted as a padding character. 

When formatting a floating point value as hexfloat (i.e., when floatfield == ([std::ios_base::fixed](../../io/ios_base/fmtflags.html) | [std::ios_base::scientific](../../io/ios_base/fmtflags.html))), the stream's precision is not used; instead, the number is always printed with enough precision to exactly represent the value.  | (since C++11)  
---|---  
  
### Example

Output a number using the facet directly, and demonstrate user-defined facet:

Run this code
    
    
    #include <iostream>
    #include <locale>
     
    // this custom num_put outputs squares of all integers (except long long)
    struct squaring_num_put : [std::num_put](../num_put.html)<char>
    {
        iter_type do_put(iter_type out, [std::ios_base](../../io/ios_base.html)& str,
                         char_type fill, long val) const
        {
            return [std::num_put](../num_put.html)<char>::do_put(out, str, fill, val * val);
        }
     
        iter_type do_put(iter_type out, [std::ios_base](../../io/ios_base.html)& str,
                         char_type fill, unsigned long val) const
        {
            return [std::num_put](../num_put.html)<char>::do_put(out, str, fill, val * val);
        }
    };
     
    int main()
    {
        auto& facet = [std::use_facet](../use_facet.html)<[std::num_put](../num_put.html)<char>>([std::locale](../locale.html)());
        facet.put([std::cout](../../io/cout.html), [std::cout](../../io/cout.html), '0', 2.71);
        [std::cout](../../io/cout.html) << '\n';
     
        [std::cout](../../io/cout.html).imbue([std::locale](../locale.html)([std::cout](../../io/cout.html).getloc(), new squaring_num_put));
        [std::cout](../../io/cout.html) << 6 << ' ' << -12 << '\n';
    }

Output: 
    
    
    2.71
    36 144

An implementation of operator<< for a user-defined type.

Run this code
    
    
    #include <iostream>
    #include <iterator>
    #include <locale>
     
    struct base { long x = 10; };
     
    template<class CharT, class Traits>
    [std::basic_ostream](../../io/basic_ostream.html)<CharT, Traits>&
        operator<<([std::basic_ostream](../../io/basic_ostream.html)<CharT, Traits>& os, const base& b)
    {
        try
        {
            typename [std::basic_ostream](../../io/basic_ostream.html)<CharT, Traits>::sentry s(os);
     
            if (s)
            {
                [std::ostreambuf_iterator](../../iterator/ostreambuf_iterator.html)<CharT, Traits> it(os);
                [std::use_facet](../use_facet.html)<[std::num_put](../num_put.html)<CharT>>(os.getloc())
                    .put(it, os, os.fill(), b.x);
            }
        }
        catch (...)
        {
            // set badbit on os and rethrow if required
        }
     
        return os;
    }
     
    int main()
    {
        base b;
        [std::cout](../../io/cout.html) << b;
    }

Output: 
    
    
    10

### Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[LWG 34](https://cplusplus.github.io/LWG/issue34) | C++98  | the bool overload used non-existing members  
truename and falsename of [std::ctype](../ctype.html "cpp/locale/ctype") | use these members  
of [std::numpunct](../numpunct.html "cpp/locale/numpunct")  
[LWG 231](https://cplusplus.github.io/LWG/issue231) | C++98  | the precision modifier was only added if  
(flags & fixed) != 0 or str.precision() > 0 | removed these conditions   
[LWG 282](https://cplusplus.github.io/LWG/issue282) | C++98  | the thousand separators were only  
inserted for integral types in stage 2  | also inserted for  
floating-point types   
[LWG 4084](https://cplusplus.github.io/LWG/issue4084) | C++11  | "NAN" and "INF" could not be printed  | they can be printed   
  
### See also

[ operator<<](../../io/basic_ostream/operator_ltlt.html "cpp/io/basic ostream/operator ltlt") |  inserts formatted data   
(public member function of `std::basic_ostream<CharT,Traits>`)   
---|---
