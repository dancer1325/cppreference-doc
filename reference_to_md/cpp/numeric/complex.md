
  


[Numerics library](../numeric.html "cpp/numeric")

[Common mathematical functions](math.html "cpp/numeric/math")  
---  
[Mathematical special functions](special_math.html "cpp/numeric/special functions") (C++17)  
[Mathematical constants](constants.html "cpp/numeric/constants") (C++20)  
[Basic linear algebra algorithms](linalg.html "cpp/numeric/linalg") (C++26)  
[Data-parallel types (SIMD)](simd.html "cpp/numeric/simd") (C++26)  
[Floating-point environment](fenv.html "cpp/numeric/fenv") (C++11)  
**Complex numbers**  
[Numeric array (`valarray`)](valarray.html "cpp/numeric/valarray")  
[Pseudo-random number generation](random.html "cpp/numeric/random")  
[Bit manipulation](../utility/bit.html "cpp/utility/bit") (C++20)  
[Saturation arithmetic](../numeric.html#Saturation_arithmetic "cpp/numeric") (C++26)  
[Factor operations](../numeric.html#Factor_operations "cpp/numeric")  
| [gcd](gcd.html "cpp/numeric/gcd")(C++17)  
---  
  
| [lcm](lcm.html "cpp/numeric/lcm")(C++17)  
---  
  
[Interpolations](../numeric.html#Interpolation_operations "cpp/numeric")  
| [midpoint](midpoint.html "cpp/numeric/midpoint")(C++20)  
---  
  
| [lerp](lerp.html "cpp/numeric/lerp")(C++20)  
---  
  
[Generic numeric operations](../numeric.html#Numeric_operations "cpp/numeric")  
| [iota](../algorithm/iota.html "cpp/algorithm/iota")(C++11)  
---  
[ranges::iota](../algorithm/ranges/iota.html "cpp/algorithm/ranges/iota")(C++23)  
[accumulate](../algorithm/accumulate.html "cpp/algorithm/accumulate")  
[inner_product](../algorithm/inner_product.html "cpp/algorithm/inner product")  
[adjacent_difference](../algorithm/adjacent_difference.html "cpp/algorithm/adjacent difference")` `  
[partial_sum](../algorithm/partial_sum.html "cpp/algorithm/partial sum")  
  
| [reduce](../algorithm/reduce.html "cpp/algorithm/reduce")(C++17)  
---  
[transform_reduce](../algorithm/transform_reduce.html "cpp/algorithm/transform reduce")(C++17)  
[inclusive_scan](../algorithm/inclusive_scan.html "cpp/algorithm/inclusive scan")(C++17)  
[exclusive_scan](../algorithm/exclusive_scan.html "cpp/algorithm/exclusive scan")(C++17)  
[transform_inclusive_scan](../algorithm/transform_inclusive_scan.html "cpp/algorithm/transform inclusive scan")(C++17)  
[transform_exclusive_scan](../algorithm/transform_exclusive_scan.html "cpp/algorithm/transform exclusive scan")(C++17)  
  
[C-style checked integer arithmetic](../numeric.html#Checked_integer_arithmetic "cpp/numeric")  
| [ckd_add](ckd_add.html "cpp/numeric/ckd add")(C++26)  
---  
[ckd_sub](ckd_sub.html "cpp/numeric/ckd sub")(C++26)  
  
| [ckd_mul](ckd_mul.html "cpp/numeric/ckd mul")(C++26)  
---  
  
  
  


**`std::complex`**

[Member functions](complex.html#Member_functions "cpp/numeric/complex")  
---  
| [complex::complex](complex/complex.html "cpp/numeric/complex/complex")  
---  
[complex::operator=](complex/operator=.html "cpp/numeric/complex/operator=")  
[complex::real](complex/real.html "cpp/numeric/complex/real")  
[complex::imag](complex/imag.html "cpp/numeric/complex/imag")  
  
| [complex::operator+=complex::operator-=complex::operator*=complex::operator/=](complex/operator_arith.html "cpp/numeric/complex/operator arith")  
---  
  
[Non-member functions](complex.html#Non-member_functions "cpp/numeric/complex")  
| [operator+operator-](complex/operator_arith2.html "cpp/numeric/complex/operator arith2")  
---  
[operator+operator-operator*operator/](complex/operator_arith3.html "cpp/numeric/complex/operator arith3")  
[operator==operator!=](complex/operator_cmp.html "cpp/numeric/complex/operator cmp")(until C++20)  
[operator<<operator>>](complex/operator_ltltgtgt.html "cpp/numeric/complex/operator ltltgtgt")  
[get(std::complex)](complex/get.html "cpp/numeric/complex/get")(C++26)` `  
  
| [real](complex/real2.html "cpp/numeric/complex/real2")  
---  
[imag](complex/imag2.html "cpp/numeric/complex/imag2")  
[abs](complex/abs.html "cpp/numeric/complex/abs")  
[arg](complex/arg.html "cpp/numeric/complex/arg")  
[norm](complex/norm.html "cpp/numeric/complex/norm")  
[conj](complex/conj.html "cpp/numeric/complex/conj")  
[proj](complex/proj.html "cpp/numeric/complex/proj")(C++11)  
[polar](complex/polar.html "cpp/numeric/complex/polar")  
[operator""ioperator""ifoperator""il](complex/operator""i.html "cpp/numeric/complex/operator""i")(C++14)(C++14)(C++14)  
  
[Exponential functions](complex.html#Exponential_functions "cpp/numeric/complex")  
|  | [log](complex/log.html "cpp/numeric/complex/log")` `  
---  
  
| [log10](complex/log10.html "cpp/numeric/complex/log10")` `  
---  
  
| [exp](complex/exp.html "cpp/numeric/complex/exp")  
---  
  
[Power functions](complex.html#Power_functions "cpp/numeric/complex")  
|  | [pow](complex/pow.html "cpp/numeric/complex/pow")` `  
---  
  
| [sqrt](complex/sqrt.html "cpp/numeric/complex/sqrt")  
---  
  
[Trigonometric functions](complex.html#Trigonometric_functions "cpp/numeric/complex")  
|  | [sin](complex/sin.html "cpp/numeric/complex/sin")` `  
---  
[cos](complex/cos.html "cpp/numeric/complex/cos")  
[tan](complex/tan.html "cpp/numeric/complex/tan")  
  
| [asin](complex/asin.html "cpp/numeric/complex/asin")(C++11)  
---  
[acos](complex/acos.html "cpp/numeric/complex/acos")(C++11)  
[atan](complex/atan.html "cpp/numeric/complex/atan")(C++11)  
  
[Hyperbolic functions](complex.html#Hyperbolic_functions "cpp/numeric/complex")  
|  | [sinh](complex/sinh.html "cpp/numeric/complex/sinh")` `  
---  
[cosh](complex/cosh.html "cpp/numeric/complex/cosh")  
[tanh](complex/tanh.html "cpp/numeric/complex/tanh")  
  
| [asinh](complex/asinh.html "cpp/numeric/complex/asinh")(C++11)  
---  
[acosh](complex/acosh.html "cpp/numeric/complex/acosh")(C++11)  
[atanh](complex/atanh.html "cpp/numeric/complex/atanh")(C++11)  
  
[Helper types](complex.html#Helper_types "cpp/numeric/complex")  
[tuple_size<std::complex>](complex/tuple_size.html "cpp/numeric/complex/tuple size")(C++26)  
[tuple_element<std::complex>](complex/tuple_element.html "cpp/numeric/complex/tuple element")(C++26)  
  


Defined in header `[<complex>](../header/complex.html "cpp/header/complex")` |  |   
---|---|---  
template< class T >  
class complex; |  (1)  |   
template<> class complex<float>; |  (2)  |  (until C++23)  
template<> class complex<double>; |  (3)  |  (until C++23)  
template<> class complex<long double>; |  (4)  |  (until C++23)  
| |   
  
Specializations of `std::complex` for cv-unqualified standard(until C++23) [floating-point types](../language/types.html#Floating-point_types "cpp/language/types") are [TriviallyCopyable](../named_req/TriviallyCopyable.html "cpp/named req/TriviallyCopyable")(since C++23) [LiteralTypes](../named_req/LiteralType.html "cpp/named req/LiteralType") for representing and manipulating [complex number](https://en.wikipedia.org/wiki/complex_number "enwiki:complex number"). 

## Contents

  * [1 Template parameters](complex.html#Template_parameters)
  * [2 Member types](complex.html#Member_types)
  * [3 Member functions](complex.html#Member_functions)
  * [4 Non-member functions](complex.html#Non-member_functions)
    * [4.1 Exponential functions](complex.html#Exponential_functions)
    * [4.2 Power functions](complex.html#Power_functions)
    * [4.3 Trigonometric functions](complex.html#Trigonometric_functions)
    * [4.4 Hyperbolic functions](complex.html#Hyperbolic_functions)
  * [5 Helper types](complex.html#Helper_types)
  * [6 Array-oriented access](complex.html#Array-oriented_access)
  * [7 Implementation notes](complex.html#Implementation_notes)
  * [8 Literals](complex.html#Literals)
  * [9 Notes](complex.html#Notes)
  * [10 Example](complex.html#Example)
  * [11 Defect reports](complex.html#Defect_reports)
  * [12 See also](complex.html#See_also)

  
---  
  
### Template parameters

T  |  \-  |  the type of the real and imaginary parts. The behavior is unspecified (and may fail to compile) if `T` is not a cv-unqualified standard(until C++23) floating-point type and undefined if `T` is not [NumericType](../named_req/NumericType.html "cpp/named req/NumericType").   
---|---|---  
  
### Member types

Member type  |  Definition   
---|---  
`value_type` |  `T`  
  
### Member functions

[ (constructor)](complex/complex.html "cpp/numeric/complex/complex") |  constructs a complex number   
(public member function)   
---|---  
[ operator=](complex/operator=.html "cpp/numeric/complex/operator=") |  assigns the contents   
(public member function)   
[ real](complex/real.html "cpp/numeric/complex/real") |  accesses the real part of the complex number   
(public member function)   
[ imag](complex/imag.html "cpp/numeric/complex/imag") |  accesses the imaginary part of the complex number   
(public member function)   
[ operator+=operator-=operator*=operator/=](complex/operator_arith.html "cpp/numeric/complex/operator arith") |  compound assignment of two complex numbers or a complex and a scalar   
(public member function)   
  
### Non-member functions

[ operator+operator-](complex/operator_arith2.html "cpp/numeric/complex/operator arith2") |  applies unary operators to complex numbers   
(function template)   
---|---  
[ operator+operator-operator*operator/](complex/operator_arith3.html "cpp/numeric/complex/operator arith3") |  performs complex number arithmetic on two complex values or a complex and a scalar   
(function template)   
[ operator==operator!=](complex/operator_cmp.html "cpp/numeric/complex/operator cmp")(removed in C++20) |  compares two complex numbers or a complex and a scalar   
(function template)   
[ operator<<operator>>](complex/operator_ltltgtgt.html "cpp/numeric/complex/operator ltltgtgt") |  serializes and deserializes a complex number   
(function template)   
[ get(std::complex)](complex/get.html "cpp/numeric/complex/get")(C++26) |  obtains a reference to real or imaginary part from a **std::complex**   
(function template)   
[ real](complex/real2.html "cpp/numeric/complex/real2") |  returns the real part   
(function template)   
[ imag](complex/imag2.html "cpp/numeric/complex/imag2") |  returns the imaginary part   
(function template)   
[ abs(std::complex)](complex/abs.html "cpp/numeric/complex/abs") |  returns the magnitude of a complex number   
(function template)   
[ arg](complex/arg.html "cpp/numeric/complex/arg") |  returns the phase angle   
(function template)   
[ norm](complex/norm.html "cpp/numeric/complex/norm") |  returns the squared magnitude   
(function template)   
[ conj](complex/conj.html "cpp/numeric/complex/conj") |  returns the complex conjugate   
(function template)   
[ proj](complex/proj.html "cpp/numeric/complex/proj")(C++11) |  returns the projection onto the Riemann sphere   
(function template)   
[ polar](complex/polar.html "cpp/numeric/complex/polar") |  constructs a complex number from magnitude and phase angle   
(function template)   
  
#####  Exponential functions   
  
[ exp(std::complex)](complex/exp.html "cpp/numeric/complex/exp") |  complex base _e_ exponential   
(function template)   
[ log(std::complex)](complex/log.html "cpp/numeric/complex/log") |  complex natural logarithm with the branch cuts along the negative real axis   
(function template)   
[ log10(std::complex)](complex/log10.html "cpp/numeric/complex/log10") |  complex common logarithm with the branch cuts along the negative real axis   
(function template)   
  
#####  Power functions   
  
[ pow(std::complex)](complex/pow.html "cpp/numeric/complex/pow") |  complex power, one or both arguments may be a complex number   
(function template)   
[ sqrt(std::complex)](complex/sqrt.html "cpp/numeric/complex/sqrt") |  complex square root in the range of the right half-plane   
(function template)   
  
#####  Trigonometric functions   
  
[ sin(std::complex)](complex/sin.html "cpp/numeric/complex/sin") |  computes sine of a complex number (\\({\small\sin{z}}\\)sin(z))   
(function template)   
[ cos(std::complex)](complex/cos.html "cpp/numeric/complex/cos") |  computes cosine of a complex number (\\({\small\cos{z}}\\)cos(z))   
(function template)   
[ tan(std::complex)](complex/tan.html "cpp/numeric/complex/tan") |  computes tangent of a complex number (\\({\small\tan{z}}\\)tan(z))   
(function template)   
[ asin(std::complex)](complex/asin.html "cpp/numeric/complex/asin")(C++11) |  computes arc sine of a complex number (\\({\small\arcsin{z}}\\)arcsin(z))   
(function template)   
[ acos(std::complex)](complex/acos.html "cpp/numeric/complex/acos")(C++11) |  computes arc cosine of a complex number (\\({\small\arccos{z}}\\)arccos(z))   
(function template)   
[ atan(std::complex)](complex/atan.html "cpp/numeric/complex/atan")(C++11) |  computes arc tangent of a complex number (\\({\small\arctan{z}}\\)arctan(z))   
(function template)   
  
#####  Hyperbolic functions   
  
[ sinh(std::complex)](complex/sinh.html "cpp/numeric/complex/sinh") |  computes hyperbolic sine of a complex number (\\({\small\sinh{z}}\\)sinh(z))   
(function template)   
[ cosh(std::complex)](complex/cosh.html "cpp/numeric/complex/cosh") |  computes hyperbolic cosine of a complex number (\\({\small\cosh{z}}\\)cosh(z))   
(function template)   
[ tanh(std::complex)](complex/tanh.html "cpp/numeric/complex/tanh") |  computes hyperbolic tangent of a complex number (\\({\small\tanh{z}}\\)tanh(z))   
(function template)   
[ asinh(std::complex)](complex/asinh.html "cpp/numeric/complex/asinh")(C++11) |  computes area hyperbolic sine of a complex number (\\({\small\operatorname{arsinh}{z}}\\)arsinh(z))   
(function template)   
[ acosh(std::complex)](complex/acosh.html "cpp/numeric/complex/acosh")(C++11) |  computes area hyperbolic cosine of a complex number (\\({\small\operatorname{arcosh}{z}}\\)arcosh(z))   
(function template)   
[ atanh(std::complex)](complex/atanh.html "cpp/numeric/complex/atanh")(C++11) |  computes area hyperbolic tangent of a complex number (\\({\small\operatorname{artanh}{z}}\\)artanh(z))   
(function template)   
  
### Helper types

[ std::tuple_size<std::complex>](complex/tuple_size.html "cpp/numeric/complex/tuple size")(C++26) |  obtains the size of a **std::complex**   
(class template specialization)   
---|---  
[ std::tuple_element<std::complex>](complex/tuple_element.html "cpp/numeric/complex/tuple element")(C++26) |  obtains the underlying real and imaginary number type of a **std::complex**   
(class template specialization)   
  
### Array-oriented access

For any object z of type `std::complex<T>`, reinterpret_cast<T(&)[2]>(z)[0] is the real part of z and reinterpret_cast<T(&)[2]>(z)[1] is the imaginary part of z. 

For any pointer to an element of an array of `std::complex<T>` named p and any valid array index i, reinterpret_cast<T*>(p)[2 * i] is the real part of the complex number p[i], and reinterpret_cast<T*>(p)[2 * i + 1] is the imaginary part of the complex number p[i]. 

The intent of this requirement is to preserve binary compatibility between the C++ library complex number types and the [C language complex number types](../../c/language/arithmetic_types.html#Complex_floating_types "c/language/arithmetic types") (and arrays thereof), which have an identical object representation requirement. 

### Implementation notes

In order to satisfy the requirements of array-oriented access, an implementation is constrained to store the real and imaginary parts of a `std::complex` specialization in separate and adjacent memory locations. Possible declarations for its non-static data members include: 

  * an array of type `value_type[2]`, with the first element holding the real part and the second element holding the imaginary part (e.g. Microsoft Visual Studio); 
  * a single member of type `value_type _Complex` (encapsulating the corresponding [C language complex number type](../../c/language/arithmetic_types.html#Complex_floating_types "c/language/arithmetic types")) (e.g. GNU libstdc++); 
  * two members of type `value_type`, with the same member access, holding the real and the imaginary parts respectively (e.g. LLVM libc++). 



An implementation cannot declare additional non-static data members that would occupy storage disjoint from the real and imaginary parts, and must ensure that the class template specialization does not contain any [padding bit](../language/objects.html#Object_representation_and_value_representation "cpp/language/object"). The implementation must also ensure that optimizations to array access account for the possibility that a pointer to `value_type` may be aliasing a `std::complex` specialization or array thereof. 

### Literals

Defined in inline namespace `std::literals::complex_literals`  
---  
[ operator""ifoperator""ioperator""il](complex/operator""i.html "cpp/numeric/complex/operator""i")(C++14) |  a **std::complex** literal representing purely imaginary number   
(function)   
  
### Notes

[Feature-test](../utility/feature_test.html "cpp/utility/feature test") macro  | Value | Std | Feature   
---|---|---|---  
[`__cpp_lib_constexpr_complex`](../experimental/feature_test.html#cpp_lib_constexpr_complex "cpp/feature test") | [`201711L`](../compiler_support/20.html#cpp_lib_constexpr_complex_201711L "cpp/compiler support/20") | (C++20) | constexpr simple complex mathematical functions in [`<complex>`](../header/complex.html "cpp/header/complex")  
[`202306L`](../compiler_support/26.html#cpp_lib_constexpr_complex_202306L "cpp/compiler support/26") | (C++26) | More constexpr for [`<complex>`](../header/complex.html "cpp/header/complex")  
[`__cpp_lib_tuple_like`](../experimental/feature_test.html#cpp_lib_tuple_like "cpp/feature test") | [`202311L`](../compiler_support/26.html#cpp_lib_tuple_like_202311L "cpp/compiler support/26") | (C++26) | Add tuple protocol to `std::complex`  
  
### Example

Run this code
    
    
    #include <cmath>
    #include <complex>
    #include <iomanip>
    #include <iostream>
    #include <ranges>
     
    int main()
    {
        using namespace std::complex_literals;
        [std::cout](../io/cout.html) << [std::fixed](../io/manip/fixed.html) << [std::setprecision](../io/manip/setprecision.html)(1);
     
        std::complex<double> z1 = 1i * 1i; // imaginary unit squared
        [std::cout](../io/cout.html) << "i * i = " << z1 << '\n';
     
        std::complex<double> z2 = [std::pow](math/pow.html)(1i, 2); // imaginary unit squared
        [std::cout](../io/cout.html) << "pow(i, 2) = " << z2 << '\n';
     
        const double PI = [std::acos](math/acos.html)(-1); // or std::numbers::pi in C++20
        std::complex<double> z3 = [std::exp](math/exp.html)(1i * PI); // Euler's formula
        [std::cout](../io/cout.html) << "exp(i * pi) = " << z3 << '\n';
     
        std::complex<double> z4 = 1.0 + 2i, z5 = 1.0 - 2i; // conjugates
        [std::cout](../io/cout.html) << "(1 + 2i) * (1 - 2i) = " << z4 * z5 << '\n';
     
        const auto zz = {0.0 + 1i, 2.0 + 3i, 4.0 + 5i};
    #if __cpp_lib_tuple_like >= 202311L
        for (double re : zz | std::[views::keys](../ranges/keys_view.html))
            [std::cout](../io/cout.html) << re << ' ';
        [std::cout](../io/cout.html) << '\n';
        for (double im : zz | std::[views::values](../ranges/values_view.html))
            [std::cout](../io/cout.html) << im << ' ';
        [std::cout](../io/cout.html) << '\n';
    #else
        for (double re : zz | std::[views::transform](../ranges/transform_view.html)([](auto z){ return z.real(); }))
            [std::cout](../io/cout.html) << re << ' ';
        [std::cout](../io/cout.html) << '\n';
        for (double im : zz | std::[views::transform](../ranges/transform_view.html)([](auto z){ return z.imag(); }))
            [std::cout](../io/cout.html) << im << ' ';
        [std::cout](../io/cout.html) << '\n';
    #endif
    }

Output: 
    
    
    i * i = (-1.0,0.0)
    pow(i, 2) = (-1.0,0.0)
    exp(i * pi) = (-1.0,0.0)
    (1 + 2i) * (1 - 2i) = (5.0,0.0)
    0.0 2.0 4.0
    1.0 3.0 5.0

### Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[LWG 387](https://cplusplus.github.io/LWG/issue387) | C++98  | `std::complex` was not guaranteed to be compatible with C `complex` | guaranteed to be compatible   
  
### See also

[C documentation](../../c/numeric/complex.html "c/numeric/complex") for Complex number arithmetic  
---
  *[Value]: The year/month in which the feature was adopted. The hyperlink under each value opens a compiler support page with entry for given feature.
  *[Std]: Standard in which the feature is introduced; DR means defect report against that revision
