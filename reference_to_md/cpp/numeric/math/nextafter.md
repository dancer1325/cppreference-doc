[C++](../../../cpp.html "cpp")

[Compiler support](../../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../../freestanding.html "cpp/freestanding")  
[Language](../../language.html "cpp/language")  
[Standard library](../../standard_library.html "cpp/standard library")  
[Standard library headers](../../headers.html "cpp/header")  
[Named requirements](../../iterator/concepts.html "cpp/named req")  
[Feature test macros](../../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../../utility.html#Language_support "cpp/utility")  
[Concepts library](../../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../../error.html "cpp/error")  
[Memory management library](../../memory.html "cpp/memory")  
[Metaprogramming library](../../meta.html "cpp/meta") (C++11)  
[General utilities library](../../utility.html "cpp/utility")  
[Containers library](../../container.html "cpp/container")  
[Iterators library](../../iterator.html "cpp/iterator")  
[Ranges library](../../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../../algorithm.html "cpp/algorithm")  
[Strings library](../../string.html "cpp/string")  
[Text processing library](../../text.html "cpp/text")  
[Numerics library](../../numeric.html "cpp/numeric")  
[Date and time library](../../chrono.html "cpp/chrono")  
[Input/output library](../../io.html "cpp/io")  
[Filesystem library](../../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../../atomic.html "cpp/thread") (C++11)  
[Execution control library](../../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../../experimental.html "cpp/experimental")  
[Symbols index](../../symbol_index.html "cpp/symbol index")  
[External libraries](../../links/libs.html "cpp/links/libs")  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/navbar_content&action=edit)

[Numerics library](../../numeric.html "cpp/numeric")

[Common mathematical functions](../math.html "cpp/numeric/math")  
---  
[Mathematical special functions](../special_math.html "cpp/numeric/special functions") (C++17)  
[Mathematical constants](../constants.html "cpp/numeric/constants") (C++20)  
[Basic linear algebra algorithms](../linalg.html "cpp/numeric/linalg") (C++26)  
[Data-parallel types (SIMD)](../simd.html "cpp/numeric/simd") (C++26)  
[Floating-point environment](../fenv.html "cpp/numeric/fenv") (C++11)  
[Complex numbers](../complex.html "cpp/numeric/complex")  
[Numeric array (`valarray`)](../valarray.html "cpp/numeric/valarray")  
[Pseudo-random number generation](../random.html "cpp/numeric/random")  
[Bit manipulation](../../utility/bit.html "cpp/utility/bit") (C++20)  
[Saturation arithmetic](../../numeric.html#Saturation_arithmetic "cpp/numeric") (C++26)  
[Factor operations](../../numeric.html#Factor_operations "cpp/numeric")  
| [gcd](../gcd.html "cpp/numeric/gcd")(C++17)  
---  
  
| [lcm](../lcm.html "cpp/numeric/lcm")(C++17)  
---  
  
[Interpolations](../../numeric.html#Interpolation_operations "cpp/numeric")  
| [midpoint](../midpoint.html "cpp/numeric/midpoint")(C++20)  
---  
  
| [lerp](../lerp.html "cpp/numeric/lerp")(C++20)  
---  
  
[Generic numeric operations](../../numeric.html#Numeric_operations "cpp/numeric")  
| [iota](../../algorithm/iota.html "cpp/algorithm/iota")(C++11)  
---  
[ranges::iota](../../algorithm/ranges/iota.html "cpp/algorithm/ranges/iota")(C++23)  
[accumulate](../../algorithm/accumulate.html "cpp/algorithm/accumulate")  
[inner_product](../../algorithm/inner_product.html "cpp/algorithm/inner product")  
[adjacent_difference](../../algorithm/adjacent_difference.html "cpp/algorithm/adjacent difference")` `  
[partial_sum](../../algorithm/partial_sum.html "cpp/algorithm/partial sum")  
  
| [reduce](../../algorithm/reduce.html "cpp/algorithm/reduce")(C++17)  
---  
[transform_reduce](../../algorithm/transform_reduce.html "cpp/algorithm/transform reduce")(C++17)  
[inclusive_scan](../../algorithm/inclusive_scan.html "cpp/algorithm/inclusive scan")(C++17)  
[exclusive_scan](../../algorithm/exclusive_scan.html "cpp/algorithm/exclusive scan")(C++17)  
[transform_inclusive_scan](../../algorithm/transform_inclusive_scan.html "cpp/algorithm/transform inclusive scan")(C++17)  
[transform_exclusive_scan](../../algorithm/transform_exclusive_scan.html "cpp/algorithm/transform exclusive scan")(C++17)  
  
[C-style checked integer arithmetic](../../numeric.html#Checked_integer_arithmetic "cpp/numeric")  
| [ckd_add](../ckd_add.html "cpp/numeric/ckd add")(C++26)  
---  
[ckd_sub](../ckd_sub.html "cpp/numeric/ckd sub")(C++26)  
  
| [ckd_mul](../ckd_mul.html "cpp/numeric/ckd mul")(C++26)  
---  
  
  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/numeric/navbar_content&action=edit)

[Common mathematical functions](../math.html "cpp/numeric/math")

[Functions](../math.html#Functions "cpp/numeric/math")  
---  
[Basic operations](../math.html#Basic_operations "cpp/numeric/math")  
| [abs(int)labsllabsimaxabs](abs.html "cpp/numeric/math/abs")(C++11)` `  
---  
[abs(float)fabs](fabs.html "cpp/numeric/math/fabs")  
[divldivlldivimaxdiv](div.html "cpp/numeric/math/div")(C++11)  
  
| [fmod](fmod.html "cpp/numeric/math/fmod")  
---  
[remainder](remainder.html "cpp/numeric/math/remainder")(C++11)` `  
[remquo](remquo.html "cpp/numeric/math/remquo")(C++11)  
[fma](fma.html "cpp/numeric/math/fma")(C++11)  
[fmax](fmax.html "cpp/numeric/math/fmax")(C++11)  
[fmin](fmin.html "cpp/numeric/math/fmin")(C++11)  
[fdim](fdim.html "cpp/numeric/math/fdim")(C++11)  
[nannanfnanl](nan.html "cpp/numeric/math/nan")(C++11)(C++11)(C++11)  
  
[Exponential functions](../math.html#Exponential_functions "cpp/numeric/math")  
| [exp](exp.html "cpp/numeric/math/exp")  
---  
[exp2](exp2.html "cpp/numeric/math/exp2")(C++11)  
[expm1](expm1.html "cpp/numeric/math/expm1")(C++11)  
  
  
  
| [log](log.html "cpp/numeric/math/log")  
---  
[log10](log10.html "cpp/numeric/math/log10")  
[log1p](log1p.html "cpp/numeric/math/log1p")(C++11)  
[log2](log2.html "cpp/numeric/math/log2")(C++11)  
  
[Power functions](../math.html#Power_functions "cpp/numeric/math")  
| [sqrt](sqrt.html "cpp/numeric/math/sqrt")  
---  
[cbrt](cbrt.html "cpp/numeric/math/cbrt")(C++11)  
  
| [hypot](hypot.html "cpp/numeric/math/hypot")(C++11)  
---  
[pow](pow.html "cpp/numeric/math/pow")  
  
[Trigonometric](../math.html#Trigonometric_functions "cpp/numeric/math") and   
[hyperbolic functions](../math.html#Hyperbolic_functions "cpp/numeric/math")  
| [sin](sin.html "cpp/numeric/math/sin")  
---  
[cos](cos.html "cpp/numeric/math/cos")  
[tan](tan.html "cpp/numeric/math/tan")  
[asin](asin.html "cpp/numeric/math/asin")  
[acos](acos.html "cpp/numeric/math/acos")  
[atan](atan.html "cpp/numeric/math/atan")  
[atan2](atan2.html "cpp/numeric/math/atan2")  
  
| [sinh](sinh.html "cpp/numeric/math/sinh")  
---  
[cosh](cosh.html "cpp/numeric/math/cosh")  
[tanh](tanh.html "cpp/numeric/math/tanh")  
[asinh](asinh.html "cpp/numeric/math/asinh")(C++11)  
[acosh](acosh.html "cpp/numeric/math/acosh")(C++11)  
[atanh](atanh.html "cpp/numeric/math/atanh")(C++11)  
  
  
  
[Error and gamma functions](../math.html#Error_and_gamma_functions "cpp/numeric/math")  
| [erf](erf.html "cpp/numeric/math/erf")(C++11)  
---  
[erfc](erfc.html "cpp/numeric/math/erfc")(C++11)  
  
| [lgamma](lgamma.html "cpp/numeric/math/lgamma")(C++11)  
---  
[tgamma](tgamma.html "cpp/numeric/math/tgamma")(C++11)  
  
[Nearest integer floating point operations](../math.html#Nearest_integer_floating_point_operations "cpp/numeric/math")  
---  
| [ceil](ceil.html "cpp/numeric/math/ceil")  
---  
[floor](floor.html "cpp/numeric/math/floor")  
[roundlroundllround](round.html "cpp/numeric/math/round")(C++11)(C++11)(C++11)  
  
| [trunc](trunc.html "cpp/numeric/math/trunc")(C++11)  
---  
[nearbyint](nearbyint.html "cpp/numeric/math/nearbyint")(C++11)  
[rintlrintllrint](rint.html "cpp/numeric/math/rint")(C++11)(C++11)(C++11)  
  
[Floating point manipulation functions](../math.html#Floating_point_manipulation_functions "cpp/numeric/math")  
| [ldexp](ldexp.html "cpp/numeric/math/ldexp")  
---  
[scalbnscalbln](scalbn.html "cpp/numeric/math/scalbn")(C++11)(C++11)  
[ilogb](ilogb.html "cpp/numeric/math/ilogb")(C++11)  
[logb](logb.html "cpp/numeric/math/logb")(C++11)  
  
| [frexp](frexp.html "cpp/numeric/math/frexp")  
---  
[modf](modf.html "cpp/numeric/math/modf")  
**nextafter nexttoward**(C++11)(C++11)  
[copysign](copysign.html "cpp/numeric/math/copysign")(C++11)  
  
[Classification and comparison](../math.html#Classification_and_comparison "cpp/numeric/math")  
| [fpclassify](fpclassify.html "cpp/numeric/math/fpclassify")(C++11)  
---  
[isfinite](isfinite.html "cpp/numeric/math/isfinite")(C++11)  
[isinf](isinf.html "cpp/numeric/math/isinf")(C++11)  
[isnan](isnan.html "cpp/numeric/math/isnan")(C++11)  
[isnormal](isnormal.html "cpp/numeric/math/isnormal")(C++11)  
[signbit](signbit.html "cpp/numeric/math/signbit")(C++11)  
  
| [isgreater](isgreater.html "cpp/numeric/math/isgreater")(C++11)  
---  
[isgreaterequal](isgreaterequal.html "cpp/numeric/math/isgreaterequal")(C++11)  
[isless](isless.html "cpp/numeric/math/isless")(C++11)  
[islessequal](islessequal.html "cpp/numeric/math/islessequal")(C++11)  
[islessgreater](islessgreater.html "cpp/numeric/math/islessgreater")(C++11)  
[isunordered](isunordered.html "cpp/numeric/math/isunordered")(C++11)  
  
[Types](../math.html#Types "cpp/numeric/math")  
| [div_t](div.html "cpp/numeric/math/div")  
---  
[ldiv_t](div.html "cpp/numeric/math/div")  
[lldiv_t](div.html "cpp/numeric/math/div")(C++11)  
  
| [imaxdiv_t](div.html "cpp/numeric/math/div")(C++11)  
---  
[float_t](../math.html#Types "cpp/numeric/math")(C++11)  
[double_t](../math.html#Types "cpp/numeric/math")(C++11)  
  
[Macro constants](../math.html#Macro_constants "cpp/numeric/math")  
| [HUGE_VALFHUGE_VALHUGE_VALL](HUGE_VALL.html "cpp/numeric/math/HUGE VAL")(C++11)(C++11)  
---  
[math_errhandlingMATH_ERRNOMATH_ERREXCEPT](math_errhandling.html "cpp/numeric/math/math errhandling")(C++11)` `  
[INFINITY](INFINITY.html "cpp/numeric/math/INFINITY")(C++11)  
[NAN](NAN.html "cpp/numeric/math/NAN")(C++11)  
  
| [Classification](../math.html#Classification "cpp/numeric/math")  
---  
[FP_NORMALFP_SUBNORMALFP_ZEROFP_INFINITEFP_NAN](FP_categories.html "cpp/numeric/math/FP categories")(C++11)(C++11)(C++11)(C++11)(C++11)  
  
  
  
  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/numeric/math/navbar_content&action=edit)

Defined in header `[<cmath>](../../header/cmath.html "cpp/header/cmath")` |  |   
---|---|---  
| (1) |   
float nextafter ( float from, float to );  
double nextafter ( double from, double to );  
long double nextafter ( long double from, long double to ); |  | (since C++11)   
(until C++23)  
constexpr /* floating-point-type */  
nextafter ( /* floating-point-type */ from,  
/* floating-point-type */ to ); |  |  (since C++23)  
float nextafterf( float from, float to ); |  (2)  |  (since C++11)   
(constexpr since C++23)  
long double nextafterl( long double from, long double to ); |  (3)  |  (since C++11)   
(constexpr since C++23)  
| (4) |   
float nexttoward ( float from, long double to );  
double nexttoward ( double from, long double to );  
long double nexttoward ( long double from, long double to ); |  | (since C++11)   
(until C++23)  
constexpr /* floating-point-type */  
nexttoward ( /* floating-point-type */ from,  
long double to ); |  |  (since C++23)  
float nexttowardf( float from, long double to ); |  (5)  |  (since C++11)   
(constexpr since C++23)  
long double nexttowardl( long double from, long double to ); |  (6)  |  (since C++11)   
(constexpr since C++23)  
[Additional overloads](nextafter.html#Notes) |  |   
Defined in header `[<cmath>](../../header/cmath.html "cpp/header/cmath")` |  |   
template< class Arithmetic1, class Arithmetic2 >  
/* common-floating-point-type */  
nextafter( Arithmetic1 from, Arithmetic2 to ); |  (A)  |  (since C++11)   
(constexpr since C++23)  
template< class Integer >  
double nexttoward( Integer from, long double to ); |  (B)  |  (since C++11)   
(constexpr since C++23)  
| |   
  
Returns the next representable value of from in the direction of to. 

1-3) If from equals to, to is returned. The library provides overloads of `std::nextafter` for all cv-unqualified floating-point types as the type of the parameters from and to.(since C++23)

4-6) If from equals to, to is returned, converted from long double to the return type of the function without loss of range or precision.  The library provides overloads of `std::nexttoward` for all cv-unqualified floating-point types as the type of the parameter from. However, an invocation of `std::nexttoward` is ill-formed if the argument corresponding to from has [extended floating-point type](../../language/types.html#Extended_floating-point_types "cpp/language/types"), because the next representable value (or to) is not guaranteed to be representable as long double.  | (since C++23)  
---|---  
  
A) Additional `std::nextafter` overloads are provided for all other combinations of arithmetic types.

B) Additional `std::nexttoward` overloads are provided for all integer types, which are treated as double.

## Contents

  * [1 Parameters](nextafter.html#Parameters)
  * [2 Return value](nextafter.html#Return_value)
  * [3 Error handling](nextafter.html#Error_handling)
  * [4 Notes](nextafter.html#Notes)
  * [5 Example](nextafter.html#Example)
  * [6 See also](nextafter.html#See_also)

  
---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/math/nextafter&action=edit&section=1 "Edit section: Parameters")] Parameters

from, to  |  \-  |  floating-point or integer values   
---|---|---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/math/nextafter&action=edit&section=2 "Edit section: Return value")] Return value

If no errors occur, the next representable value of from in the direction of to. is returned. If from equals to, then to is returned. 

If a range error due to overflow occurs, [±HUGE_VAL](HUGE_VALL.html "cpp/numeric/math/HUGE VAL"), `±HUGE_VALF`, or `±HUGE_VALL` is returned (with the same sign as from). 

If a range error occurs due to underflow, the correct result is returned. 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/math/nextafter&action=edit&section=3 "Edit section: Error handling")] Error handling

Errors are reported as specified in [math_errhandling](math_errhandling.html "cpp/numeric/math/math errhandling"). 

If the implementation supports IEEE floating-point arithmetic (IEC 60559), 

  * if from is finite, but the expected result is an infinity, raises [FE_INEXACT](../fenv/FE_exceptions.html "cpp/numeric/fenv/FE exceptions") and [FE_OVERFLOW](../fenv/FE_exceptions.html "cpp/numeric/fenv/FE exceptions"). 
  * if from does not equal to and the result is subnormal or zero, raises [FE_INEXACT](../fenv/FE_exceptions.html "cpp/numeric/fenv/FE exceptions") and [FE_UNDERFLOW](../fenv/FE_exceptions.html "cpp/numeric/fenv/FE exceptions"). 
  * in any case, the returned value is independent of the current rounding mode. 
  * if either from or to is NaN, NaN is returned. 



### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/math/nextafter&action=edit&section=4 "Edit section: Notes")] Notes

[POSIX specifies](https://pubs.opengroup.org/onlinepubs/9699919799/functions/nextafter.html) that the overflow and the underflow conditions are range errors ([errno](../../error/errno.html "cpp/error/errno") may be set). 

IEC 60559 recommends that from is returned whenever from == to. These functions return to instead, which makes the behavior around zero consistent: std::nextafter(-0.0, +0.0) returns +0.0 and std::nextafter(+0.0, -0.0) returns -0.0. 

`std::nextafter` is typically implemented by manipulation of IEEE representation ([glibc](https://github.com/bminor/glibc/blob/master/math/s_nextafter.c), [musl](https://github.com/ifduyue/musl/blob/master/src/math/nextafter.c)). 

The additional `std::nextafter` overloads are not required to be provided exactly as (A). They only need to be sufficient to ensure that for their first argument num1 and second argument num2: 

  * If num1 or num2 has type long double, then std::nextafter(num1, num2) has the same effect as std::nextafter(static_cast<long double>(num1),  
static_cast<long double>(num2)). 
  * Otherwise, if num1 and/or num2 has type double or an integer type, then std::nextafter(num1, num2) has the same effect as std::nextafter(static_cast<double>(num1),  
static_cast<double>(num2)). 
  * Otherwise, if num1 or num2 has type float, then std::nextafter(num1, num2) has the same effect as std::nextafter(static_cast<float>(num1),  
static_cast<float>(num2)). 

| (until C++23)  
---|---  
If num1 and num2 have arithmetic types, then std::nextafter(num1, num2) has the same effect as std::nextafter(static_cast</*common-floating-point-type*/>(num1),  
static_cast</*common-floating-point-type*/>(num2)), where /*common-floating-point-type*/ is the floating-point type with the greatest [floating-point conversion rank](../../language/usual_arithmetic_conversions.html#Floating-point_conversion_rank "cpp/language/usual arithmetic conversions") and greatest [floating-point conversion subrank](../../language/usual_arithmetic_conversions.html#Floating-point_conversion_subrank "cpp/language/usual arithmetic conversions") between the types of num1 and num2, arguments of integer type are considered to have the same floating-point conversion rank as double. If no such floating-point type with the greatest rank and subrank exists, then [overload resolution](../../language/overload_resolution.html "cpp/language/overload resolution") does not result in a usable candidate from the overloads provided.  | (since C++23)  
  
The additional `std::nexttoward` overloads are not required to be provided exactly as (B). They only need to be sufficient to ensure that for their argument num of integer type, std::nexttoward(num) has the same effect as std::nexttoward(static_cast<double>(num)). 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/math/nextafter&action=edit&section=5 "Edit section: Example")] Example

Run this code
    
    
    #include <cfenv>
    #include <cfloat>
    #include <cmath>
    #include <concepts>
    #include <iomanip>
    #include <iostream>
     
    int main()
    {
        float from1 = 0, to1 = std::nextafter(from1, 1.f);
        [std::cout](../../io/cout.html) << "The next representable float after " << [std::setprecision](../../io/manip/setprecision.html)(20) << from1
                  << " is " << to1
                  << [std::hexfloat](../../io/manip/fixed.html) << " (" << to1 << ")\n" << [std::defaultfloat](../../io/manip/fixed.html);
     
        float from2 = 1, to2 = std::nextafter(from2, 2.f);
        [std::cout](../../io/cout.html) << "The next representable float after " << from2 << " is " << to2
                  << [std::hexfloat](../../io/manip/fixed.html) << " (" << to2 << ")\n" << [std::defaultfloat](../../io/manip/fixed.html);
     
        double from3 = std::nextafter(0.1, 0), to3 = 0.1;
        [std::cout](../../io/cout.html) << "The number 0.1 lies between two valid doubles:\n"
                  << [std::setprecision](../../io/manip/setprecision.html)(56) << "    " << from3
                  << [std::hexfloat](../../io/manip/fixed.html) << " (" << from3 << ')' << [std::defaultfloat](../../io/manip/fixed.html)
                  << "\nand " << to3 << [std::hexfloat](../../io/manip/fixed.html) << "  (" << to3 << ")\n"
                  << [std::defaultfloat](../../io/manip/fixed.html) << [std::setprecision](../../io/manip/setprecision.html)(20);
     
        [std::cout](../../io/cout.html) << "\nDifference between nextafter and nexttoward:\n";
        long double dir = std::nextafter(from1, 1.0L); // first subnormal long double
        float x = std::nextafter(from1, dir); // first converts dir to float, giving 0
        [std::cout](../../io/cout.html) << "With nextafter, next float after " << from1 << " is " << x << '\n';
        x = std::nexttoward(from1, dir);
        [std::cout](../../io/cout.html) << "With nexttoward, next float after " << from1 << " is " << x << '\n';
     
        [std::cout](../../io/cout.html) << "\nSpecial values:\n";
        {
            // #pragma STDC FENV_ACCESS ON
            [std::feclearexcept](../fenv/feclearexcept.html)([FE_ALL_EXCEPT](../fenv/FE_exceptions.html));
            double from4 = [DBL_MAX](../../types/climits.html), to4 = std::nextafter(from4, [INFINITY](INFINITY.html));
            [std::cout](../../io/cout.html) << "The next representable double after " << [std::setprecision](../../io/manip/setprecision.html)(6)
                      << from4 << [std::hexfloat](../../io/manip/fixed.html) << " (" << from4 << ')'
                      << [std::defaultfloat](../../io/manip/fixed.html) << " is " << to4
                      << [std::hexfloat](../../io/manip/fixed.html) << " (" << to4 << ")\n" << [std::defaultfloat](../../io/manip/fixed.html);
     
            if ([std::fetestexcept](../fenv/fetestexcept.html)([FE_OVERFLOW](../fenv/FE_exceptions.html)))
                [std::cout](../../io/cout.html) << "   raised FE_OVERFLOW\n";
            if ([std::fetestexcept](../fenv/fetestexcept.html)([FE_INEXACT](../fenv/FE_exceptions.html)))
                [std::cout](../../io/cout.html) << "   raised FE_INEXACT\n";
        } // end FENV_ACCESS block
     
        float from5 = 0.0, to5 = std::nextafter(from5, -0.0);
        [std::cout](../../io/cout.html) << "std::nextafter(+0.0, -0.0) gives " << [std::fixed](../../io/manip/fixed.html) << to5 << '\n';
     
        auto precision_loss_demo = []<[std::floating_point](../../concepts/floating_point.html) Fp>(const auto rem, const Fp start)
        {
            [std::cout](../../io/cout.html) << rem;
            for (Fp from = start, to, Δ;
                (Δ = (to = std::nextafter(from, +[INFINITY](INFINITY.html))) - from) < Fp(10.0);
                from *= Fp(10.0))
                [std::cout](../../io/cout.html) << "nextafter(" << [std::scientific](../../io/manip/fixed.html) << [std::setprecision](../../io/manip/setprecision.html)(0) << from 
                          << ", INF) gives " << [std::fixed](../../io/manip/fixed.html) << [std::setprecision](../../io/manip/setprecision.html)(6) << to
                          << "; Δ = " << Δ << '\n';
        };
     
        precision_loss_demo("\nPrecision loss demo for float:\n", 10.0f);
        precision_loss_demo("\nPrecision loss demo for double:\n", 10.0e9);
        precision_loss_demo("\nPrecision loss demo for long double:\n", 10.0e17L);
    }

Output: 
    
    
    The next representable float after 0 is 1.4012984643248170709e-45 (0x1p-149)
    The next representable float after 1 is 1.0000001192092895508 (0x1.000002p+0)
    The number 0.1 lies between two valid doubles:
        0.09999999999999999167332731531132594682276248931884765625 (0x1.9999999999999p-4)
    and 0.1000000000000000055511151231257827021181583404541015625  (0x1.999999999999ap-4)
     
    Difference between nextafter and nexttoward:
    With nextafter, next float after 0 is 0
    With nexttoward, next float after 0 is 1.4012984643248170709e-45
     
    Special values:
    The next representable double after 1.79769e+308 (0x1.fffffffffffffp+1023) is inf (inf)
       raised FE_OVERFLOW
       raised FE_INEXACT
    std::nextafter(+0.0, -0.0) gives -0.000000
     
    Precision loss demo for float:
    nextafter(1e+01, INF) gives 10.000001; Δ = 0.000001
    nextafter(1e+02, INF) gives 100.000008; Δ = 0.000008
    nextafter(1e+03, INF) gives 1000.000061; Δ = 0.000061
    nextafter(1e+04, INF) gives 10000.000977; Δ = 0.000977
    nextafter(1e+05, INF) gives 100000.007812; Δ = 0.007812
    nextafter(1e+06, INF) gives 1000000.062500; Δ = 0.062500
    nextafter(1e+07, INF) gives 10000001.000000; Δ = 1.000000
    nextafter(1e+08, INF) gives 100000008.000000; Δ = 8.000000
     
    Precision loss demo for double:
    nextafter(1e+10, INF) gives 10000000000.000002; Δ = 0.000002
    nextafter(1e+11, INF) gives 100000000000.000015; Δ = 0.000015
    nextafter(1e+12, INF) gives 1000000000000.000122; Δ = 0.000122
    nextafter(1e+13, INF) gives 10000000000000.001953; Δ = 0.001953
    nextafter(1e+14, INF) gives 100000000000000.015625; Δ = 0.015625
    nextafter(1e+15, INF) gives 1000000000000000.125000; Δ = 0.125000
    nextafter(1e+16, INF) gives 10000000000000002.000000; Δ = 2.000000
     
    Precision loss demo for long double:
    nextafter(1e+18, INF) gives 1000000000000000000.062500; Δ = 0.062500
    nextafter(1e+19, INF) gives 10000000000000000001.000000; Δ = 1.000000
    nextafter(1e+20, INF) gives 100000000000000000008.000000; Δ = 8.000000

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/math/nextafter&action=edit&section=6 "Edit section: See also")] See also

[C documentation](../../../c/numeric/math/nexttoward.html "c/numeric/math/nextafter") for nextafter  
---
