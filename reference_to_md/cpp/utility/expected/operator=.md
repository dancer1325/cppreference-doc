[C++](../../../cpp.html "cpp")

[Compiler support](../../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../../freestanding.html "cpp/freestanding")  
[Language](../../language.html "cpp/language")  
[Standard library](../../standard_library.html "cpp/standard library")  
[Standard library headers](../../headers.html "cpp/header")  
[Named requirements](../../iterator/concepts.html "cpp/named req")  
[Feature test macros](../../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../../utility.html#Language_support "cpp/utility")  
[Concepts library](../../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../../error.html "cpp/error")  
[Memory management library](../../memory.html "cpp/memory")  
[Metaprogramming library](../../meta.html "cpp/meta") (C++11)  
[General utilities library](../../utility.html "cpp/utility")  
[Containers library](../../container.html "cpp/container")  
[Iterators library](../../iterator.html "cpp/iterator")  
[Ranges library](../../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../../algorithm.html "cpp/algorithm")  
[Strings library](../../string.html "cpp/string")  
[Text processing library](../../text.html "cpp/text")  
[Numerics library](../../numeric.html "cpp/numeric")  
[Date and time library](../../chrono.html "cpp/chrono")  
[Input/output library](../../io.html "cpp/io")  
[Filesystem library](../../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../../atomic.html "cpp/thread") (C++11)  
[Execution control library](../../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../../experimental.html "cpp/experimental")  
[Symbols index](../../symbol_index.html "cpp/symbol index")  
[External libraries](../../links/libs.html "cpp/links/libs")  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/navbar_content&action=edit)

[Utilities library](../../utility.html "cpp/utility")

| [Language support](../../utility.html#Language_support "cpp/utility")  
---  
[Type support](../rtti.html "cpp/types") (basic types, RTTI)  
[Library feature-test macros](../feature_test.html "cpp/utility/feature test") (C++20)  
[Program utilities](../program.html "cpp/utility/program")  
[Variadic functions](../variadic.html "cpp/utility/variadic")  
[initializer_list](../initializer_list.html "cpp/utility/initializer list")(C++11)  
[is_constant_evaluated](../../types/is_constant_evaluated.html "cpp/types/is constant evaluated")(C++20)  
[is_within_lifetime](../../types/is_within_lifetime.html "cpp/types/is within lifetime")(C++26)  
[source_location](../source_location.html "cpp/utility/source location")(C++20)  
[Coroutine support](../../coroutine.html "cpp/coroutine") (C++20)  
[Contract support](../../contract.html "cpp/contract") (C++26)  
[Three-way comparison](../../utility.html#Three-way_comparison "cpp/utility")  
[three_way_comparablethree_way_comparable_with](../compare/three_way_comparable.html "cpp/utility/compare/three way comparable")(C++20)(C++20)  
[strong_ordering](../compare/strong_ordering.html "cpp/utility/compare/strong ordering")(C++20)  
[weak_ordering](../compare/weak_ordering.html "cpp/utility/compare/weak ordering")(C++20)  
[partial_ordering](../compare/partial_ordering.html "cpp/utility/compare/partial ordering")(C++20)  
[common_comparison_category](../compare/common_comparison_category.html "cpp/utility/compare/common comparison category")(C++20)  
[compare_three_way_result](../compare/compare_three_way_result.html "cpp/utility/compare/compare three way result")(C++20)  
[compare_three_way](../compare/compare_three_way.html "cpp/utility/compare/compare three way")(C++20)  
[strong_order](../compare/strong_order.html "cpp/utility/compare/strong order")(C++20)  
[weak_order](../compare/weak_order.html "cpp/utility/compare/weak order")(C++20)  
[partial_order](../compare/partial_order.html "cpp/utility/compare/partial order")(C++20)  
[compare_strong_order_fallback](../compare/compare_strong_order_fallback.html "cpp/utility/compare/compare strong order fallback")(C++20)  
[compare_weak_order_fallback](../compare/compare_weak_order_fallback.html "cpp/utility/compare/compare weak order fallback")(C++20)  
[compare_partial_order_fallback](../compare/compare_partial_order_fallback.html "cpp/utility/compare/compare partial order fallback")(C++20)` `  
|  | [is_eqis_ltis_lteq](../compare/named_comparison_functions.html "cpp/utility/compare/named comparison functions")(C++20)(C++20)(C++20)` `  
---  
  
| [is_neqis_gtis_gteq](../compare/named_comparison_functions.html "cpp/utility/compare/named comparison functions")(C++20)(C++20)(C++20)  
---  
  
  
  
  
| General utilities  
---  
| [Function objects](../../functional.html "cpp/utility/functional")  
---  
[Bit manipulation](../bit.html "cpp/utility/bit") (C++20)  
[C-style bit manipulation](https://en.cppreference.com/mwiki/index.php?title=cpp/utility/stdbit&action=edit&redlink=1 "cpp/utility/stdbit \(page does not exist\)") (C++26)  
[bitset](../bitset.html "cpp/utility/bitset")  
[hash](../hash.html "cpp/utility/hash")(C++11)  
  
[Relational operators](../../utility.html#Relational_operators "cpp/utility") (deprecated in C++20)  
|  | [rel_ops::operator!=rel_ops::operator>](../rel_ops/operator_cmp.html "cpp/utility/rel ops/operator cmp")` `  
---  
  
| [rel_ops::operator<=rel_ops::operator>=](../rel_ops/operator_cmp.html "cpp/utility/rel ops/operator cmp")  
---  
  
[Integer comparison functions](../../utility.html#Integer_comparison_functions "cpp/utility")  
| [cmp_equalcmp_lesscmp_less_than](../intcmp.html "cpp/utility/intcmp")(C++20)(C++20)(C++20)` `  
---  
  
| [cmp_not_equalcmp_greatercmp_greater_than](../intcmp.html "cpp/utility/intcmp")(C++20)(C++20)(C++20)  
---  
  
[in_range](../in_range.html "cpp/utility/in range")(C++20)  
[Swap](../../utility.html#Swap "cpp/utility") and [type operations](../../utility.html#Type_operations "cpp/utility")  
| [swap](../swap.html "cpp/algorithm/swap")  
---  
[ranges::swap](../ranges/swap.html "cpp/utility/ranges/swap")(C++20)  
[exchange](../exchange.html "cpp/utility/exchange")(C++14)  
[declval](../declval.html "cpp/utility/declval")(C++11)  
[to_underlying](../to_underlying.html "cpp/utility/to underlying")(C++23)  
  
| [forward](../forward.html "cpp/utility/forward")(C++11)  
---  
[forward_like](../forward_like.html "cpp/utility/forward like")(C++23)  
[move](../move.html "cpp/utility/move")(C++11)  
[move_if_noexcept](../move_if_noexcept.html "cpp/utility/move if noexcept")(C++11)  
[as_const](../as_const.html "cpp/utility/as const")(C++17)  
  
Common vocabulary types  
| [pair](../pair.html "cpp/utility/pair")  
---  
[tuple](../tuple.html "cpp/utility/tuple")(C++11)  
[optional](../optional.html "cpp/utility/optional")(C++17)  
[any](../any.html "cpp/utility/any")(C++17)  
[variant](../variant.html "cpp/utility/variant")(C++17)  
  
| [tuple_size](../tuple_size.html "cpp/utility/tuple size")(C++11)  
---  
[tuple_element](../tuple_element.html "cpp/utility/tuple element")(C++11)  
[apply](../apply.html "cpp/utility/apply")(C++17)  
[make_from_tuple](../make_from_tuple.html "cpp/utility/make from tuple")(C++17)  
[expected](../expected.html "cpp/utility/expected")(C++23)  
  
  
  
  
  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/navbar_content&action=edit)

[`std::expected`](../expected.html "cpp/utility/expected")

[Member functions](../expected.html#Member_functions "cpp/utility/expected")  
---  
[expected::expected](expected.html "cpp/utility/expected/expected")  
[expected::~expected](~expected.html "cpp/utility/expected/~expected")  
**expected::operator=**  
[Observers](../expected.html#Observers "cpp/utility/expected")  
[expected::operator->expected::operator*](operator*.html "cpp/utility/expected/operator*")  
[expected::operator boolexpected::has_value](operator_bool.html "cpp/utility/expected/operator bool")  
[expected::value](value.html "cpp/utility/expected/value")  
[expected::error](error.html "cpp/utility/expected/error")  
[expected::value_or](value_or.html "cpp/utility/expected/value or")  
[expected::error_or](error_or.html "cpp/utility/expected/error or")  
[Monadic operations](../expected.html#Monadic_operations "cpp/utility/expected")  
[expected::and_then](and_then.html "cpp/utility/expected/and then")  
[expected::or_else](or_else.html "cpp/utility/expected/or else")  
[expected::transform](transform.html "cpp/utility/expected/transform")  
[expected::transform_error](transform_error.html "cpp/utility/expected/transform error")  
[Modifiers](../expected.html#Modifiers "cpp/utility/expected")  
[expected::emplace](emplace.html "cpp/utility/expected/emplace")  
[expected::swap](swap.html "cpp/utility/expected/swap")  
[Non-member functions](../expected.html#Non-member_functions "cpp/utility/expected")  
[operator==(std::expected)](operator_cmp.html "cpp/utility/expected/operator cmp")  
[swap(std::expected)](swap2.html "cpp/utility/expected/swap2")  
[Helper classes](../expected.html#Helper_classes "cpp/utility/expected")  
[unexpected](unexpected.html "cpp/utility/expected/unexpected")  
[bad_expected_access](bad_expected_access.html "cpp/utility/expected/bad expected access")  
[unexpect_tunexpect](unexpect_t.html "cpp/utility/expected/unexpect t")  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/expected/navbar_content&action=edit)

Primary template |  |   
---|---|---  
constexpr expected& operator=( const expected& other ); |  (1) | (since C++23)  
constexpr expected& operator=( expected&& other )  
noexcept(/* see below */); |  (2) | (since C++23)  
template< class U = [std::remove_cv_t](../../types/remove_cv.html)<T> >  
constexpr expected& operator=( U&& v ); |  (3) | (since C++23)  
template< class G >  
constexpr expected& operator=( const [std::unexpected](unexpected.html)<G>& e ); |  (4) | (since C++23)  
template< class G >  
constexpr expected& operator=( [std::unexpected](unexpected.html)<G>&& e ); |  (5) | (since C++23)  
void partial specialization |  |   
constexpr expected& operator=( const expected& other ); |  (6) | (since C++23)  
constexpr expected& operator=( expected&& other )  
noexcept(/* see below */); |  (7) | (since C++23)  
template< class G >  
constexpr expected& operator=( const [std::unexpected](unexpected.html)<G>& e ); |  (8) | (since C++23)  
template< class G >  
constexpr expected& operator=( [std::unexpected](unexpected.html)<G>&& e ); |  (9) | (since C++23)  
Helper function template |  |   
template< class T, class U, class... Args >  
constexpr void /*reinit-expected*/( T& newval, U& oldval, Args&&... args ) |  (10) | (since C++23)   
(exposition only*)  
| |   
  
Assigns a new value to an existing `expected` object. 

## Contents

  * [1 Parameters](operator=.html#Parameters)
  * [2 Effects](operator=.html#Effects)
    * [2.1 Primary template assignment operators](operator=.html#Primary_template_assignment_operators)
    * [2.2 void partial specialization assignment operators](operator=.html#void_partial_specialization_assignment_operators)
    * [2.3 Helper function template](operator=.html#Helper_function_template)
  * [3 Return value](operator=.html#Return_value)
  * [4 Constraints and supplement information](operator=.html#Constraints_and_supplement_information)
    * [4.1 Primary template assignment operators](operator=.html#Primary_template_assignment_operators_2)
    * [4.2 void partial specialization assignment operators](operator=.html#void_partial_specialization_assignment_operators_2)
  * [5 Exceptions](operator=.html#Exceptions)
  * [6 Example](operator=.html#Example)
  * [7 Defect reports](operator=.html#Defect_reports)
  * [8 See also](operator=.html#See_also)

  
---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/utility/expected/operator%3D&action=edit&section=1 "Edit section: Parameters")] Parameters

other  |  \-  |  another `expected` object whose contained value to assign   
---|---|---  
v  |  \-  |  value to assign to the contained value   
e  |  \-  |  [`std::unexpected`](unexpected.html "cpp/utility/expected/unexpected") object whose contained value to assign   
newval  |  \-  |  the contained value to be constructed   
oldval  |  \-  |  the contained value to be destroyed   
args  |  \-  |  the arguments used as initializers of newval  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/utility/expected/operator%3D&action=edit&section=2 "Edit section: Effects")] Effects

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/utility/expected/operator%3D&action=edit&section=3 "Edit section: Primary template assignment operators")] Primary template assignment operators

1,2) Assigns the state of other to *this.

If [`has_value()`](operator_bool.html "cpp/utility/expected/operator bool") and rhs.has_value() have different values (i.e. one of *this and other contains an expected value [`_val_`](../expected.html#Data_members "cpp/utility/expected") and the other contains an unexpected value [`_unex_`](../expected.html#Data_members "cpp/utility/expected") ﻿), the exposition-only function template [`_reinit-expected_`](operator=.html#Helper_function_template) is called to safely update the state.

1) The contained value is assigned as follows:  Value of  
[`has_value()`](operator_bool.html "cpp/utility/expected/operator bool") | Value of other.has_value()  
---|---  
true | false  
true | `_val_`` `= *other; | `_reinit-expected_`  
` `(`_unex_` ,` `` _val_` , other.error());  
false | `_reinit-expected_`  
` `(`_val_` ,` `` _unex_` , *other); | `_unex_`` `= other.error();  
  
2) The contained value is assigned as follows:  Value of  
[`has_value()`](operator_bool.html "cpp/utility/expected/operator bool") | Value of other.has_value()  
---|---  
true | false  
true | `_val_`` `= std::move(*other); | `_reinit-expected_`  
` `(`_unex_` ,` `` _val_` , std::move(other.error()));  
false | `_reinit-expected_`  
` `(`_val_` ,` `` _unex_` ,  
` `std::move(*other)); | `_unex_`` `= std::move(other.error());  
  
Then, if no exception was thrown, executes [`_has_val_`](../expected.html#Data_members "cpp/utility/expected")` `= other.has_value();.

3) The expected value is assigned as follows:  Value of  
[`has_value()`](operator_bool.html "cpp/utility/expected/operator bool") | Equivalent to   
---|---  
true | `_val_`` `= [std::forward](../forward.html)<U>(v);  
false | `_reinit-expected_`(`_val_` ,` `` _unex_` , [std::forward](../forward.html)<U>(v));  
`_has_val_`` `= false;  
  
4,5) The unexpected value is assigned as follows:  Overload  | Value of  
[`has_value()`](operator_bool.html "cpp/utility/expected/operator bool") | Equivalent to   
---|---|---  
([4](operator=.html#Version_4)) | true | `_reinit-expected_`(`_val_` ,` `` _unex_` , [std::forward](../forward.html)<const G&>(e.error()));  
`_has_val_`` `= false;  
false | `_unex_`` `= [std::forward](../forward.html)<const G&>(e.error());  
([5](operator=.html#Version_5)) | true | `_reinit-expected_`(`_val_` ,` `` _unex_` , [std::forward](../forward.html)<G>(e.error()));  
`_has_val_`` `= false;  
false | `_unex_`` `= [std::forward](../forward.html)<G>(e.error());  
  
#### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/utility/expected/operator%3D&action=edit&section=4 "Edit section: void partial specialization assignment operators")] void partial specialization assignment operators

6) The unexpected value is assigned or destroyed as follows:  Value of  
[`has_value()`](operator_bool.html "cpp/utility/expected/operator bool") | Value of other.has_value()  
---|---  
true | false  
true | (no effects)  | [std::construct_at](../../memory/construct_at.html)  
` `([std::addressof](../../memory/addressof.html)(`_unex_`), rhs.`_unex_`);  
`_has_val_`` `= false;  
false | [std::destroy_at](../../memory/destroy_at.html)([std::addressof](../../memory/addressof.html)(`_unex_`));  
`_has_val_`` `= true; | `_unex_`` `= other.error();  
  
7) The unexpected value is assigned or destroyed as follows:  Value of  
[`has_value()`](operator_bool.html "cpp/utility/expected/operator bool") | Value of other.has_value()  
---|---  
true | false  
true | (no effects)  | [std::construct_at](../../memory/construct_at.html)  
` `([std::addressof](../../memory/addressof.html)(`_unex_`),  
` `std::move(rhs.`_unex_`));  
`_has_val_`` `= false;  
false | [std::destroy_at](../../memory/destroy_at.html)([std::addressof](../../memory/addressof.html)(`_unex_`));  
`_has_val_`` `= true; | `_unex_`` `= std::move(other.error());  
  
8,9) The unexpected value is assigned as follows:  Overload  | Value of  
[`has_value()`](operator_bool.html "cpp/utility/expected/operator bool") | Equivalent to   
---|---|---  
([8](operator=.html#Version_8)) | true | [std::construct_at](../../memory/construct_at.html)([std::addressof](../../memory/addressof.html)(`_unex_`),  
` `[std::forward](../forward.html)<const G&>(e.error()));  
`_has_val_`` `= false;  
false | `_unex_`` `= [std::forward](../forward.html)<const G&>(e.error());  
([9](operator=.html#Version_9)) | true | [std::construct_at](../../memory/construct_at.html)([std::addressof](../../memory/addressof.html)(`_unex_`), [std::forward](../forward.html)<G>(e.error()));  
`_has_val_`` `= false;  
false | `_unex_`` `= [std::forward](../forward.html)<G>(e.error());  
  
#### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/utility/expected/operator%3D&action=edit&section=5 "Edit section: Helper function template")] Helper function template

The exposition-only function template `_reinit-expected_` is “defined” as follows: 
    
    
    template<class NewType, class OldType, class... Args>
    constexpr void reinit-expected(NewType& new_val, OldType& old_val, Args&&... args)
    {
        // Case 1: the construction of “new_val” is non-throwing:
        // “new_val” can be directly constructed after destroying “old_val”
        if constexpr ([std::is_nothrow_constructible_v](../../types/is_constructible.html)<NewType, Args...>)
        {
            [std::destroy_at](../../memory/destroy_at.html)([std::addressof](../../memory/addressof.html)(old_val));
            [std::construct_at](../../memory/construct_at.html)([std::addressof](../../memory/addressof.html)(new_val), [std::forward](../forward.html)<Args>(args)...);
        }
        // Case 2: the move construction of “new_val” is non-throwing:
        // constuct a temporary NewType object first
        // (“old_val” is left intact if an exception is thrown from this construction)
        else if constexpr ([std::is_nothrow_move_constructible_v](../../types/is_move_constructible.html)<NewType>)
        {
            NewType temp([std::forward](../forward.html)<Args>(args)...); // may throw
            [std::destroy_at](../../memory/destroy_at.html)([std::addressof](../../memory/addressof.html)(old_val));
            [std::construct_at](../../memory/construct_at.html)([std::addressof](../../memory/addressof.html)(new_val), std::move(temp));
        }
        // Case 3: the construction of “new_val” is potentially-throwing:
        // a backup of “old_val” is required in order to recover from an exception
        else
        {
            OldType temp(std::move(old_val)); // may throw
            [std::destroy_at](../../memory/destroy_at.html)([std::addressof](../../memory/addressof.html)(old_val));
            try
            {
                [std::construct_at](../../memory/construct_at.html)([std::addressof](../../memory/addressof.html)(new_val),
                                  [std::forward](../forward.html)<Args>(args)...); // may throw
            }
            catch (...)
            {
                [std::construct_at](../../memory/construct_at.html)([std::addressof](../../memory/addressof.html)(old_val), std::move(temp));
                throw;
            }
        }
    }

This function template is called when the assignment is going to make *this hold the alternative value (i.e. from expected value to unexpected value, or from unexpected value to expected value). 

In this case, the old value oldval needs to be destroyed before constructing the new value newval. However, the construction of newval may throw an exception. In order to provide [strong exception safety guarantee](../../language/exceptions.html#Exception_safety "cpp/language/exceptions"), the old value needs to be restored before rethrowing the exception so that *this will have a valid state while the exception is being handled. 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/utility/expected/operator%3D&action=edit&section=6 "Edit section: Return value")] Return value

1-9) *this

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/utility/expected/operator%3D&action=edit&section=7 "Edit section: Constraints and supplement information")] Constraints and supplement information

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/utility/expected/operator%3D&action=edit&section=8 "Edit section: Primary template assignment operators")] Primary template assignment operators

1) This overload is defined as deleted unless all following values are true: 

  * [std::is_copy_assignable_v](../../types/is_copy_assignable.html)<T>
  * [std::is_copy_constructible_v](../../types/is_copy_constructible.html)<T>
  * [std::is_copy_assignable_v](../../types/is_copy_assignable.html)<E>
  * [std::is_copy_constructible_v](../../types/is_copy_constructible.html)<E>
  * [std::is_nothrow_move_constructible_v](../../types/is_move_constructible.html)<T> || [std::is_nothrow_move_constructible_v](../../types/is_move_constructible.html)<E>



2) This overload participates in overload resolution only if all following values are true: 

  * [std::is_move_assignable_v](../../types/is_move_assignable.html)<T>
  * [std::is_move_constructible_v](../../types/is_move_constructible.html)<T>
  * [std::is_move_assignable_v](../../types/is_move_assignable.html)<E>
  * [std::is_move_constructible_v](../../types/is_move_constructible.html)<E>
  * [std::is_nothrow_move_constructible_v](../../types/is_move_constructible.html)<T> || [std::is_nothrow_move_constructible_v](../../types/is_move_constructible.html)<E>



3) This overload participates in overload resolution only if all following conditions are satisfied: 

  * [std::is_same_v](../../types/is_same.html)<expected, [std::remove_cvref_t](../../types/remove_cvref.html)<U>> is false. 
  * [std::remove_cvref_t](../../types/remove_cvref.html)<U> is not a specialization of `std::unexpected`. 
  * All following values are true: 
    * [std::is_constructible_v](../../types/is_constructible.html)<T, U>
    * [std::is_assignable_v](../../types/is_assignable.html)<T&, U>
    * [std::is_nothrow_constructible_v](../../types/is_constructible.html)<T, U> || [std::is_nothrow_move_constructible_v](../../types/is_move_constructible.html)<T> ||  
[std::is_nothrow_move_constructible_v](../../types/is_move_constructible.html)<E>



4) This overload participates in overload resolution only if all following values are true: 

  * [std::is_constructible_v](../../types/is_constructible.html)<E, const G&>
  * [std::is_assignable_v](../../types/is_assignable.html)<E&, const G&>
  * [std::is_nothrow_constructible_v](../../types/is_constructible.html)<E, const G&> || [std::is_nothrow_move_constructible_v](../../types/is_move_constructible.html)<T> ||  
[std::is_nothrow_move_constructible_v](../../types/is_move_constructible.html)<E>



5) This overload participates in overload resolution only if all following values are true: 

  * [std::is_constructible_v](../../types/is_constructible.html)<E, G>
  * [std::is_assignable_v](../../types/is_assignable.html)<E&, G>
  * [std::is_nothrow_constructible_v](../../types/is_constructible.html)<E, G> || [std::is_nothrow_move_constructible_v](../../types/is_move_constructible.html)<T> ||  
[std::is_nothrow_move_constructible_v](../../types/is_move_constructible.html)<E>



#### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/utility/expected/operator%3D&action=edit&section=9 "Edit section: void partial specialization assignment operators")] void partial specialization assignment operators

6) This overload is defined as deleted unless [std::is_copy_assignable_v](../../types/is_copy_assignable.html)<E> and [std::is_copy_constructible_v](../../types/is_copy_constructible.html)<E> are both true.

7) This overload participates in overload resolution only if [std::is_move_constructible_v](../../types/is_move_constructible.html)<E> and [std::is_move_assignable_v](../../types/is_move_assignable.html)<E> are both true.

8) This overload participates in overload resolution only if [std::is_constructible_v](../../types/is_constructible.html)<E, const G&> and [std::is_assignable_v](../../types/is_assignable.html)<E&, const G&> are both true.

9) This overload participates in overload resolution only if [std::is_constructible_v](../../types/is_constructible.html)<E, G> and [std::is_assignable_v](../../types/is_assignable.html)<E&, G> are both true.

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/utility/expected/operator%3D&action=edit&section=10 "Edit section: Exceptions")] Exceptions

2)

[`noexcept`](../../language/noexcept_spec.html "cpp/language/noexcept spec") specification: 

noexcept(  


[std::is_nothrow_move_constructible_v](../../types/is_move_constructible.html)<T> && [std::is_nothrow_move_assignable_v](../../types/is_move_assignable.html)<T> &&  


[std::is_nothrow_move_constructible_v](../../types/is_move_constructible.html)<E> && [std::is_nothrow_move_assignable_v](../../types/is_move_assignable.html)<E>)

7)

[`noexcept`](../../language/noexcept_spec.html "cpp/language/noexcept spec") specification: 

noexcept([std::is_nothrow_move_constructible_v](../../types/is_move_constructible.html)<E> && [std::is_nothrow_move_assignable_v](../../types/is_move_assignable.html)<E>)

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/utility/expected/operator%3D&action=edit&section=11 "Edit section: Example")] Example

| This section is incomplete  
Reason: no example   
---|---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/utility/expected/operator%3D&action=edit&section=12 "Edit section: Defect reports")] Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[LWG 3886](https://cplusplus.github.io/LWG/issue3886) | C++23  | the default template argument of overload ([3](operator=.html#Version_3)) was `T` | changed to [std::remove_cv_t](../../types/remove_cv.html)<T>  
[LWG 4025](https://cplusplus.github.io/LWG/issue4025) | C++23  | overload ([7](operator=.html#Version_7)) was defined as deleted if `E` is not  
move constructible or not move assignable  | it does not participate in  
overload resolution in this case   
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/utility/expected/operator%3D&action=edit&section=13 "Edit section: See also")] See also

[ emplace](emplace.html "cpp/utility/expected/emplace") |  constructs the expected value in-place   
(public member function) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/expected/dsc_emplace&action=edit)  
---|---
