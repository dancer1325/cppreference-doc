
  


[Utilities library](../utility.html "cpp/utility")

| [Language support](../utility.html#Language_support "cpp/utility")  
---  
[Type support](rtti.html "cpp/types") (basic types, RTTI)  
[Library feature-test macros](feature_test.html "cpp/utility/feature test") (C++20)  
[Program utilities](program.html "cpp/utility/program")  
[Variadic functions](variadic.html "cpp/utility/variadic")  
[initializer_list](initializer_list.html "cpp/utility/initializer list")(C++11)  
[is_constant_evaluated](../types/is_constant_evaluated.html "cpp/types/is constant evaluated")(C++20)  
[is_within_lifetime](../types/is_within_lifetime.html "cpp/types/is within lifetime")(C++26)  
[source_location](source_location.html "cpp/utility/source location")(C++20)  
[Coroutine support](../coroutine.html "cpp/coroutine") (C++20)  
[Contract support](../contract.html "cpp/contract") (C++26)  
[Three-way comparison](../utility.html#Three-way_comparison "cpp/utility")  
[three_way_comparablethree_way_comparable_with](compare/three_way_comparable.html "cpp/utility/compare/three way comparable")(C++20)(C++20)  
[strong_ordering](compare/strong_ordering.html "cpp/utility/compare/strong ordering")(C++20)  
[weak_ordering](compare/weak_ordering.html "cpp/utility/compare/weak ordering")(C++20)  
[partial_ordering](compare/partial_ordering.html "cpp/utility/compare/partial ordering")(C++20)  
[common_comparison_category](compare/common_comparison_category.html "cpp/utility/compare/common comparison category")(C++20)  
[compare_three_way_result](compare/compare_three_way_result.html "cpp/utility/compare/compare three way result")(C++20)  
[compare_three_way](compare/compare_three_way.html "cpp/utility/compare/compare three way")(C++20)  
[strong_order](compare/strong_order.html "cpp/utility/compare/strong order")(C++20)  
[weak_order](compare/weak_order.html "cpp/utility/compare/weak order")(C++20)  
[partial_order](compare/partial_order.html "cpp/utility/compare/partial order")(C++20)  
[compare_strong_order_fallback](compare/compare_strong_order_fallback.html "cpp/utility/compare/compare strong order fallback")(C++20)  
[compare_weak_order_fallback](compare/compare_weak_order_fallback.html "cpp/utility/compare/compare weak order fallback")(C++20)  
[compare_partial_order_fallback](compare/compare_partial_order_fallback.html "cpp/utility/compare/compare partial order fallback")(C++20)` `  
|  | [is_eqis_ltis_lteq](compare/named_comparison_functions.html "cpp/utility/compare/named comparison functions")(C++20)(C++20)(C++20)` `  
---  
  
| [is_neqis_gtis_gteq](compare/named_comparison_functions.html "cpp/utility/compare/named comparison functions")(C++20)(C++20)(C++20)  
---  
  
  
  
  
| General utilities  
---  
| [Function objects](../functional.html "cpp/utility/functional")  
---  
[Bit manipulation](bit.html "cpp/utility/bit") (C++20)  
[C-style bit manipulation](https://en.cppreference.com/mwiki/index.php?title=cpp/utility/stdbit&action=edit&redlink=1 "cpp/utility/stdbit \(page does not exist\)") (C++26)  
[bitset](bitset.html "cpp/utility/bitset")  
**hash**(C++11)  
  
[Relational operators](../utility.html#Relational_operators "cpp/utility") (deprecated in C++20)  
|  | [rel_ops::operator!=rel_ops::operator>](rel_ops/operator_cmp.html "cpp/utility/rel ops/operator cmp")` `  
---  
  
| [rel_ops::operator<=rel_ops::operator>=](rel_ops/operator_cmp.html "cpp/utility/rel ops/operator cmp")  
---  
  
[Integer comparison functions](../utility.html#Integer_comparison_functions "cpp/utility")  
| [cmp_equalcmp_lesscmp_less_than](intcmp.html "cpp/utility/intcmp")(C++20)(C++20)(C++20)` `  
---  
  
| [cmp_not_equalcmp_greatercmp_greater_than](intcmp.html "cpp/utility/intcmp")(C++20)(C++20)(C++20)  
---  
  
[in_range](in_range.html "cpp/utility/in range")(C++20)  
[Swap](../utility.html#Swap "cpp/utility") and [type operations](../utility.html#Type_operations "cpp/utility")  
| [swap](swap.html "cpp/algorithm/swap")  
---  
[ranges::swap](ranges/swap.html "cpp/utility/ranges/swap")(C++20)  
[exchange](exchange.html "cpp/utility/exchange")(C++14)  
[declval](declval.html "cpp/utility/declval")(C++11)  
[to_underlying](to_underlying.html "cpp/utility/to underlying")(C++23)  
  
| [forward](forward.html "cpp/utility/forward")(C++11)  
---  
[forward_like](forward_like.html "cpp/utility/forward like")(C++23)  
[move](move.html "cpp/utility/move")(C++11)  
[move_if_noexcept](move_if_noexcept.html "cpp/utility/move if noexcept")(C++11)  
[as_const](as_const.html "cpp/utility/as const")(C++17)  
  
Common vocabulary types  
| [pair](pair.html "cpp/utility/pair")  
---  
[tuple](tuple.html "cpp/utility/tuple")(C++11)  
[optional](optional.html "cpp/utility/optional")(C++17)  
[any](any.html "cpp/utility/any")(C++17)  
[variant](variant.html "cpp/utility/variant")(C++17)  
  
| [tuple_size](tuple_size.html "cpp/utility/tuple size")(C++11)  
---  
[tuple_element](tuple_element.html "cpp/utility/tuple element")(C++11)  
[apply](apply.html "cpp/utility/apply")(C++17)  
[make_from_tuple](make_from_tuple.html "cpp/utility/make from tuple")(C++17)  
[expected](expected.html "cpp/utility/expected")(C++23)  
  
  
  
  
  
  


**`std::hash`**

[hash::hash](hash/hash.html "cpp/utility/hash/hash")  
---  
[hash::operator()](hash/operator\(\).html "cpp/utility/hash/operator\(\)")  
  


Defined in header `[<bitset>](../header/bitset.html "cpp/header/bitset")` |  |   
---|---|---  
Defined in header `[<coroutine>](../header/coroutine.html "cpp/header/coroutine")` |  | (since C++20)  
Defined in header `[<chrono>](../header/chrono.html "cpp/header/chrono")` |  | (since C++26)  
Defined in header `[<filesystem>](../header/filesystem.html "cpp/header/filesystem")` |  | (since C++17)  
Defined in header `[<functional>](../header/functional.html "cpp/header/functional")` |  |   
Defined in header `[<memory>](../header/memory.html "cpp/header/memory")` |  |   
Defined in header `[<optional>](../header/optional.html "cpp/header/optional")` |  | (since C++17)  
Defined in header `[<stacktrace>](../header/stacktrace.html "cpp/header/stacktrace")` |  | (since C++23)  
Defined in header `[<string>](../header/string.html "cpp/header/string")` |  |   
Defined in header `[<string_view>](../header/string_view.html "cpp/header/string view")` |  | (since C++17)  
Defined in header `[<system_error>](../header/system_error.html "cpp/header/system error")` |  |   
Defined in header `[<text_encoding>](../header/text_encoding.html "cpp/header/text encoding")` |  | (since C++26)  
Defined in header `[<thread>](../header/thread.html "cpp/header/thread")` |  |   
Defined in header `[<typeindex>](../header/typeindex.html "cpp/header/typeindex")` |  |   
Defined in header `[<utility>](../header/utility.html "cpp/header/utility")` |  | (since C++26)  
Defined in header `[<variant>](../header/variant.html "cpp/header/variant")` |  | (since C++17)  
Defined in header `[<vector>](../header/vector.html "cpp/header/vector")` |  |   
template< class Key >  
struct hash; |  |  (since C++11)  
| |   
  
The enabled specializations of the `hash` template define a function object that implements a [hash function](https://en.wikipedia.org/wiki/Hash_function "enwiki:Hash function"). 

Given a type `Key`, each specialization `std::hash<Key>` is either _enabled_ or _disabled ﻿_ : 

  * If `std::hash<Key>` is not provided by the program or the user, it is disabled. 
  * Otherwise, `std::hash<Key>` is enabled if all following conditions are satisfied: 



    

  * All following requirements are satisfied: 



    

  * [Hash](../named_req/Hash.html "cpp/named req/Hash") (with `Key` as the function call argument type) 
  * [DefaultConstructible](../named_req/DefaultConstructible.html "cpp/named req/DefaultConstructible")
  * [CopyAssignable](../named_req/CopyAssignable.html "cpp/named req/CopyAssignable")
  * [Swappable](../named_req/Swappable.html "cpp/named req/Swappable")



  * Given the following values: 



    

  * h, an object of type `std::hash<Key>`. 
  * k1 and k2, objects of type `Key`. 


     All following requirements are satisfied: 

  * If k1 == k2 is true, h(k1) == h(k2) is also true. 
  * Unless `std::hash<Key>` is a [program-defined specialization](../language/type-id.html#Program-defined_type "cpp/language/type"), h(k1) will never throw an exception. 



  * Otherwise, `std::hash<Key>` is disabled. 



Disabled specializations do not satisfy [Hash](../named_req/Hash.html "cpp/named req/Hash"), do not satisfy [FunctionObject](../named_req/FunctionObject.html "cpp/named req/FunctionObject"), and following values are all false: 

  * [std::is_default_constructible](../types/is_default_constructible.html)<std::hash<Key>>::value
  * [std::is_copy_constructible](../types/is_copy_constructible.html)<std::hash<Key>>::value
  * [std::is_move_constructible](../types/is_move_constructible.html)<std::hash<Key>>::value
  * [std::is_copy_assignable](../types/is_copy_assignable.html)<std::hash<Key>>::value
  * [std::is_move_assignable](../types/is_move_assignable.html)<std::hash<Key>>::value



In other words, they exist, but cannot be used. 

| 

## Contents

  * [1 Nested types](hash.html#Nested_types)
  * [2 Member functions](hash.html#Member_functions)
  * [3 Standard library specializations](hash.html#Standard_library_specializations)
  * [4 Specializations for library types](hash.html#Specializations_for_library_types)
    * [4.1 Language support library](hash.html#Language_support_library)
    * [4.2 Dianostics library](hash.html#Dianostics_library)
    * [4.3 Memory management library](hash.html#Memory_management_library)
    * [4.4 General utilities library](hash.html#General_utilities_library)
    * [4.5 Containers library](hash.html#Containers_library)
    * [4.6 Strings library](hash.html#Strings_library)
    * [4.7 Text processing library](hash.html#Text_processing_library)
    * [4.8 Time library](hash.html#Time_library)
    * [4.9 Input/output library](hash.html#Input.2Foutput_library)
    * [4.10 Concurrency support library](hash.html#Concurrency_support_library)
  * [5 Notes](hash.html#Notes)
  * [6 Example](hash.html#Example)
  * [7 Defect reports](hash.html#Defect_reports)

  
---  
  
###  Nested types

Type  |  Definition   
---|---  
`argument_type` (deprecated in C++17) |  `Key`  
`result_type` (deprecated in C++17) |  [std::size_t](../types/size_t.html "cpp/types/size t")  
(until C++20)  
  
### Member functions

[ (constructor)](hash/hash.html "cpp/utility/hash/hash") |  constructs a hash function object   
(public member function)  
---|---  
[ operator()](hash/operator\(\).html "cpp/utility/hash/operator\(\)") |  calculates the hash of the argument   
(public member function)  
  
### Standard library specializations

Each header that declares the template `std::hash` also provides enabled specializations of `std::hash` for the following types: 

  * all cv-unqualified [arithmetic types](../language/types.html "cpp/language/types")
  * all cv-unqualified [enumeration types](../language/enum.html "cpp/language/enum")
  * all cv-unqualified [pointer types](../language/pointer.html "cpp/language/pointer")
  * [std::nullptr_t](../types/nullptr_t.html "cpp/types/nullptr t")

A [freestanding implementation](../freestanding.html "cpp/freestanding") is required to provide these aforementioned specializations and the disabled-by-default specializations.  | (since C++20)  
---|---  
  
On top of that, some headers also provide other enabled `std::hash` specializations for library types (see [below](hash.html#Specializations_for_library_types)). 

For all `std::hash` specializations provided by the standard library except the following, all their member functions are noexcept: 

  * [`std::hash<std::optional>`](optional/hash.html "cpp/utility/optional/hash")
  * [`std::hash<std::variant>`](variant/hash.html "cpp/utility/variant/hash")
  * [`std::hash<std::unique_ptr>`](../memory/unique_ptr/hash.html "cpp/memory/unique ptr/hash")

| 

  * [`std::hash<std::indirect>`](../memory/indirect/hash.html "cpp/memory/indirect/hash")
  * [`std::hash<std::chrono::duration>`](../chrono/duration/hash.html "cpp/chrono/duration/hash")
  * [`std::hash<std::chrono::time_point>`](../chrono/time_point/hash.html "cpp/chrono/time point/hash")
  * [`std::hash<std::chrono::zoned_time>`](../chrono/zoned_time/hash.html "cpp/chrono/zoned time/hash")

| (since C++26)  
---|---  
(since C++17)  
  
### Specializations for library types

#####  Language support library   
  
---  
[ std::hash<std::coroutine_handle>](../coroutine/coroutine_handle/hash.html "cpp/coroutine/coroutine handle/hash")(C++20) |  hash support for [`std::coroutine_handle`](../coroutine/coroutine_handle.html "cpp/coroutine/coroutine handle")   
(class template specialization)   
  
#####  Dianostics library   
  
[ std::hash<std::error_code>](../error/error_code/hash.html "cpp/error/error code/hash")(C++11) |  hash support for [`std::error_code`](../error/error_code.html "cpp/error/error code")   
(class template specialization)   
[ std::hash<std::error_condition>](../error/error_condition/hash.html "cpp/error/error condition/hash")(C++17) |  hash support for [`std::error_condition`](../error/error_condition.html "cpp/error/error condition")   
(class template specialization)   
[ std::hash<std::type_index>](../types/type_index/hash.html "cpp/types/type index/hash")(C++11) |  hash support for [`std::type_index`](../types/type_index.html "cpp/types/type index")   
(class template specialization)   
[ std::hash<std::stacktrace_entry>](stacktrace_entry/hash.html "cpp/utility/stacktrace entry/hash")(C++23) |  hash support for [`std::stacktrace_entry`](stacktrace_entry.html "cpp/utility/stacktrace entry")   
(class template specialization)   
[ std::hash<std::basic_stacktrace>](basic_stacktrace/hash.html "cpp/utility/basic stacktrace/hash")(C++23) |  hash support for [`std::basic_stacktrace`](basic_stacktrace.html "cpp/utility/basic stacktrace")   
(class template specialization)   
  
#####  Memory management library   
  
[ std::hash<std::unique_ptr>](../memory/unique_ptr/hash.html "cpp/memory/unique ptr/hash")(C++11) |  hash support for [`std::unique_ptr`](../memory/unique_ptr.html "cpp/memory/unique ptr")   
(class template specialization)   
[ std::hash<std::shared_ptr>](../memory/shared_ptr/hash.html "cpp/memory/shared ptr/hash")(C++11) |  hash support for [`std::shared_ptr`](../memory/shared_ptr.html "cpp/memory/shared ptr")   
(class template specialization)   
[ std::hash<std::indirect>](../memory/indirect/hash.html "cpp/memory/indirect/hash")(C++26) |  hash support for [`std::indirect`](../memory/indirect.html "cpp/memory/indirect")   
(class template specialization)   
  
#####  General utilities library   
  
[ std::hash<std::optional>](optional/hash.html "cpp/utility/optional/hash")(C++17) |  hash support for [`std::optional`](optional.html "cpp/utility/optional")   
(class template specialization)   
[ std::hash<std::variant>](variant/hash.html "cpp/utility/variant/hash")(C++17) |  hash support for [`std::variant`](variant.html "cpp/utility/variant")   
(class template specialization)   
[ std::hash<std::monostate>](variant/monostate.html#Helper_classes "cpp/utility/variant/monostate")(C++17) |  hash support for [std::monostate](variant/monostate.html "cpp/utility/variant/monostate")   
(class template specialization)  
[ std::hash<std::bitset>](bitset/hash.html "cpp/utility/bitset/hash")(C++11) |  hash support for [`std::bitset`](bitset.html "cpp/utility/bitset")   
(class template specialization)   
  
#####  Containers library   
  
[ std::hash<std::vector<bool>>](../container/vector_bool/hash.html "cpp/container/vector bool/hash")(C++11) |  hash support for [`std::vector<bool>`](../container/vector_bool.html "cpp/container/vector bool")   
(class template specialization)  
  
#####  Strings library   
  
[ std::hash<std::basic_string>](../string/basic_string/hash.html "cpp/string/basic string/hash")(C++11) |  hash support for strings   
(class template specialization)   
[ std::hash<std::string_view>std::hash<std::wstring_view>std::hash<std::u8string_view>std::hash<std::u16string_view>std::hash<std::u32string_view>](../string/basic_string_view/hash.html "cpp/string/basic string view/hash")(C++17)(C++17)(C++20)(C++17)(C++17) |  hash support for string views   
(class template specialization)   
  
#####  Text processing library   
  
[ std::hash<std::text_encoding>](../text/text_encoding/hash.html "cpp/text/text encoding/hash")(C++26) |  hash support for [`std::text_encoding`](../locale/text_encoding.html "cpp/text/text encoding")   
(class template specialization)   
  
#####  Time library   
  
---  
[ std::hash<std::chrono::duration>](../chrono/duration/hash.html "cpp/chrono/duration/hash")(C++26) |  hash support for [`std::chrono::duration`](../chrono/duration.html "cpp/chrono/duration")   
(class template specialization)  
[ std::hash<std::chrono::time_point>](../chrono/time_point/hash.html "cpp/chrono/time point/hash")(C++26) |  hash support for [`std::chrono::time_point`](../chrono/time_point.html "cpp/chrono/time point")   
(class template specialization)  
[ std::hash<std::chrono::day>](../chrono/day/hash.html "cpp/chrono/day/hash")(C++26) |  hash support for [`std::chrono::day`](../chrono/day.html "cpp/chrono/day")   
(class template specialization)  
[ std::hash<std::chrono::month>](../chrono/month/hash.html "cpp/chrono/month/hash")(C++26) |  hash support for [`std::chrono::month`](../chrono/month.html "cpp/chrono/month")   
(class template specialization)  
[ std::hash<std::chrono::year>](../chrono/year/hash.html "cpp/chrono/year/hash")(C++26) |  hash support for [`std::chrono::year`](../chrono/year.html "cpp/chrono/year")   
(class template specialization)  
[ std::hash<std::chrono::weekday>](../chrono/weekday/hash.html "cpp/chrono/weekday/hash")(C++26) |  hash support for [`std::chrono::weekday`](../chrono/weekday.html "cpp/chrono/weekday")   
(class template specialization)  
[ std::hash<std::chrono::weekday_indexed>](../chrono/weekday_indexed/hash.html "cpp/chrono/weekday indexed/hash")(C++26) |  hash support for [`std::chrono::weekday_indexed`](../chrono/weekday_indexed.html "cpp/chrono/weekday indexed")   
(class template specialization)  
[ std::hash<std::chrono::weekday_last>](../chrono/weekday_last/hash.html "cpp/chrono/weekday last/hash")(C++26) |  hash support for [`std::chrono::weekday_last`](../chrono/weekday_last.html "cpp/chrono/weekday last")   
(class template specialization)  
[ std::hash<std::chrono::month_day>](../chrono/month_day/hash.html "cpp/chrono/month day/hash")(C++26) |  hash support for [`std::chrono::month_day`](../chrono/month_day.html "cpp/chrono/month day")   
(class template specialization)  
[ std::hash<std::chrono::month_day_last>](../chrono/month_day_last/hash.html "cpp/chrono/month day last/hash")(C++26) |  hash support for [`std::chrono::month_day_last`](../chrono/month_day_last.html "cpp/chrono/month day last")   
(class template specialization)  
[ std::hash<std::chrono::month_weekday>](../chrono/month_weekday/hash.html "cpp/chrono/month weekday/hash")(C++26) |  hash support for [`std::chrono::month_weekday`](../chrono/month_weekday.html "cpp/chrono/month weekday")   
(class template specialization)  
[ std::hash<std::chrono::month_weekday_last>](../chrono/month_weekday_last/hash.html "cpp/chrono/month weekday last/hash")(C++26) |  hash support for [`std::chrono::month_weekday_last`](../chrono/month_weekday_last.html "cpp/chrono/month weekday last")   
(class template specialization)  
[ std::hash<std::chrono::year_month>](../chrono/year_month/hash.html "cpp/chrono/year month/hash")(C++26) |  hash support for [`std::chrono::year_month`](../chrono/year_month.html "cpp/chrono/year month")   
(class template specialization)  
[ std::hash<std::chrono::year_month_day>](../chrono/year_month_day/hash.html "cpp/chrono/year month day/hash")(C++26) |  hash support for [`std::chrono::year_month_day`](../chrono/year_month_day.html "cpp/chrono/year month day")   
(class template specialization)  
[ std::hash<std::chrono::year_month_day_last>](../chrono/year_month_day_last/hash.html "cpp/chrono/year month day last/hash")(C++26) |  hash support for [`std::chrono::year_month_day_last`](../chrono/year_month_day_last.html "cpp/chrono/year month day last")   
(class template specialization)  
[ std::hash<std::chrono::year_month_weekday>](../chrono/year_month_weekday/hash.html "cpp/chrono/year month weekday/hash")(C++26) |  hash support for [`std::chrono::year_month_weekday`](../chrono/year_month_weekday.html "cpp/chrono/year month weekday")   
(class template specialization)  
[ std::hash<std::chrono::year_month_weekday_last>](../chrono/year_month_weekday_last/hash.html "cpp/chrono/year month weekday last/hash")(C++26) |  hash support for [`std::chrono::year_month_weekday_last`](../chrono/year_month_weekday_last.html "cpp/chrono/year month weekday last")   
(class template specialization)  
[ std::hash<std::chrono::zoned_time>](../chrono/zoned_time/hash.html "cpp/chrono/zoned time/hash")(C++26) |  hash support for [`std::chrono::zoned_time`](../chrono/zoned_time.html "cpp/chrono/zoned time")   
(class template specialization)  
[ std::hash<std::chrono::leap_second>](../chrono/leap_second/hash.html "cpp/chrono/leap second/hash")(C++26) |  hash support for [`std::chrono::leap_second`](../chrono/leap_second.html "cpp/chrono/leap second")   
(class template specialization)  
  
#####  Input/output library   
  
---  
[ std::hash<std::filesystem::path>](../filesystem/path/hash.html "cpp/filesystem/path/hash")(C++17) |  hash support for [`std::filesystem::path`](../filesystem/path.html "cpp/filesystem/path")   
(class template specialization)   
  
#####  Concurrency support library   
  
[ std::hash<std::thread::id>](../thread/thread/id/hash.html "cpp/thread/thread/id/hash")(C++11) |  hash support for [`std::thread::id`](../thread/thread/id.html "cpp/thread/thread/id")   
(class template specialization)   
  
### Notes

The actual hash functions are implementation-dependent and are not required to fulfill any other quality criteria except those specified above. Notably, some implementations use trivial (identity) hash functions which map an integer to itself. In other words, these hash functions are designed to work with unordered associative containers, but not as cryptographic hashes, for example. 

Hash functions are only required to produce the same result for the same input within a single execution of a program; this allows salted hashes that prevent collision denial-of-service attacks. 

There is no specialization for C strings. std::hash<const char*> produces a hash of the value of the pointer (the memory address), it does not examine the contents of any character array. 

Additional specializations for [std::pair](pair.html "cpp/utility/pair") and the standard container types, as well as utility functions to compose hashes are available in [`boost::hash`](https://www.boost.org/doc/libs/release/libs/container_hash/doc/html/hash.html#ref). 

### Example

Run this code
    
    
    #include <cstddef>
    #include <functional>
    #include <iomanip>
    #include <iostream>
    #include <string>
    #include <unordered_set>
     
    struct S
    {
        [std::string](../string/basic_string.html) first_name;
        [std::string](../string/basic_string.html) last_name;
        bool operator==(const S&) const = default; // since C++20
    };
     
    // Before C++20.
    // bool operator==(const S& lhs, const S& rhs)
    // {
    //     return lhs.first_name == rhs.first_name && lhs.last_name == rhs.last_name;
    // }
     
    // Custom hash can be a standalone function object.
    struct MyHash
    {
        [std::size_t](../types/size_t.html) operator()(const S& s) const noexcept
        {
            [std::size_t](../types/size_t.html) h1 = std::hash<[std::string](../string/basic_string.html)>{}(s.first_name);
            [std::size_t](../types/size_t.html) h2 = std::hash<[std::string](../string/basic_string.html)>{}(s.last_name);
            return h1 ^ (h2 << 1); // or use boost::hash_combine
        }
    };
     
    // Custom specialization of std::hash can be injected in namespace std.
    template<>
    struct std::hash<S>
    {
        [std::size_t](../types/size_t.html) operator()(const S& s) const noexcept
        {
            [std::size_t](../types/size_t.html) h1 = std::hash<[std::string](../string/basic_string.html)>{}(s.first_name);
            [std::size_t](../types/size_t.html) h2 = std::hash<[std::string](../string/basic_string.html)>{}(s.last_name);
            return h1 ^ (h2 << 1); // or use boost::hash_combine
        }
    };
     
    int main()
    {
        [std::string](../string/basic_string.html) str = "Meet the new boss...";
        [std::size_t](../types/size_t.html) str_hash = std::hash<[std::string](../string/basic_string.html)>{}(str);
        [std::cout](../io/cout.html) << "hash(" << [std::quoted](../io/manip/quoted.html)(str) << ") =\t" << str_hash << '\n';
     
        S obj = {"Hubert", "Farnsworth"};
        // Using the standalone function object.
        [std::cout](../io/cout.html) << "hash(" << [std::quoted](../io/manip/quoted.html)(obj.first_name) << ", "
                  << [std::quoted](../io/manip/quoted.html)(obj.last_name) << ") =\t"
                  << MyHash{}(obj) << " (using MyHash) or\n\t\t\t\t"
                  << std::hash<S>{}(obj) << " (using injected specialization)\n";
     
        // Custom hash makes it possible to use custom types in unordered containers.
        // The example will use the injected std::hash<S> specialization above,
        // to use MyHash instead, pass it as a second template argument.
        [std::unordered_set](../container/unordered_set.html)<S> names = {obj, {"Bender", "Rodriguez"}, {"Turanga", "Leela"}};
        for (auto const& s: names)
            [std::cout](../io/cout.html) << [std::quoted](../io/manip/quoted.html)(s.first_name) << ' '
                      << [std::quoted](../io/manip/quoted.html)(s.last_name) << '\n';
    }

Possible output: 
    
    
    hash("Meet the new boss...") =  10656026664466977650
    hash("Hubert", "Farnsworth") =  12922914235676820612 (using MyHash) or
                                    12922914235676820612 (using injected specialization)
    "Bender" "Rodriguez"
    "Turanga" "Leela"
    "Hubert" "Farnsworth"

### Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[LWG 2119](https://cplusplus.github.io/LWG/issue2119) | C++11  | specializations for extended integer types were missing  | provided   
[LWG 2148](https://cplusplus.github.io/LWG/issue2148) | C++11  | specializations for enumerations were missing  | provided   
[LWG 2543](https://cplusplus.github.io/LWG/issue2543) | C++11  | `std::hash` might not be SFINAE-friendly  | made SFINAE-friendly   
[LWG 2817](https://cplusplus.github.io/LWG/issue2817) | C++11  | specialization for [std::nullptr_t](../types/nullptr_t.html "cpp/types/nullptr t") was missing  | provided 
