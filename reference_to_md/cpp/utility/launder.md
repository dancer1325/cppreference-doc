
  


[Utilities library](../utility.html "cpp/utility")

| [Language support](../utility.html#Language_support "cpp/utility")  
---  
[Type support](rtti.html "cpp/types") (basic types, RTTI)  
[Library feature-test macros](feature_test.html "cpp/utility/feature test") (C++20)  
[Program utilities](program.html "cpp/utility/program")  
[Variadic functions](variadic.html "cpp/utility/variadic")  
[initializer_list](initializer_list.html "cpp/utility/initializer list")(C++11)  
[is_constant_evaluated](../types/is_constant_evaluated.html "cpp/types/is constant evaluated")(C++20)  
[is_within_lifetime](../types/is_within_lifetime.html "cpp/types/is within lifetime")(C++26)  
[source_location](source_location.html "cpp/utility/source location")(C++20)  
[Coroutine support](../coroutine.html "cpp/coroutine") (C++20)  
[Contract support](../contract.html "cpp/contract") (C++26)  
[Three-way comparison](../utility.html#Three-way_comparison "cpp/utility")  
[three_way_comparablethree_way_comparable_with](compare/three_way_comparable.html "cpp/utility/compare/three way comparable")(C++20)(C++20)  
[strong_ordering](compare/strong_ordering.html "cpp/utility/compare/strong ordering")(C++20)  
[weak_ordering](compare/weak_ordering.html "cpp/utility/compare/weak ordering")(C++20)  
[partial_ordering](compare/partial_ordering.html "cpp/utility/compare/partial ordering")(C++20)  
[common_comparison_category](compare/common_comparison_category.html "cpp/utility/compare/common comparison category")(C++20)  
[compare_three_way_result](compare/compare_three_way_result.html "cpp/utility/compare/compare three way result")(C++20)  
[compare_three_way](compare/compare_three_way.html "cpp/utility/compare/compare three way")(C++20)  
[strong_order](compare/strong_order.html "cpp/utility/compare/strong order")(C++20)  
[weak_order](compare/weak_order.html "cpp/utility/compare/weak order")(C++20)  
[partial_order](compare/partial_order.html "cpp/utility/compare/partial order")(C++20)  
[compare_strong_order_fallback](compare/compare_strong_order_fallback.html "cpp/utility/compare/compare strong order fallback")(C++20)  
[compare_weak_order_fallback](compare/compare_weak_order_fallback.html "cpp/utility/compare/compare weak order fallback")(C++20)  
[compare_partial_order_fallback](compare/compare_partial_order_fallback.html "cpp/utility/compare/compare partial order fallback")(C++20)` `  
|  | [is_eqis_ltis_lteq](compare/named_comparison_functions.html "cpp/utility/compare/named comparison functions")(C++20)(C++20)(C++20)` `  
---  
  
| [is_neqis_gtis_gteq](compare/named_comparison_functions.html "cpp/utility/compare/named comparison functions")(C++20)(C++20)(C++20)  
---  
  
  
  
  
| General utilities  
---  
| [Function objects](../functional.html "cpp/utility/functional")  
---  
[Bit manipulation](bit.html "cpp/utility/bit") (C++20)  
[C-style bit manipulation](https://en.cppreference.com/mwiki/index.php?title=cpp/utility/stdbit&action=edit&redlink=1 "cpp/utility/stdbit \(page does not exist\)") (C++26)  
[bitset](bitset.html "cpp/utility/bitset")  
[hash](hash.html "cpp/utility/hash")(C++11)  
  
[Relational operators](../utility.html#Relational_operators "cpp/utility") (deprecated in C++20)  
|  | [rel_ops::operator!=rel_ops::operator>](rel_ops/operator_cmp.html "cpp/utility/rel ops/operator cmp")` `  
---  
  
| [rel_ops::operator<=rel_ops::operator>=](rel_ops/operator_cmp.html "cpp/utility/rel ops/operator cmp")  
---  
  
[Integer comparison functions](../utility.html#Integer_comparison_functions "cpp/utility")  
| [cmp_equalcmp_lesscmp_less_than](intcmp.html "cpp/utility/intcmp")(C++20)(C++20)(C++20)` `  
---  
  
| [cmp_not_equalcmp_greatercmp_greater_than](intcmp.html "cpp/utility/intcmp")(C++20)(C++20)(C++20)  
---  
  
[in_range](in_range.html "cpp/utility/in range")(C++20)  
[Swap](../utility.html#Swap "cpp/utility") and [type operations](../utility.html#Type_operations "cpp/utility")  
| [swap](swap.html "cpp/algorithm/swap")  
---  
[ranges::swap](ranges/swap.html "cpp/utility/ranges/swap")(C++20)  
[exchange](exchange.html "cpp/utility/exchange")(C++14)  
[declval](declval.html "cpp/utility/declval")(C++11)  
[to_underlying](to_underlying.html "cpp/utility/to underlying")(C++23)  
  
| [forward](forward.html "cpp/utility/forward")(C++11)  
---  
[forward_like](forward_like.html "cpp/utility/forward like")(C++23)  
[move](move.html "cpp/utility/move")(C++11)  
[move_if_noexcept](move_if_noexcept.html "cpp/utility/move if noexcept")(C++11)  
[as_const](as_const.html "cpp/utility/as const")(C++17)  
  
Common vocabulary types  
| [pair](pair.html "cpp/utility/pair")  
---  
[tuple](tuple.html "cpp/utility/tuple")(C++11)  
[optional](optional.html "cpp/utility/optional")(C++17)  
[any](any.html "cpp/utility/any")(C++17)  
[variant](variant.html "cpp/utility/variant")(C++17)  
  
| [tuple_size](tuple_size.html "cpp/utility/tuple size")(C++11)  
---  
[tuple_element](tuple_element.html "cpp/utility/tuple element")(C++11)  
[apply](apply.html "cpp/utility/apply")(C++17)  
[make_from_tuple](make_from_tuple.html "cpp/utility/make from tuple")(C++17)  
[expected](expected.html "cpp/utility/expected")(C++23)  
  
  
  
  
  
  


[Memory management library](../memory.html "cpp/memory")

| [_voidify_](../memory/voidify.html "cpp/memory/voidify")(exposition only*)  
---  
[Allocators](../memory.html#Allocators "cpp/memory")  
| [allocator](../memory/allocator.html "cpp/memory/allocator")  
---  
[allocator_traits](../memory/allocator_traits.html "cpp/memory/allocator traits")(C++11)  
[allocation_result](../memory/allocation_result.html "cpp/memory/allocation result")(C++23)  
[scoped_allocator_adaptor](../memory/scoped_allocator_adaptor.html "cpp/memory/scoped allocator adaptor")(C++11)  
[pmr::polymorphic_allocator](../memory/polymorphic_allocator.html "cpp/memory/polymorphic allocator")(C++17)  
  
| [allocator_arg](../memory/allocator_arg.html "cpp/memory/allocator arg")(C++11)  
---  
[uses_allocator](../memory/uses_allocator.html "cpp/memory/uses allocator")(C++11)  
[uses_allocator_construction_args](../memory/uses_allocator_construction_args.html "cpp/memory/uses allocator construction args")(C++20)  
[make_obj_using_allocator](../memory/make_obj_using_allocator.html "cpp/memory/make obj using allocator")(C++20)  
[uninitialized_construct_using_allocator](../memory/uninitialized_construct_using_allocator.html "cpp/memory/uninitialized construct using allocator")(C++20)  
  
[Uninitialized memory algorithms](../memory.html#Uninitialized_memory_algorithms "cpp/memory")  
| [uninitialized_copy](../memory/uninitialized_copy.html "cpp/memory/uninitialized copy")  
---  
[uninitialized_fill](../memory/uninitialized_fill.html "cpp/memory/uninitialized fill")  
[uninitialized_move](../memory/uninitialized_move.html "cpp/memory/uninitialized move")(C++17)  
[uninitialized_copy_n](../memory/uninitialized_copy_n.html "cpp/memory/uninitialized copy n")(C++11)  
[uninitialized_fill_n](../memory/uninitialized_fill_n.html "cpp/memory/uninitialized fill n")  
[uninitialized_move_n](../memory/uninitialized_move_n.html "cpp/memory/uninitialized move n")(C++17)  
[construct_at](../memory/construct_at.html "cpp/memory/construct at")(C++20)  
  
| [uninitialized_default_construct](../memory/uninitialized_default_construct.html "cpp/memory/uninitialized default construct")(C++17)  
---  
[uninitialized_value_construct](../memory/uninitialized_value_construct.html "cpp/memory/uninitialized value construct")(C++17)  
[destroy](../memory/destroy.html "cpp/memory/destroy")(C++17)  
[uninitialized_default_construct_n](../memory/uninitialized_default_construct_n.html "cpp/memory/uninitialized default construct n")(C++17)  
[uninitialized_value_construct_n](../memory/uninitialized_value_construct_n.html "cpp/memory/uninitialized value construct n")(C++17)  
[destroy_n](../memory/destroy_n.html "cpp/memory/destroy n")(C++17)  
[destroy_at](../memory/destroy_at.html "cpp/memory/destroy at")(C++17)  
  
[Constrained uninitialized memory algorithms](../memory.html#Constrained_uninitialized_memory_algorithms "cpp/memory")  
| [ranges::uninitialized_copy](../memory/ranges/uninitialized_copy.html "cpp/memory/ranges/uninitialized copy")(C++20)  
---  
[ranges::uninitialized_fill](../memory/ranges/uninitialized_fill.html "cpp/memory/ranges/uninitialized fill")(C++20)  
[ranges::uninitialized_move](../memory/ranges/uninitialized_move.html "cpp/memory/ranges/uninitialized move")(C++20)  
[ranges::uninitialized_copy_n](../memory/ranges/uninitialized_copy_n.html "cpp/memory/ranges/uninitialized copy n")(C++20)` `  
[ranges::uninitialized_fill_n](../memory/ranges/uninitialized_fill_n.html "cpp/memory/ranges/uninitialized fill n")(C++20)  
[ranges::uninitialized_move_n](../memory/ranges/uninitialized_move_n.html "cpp/memory/ranges/uninitialized move n")(C++20)  
[ranges::construct_at](../memory/ranges/construct_at.html "cpp/memory/ranges/construct at")(C++20)  
  
| [ranges::uninitialized_default_construct](../memory/ranges/uninitialized_default_construct.html "cpp/memory/ranges/uninitialized default construct")(C++20)  
---  
[ranges::uninitialized_value_construct](../memory/ranges/uninitialized_value_construct.html "cpp/memory/ranges/uninitialized value construct")(C++20)  
[ranges::destroy](../memory/ranges/destroy.html "cpp/memory/ranges/destroy")(C++20)  
[ranges::uninitialized_default_construct_n](../memory/ranges/uninitialized_default_construct_n.html "cpp/memory/ranges/uninitialized default construct n")(C++20)` `  
[ranges::uninitialized_value_construct_n](../memory/ranges/uninitialized_value_construct_n.html "cpp/memory/ranges/uninitialized value construct n")(C++20)  
[ranges::destroy_n](../memory/ranges/destroy_n.html "cpp/memory/ranges/destroy n")(C++20)  
[ranges::destroy_at](../memory/ranges/destroy_at.html "cpp/memory/ranges/destroy at")(C++20)  
  
[Memory resources](../memory.html#Memory_resources "cpp/memory")  
| [pmr::memory_resource](../memory/memory_resource.html "cpp/memory/memory resource")(C++17)  
---  
[pmr::get_default_resource](../memory/get_default_resource.html "cpp/memory/get default resource")(C++17)  
[pmr::set_default_resource](../memory/set_default_resource.html "cpp/memory/set default resource")(C++17)  
[pmr::new_delete_resource](../memory/new_delete_resource.html "cpp/memory/new delete resource")(C++17)  
[pmr::pool_options](../memory/pool_options.html "cpp/memory/pool options")(C++17)  
  
| [pmr::null_memory_resource](../memory/null_memory_resource.html "cpp/memory/null memory resource")(C++17)  
---  
[pmr::synchronized_pool_resource](../memory/synchronized_pool_resource.html "cpp/memory/synchronized pool resource")(C++17)  
[pmr::unsynchronized_pool_resource](../memory/unsynchronized_pool_resource.html "cpp/memory/unsynchronized pool resource")(C++17)  
[pmr::monotonic_buffer_resource](../memory/monotonic_buffer_resource.html "cpp/memory/monotonic buffer resource")(C++17)  
  
  
  
| [Explicit lifetime management](../memory.html#Explicit_lifetime_management "cpp/memory")  
---  
[start_lifetime_as](../memory/start_lifetime_as.html "cpp/memory/start lifetime as")(C++23)  
[start_lifetime_as_array](../memory/start_lifetime_as.html "cpp/memory/start lifetime as")(C++23)  
  
| [Types for composite class design](../memory.html#Types_for_composite_class_design "cpp/memory")  
---  
[indirect](../memory/indirect.html "cpp/memory/indirect")(C++26)  
[polymorphic](../memory/polymorphic.html "cpp/memory/polymorphic")(C++26)  
  
[Uninitialized storage](../memory.html#Uninitialized_storage "cpp/memory") (until C++20)  
| [raw_storage_iterator](../memory/raw_storage_iterator.html "cpp/memory/raw storage iterator")(until C++20*)  
---  
[get_temporary_buffer](../memory/get_temporary_buffer.html "cpp/memory/get temporary buffer")(until C++20*)  
  
| [return_temporary_buffer](../memory/return_temporary_buffer.html "cpp/memory/return temporary buffer")(until C++20*)  
---  
  
  
  
[Garbage collector support](../memory.html#Garbage_collector_support "cpp/memory") (until C++23)  
| [declare_reachable](../memory/gc/declare_reachable.html "cpp/memory/gc/declare reachable")(C++11)(until C++23)  
---  
[declare_no_pointers](../memory/gc/declare_no_pointers.html "cpp/memory/gc/declare no pointers")(C++11)(until C++23)  
[pointer_safety](../memory/gc/pointer_safety.html "cpp/memory/gc/pointer safety")(C++11)(until C++23)  
  
| [undeclare_reachable](../memory/gc/undeclare_reachable.html "cpp/memory/gc/undeclare reachable")(C++11)(until C++23)  
---  
[undeclare_no_pointers](../memory/gc/undeclare_no_pointers.html "cpp/memory/gc/undeclare no pointers")(C++11)(until C++23)  
[get_pointer_safety](../memory/gc/get_pointer_safety.html "cpp/memory/gc/get pointer safety")(C++11)(until C++23)  
  
| [Low level memory  
management](../memory/new.html#Low_level_memory_management "cpp/memory/new")  
---  
[operator newoperator new[]](../memory/new/operator_new.html "cpp/memory/new/operator new")  
[operator deleteoperator delete[]](../memory/new/operator_delete.html "cpp/memory/new/operator delete")  
[nothrow_t](../memory/new/nothrow_t.html "cpp/memory/new/nothrow t")  
[nothrow](../memory/new/nothrow.html "cpp/memory/new/nothrow")  
[new_handler](../memory/new/new_handler.html "cpp/memory/new/new handler")  
[set_new_handler](../memory/new/set_new_handler.html "cpp/memory/new/set new handler")  
[get_new_handler](../memory/new/get_new_handler.html "cpp/memory/new/get new handler")(C++11)  
[bad_alloc](../memory/new/bad_alloc.html "cpp/memory/new/bad alloc")  
[bad_array_new_length](../memory/new/bad_array_new_length.html "cpp/memory/new/bad array new length")(C++11)  
[align_val_t](../memory/new/align_val_t.html "cpp/memory/new/align val t")(C++17)  
[destroying_delete_t](../memory/new/destroying_delete_t.html "cpp/memory/new/destroying delete t")(C++20)  
**launder**(C++17)  
[Smart pointers](../memory.html#Smart_pointers "cpp/memory")  
[unique_ptr](../memory/unique_ptr.html "cpp/memory/unique ptr")(C++11)  
[shared_ptr](../memory/shared_ptr.html "cpp/memory/shared ptr")(C++11)  
[weak_ptr](../memory/weak_ptr.html "cpp/memory/weak ptr")(C++11)  
[auto_ptr](../memory/auto_ptr.html "cpp/memory/auto ptr")(until C++17*)  
[owner_less](../memory/owner_less.html "cpp/memory/owner less")(C++11)  
[owner_less<void>](../memory/owner_less_void.html "cpp/memory/owner less void")(C++17)  
[owner_hash](../memory/owner_hash.html "cpp/memory/owner hash")(C++26)  
[owner_equal](../memory/owner_equal.html "cpp/memory/owner equal")(C++26)  
[enable_shared_from_this](../memory/enable_shared_from_this.html "cpp/memory/enable shared from this")(C++11)  
[bad_weak_ptr](../memory/bad_weak_ptr.html "cpp/memory/bad weak ptr")(C++11)  
[default_delete](../memory/default_delete.html "cpp/memory/default delete")(C++11)  
[out_ptr_t](../memory/out_ptr_t.html "cpp/memory/out ptr t")(C++23)  
[inout_ptr_t](../memory/inout_ptr_t.html "cpp/memory/inout ptr t")(C++23)  
[Miscellaneous](../memory.html#Miscellaneous "cpp/memory")  
[pointer_traits](../memory/pointer_traits.html "cpp/memory/pointer traits")(C++11)  
[to_address](../memory/to_address.html "cpp/memory/to address")(C++20)  
[addressof](../memory/addressof.html "cpp/memory/addressof")(C++11)  
[align](../memory/align.html "cpp/memory/align")(C++11)  
[assume_aligned](../memory/assume_aligned.html "cpp/memory/assume aligned")(C++20)  
[is_sufficiently_aligned](../memory/is_sufficiently_aligned.html "cpp/memory/is sufficiently aligned")(C++26)  
[C Library](../memory/c.html "cpp/memory/c")  
| [malloc](../memory/c/malloc.html "cpp/memory/c/malloc")  
---  
[calloc](../memory/c/calloc.html "cpp/memory/c/calloc")  
[realloc](../memory/c/realloc.html "cpp/memory/c/realloc")  
  
| [free](../memory/c/free.html "cpp/memory/c/free")  
---  
[aligned_alloc](../memory/c/aligned_alloc.html "cpp/memory/c/aligned alloc")(C++17)  
  
  
  


[Low level memory management](../memory/new.html "cpp/memory/new")

[Functions](../memory/new.html#Functions "cpp/memory/new")  
---  
[operator newoperator new[]](../memory/new/operator_new.html "cpp/memory/new/operator new")  
[operator deleteoperator delete[]](../memory/new/operator_delete.html "cpp/memory/new/operator delete")  
[get_new_handler](../memory/new/get_new_handler.html "cpp/memory/new/get new handler")(C++11)  
[set_new_handler](../memory/new/set_new_handler.html "cpp/memory/new/set new handler")  
[Classes](../memory/new.html#Classes "cpp/memory/new")  
[bad_alloc](../memory/new/bad_alloc.html "cpp/memory/new/bad alloc")  
[bad_array_new_length](../memory/new/bad_array_new_length.html "cpp/memory/new/bad array new length")(C++11)  
[align_val_t](../memory/new/align_val_t.html "cpp/memory/new/align val t")(C++17)  
[Types](../memory/new.html#Types "cpp/memory/new")  
[new_handler](../memory/new/new_handler.html "cpp/memory/new/new handler")  
[Objects](../memory/new.html#Objects "cpp/memory/new")  
[nothrow](../memory/new/nothrow.html "cpp/memory/new/nothrow")  
[destroying_delete](../memory/new/destroying_delete_t.html "cpp/memory/new/destroying delete")(C++20)  
[Object access](../memory/new.html#Object_access "cpp/memory/new")  
**launder**(C++17)  
  


Defined in header `[<new>](../header/new.html "cpp/header/new")` |  |   
---|---|---  
template< class T >  
constexpr T* launder( T* p ) noexcept; |  |  (since C++17)  
| |   
  
Devirtualization fence with respect to p. Returns a pointer to an object at the same address that p represents, while the object can be a new base class subobject whose most derived class is different from that of the original *p object. 

Formally, given 

  * the pointer p represents the address `A` of a byte in memory 
  * an object x is located at the address `A`
  * x is within its [lifetime](../language/lifetime.html "cpp/language/lifetime")
  * the type of x is the same as `T`, ignoring cv-qualifiers at every level 
  * every byte that would be reachable through the result is reachable through p (bytes are reachable through a pointer that points to an object y if those bytes are within the storage of an object z that is [pointer-interconvertible](../language/static_cast.html#pointer-interconvertible "cpp/language/static cast") with y, or within the immediately enclosing array of which z is an element). 



Then std::launder(p) returns a value of type `T*` that points to the object x. Otherwise, the behavior is undefined. 

The program is ill-formed if `T` is a function type or (possibly cv-qualified) void. 

`std::launder` may be used in a [core constant expression](../language/constant_expression.html "cpp/language/constant expression") if and only if the (converted) value of its argument may be used in place of the function invocation. In other words, `std::launder` does not relax restrictions in constant evaluation. 

### Notes

`std::launder` has no effect on its argument. Its return value must be used to access the object. Thus, it's always an error to discard the return value. 

Typical uses of `std::launder` include: 

  * Obtaining a pointer to an object created in the storage of an existing object of the same type, where pointers to the old object cannot be [reused](../language/lifetime.html#Storage_reuse "cpp/language/lifetime") (for instance, because either object is a base class subobject); 
  * Obtaining a pointer to an object created by placement `new` from a pointer to an object providing storage for that object. 



The _reachability_ restriction ensures that `std::launder` cannot be used to access bytes not accessible through the original pointer, thereby interfering with the compiler's escape analysis. 
    
    
    int x[10];
    auto p = std::launder(reinterpret_cast<int(*)[10]>(&x[0])); // OK
     
    int x2[2][10];
    auto p2 = std::launder(reinterpret_cast<int(*)[10]>(&x2[0][0]));
    // Undefined behavior: x2[1] would be reachable through the resulting pointer to x2[0]
    // but is not reachable from the source
     
    struct X { int a[10]; } x3, x4[2]; // standard layout; assume no padding
    auto p3 = std::launder(reinterpret_cast<int(*)[10]>(&x3.a[0])); // OK
    auto p4 = std::launder(reinterpret_cast<int(*)[10]>(&x4[0].a[0]));
    // Undefined behavior: x4[1] would be reachable through the resulting pointer to x4[0].a
    // (which is pointer-interconvertible with x4[0]) but is not reachable from the source
     
    struct Y { int a[10]; double y; } x5;
    auto p5 = std::launder(reinterpret_cast<int(*)[10]>(&x5.a[0]));
    // Undefined behavior: x5.y would be reachable through the resulting pointer to x5.a
    // but is not reachable from the source

### Example

Run this code
    
    
    #include <cassert>
    #include <cstddef>
    #include <new>
     
    struct Base
    {
        virtual int transmogrify();
    };
     
    struct Derived : Base
    {
        int transmogrify() override
        {
            new(this) Base;
            return 2;
        }
    };
     
    int Base::transmogrify()
    {
        new(this) Derived;
        return 1;
    }
     
    static_assert(sizeof(Derived) == sizeof(Base));
     
    int main()
    {
        // Case 1: the new object failed to be transparently replaceable because
        // it is a base subobject but the old object is a complete object.
        Base base;
        int n = base.transmogrify();
        // int m = base.transmogrify(); // undefined behavior
        int m = std::launder(&base)->transmogrify(); // OK
        [assert](../error/assert.html)(m + n == 3);
     
        // Case 2: access to a new object whose storage is provided
        // by a byte array through a pointer to the array.
        struct Y { int z; };
        alignas(Y) [std::byte](../types/byte.html) s[sizeof(Y)];
        Y* q = new(&s) Y{2};
        const int f = reinterpret_cast<Y*>(&s)->z; // Class member access is undefined
                                                   // behavior: reinterpret_cast<Y*>(&s)
                                                   // has value "pointer to s" and does
                                                   // not point to a Y object
        const int g = q->z; // OK
        const int h = std::launder(reinterpret_cast<Y*>(&s))->z; // OK
     
        [](...){}(f, g, h); // evokes [[maybe_unused]] effect
    }

### Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[LWG 2859](https://cplusplus.github.io/LWG/issue2859) | C++17  | definition of _reachable_ did not consider pointer  
arithmetic from pointer-interconvertible object  | included   
[LWG 3495](https://cplusplus.github.io/LWG/issue3495) | C++17  | `std::launder` might make pointer to an inactive  
member dereferenceable in constant expression  | forbidden 
