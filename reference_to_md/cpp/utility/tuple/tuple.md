[C++](../../../cpp.html "cpp")

[Compiler support](../../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../../freestanding.html "cpp/freestanding")  
[Language](../../language.html "cpp/language")  
[Standard library](../../standard_library.html "cpp/standard library")  
[Standard library headers](../../headers.html "cpp/header")  
[Named requirements](../../iterator/concepts.html "cpp/named req")  
[Feature test macros](../../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../../utility.html#Language_support "cpp/utility")  
[Concepts library](../../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../../error.html "cpp/error")  
[Memory management library](../../memory.html "cpp/memory")  
[Metaprogramming library](../../meta.html "cpp/meta") (C++11)  
[General utilities library](../../utility.html "cpp/utility")  
[Containers library](../../container.html "cpp/container")  
[Iterators library](../../iterator.html "cpp/iterator")  
[Ranges library](../../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../../algorithm.html "cpp/algorithm")  
[Strings library](../../string.html "cpp/string")  
[Text processing library](../../text.html "cpp/text")  
[Numerics library](../../numeric.html "cpp/numeric")  
[Date and time library](../../chrono.html "cpp/chrono")  
[Input/output library](../../io.html "cpp/io")  
[Filesystem library](../../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../../atomic.html "cpp/thread") (C++11)  
[Execution control library](../../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../../experimental.html "cpp/experimental")  
[Symbols index](../../symbol_index.html "cpp/symbol index")  
[External libraries](../../links/libs.html "cpp/links/libs")  
  


[Utilities library](../../utility.html "cpp/utility")

| [Language support](../../utility.html#Language_support "cpp/utility")  
---  
[Type support](../rtti.html "cpp/types") (basic types, RTTI)  
[Library feature-test macros](../feature_test.html "cpp/utility/feature test") (C++20)  
[Program utilities](../program.html "cpp/utility/program")  
[Variadic functions](../variadic.html "cpp/utility/variadic")  
[initializer_list](../initializer_list.html "cpp/utility/initializer list")(C++11)  
[is_constant_evaluated](../../types/is_constant_evaluated.html "cpp/types/is constant evaluated")(C++20)  
[is_within_lifetime](../../types/is_within_lifetime.html "cpp/types/is within lifetime")(C++26)  
[source_location](../source_location.html "cpp/utility/source location")(C++20)  
[Coroutine support](../../coroutine.html "cpp/coroutine") (C++20)  
[Contract support](../../contract.html "cpp/contract") (C++26)  
[Three-way comparison](../../utility.html#Three-way_comparison "cpp/utility")  
[three_way_comparablethree_way_comparable_with](../compare/three_way_comparable.html "cpp/utility/compare/three way comparable")(C++20)(C++20)  
[strong_ordering](../compare/strong_ordering.html "cpp/utility/compare/strong ordering")(C++20)  
[weak_ordering](../compare/weak_ordering.html "cpp/utility/compare/weak ordering")(C++20)  
[partial_ordering](../compare/partial_ordering.html "cpp/utility/compare/partial ordering")(C++20)  
[common_comparison_category](../compare/common_comparison_category.html "cpp/utility/compare/common comparison category")(C++20)  
[compare_three_way_result](../compare/compare_three_way_result.html "cpp/utility/compare/compare three way result")(C++20)  
[compare_three_way](../compare/compare_three_way.html "cpp/utility/compare/compare three way")(C++20)  
[strong_order](../compare/strong_order.html "cpp/utility/compare/strong order")(C++20)  
[weak_order](../compare/weak_order.html "cpp/utility/compare/weak order")(C++20)  
[partial_order](../compare/partial_order.html "cpp/utility/compare/partial order")(C++20)  
[compare_strong_order_fallback](../compare/compare_strong_order_fallback.html "cpp/utility/compare/compare strong order fallback")(C++20)  
[compare_weak_order_fallback](../compare/compare_weak_order_fallback.html "cpp/utility/compare/compare weak order fallback")(C++20)  
[compare_partial_order_fallback](../compare/compare_partial_order_fallback.html "cpp/utility/compare/compare partial order fallback")(C++20)` `  
|  | [is_eqis_ltis_lteq](../compare/named_comparison_functions.html "cpp/utility/compare/named comparison functions")(C++20)(C++20)(C++20)` `  
---  
  
| [is_neqis_gtis_gteq](../compare/named_comparison_functions.html "cpp/utility/compare/named comparison functions")(C++20)(C++20)(C++20)  
---  
  
  
  
  
| General utilities  
---  
| [Function objects](../../functional.html "cpp/utility/functional")  
---  
[Bit manipulation](../bit.html "cpp/utility/bit") (C++20)  
[C-style bit manipulation](https://en.cppreference.com/mwiki/index.php?title=cpp/utility/stdbit&action=edit&redlink=1 "cpp/utility/stdbit \(page does not exist\)") (C++26)  
[bitset](../bitset.html "cpp/utility/bitset")  
[hash](../hash.html "cpp/utility/hash")(C++11)  
  
[Relational operators](../../utility.html#Relational_operators "cpp/utility") (deprecated in C++20)  
|  | [rel_ops::operator!=rel_ops::operator>](../rel_ops/operator_cmp.html "cpp/utility/rel ops/operator cmp")` `  
---  
  
| [rel_ops::operator<=rel_ops::operator>=](../rel_ops/operator_cmp.html "cpp/utility/rel ops/operator cmp")  
---  
  
[Integer comparison functions](../../utility.html#Integer_comparison_functions "cpp/utility")  
| [cmp_equalcmp_lesscmp_less_than](../intcmp.html "cpp/utility/intcmp")(C++20)(C++20)(C++20)` `  
---  
  
| [cmp_not_equalcmp_greatercmp_greater_than](../intcmp.html "cpp/utility/intcmp")(C++20)(C++20)(C++20)  
---  
  
[in_range](../in_range.html "cpp/utility/in range")(C++20)  
[Swap](../../utility.html#Swap "cpp/utility") and [type operations](../../utility.html#Type_operations "cpp/utility")  
| [swap](../swap.html "cpp/algorithm/swap")  
---  
[ranges::swap](../ranges/swap.html "cpp/utility/ranges/swap")(C++20)  
[exchange](../exchange.html "cpp/utility/exchange")(C++14)  
[declval](../declval.html "cpp/utility/declval")(C++11)  
[to_underlying](../to_underlying.html "cpp/utility/to underlying")(C++23)  
  
| [forward](../forward.html "cpp/utility/forward")(C++11)  
---  
[forward_like](../forward_like.html "cpp/utility/forward like")(C++23)  
[move](../move.html "cpp/utility/move")(C++11)  
[move_if_noexcept](../move_if_noexcept.html "cpp/utility/move if noexcept")(C++11)  
[as_const](../as_const.html "cpp/utility/as const")(C++17)  
  
Common vocabulary types  
| [pair](../pair.html "cpp/utility/pair")  
---  
[tuple](../tuple.html "cpp/utility/tuple")(C++11)  
[optional](../optional.html "cpp/utility/optional")(C++17)  
[any](../any.html "cpp/utility/any")(C++17)  
[variant](../variant.html "cpp/utility/variant")(C++17)  
  
| [tuple_size](../tuple_size.html "cpp/utility/tuple size")(C++11)  
---  
[tuple_element](../tuple_element.html "cpp/utility/tuple element")(C++11)  
[apply](../apply.html "cpp/utility/apply")(C++17)  
[make_from_tuple](../make_from_tuple.html "cpp/utility/make from tuple")(C++17)  
[expected](../expected.html "cpp/utility/expected")(C++23)  
  
  
  
  
  
  


[`std::tuple`](../tuple.html "cpp/utility/tuple")

[Member functions](../tuple.html#Member_functions "cpp/utility/tuple")  
---  
**tuple::tuple**  
[tuple::operator=](operator=.html "cpp/utility/tuple/operator=")  
[tuple::swap](swap.html "cpp/utility/tuple/swap")  
[Non-member functions](../tuple.html#Non-member_functions "cpp/utility/tuple")  
[make_tuple](make_tuple.html "cpp/utility/tuple/make tuple")  
[tie](tie.html "cpp/utility/tuple/tie")  
[forward_as_tuple](forward_as_tuple.html "cpp/utility/tuple/forward as tuple")  
[tuple_cat](tuple_cat.html "cpp/utility/tuple/tuple cat")  
[operator==operator!=operator<operator<=operator>operator>=operator<=>](operator_cmp.html "cpp/utility/tuple/operator cmp")(until C++20)(until C++20)(until C++20)(until C++20)(until C++20)(C++20)  
[swap(std::tuple)](swap2.html "cpp/utility/tuple/swap2")  
[get(std::tuple)](get.html "cpp/utility/tuple/get")  
[Helper concepts](../tuple.html#Helper_concepts "cpp/utility/tuple")  
[`_tuple-like_`](tuple-like.html "cpp/utility/tuple/tuple-like")(C++23)  
[Helper classes](../tuple.html#Helper_classes "cpp/utility/tuple")  
[tuple_size<std::tuple>](tuple_size.html "cpp/utility/tuple/tuple size")  
[tuple_element<std::tuple>](tuple_element.html "cpp/utility/tuple/tuple element")  
[uses_allocator<std::tuple>](uses_allocator.html "cpp/utility/tuple/uses allocator")  
[basic_common_reference<std::tuple>](basic_common_reference.html "cpp/utility/tuple/basic common reference")(C++23)  
[common_type<std::tuple>](common_type.html "cpp/utility/tuple/common type")(C++23)  
[formatter<std::tuple>](../format/tuple_formatter.html "cpp/utility/format/tuple formatter")(C++23)  
[ignore](ignore.html "cpp/utility/tuple/ignore")  
[Deduction guides](deduction_guides.html "cpp/utility/tuple/deduction guides")(C++17)  
  


Defined in header `[<tuple>](../../header/tuple.html "cpp/header/tuple")` |  |   
---|---|---  
constexpr tuple(); |  (1)  |  (since C++11)   
(conditionally explicit)  
tuple( const Types&... args ); |  (2)  |  (since C++11)   
(constexpr since C++14)  
(conditionally explicit)  
template< class... UTypes >  
tuple( UTypes&&... args ); |  (3)  |  (since C++11)   
(constexpr since C++14)  
(conditionally explicit)  
template< class... UTypes >  
constexpr tuple( tuple<UTypes...>& other ); |  (4)  |  (since C++23)   
(conditionally explicit)  
template< class... UTypes >  
tuple( const tuple<UTypes...>& other ); |  (5)  |  (since C++11)   
(constexpr since C++14)  
(conditionally explicit)  
template< class... UTypes >  
tuple( tuple<UTypes...>&& other ); |  (6)  |  (since C++11)   
(constexpr since C++14)  
(conditionally explicit)  
template< class... UTypes >  
constexpr tuple( const tuple<UTypes...>&& other ); |  (7)  |  (since C++23)   
(conditionally explicit)  
template< class U1, class U2 >  
constexpr tuple( [std::pair](../pair.html)<U1, U2>& p ); |  (8)  |  (since C++23)   
(conditionally explicit)  
template< class U1, class U2 >  
tuple( const [std::pair](../pair.html)<U1, U2>& p ); |  (9)  |  (since C++11)   
(constexpr since C++14)  
(conditionally explicit)  
template< class U1, class U2 >  
tuple( [std::pair](../pair.html)<U1, U2>&& p ); |  (10)  |  (since C++11)   
(constexpr since C++14)  
(conditionally explicit)  
template< class U1, class U2 >  
constexpr tuple( const [std::pair](../pair.html)<U1, U2>&& p ); |  (11)  |  (since C++23)   
(conditionally explicit)  
template< tuple-like UTuple >  
constexpr tuple( UTuple&& u ); |  (12)  |  (since C++23)   
(conditionally explicit)  
tuple( const tuple& other ) = default; |  (13)  |  (since C++11)  
tuple( tuple&& other ) = default; |  (14)  |  (since C++11)  
Allocator-extended constructors |  |   
template< class Alloc >  
tuple( [std::allocator_arg_t](../../memory/allocator_arg_t.html), const Alloc& a ); |  (15)  |  (since C++11)   
(constexpr since C++20)  
(conditionally explicit)  
template< class Alloc >  
tuple( [std::allocator_arg_t](../../memory/allocator_arg_t.html), const Alloc& a,  
const Types&... args ); |  (16)  |  (since C++11)   
(constexpr since C++20)  
(conditionally explicit)  
template< class Alloc, class... UTypes >  
tuple( [std::allocator_arg_t](../../memory/allocator_arg_t.html), const Alloc& a,  
UTypes&&... args ); |  (17)  |  (since C++11)   
(constexpr since C++20)  
(conditionally explicit)  
template< class Alloc, class... UTypes >  
constexpr tuple( [std::allocator_arg_t](../../memory/allocator_arg_t.html), const Alloc& a,  
tuple<UTypes...>& other ); |  (18)  |  (since C++23)   
(conditionally explicit)  
template< class Alloc, class... UTypes >  
tuple( [std::allocator_arg_t](../../memory/allocator_arg_t.html), const Alloc& a,  
const tuple<UTypes...>& other ); |  (19)  |  (since C++11)   
(constexpr since C++20)  
(conditionally explicit)  
template< class Alloc, class... UTypes >  
tuple( [std::allocator_arg_t](../../memory/allocator_arg_t.html), const Alloc& a,  
tuple<UTypes...>&& other ); |  (20)  |  (since C++11)   
(constexpr since C++20)  
(conditionally explicit)  
template< class Alloc, class... UTypes >  
constexpr tuple( [std::allocator_arg_t](../../memory/allocator_arg_t.html), const Alloc& a,  
const tuple<UTypes...>&& other ); |  (21)  |  (since C++23)   
(conditionally explicit)  
template< class Alloc, class U1, class U2 >  
constexpr tuple( [std::allocator_arg_t](../../memory/allocator_arg_t.html), const Alloc& a,  
[std::pair](../pair.html)<U1, U2>& p ); |  (22)  |  (since C++23)   
(conditionally explicit)  
template< class Alloc, class U1, class U2 >  
tuple( [std::allocator_arg_t](../../memory/allocator_arg_t.html), const Alloc& a,  
const [std::pair](../pair.html)<U1, U2>& p ); |  (23)  |  (since C++11)   
(constexpr since C++20)  
(conditionally explicit)  
template< class Alloc, class U1, class U2 >  
tuple( [std::allocator_arg_t](../../memory/allocator_arg_t.html), const Alloc& a,  
[std::pair](../pair.html)<U1, U2>&& p ); |  (24)  |  (since C++11)   
(constexpr since C++20)  
(conditionally explicit)  
template< class Alloc, class U1, class U2 >  
constexpr tuple( [std::allocator_arg_t](../../memory/allocator_arg_t.html), const Alloc& a,  
const [std::pair](../pair.html)<U1, U2>&& p ); |  (25)  |  (since C++23)   
(conditionally explicit)  
template< class Alloc, tuple-like UTuple >  
constexpr tuple( [std::allocator_arg_t](../../memory/allocator_arg_t.html), const Alloc& a, UTuple&& u ); |  (26)  |  (since C++23)   
(conditionally explicit)  
template< class Alloc >  
tuple( [std::allocator_arg_t](../../memory/allocator_arg_t.html), const Alloc& a,  
const tuple& other ); |  (27)  |  (since C++11)   
(constexpr since C++20)  
template< class Alloc >  
tuple( [std::allocator_arg_t](../../memory/allocator_arg_t.html), const Alloc& a,  
tuple&& other ); |  (28)  |  (since C++11)   
(constexpr since C++20)  
| |   
  
Constructs a new tuple. 

In the descriptions that follow, let 

  * i be in the range `[`​0​`, `sizeof...(Types)`)` in order, 
  * `Ti` be the `i`th type in `Types`, and 
  * `Ui` be the `i`th type in a template parameter pack named `UTypes`,  




where indexing is zero-based. 

1) Default constructor. [Value-initializes](../../language/value_initialization.html "cpp/language/value initialization") all elements, if any. The default constructor is trivial if sizeof...(Types) == 0. 

  * This overload participates in overload resolution only if [std::is_default_constructible](../../types/is_default_constructible.html)<Ti>::value is true for all i. 
  * The constructor is explicit if and only if `Ti` is not copy-list-initializable from {} for at least one i.



2) Direct constructor. Initializes each element of the tuple with the corresponding parameter. 

  * This overload participates in overload resolution only if sizeof...(Types) >= 1 and [std::is_copy_constructible](../../types/is_copy_constructible.html)<Ti>::value is true for all i. 
  * This constructor is explicit if and only if [std::is_convertible](../../types/is_convertible.html)<const Ti&, Ti>::value is false for at least one i.



3) Converting constructor. Initializes each element of the tuple with the corresponding value in [std::forward](../forward.html)<UTypes>(args). 

  * This overload participates in overload resolution only if 
    * sizeof...(Types) == sizeof...(UTypes), 
    * sizeof...(Types) >= 1, 
    * [std::is_constructible](../../types/is_constructible.html)<Ti, Ui>::value is true for all i, and 
    * let `D` be [std::decay](../../types/decay.html)<U0>::type(until C++20)[std::remove_cvref_t](../../types/remove_cvref.html)<U0>(since C++20), 
      * if sizeof...(Types) == 1, then `D` is not `std::tuple`, otherwise, 
      * if sizeof...(Types) == 2 or sizeof...(Types) == 3, then either `D` is not [std::allocator_arg_t](../../memory/allocator_arg_t.html "cpp/memory/allocator arg t"), or `T0` is [std::allocator_arg_t](../../memory/allocator_arg_t.html "cpp/memory/allocator arg t"). 
  * The constructor is explicit if and only if [std::is_convertible](../../types/is_convertible.html)<Ui, Ti>::value is false for at least one i. 



  * This constructor is defined as deleted if the initialization of any element that is a reference would [bind it to a temporary object](../../language/reference_initialization.html#Lifetime_of_a_temporary "cpp/language/reference initialization"). 

| (since C++23)  
---|---  
  
4-7) Converting constructor. Initializes each element of the tuple with the corresponding element of other. 

Formally, let FWD(other) be [std::forward](../forward.html)<decltype(other)>(other), for all i, initializes `i`th element of the tuple with std::get<i>(FWD(other)). 

  * This overload participates in overload resolution only if 
    * sizeof...(Types) == sizeof...(UTypes), 
    * [std::is_constructible_v](../../types/is_constructible.html)<Ti, decltype(std::get<i>(FWD(other)))> is true for all i, and 
    * either 
      * sizeof...(Types) is not 1, or 
      * (when `Types...` expands to `T` and `UTypes...` expands to `U`) [std::is_convertible_v](../../types/is_convertible.html)<decltype(other), T>, [std::is_constructible_v](../../types/is_constructible.html)<T, decltype(other)>, and [std::is_same_v](../../types/is_same.html)<T, U> are all false. 
  * These constructors are explicit if and only if [std::is_convertible_v](../../types/is_convertible.html)<decltype(std::get<i>(FWD(other))), Ti> is false for at least one i. 



  * These constructors are defined as deleted if the initialization of any element that is a reference would bind it to a temporary object. 

| (since C++23)  
---|---  
  
8-11) Pair constructor. Constructs a 2-element tuple with each element constructed from the corresponding element of p. 

Formally, let FWD(p) be [std::forward](../forward.html)<decltype(p)>(p), initializes the first element with std::get<0>(FWD(p)) and the second element with std::get<1>(FWD(p)). 

  * This overload participates in overload resolution only if 
    * sizeof...(Types) == 2, 
    * [std::is_constructible_v](../../types/is_constructible.html)<T0, decltype(std::get<0>(FWD(p)))> is true, and 
    * [std::is_constructible_v](../../types/is_constructible.html)<T1, decltype(std::get<1>(FWD(p)))> is true. 
  * The constructor is explicit if and only if [std::is_convertible_v](../../types/is_convertible.html)<decltype(std::get<0>(FWD(p))), T0> or [std::is_convertible_v](../../types/is_convertible.html)<decltype(std::get<1>(FWD(p))), T1> is false. 



  * These constructors are defined as deleted if the initialization of any element that is a reference would bind it to a temporary object. 

| (since C++23)  
---|---  
  
12) [`_tuple-like_`](tuple-like.html "cpp/utility/tuple/tuple-like") constructor. Constructs a tuple with each element constructed from the corresponding element of u. 

Formally, for all i, initializes `i`th element of the tuple with std::get<i>([std::forward](../forward.html)<UTuple>(u)). 

  * This overload participates in overload resolution only if 
    * [std::same_as](../../concepts/same_as.html)<[std::remove_cvref_t](../../types/remove_cvref.html)<UTuple>, [std::tuple](../tuple.html)> is false, 
    * [std::remove_cvref_t](../../types/remove_cvref.html)<UTuple> is not a specialization of [std::ranges::subrange](../../ranges/subrange.html "cpp/ranges/subrange"), 
    * sizeof...(Types) equals [std::tuple_size_v](../tuple_size.html)<[std::remove_cvref_t](../../types/remove_cvref.html)<UTuple>>, 
    * [std::is_constructible_v](../../types/is_constructible.html)<Ti, decltype(std::get<i>([std::forward](../forward.html)<UTuple>(u)))> is true for all i, and 
    * either 
      * sizeof...(Types) is not 1, or 
      * (when `Types...` expands to `T`) [std::is_convertible_v](../../types/is_convertible.html)<UTuple, T> and [std::is_constructible_v](../../types/is_constructible.html)<T, UTuple> are both false. 
  * This constructor is defined as deleted if the initialization of any element that is a reference would bind it to a temporary object.



13) Implicitly-defined copy constructor. Initializes each element of the tuple with the corresponding element of other. 

  * This constructor is constexpr if every operation it performs is constexpr. For the empty tuple [std::tuple](../tuple.html)<>, it is constexpr. 
  * [std::is_copy_constructible](../../types/is_copy_constructible.html)<Ti>::value must be true for all i, otherwise the behavior is undefined(until C++20)the program is ill-formed(since C++20).



14) Implicitly-defined move constructor. For all i, initializes the `i`th element of the tuple with [std::forward](../forward.html)<Ui>(std::get<i>(other)). 

  * This constructor is constexpr if every operation it performs is constexpr. For the empty tuple [std::tuple](../tuple.html)<>, it is constexpr. 
  * [std::is_move_constructible](../../types/is_move_constructible.html)<Ti>::value must be true for all i, otherwise the behavior is undefined(until C++20)this overload does not participate in overload resolution(since C++20).



15-28) Identical to (1-14) except each element is created by [uses-allocator construction](../../memory/uses_allocator.html#Uses-allocator_construction "cpp/memory/uses allocator"), that is, the Allocator object a is passed as an additional argument to the constructor of each element for which [std::uses_allocator](../../memory/uses_allocator.html)<Ui, Alloc>::value is true.

## Contents

  * [1 Parameters](tuple.html#Parameters)
  * [2 Notes](tuple.html#Notes)
  * [3 Example](tuple.html#Example)
  * [4 Defect reports](tuple.html#Defect_reports)
  * [5 See also](tuple.html#See_also)

  
---  
  
### Parameters

args  |  \-  |  values used to initialize each element of the tuple   
---|---|---  
other  |  \-  |  the tuple of values used to initialize each element of the tuple   
p  |  \-  |  the pair of values used to initialize both elements of the 2-tuple   
u  |  \-  |  the [`_tuple-like_`](tuple-like.html "cpp/utility/tuple/tuple-like") object of values used to initialize each element of the tuple   
a  |  \-  |  the allocator to use in uses-allocator construction   
  
### Notes

Conditionally-explicit constructors make it possible to construct a tuple in copy-initialization context using list-initialization syntax: 
    
    
    [std::tuple](../tuple.html)<int, int> foo_tuple() 
    {
        // return {1, -1};             // Error before N4387
        return [std::make_tuple](make_tuple.html)(1, -1); // Always works
    }

Note that if some element of the list is not implicitly convertible to the corresponding element of the target tuple, the constructors become explicit: 
    
    
    using namespace std::chrono;
    void launch_rocket_at([std::tuple](../tuple.html)<hours, minutes, seconds>);
     
    launch_rocket_at({hours(1), minutes(2), seconds(3)}); // OK
    launch_rocket_at({1, 2, 3}); // Error: int is not implicitly convertible to duration
    launch_rocket_at([std::tuple](../tuple.html)<hours, minutes, seconds>{1, 2, 3}); // OK

### Example

Run this code
    
    
    #include <iomanip>
    #include <iostream>
    #include <memory>
    #include <string>
    #include <string_view>
    #include <tuple>
    #include <type_traits>
    #include <vector>
     
    // helper function to print a vector to a stream
    template<class Os, class T>
    Os& operator<<(Os& os, [std::vector](../../container/vector.html)<T> const& v)
    {
        os << '{';
        for (auto i{v.size()}; const T& e : v)
            os << e << (--i ? "," : "");
        return os << '}';
    }
     
    template<class T>
    void print_single(T const& v)
    {
        if constexpr ([std::is_same_v](../../types/is_same.html)<T, [std::decay_t](../../types/decay.html)<[std::string](../../string/basic_string.html)>>)
            [std::cout](../../io/cout.html) << [std::quoted](../../io/manip/quoted.html)(v);
        else if constexpr ([std::is_same_v](../../types/is_same.html)<[std::decay_t](../../types/decay.html)<T>, char>)
            [std::cout](../../io/cout.html) << "'" << v << "'";
        else
            [std::cout](../../io/cout.html) << v;
    }
     
    // helper function to print a tuple of any size
    template<class Tuple, [std::size_t](../../types/size_t.html) N>
    struct TuplePrinter
    {
        static void print(const Tuple& t)
        {
            TuplePrinter<Tuple, N - 1>::print(t);
            [std::cout](../../io/cout.html) << ", ";
            print_single(std::get<N - 1>(t));
        }
    };
     
    template<class Tuple>
    struct TuplePrinter<Tuple, 1>
    {
        static void print(const Tuple& t)
        {
            print_single(std::get<0>(t));
        }
    };
     
    template<class... Args>
    void print([std::string_view](../../string/basic_string_view.html) message, const [std::tuple](../tuple.html)<Args...>& t)
    {
        [std::cout](../../io/cout.html) << message << " (";
        TuplePrinter<decltype(t), sizeof...(Args)>::print(t);
        [std::cout](../../io/cout.html) << ")\n";
    }
    // end helper function
     
    int main()
    {
        [std::tuple](../tuple.html)<int, [std::string](../../string/basic_string.html), double> t1;
        print("Value-initialized, t1:", t1);
     
        [std::tuple](../tuple.html)<int, [std::string](../../string/basic_string.html), double> t2{42, "Test", -3.14};
        print("Initialized with values, t2:", t2);
     
        [std::tuple](../tuple.html)<char, [std::string](../../string/basic_string.html), int> t3{t2};
        print("Implicitly converted, t3:", t3);
     
        [std::tuple](../tuple.html)<int, double> t4{[std::make_pair](../pair/make_pair.html)(42, 3.14)};
        print("Constructed from a pair, t4:", t4);
     
        // given Allocator my_alloc with a single-argument constructor
        // my_alloc(int); use my_alloc(1) to allocate 5 ints in a vector
        using my_alloc = [std::allocator](../../memory/allocator.html)<int>;
        [std::vector](../../container/vector.html)<int, my_alloc> v{5, 1, my_alloc{/* 1 */}};
     
        // use my_alloc(2) to allocate 5 ints in a vector in a tuple
        [std::tuple](../tuple.html)<int, [std::vector](../../container/vector.html)<int, my_alloc>, double> t5
            {[std::allocator_arg](../../memory/allocator_arg.html), my_alloc{/* 2 */}, 42, v, -3.14};
        print("Constructed with allocator, t5:", t5);
    }

Possible output: 
    
    
    Value-initialized, t1: (0, "", 0)
    Initialized with values, t2: (42, "Test", -3.14)
    Implicitly converted, t3: ('*', "Test", -3)
    Constructed from a pair, t4: (42, 3.14)
    Constructed with allocator, t5: (42, {1,1,1,1,1}, -3.14)

### Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[LWG 2510](https://cplusplus.github.io/LWG/issue2510) | C++11  | default constructor was implicit  | made conditionally-explicit   
[LWG 3121](https://cplusplus.github.io/LWG/issue3121) | C++11  | constructor of 1-tuple might recursively check the constraints;  
`allocator_arg_t` argument brought ambiguity  | furtherly constrained  
the constructor   
[LWG 3158](https://cplusplus.github.io/LWG/issue3158) | C++11  | the uses-allocator constructor corresponding  
to default constructor was implicit  | made conditionally-explicit   
[LWG 3211](https://cplusplus.github.io/LWG/issue3211) | C++11  | whether the default constructor of  
`tuple<>` is trivial was unspecified  | require to be trivial   
[LWG 4045](https://cplusplus.github.io/LWG/issue4045) | C++23  | `_tuple-like_` constructor may potentially create dangling references  | made defined as deleted   
[N4387](https://wg21.link/N4387) | C++11  | some constructors were explicit, preventing useful behavior  | most constructors made  
conditionally-explicit   
  
### See also

[ operator=](operator=.html "cpp/utility/tuple/operator=") |  assigns the contents of one `tuple` to another   
(public member function)   
---|---  
[ make_tuple](make_tuple.html "cpp/utility/tuple/make tuple")(C++11) |  creates a `tuple` object of the type defined by the argument types   
(function template)   
[ tie](tie.html "cpp/utility/tuple/tie")(C++11) |  creates a [tuple](../tuple.html "cpp/utility/tuple") of lvalue references or unpacks a tuple into individual objects   
(function template)   
[ forward_as_tuple](forward_as_tuple.html "cpp/utility/tuple/forward as tuple")(C++11) |  creates a `tuple` of [forwarding references](../../language/reference.html#Forwarding_references "cpp/language/reference")   
(function template)   
[ (constructor)](../pair/pair.html "cpp/utility/pair/pair") |  constructs new `pair`   
(public member function of `std::pair<T1,T2>`) 
