
  


[Utilities library](../utility.html "cpp/utility")

| [Language support](../utility.html#Language_support "cpp/utility")  
---  
[Type support](rtti.html "cpp/types") (basic types, RTTI)  
[Library feature-test macros](feature_test.html "cpp/utility/feature test") (C++20)  
[Program utilities](program.html "cpp/utility/program")  
[Variadic functions](variadic.html "cpp/utility/variadic")  
[initializer_list](initializer_list.html "cpp/utility/initializer list")(C++11)  
[is_constant_evaluated](../types/is_constant_evaluated.html "cpp/types/is constant evaluated")(C++20)  
[is_within_lifetime](../types/is_within_lifetime.html "cpp/types/is within lifetime")(C++26)  
[source_location](source_location.html "cpp/utility/source location")(C++20)  
[Coroutine support](../coroutine.html "cpp/coroutine") (C++20)  
[Contract support](../contract.html "cpp/contract") (C++26)  
[Three-way comparison](../utility.html#Three-way_comparison "cpp/utility")  
[three_way_comparablethree_way_comparable_with](compare/three_way_comparable.html "cpp/utility/compare/three way comparable")(C++20)(C++20)  
[strong_ordering](compare/strong_ordering.html "cpp/utility/compare/strong ordering")(C++20)  
[weak_ordering](compare/weak_ordering.html "cpp/utility/compare/weak ordering")(C++20)  
[partial_ordering](compare/partial_ordering.html "cpp/utility/compare/partial ordering")(C++20)  
[common_comparison_category](compare/common_comparison_category.html "cpp/utility/compare/common comparison category")(C++20)  
[compare_three_way_result](compare/compare_three_way_result.html "cpp/utility/compare/compare three way result")(C++20)  
[compare_three_way](compare/compare_three_way.html "cpp/utility/compare/compare three way")(C++20)  
[strong_order](compare/strong_order.html "cpp/utility/compare/strong order")(C++20)  
[weak_order](compare/weak_order.html "cpp/utility/compare/weak order")(C++20)  
[partial_order](compare/partial_order.html "cpp/utility/compare/partial order")(C++20)  
[compare_strong_order_fallback](compare/compare_strong_order_fallback.html "cpp/utility/compare/compare strong order fallback")(C++20)  
[compare_weak_order_fallback](compare/compare_weak_order_fallback.html "cpp/utility/compare/compare weak order fallback")(C++20)  
[compare_partial_order_fallback](compare/compare_partial_order_fallback.html "cpp/utility/compare/compare partial order fallback")(C++20)` `  
|  | [is_eqis_ltis_lteq](compare/named_comparison_functions.html "cpp/utility/compare/named comparison functions")(C++20)(C++20)(C++20)` `  
---  
  
| [is_neqis_gtis_gteq](compare/named_comparison_functions.html "cpp/utility/compare/named comparison functions")(C++20)(C++20)(C++20)  
---  
  
  
  
  
| General utilities  
---  
| [Function objects](../functional.html "cpp/utility/functional")  
---  
[Bit manipulation](bit.html "cpp/utility/bit") (C++20)  
[C-style bit manipulation](https://en.cppreference.com/mwiki/index.php?title=cpp/utility/stdbit&action=edit&redlink=1 "cpp/utility/stdbit \(page does not exist\)") (C++26)  
[bitset](bitset.html "cpp/utility/bitset")  
[hash](hash.html "cpp/utility/hash")(C++11)  
  
[Relational operators](../utility.html#Relational_operators "cpp/utility") (deprecated in C++20)  
|  | [rel_ops::operator!=rel_ops::operator>](rel_ops/operator_cmp.html "cpp/utility/rel ops/operator cmp")` `  
---  
  
| [rel_ops::operator<=rel_ops::operator>=](rel_ops/operator_cmp.html "cpp/utility/rel ops/operator cmp")  
---  
  
[Integer comparison functions](../utility.html#Integer_comparison_functions "cpp/utility")  
| [cmp_equalcmp_lesscmp_less_than](intcmp.html "cpp/utility/intcmp")(C++20)(C++20)(C++20)` `  
---  
  
| [cmp_not_equalcmp_greatercmp_greater_than](intcmp.html "cpp/utility/intcmp")(C++20)(C++20)(C++20)  
---  
  
[in_range](in_range.html "cpp/utility/in range")(C++20)  
[Swap](../utility.html#Swap "cpp/utility") and [type operations](../utility.html#Type_operations "cpp/utility")  
| [swap](swap.html "cpp/algorithm/swap")  
---  
[ranges::swap](ranges/swap.html "cpp/utility/ranges/swap")(C++20)  
[exchange](exchange.html "cpp/utility/exchange")(C++14)  
[declval](declval.html "cpp/utility/declval")(C++11)  
[to_underlying](to_underlying.html "cpp/utility/to underlying")(C++23)  
  
| [forward](forward.html "cpp/utility/forward")(C++11)  
---  
[forward_like](forward_like.html "cpp/utility/forward like")(C++23)  
[move](move.html "cpp/utility/move")(C++11)  
[move_if_noexcept](move_if_noexcept.html "cpp/utility/move if noexcept")(C++11)  
[as_const](as_const.html "cpp/utility/as const")(C++17)  
  
Common vocabulary types  
| [pair](pair.html "cpp/utility/pair")  
---  
**tuple**(C++11)  
[optional](optional.html "cpp/utility/optional")(C++17)  
[any](any.html "cpp/utility/any")(C++17)  
[variant](variant.html "cpp/utility/variant")(C++17)  
  
| [tuple_size](tuple_size.html "cpp/utility/tuple size")(C++11)  
---  
[tuple_element](tuple_element.html "cpp/utility/tuple element")(C++11)  
[apply](apply.html "cpp/utility/apply")(C++17)  
[make_from_tuple](make_from_tuple.html "cpp/utility/make from tuple")(C++17)  
[expected](expected.html "cpp/utility/expected")(C++23)  
  
  
  
  
  
  


**`std::tuple`**

[Member functions](tuple.html#Member_functions "cpp/utility/tuple")  
---  
[tuple::tuple](tuple/tuple.html "cpp/utility/tuple/tuple")  
[tuple::operator=](tuple/operator=.html "cpp/utility/tuple/operator=")  
[tuple::swap](tuple/swap.html "cpp/utility/tuple/swap")  
[Non-member functions](tuple.html#Non-member_functions "cpp/utility/tuple")  
[make_tuple](tuple/make_tuple.html "cpp/utility/tuple/make tuple")  
[tie](tuple/tie.html "cpp/utility/tuple/tie")  
[forward_as_tuple](tuple/forward_as_tuple.html "cpp/utility/tuple/forward as tuple")  
[tuple_cat](tuple/tuple_cat.html "cpp/utility/tuple/tuple cat")  
[operator==operator!=operator<operator<=operator>operator>=operator<=>](tuple/operator_cmp.html "cpp/utility/tuple/operator cmp")(until C++20)(until C++20)(until C++20)(until C++20)(until C++20)(C++20)  
[swap(std::tuple)](tuple/swap2.html "cpp/utility/tuple/swap2")  
[get(std::tuple)](tuple/get.html "cpp/utility/tuple/get")  
[Helper concepts](tuple.html#Helper_concepts "cpp/utility/tuple")  
[`_tuple-like_`](tuple/tuple-like.html "cpp/utility/tuple/tuple-like")(C++23)  
[Helper classes](tuple.html#Helper_classes "cpp/utility/tuple")  
[tuple_size<std::tuple>](tuple/tuple_size.html "cpp/utility/tuple/tuple size")  
[tuple_element<std::tuple>](tuple/tuple_element.html "cpp/utility/tuple/tuple element")  
[uses_allocator<std::tuple>](tuple/uses_allocator.html "cpp/utility/tuple/uses allocator")  
[basic_common_reference<std::tuple>](tuple/basic_common_reference.html "cpp/utility/tuple/basic common reference")(C++23)  
[common_type<std::tuple>](tuple/common_type.html "cpp/utility/tuple/common type")(C++23)  
[formatter<std::tuple>](format/tuple_formatter.html "cpp/utility/format/tuple formatter")(C++23)  
[ignore](tuple/ignore.html "cpp/utility/tuple/ignore")  
[Deduction guides](tuple/deduction_guides.html "cpp/utility/tuple/deduction guides")(C++17)  
  


Defined in header `[<tuple>](../header/tuple.html "cpp/header/tuple")` |  |   
---|---|---  
template< class... Types >  
class tuple; |  |  (since C++11)  
| |   
  
Class template `std::tuple` is a fixed-size collection of heterogeneous values. It is a generalization of [std::pair](pair.html "cpp/utility/pair"). 

If [std::is_trivially_destructible](../types/is_destructible.html)<Ti>::value is true for every `Ti` in `Types`, the destructor of `std::tuple` is trivial. 

If a program declares an [explicit](../language/template_specialization.html "cpp/language/template specialization") or [partial](../language/partial_specialization.html "cpp/language/partial specialization") specialization of `std::tuple`, the program is ill-formed, no diagnostic required. 

## Contents

  * [1 Template parameters](tuple.html#Template_parameters)
  * [2 Member functions](tuple.html#Member_functions)
  * [3 Non-member functions](tuple.html#Non-member_functions)
  * [4 Helper concepts](tuple.html#Helper_concepts)
  * [5 Helper classes](tuple.html#Helper_classes)
  * [6 Helper specializations](tuple.html#Helper_specializations)
  * [7 Deduction guides (since C++17)](tuple.html#Deduction_guides_.28since_C.2B.2B17.29)
  * [8 Notes](tuple.html#Notes)
  * [9 Example](tuple.html#Example)
  * [10 Defect reports](tuple.html#Defect_reports)
  * [11 References](tuple.html#References)
  * [12 See also](tuple.html#See_also)

  
---  
  
### Template parameters

Types...  |  \-  |  the types of the elements that the tuple stores. Empty list is supported.   
---|---|---  
  
### Member functions

[ (constructor)](tuple/tuple.html "cpp/utility/tuple/tuple") |  constructs a new `tuple`   
(public member function)   
---|---  
[ operator=](tuple/operator=.html "cpp/utility/tuple/operator=") |  assigns the contents of one `tuple` to another   
(public member function)   
[ swap](tuple/swap.html "cpp/utility/tuple/swap") |  swaps the contents of two `tuple`s   
(public member function)   
  
### Non-member functions

[ make_tuple](tuple/make_tuple.html "cpp/utility/tuple/make tuple")(C++11) |  creates a `tuple` object of the type defined by the argument types   
(function template)   
---|---  
[ tie](tuple/tie.html "cpp/utility/tuple/tie")(C++11) |  creates a **tuple** of lvalue references or unpacks a tuple into individual objects   
(function template)   
[ forward_as_tuple](tuple/forward_as_tuple.html "cpp/utility/tuple/forward as tuple")(C++11) |  creates a `tuple` of [forwarding references](../language/reference.html#Forwarding_references "cpp/language/reference")   
(function template)   
[ tuple_cat](tuple/tuple_cat.html "cpp/utility/tuple/tuple cat")(C++11) |  creates a `tuple` by concatenating any number of tuples   
(function template)   
[ get(std::tuple)](tuple/get.html "cpp/utility/tuple/get")(C++11) |  tuple accesses specified element   
(function template)   
[ operator==operator!=operator<operator<=operator>operator>=operator<=>](tuple/operator_cmp.html "cpp/utility/tuple/operator cmp")(removed in C++20)(removed in C++20)(removed in C++20)(removed in C++20)(removed in C++20)(C++20) |  lexicographically compares the values in the tuple   
(function template)   
[ std::swap(std::tuple)](tuple/swap2.html "cpp/utility/tuple/swap2")(C++11) |  specializes the [std::swap](swap.html "cpp/algorithm/swap") algorithm   
(function template)   
  
### Helper concepts

[_tuple-like pair-like_](tuple/tuple-like.html "cpp/utility/tuple/tuple-like")(C++23) |  specifies that a type implemented the _tuple protocol_  
([`std::get`](tuple/get.html "cpp/utility/tuple/get"), [`std::tuple_element`](tuple_element.html "cpp/utility/tuple element"), [`std::tuple_size`](tuple_size.html "cpp/utility/tuple size"))  
(exposition-only concept*)  
---|---  
  
### Helper classes

[ std::tuple_size<std::tuple>](tuple/tuple_size.html "cpp/utility/tuple/tuple size")(C++11) |  obtains the size of a `tuple`   
(class template specialization)   
---|---  
[ std::tuple_element<std::tuple>](tuple/tuple_element.html "cpp/utility/tuple/tuple element")(C++11) |  obtains the type of the specified element   
(class template specialization)   
[ std::uses_allocator<std::tuple>](tuple/uses_allocator.html "cpp/utility/tuple/uses allocator")(C++11) |  specializes the [std::uses_allocator](../memory/uses_allocator.html "cpp/memory/uses allocator") type trait   
(class template specialization)   
[ std::basic_common_reference<_tuple-like_ >](tuple/basic_common_reference.html "cpp/utility/tuple/basic common reference")(C++23) |  determines the common reference type of a `tuple` and a `_tuple-like_` type   
(class template specialization)   
[ std::common_type<_tuple-like_ >](tuple/common_type.html "cpp/utility/tuple/common type")(C++23) |  determines the common type of a `tuple` and a `_tuple-like_` type   
(class template specialization)   
[ std::formatter<std::tuple>](format/tuple_formatter.html "cpp/utility/format/tuple formatter")(C++23) |  formatting support for `tuple`   
(class template specialization)   
[ ignore](tuple/ignore.html "cpp/utility/tuple/ignore")(C++11) |  placeholder to skip an element when unpacking a `tuple` using [`tie`](tuple/tie.html "cpp/utility/tuple/tie")   
(constant)   
  
### Helper specializations

template< class... Ts >  
constexpr bool enable_nonlocking_formatter_optimization<std::tuple<Ts...>>   
= (enable_nonlocking_formatter_optimization<Ts> && ...); |  |  (since C++23)  
---|---|---  
| |   
  
This specialization of [`std::enable_nonlocking_formatter_optimization`](format/enable_nonlocking_formatter_optimization.html "cpp/utility/format/enable nonlocking formatter optimization") enables efficient implementation of [`std::print`](../io/print.html "cpp/io/print") and [`std::println`](../io/println.html "cpp/io/println") for printing a `tuple` object when each element type enables it. 

### [Deduction guides](tuple/deduction_guides.html "cpp/utility/tuple/deduction guides") (since C++17)

### Notes

Since the "shape" of a tuple – its size, the types of its elements, and the ordering of those types – are part of its type signature, they must all be available at compile time and can only depend on other compile-time information. This means that many conditional operations on tuples – in particular, conditional prepend/append and filter – are only possible if the conditions can be evaluated at compile time. For example, given a std::tuple<int, double, int>, it is possible to filter on types – e.g. returning a std::tuple<int, int> – but not to filter on whether or not each element is positive (which would have a different type signature depending on runtime values of the tuple), unless all the elements were themselves constexpr. 

As a workaround, one can work with tuples of [std::optional](optional.html), but there is still no way to adjust the size based on runtime information. 

Until [N4387](https://wg21.link/N4387) (applied as a defect report for C++11), a function could not return a tuple using copy-list-initialization: 
    
    
    std::tuple<int, int> foo_tuple()
    {
        return {1, -1};  // Error until N4387
        return std::tuple<int, int>{1, -1}; // Always works
        return [std::make_tuple](tuple/make_tuple.html)(1, -1); // Always works
    }

### Example

Run this code
    
    
    #include <iostream>
    #include <stdexcept>
    #include <string>
    #include <tuple>
     
    std::tuple<double, char, [std::string](../string/basic_string.html)> get_student(int id)
    {
        switch (id)
        {
            case 0: return {3.8, 'A', "Lisa Simpson"};
            case 1: return {2.9, 'C', "Milhouse Van Houten"};
            case 2: return {1.7, 'D', "Ralph Wiggum"};
            case 3: return {0.6, 'F', "Bart Simpson"};
        }
     
        throw [std::invalid_argument](../error/invalid_argument.html)("id");
    }
     
    int main()
    {
        const auto student0 = get_student(0);
        [std::cout](../io/cout.html) << "ID: 0, "
                  << "GPA: " << std::get<0>(student0) << ", "
                  << "grade: " << std::get<1>(student0) << ", "
                  << "name: " << std::get<2>(student0) << '\n';
     
        const auto student1 = get_student(1);
        [std::cout](../io/cout.html) << "ID: 1, "
                  << "GPA: " << std::get<double>(student1) << ", "
                  << "grade: " << std::get<char>(student1) << ", "
                  << "name: " << std::get<[std::string](../string/basic_string.html)>(student1) << '\n';
     
        double gpa2;
        char grade2;
        [std::string](../string/basic_string.html) name2;
        [std::tie](tuple/tie.html)(gpa2, grade2, name2) = get_student(2);
        [std::cout](../io/cout.html) << "ID: 2, "
                  << "GPA: " << gpa2 << ", "
                  << "grade: " << grade2 << ", "
                  << "name: " << name2 << '\n';
     
        // C++17 structured binding:
        const auto [gpa3, grade3, name3] = get_student(3);
        [std::cout](../io/cout.html) << "ID: 3, "
                  << "GPA: " << gpa3 << ", "
                  << "grade: " << grade3 << ", "
                  << "name: " << name3 << '\n';
    }

Output: 
    
    
    ID: 0, GPA: 3.8, grade: A, name: Lisa Simpson
    ID: 1, GPA: 2.9, grade: C, name: Milhouse Van Houten
    ID: 2, GPA: 1.7, grade: D, name: Ralph Wiggum
    ID: 3, GPA: 0.6, grade: F, name: Bart Simpson

### Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[LWG 2796](https://cplusplus.github.io/LWG/issue2796) | C++11  | triviality of the destructor of `std::tuple` was unspecified  | specified   
[LWG 3990](https://cplusplus.github.io/LWG/issue3990) | C++11  | a program could declare an explicit or  
partial specialization of `std::tuple` | the program is ill-formed in this  
case (no diagnostic required)   
  
### References

  * C++23 standard (ISO/IEC 14882:2024): 



    

  * 22.4 Tuples [tuple] 



  * C++20 standard (ISO/IEC 14882:2020): 



    

  * 20.5 Tuples [tuple] 



  * C++17 standard (ISO/IEC 14882:2017): 



    

  * 23.5 Tuples [tuple] 



  * C++14 standard (ISO/IEC 14882:2014): 



    

  * 20.4 Tuples [tuple] 



  * C++11 standard (ISO/IEC 14882:2011): 



    

  * 20.4 Tuples [tuple] 



### See also

[ pair](pair.html "cpp/utility/pair") |  implements binary tuple, i.e. a pair of values   
(class template)   
---|---
