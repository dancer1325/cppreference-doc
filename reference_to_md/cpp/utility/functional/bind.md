[C++](../../../cpp.html "cpp")

[Compiler support](../../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../../freestanding.html "cpp/freestanding")  
[Language](../../language.html "cpp/language")  
[Standard library](../../standard_library.html "cpp/standard library")  
[Standard library headers](../../headers.html "cpp/header")  
[Named requirements](../../iterator/concepts.html "cpp/named req")  
[Feature test macros](../../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../../utility.html#Language_support "cpp/utility")  
[Concepts library](../../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../../error.html "cpp/error")  
[Memory management library](../../memory.html "cpp/memory")  
[Metaprogramming library](../../meta.html "cpp/meta") (C++11)  
[General utilities library](../../utility.html "cpp/utility")  
[Containers library](../../container.html "cpp/container")  
[Iterators library](../../iterator.html "cpp/iterator")  
[Ranges library](../../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../../algorithm.html "cpp/algorithm")  
[Strings library](../../string.html "cpp/string")  
[Text processing library](../../text.html "cpp/text")  
[Numerics library](../../numeric.html "cpp/numeric")  
[Date and time library](../../chrono.html "cpp/chrono")  
[Input/output library](../../io.html "cpp/io")  
[Filesystem library](../../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../../atomic.html "cpp/thread") (C++11)  
[Execution control library](../../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../../experimental.html "cpp/experimental")  
[Symbols index](../../symbol_index.html "cpp/symbol index")  
[External libraries](../../links/libs.html "cpp/links/libs")  
  


[Utilities library](../../utility.html "cpp/utility")

| [Language support](../../utility.html#Language_support "cpp/utility")  
---  
[Type support](../rtti.html "cpp/types") (basic types, RTTI)  
[Library feature-test macros](../feature_test.html "cpp/utility/feature test") (C++20)  
[Program utilities](../program.html "cpp/utility/program")  
[Variadic functions](../variadic.html "cpp/utility/variadic")  
[initializer_list](../initializer_list.html "cpp/utility/initializer list")(C++11)  
[is_constant_evaluated](../../types/is_constant_evaluated.html "cpp/types/is constant evaluated")(C++20)  
[is_within_lifetime](../../types/is_within_lifetime.html "cpp/types/is within lifetime")(C++26)  
[source_location](../source_location.html "cpp/utility/source location")(C++20)  
[Coroutine support](../../coroutine.html "cpp/coroutine") (C++20)  
[Contract support](../../contract.html "cpp/contract") (C++26)  
[Three-way comparison](../../utility.html#Three-way_comparison "cpp/utility")  
[three_way_comparablethree_way_comparable_with](../compare/three_way_comparable.html "cpp/utility/compare/three way comparable")(C++20)(C++20)  
[strong_ordering](../compare/strong_ordering.html "cpp/utility/compare/strong ordering")(C++20)  
[weak_ordering](../compare/weak_ordering.html "cpp/utility/compare/weak ordering")(C++20)  
[partial_ordering](../compare/partial_ordering.html "cpp/utility/compare/partial ordering")(C++20)  
[common_comparison_category](../compare/common_comparison_category.html "cpp/utility/compare/common comparison category")(C++20)  
[compare_three_way_result](../compare/compare_three_way_result.html "cpp/utility/compare/compare three way result")(C++20)  
[compare_three_way](../compare/compare_three_way.html "cpp/utility/compare/compare three way")(C++20)  
[strong_order](../compare/strong_order.html "cpp/utility/compare/strong order")(C++20)  
[weak_order](../compare/weak_order.html "cpp/utility/compare/weak order")(C++20)  
[partial_order](../compare/partial_order.html "cpp/utility/compare/partial order")(C++20)  
[compare_strong_order_fallback](../compare/compare_strong_order_fallback.html "cpp/utility/compare/compare strong order fallback")(C++20)  
[compare_weak_order_fallback](../compare/compare_weak_order_fallback.html "cpp/utility/compare/compare weak order fallback")(C++20)  
[compare_partial_order_fallback](../compare/compare_partial_order_fallback.html "cpp/utility/compare/compare partial order fallback")(C++20)` `  
|  | [is_eqis_ltis_lteq](../compare/named_comparison_functions.html "cpp/utility/compare/named comparison functions")(C++20)(C++20)(C++20)` `  
---  
  
| [is_neqis_gtis_gteq](../compare/named_comparison_functions.html "cpp/utility/compare/named comparison functions")(C++20)(C++20)(C++20)  
---  
  
  
  
  
| General utilities  
---  
| [Function objects](../../functional.html "cpp/utility/functional")  
---  
[Bit manipulation](../bit.html "cpp/utility/bit") (C++20)  
[C-style bit manipulation](https://en.cppreference.com/mwiki/index.php?title=cpp/utility/stdbit&action=edit&redlink=1 "cpp/utility/stdbit \(page does not exist\)") (C++26)  
[bitset](../bitset.html "cpp/utility/bitset")  
[hash](../hash.html "cpp/utility/hash")(C++11)  
  
[Relational operators](../../utility.html#Relational_operators "cpp/utility") (deprecated in C++20)  
|  | [rel_ops::operator!=rel_ops::operator>](../rel_ops/operator_cmp.html "cpp/utility/rel ops/operator cmp")` `  
---  
  
| [rel_ops::operator<=rel_ops::operator>=](../rel_ops/operator_cmp.html "cpp/utility/rel ops/operator cmp")  
---  
  
[Integer comparison functions](../../utility.html#Integer_comparison_functions "cpp/utility")  
| [cmp_equalcmp_lesscmp_less_than](../intcmp.html "cpp/utility/intcmp")(C++20)(C++20)(C++20)` `  
---  
  
| [cmp_not_equalcmp_greatercmp_greater_than](../intcmp.html "cpp/utility/intcmp")(C++20)(C++20)(C++20)  
---  
  
[in_range](../in_range.html "cpp/utility/in range")(C++20)  
[Swap](../../utility.html#Swap "cpp/utility") and [type operations](../../utility.html#Type_operations "cpp/utility")  
| [swap](../swap.html "cpp/algorithm/swap")  
---  
[ranges::swap](../ranges/swap.html "cpp/utility/ranges/swap")(C++20)  
[exchange](../exchange.html "cpp/utility/exchange")(C++14)  
[declval](../declval.html "cpp/utility/declval")(C++11)  
[to_underlying](../to_underlying.html "cpp/utility/to underlying")(C++23)  
  
| [forward](../forward.html "cpp/utility/forward")(C++11)  
---  
[forward_like](../forward_like.html "cpp/utility/forward like")(C++23)  
[move](../move.html "cpp/utility/move")(C++11)  
[move_if_noexcept](../move_if_noexcept.html "cpp/utility/move if noexcept")(C++11)  
[as_const](../as_const.html "cpp/utility/as const")(C++17)  
  
Common vocabulary types  
| [pair](../pair.html "cpp/utility/pair")  
---  
[tuple](../tuple.html "cpp/utility/tuple")(C++11)  
[optional](../optional.html "cpp/utility/optional")(C++17)  
[any](../any.html "cpp/utility/any")(C++17)  
[variant](../variant.html "cpp/utility/variant")(C++17)  
  
| [tuple_size](../tuple_size.html "cpp/utility/tuple size")(C++11)  
---  
[tuple_element](../tuple_element.html "cpp/utility/tuple element")(C++11)  
[apply](../apply.html "cpp/utility/apply")(C++17)  
[make_from_tuple](../make_from_tuple.html "cpp/utility/make from tuple")(C++17)  
[expected](../expected.html "cpp/utility/expected")(C++23)  
  
  
  
  
  
  


[Function objects](../../functional.html "cpp/utility/functional")

| [Function wrappers](../../functional.html#Function_wrappers "cpp/utility/functional")  
---  
[function](function.html "cpp/utility/functional/function")(C++11)  
[move_only_function](move_only_function.html "cpp/utility/functional/move only function")(C++23)  
[copyable_function](copyable_function.html "cpp/utility/functional/copyable function")(C++26)  
[function_ref](function_ref.html "cpp/utility/functional/function ref")(C++26)  
[mem_fn](mem_fn.html "cpp/utility/functional/mem fn")(C++11)  
[bad_function_call](bad_function_call.html "cpp/utility/functional/bad function call")(C++11)  
  
| [Partial function application](../../functional.html#Partial_function_application "cpp/utility/functional")  
---  
[bind_frontbind_back](bind_front.html "cpp/utility/functional/bind front")(C++20)(C++23)  
**bind**(C++11)  
[is_bind_expression](is_bind_expression.html "cpp/utility/functional/is bind expression")(C++11)  
[is_placeholder](is_placeholder.html "cpp/utility/functional/is placeholder")(C++11)  
[_1, _2, _3, ...](placeholders.html "cpp/utility/functional/placeholders")(C++11)  
  
| [Function invocation](../../functional.html#Function_invocation "cpp/utility/functional")  
---  
[invokeinvoke_r](invoke.html "cpp/utility/functional/invoke")(C++17)(C++23)  
Identity function object  
[identity](identity.html "cpp/utility/functional/identity")(C++20)  
  
| [Reference wrappers](../../functional.html#Reference_wrappers "cpp/utility/functional")  
---  
[reference_wrapper](reference_wrapper.html "cpp/utility/functional/reference wrapper")(C++11)  
[refcref](ref.html "cpp/utility/functional/ref")(C++11)(C++11)  
[unwrap_referenceunwrap_ref_decay](unwrap_reference.html "cpp/utility/functional/unwrap reference")(C++20)(C++20)  
  
| [Operator wrappers](../../functional.html#Operator_function_objects "cpp/utility/functional")  
---  
| [plus](plus.html "cpp/utility/functional/plus")  
---  
[minus](minus.html "cpp/utility/functional/minus")  
[negate](negate.html "cpp/utility/functional/negate")  
[multiplies](multiplies.html "cpp/utility/functional/multiplies")  
[divides](divides.html "cpp/utility/functional/divides")  
[modulus](modulus.html "cpp/utility/functional/modulus")  
[bit_and](bit_and.html "cpp/utility/functional/bit and")  
[bit_or](bit_or.html "cpp/utility/functional/bit or")  
[bit_not](bit_not.html "cpp/utility/functional/bit not")(C++14)  
[bit_xor](bit_xor.html "cpp/utility/functional/bit xor")  
  
| [equal_to](equal_to.html "cpp/utility/functional/equal to")  
---  
[not_equal_to](not_equal_to.html "cpp/utility/functional/not equal to")  
[greater](greater.html "cpp/utility/functional/greater")  
[less](less.html "cpp/utility/functional/less")  
[greater_equal](greater_equal.html "cpp/utility/functional/greater equal")  
[less_equal](less_equal.html "cpp/utility/functional/less equal")  
[logical_and](logical_and.html "cpp/utility/functional/logical and")  
[logical_or](logical_or.html "cpp/utility/functional/logical or")  
[logical_not](logical_not.html "cpp/utility/functional/logical not")  
  
  
  
| [Transparent operator wrappers](../../functional.html#Transparent_function_objects "cpp/utility/functional")  
---  
| [plus<>](plus_void.html "cpp/utility/functional/plus void")(C++14)  
---  
[minus<>](minus_void.html "cpp/utility/functional/minus void")(C++14)  
[negate<>](negate_void.html "cpp/utility/functional/negate void")(C++14)  
[multiplies<>](multiplies_void.html "cpp/utility/functional/multiplies void")(C++14)  
[divides<>](divides_void.html "cpp/utility/functional/divides void")(C++14)  
[modulus<>](modulus_void.html "cpp/utility/functional/modulus void")(C++14)  
[bit_and<>](bit_and_void.html "cpp/utility/functional/bit and void")(C++14)  
[bit_or<>](bit_or_void.html "cpp/utility/functional/bit or void")(C++14)  
[bit_not<>](bit_not_void.html "cpp/utility/functional/bit not void")(C++14)  
[bit_xor<>](bit_xor_void.html "cpp/utility/functional/bit xor void")(C++14)  
  
| [equal_to<>](equal_to_void.html "cpp/utility/functional/equal to void")(C++14)  
---  
[not_equal_to<>](not_equal_to_void.html "cpp/utility/functional/not equal to void")(C++14)  
[greater<>](greater_void.html "cpp/utility/functional/greater void")(C++14)  
[less<>](less_void.html "cpp/utility/functional/less void")(C++14)  
[greater_equal<>](greater_equal_void.html "cpp/utility/functional/greater equal void")(C++14)  
[less_equal<>](less_equal_void.html "cpp/utility/functional/less equal void")(C++14)  
[logical_and<>](logical_and_void.html "cpp/utility/functional/logical and void")(C++14)  
[logical_or<>](logical_or_void.html "cpp/utility/functional/logical or void")(C++14)  
[logical_not<>](logical_not_void.html "cpp/utility/functional/logical not void")(C++14)  
  
  
  
| [Negators](../../functional.html#Negators "cpp/utility/functional")  
---  
[not_fn](not_fn.html "cpp/utility/functional/not fn")(C++17)  
[Searchers](../../functional.html#Searchers "cpp/utility/functional")  
[default_searcher](default_searcher.html "cpp/utility/functional/default searcher")(C++17)  
[boyer_moore_searcher](boyer_moore_searcher.html "cpp/utility/functional/boyer moore searcher")(C++17)  
[boyer_moore_horspool_searcher](boyer_moore_horspool_searcher.html "cpp/utility/functional/boyer moore horspool searcher")(C++17)  
  
| [Constrained comparators](../../functional.html#Constrained_comparison_function_objects "cpp/utility/functional")  
---  
[ranges::equal_to](ranges/equal_to.html "cpp/utility/functional/ranges/equal to")(C++20)  
[ranges::not_equal_to](ranges/not_equal_to.html "cpp/utility/functional/ranges/not equal to")(C++20)  
[ranges::greater](ranges/greater.html "cpp/utility/functional/ranges/greater")(C++20)  
[ranges::less](ranges/less.html "cpp/utility/functional/ranges/less")(C++20)  
[ranges::greater_equal](ranges/greater_equal.html "cpp/utility/functional/ranges/greater equal")(C++20)  
[ranges::less_equal](ranges/less_equal.html "cpp/utility/functional/ranges/less equal")(C++20)  
[compare_three_way](../compare/compare_three_way.html "cpp/utility/compare/compare three way")(C++20)  
  
[Old binders and adaptors](../../functional.html#Old_binders_and_adaptors "cpp/utility/functional")  
| [unary_function](unary_function.html "cpp/utility/functional/unary function")(until C++17*)  
---  
[binary_function](binary_function.html "cpp/utility/functional/binary function")(until C++17*)  
[ptr_fun](ptr_fun.html "cpp/utility/functional/ptr fun")(until C++17*)  
[pointer_to_unary_function](pointer_to_unary_function.html "cpp/utility/functional/pointer to unary function")(until C++17*)  
[pointer_to_binary_function](pointer_to_binary_function.html "cpp/utility/functional/pointer to binary function")(until C++17*)  
[mem_fun](mem_fun.html "cpp/utility/functional/mem fun")(until C++17*)  
[mem_fun_tmem_fun1_tconst_mem_fun_tconst_mem_fun1_t](mem_fun_t.html "cpp/utility/functional/mem fun t")(until C++17*)(until C++17*)(until C++17*)(until C++17*)  
[not1](not1.html "cpp/utility/functional/not1")(until C++20*)  
[not2](not2.html "cpp/utility/functional/not2")(until C++20*)  
  
| [binder1stbinder2nd](binder12.html "cpp/utility/functional/binder12")(until C++17*)(until C++17*)  
---  
[bind1stbind2nd](bind12.html "cpp/utility/functional/bind12")(until C++17*)(until C++17*)  
  
  
[mem_fun_ref](mem_fun_ref.html "cpp/utility/functional/mem fun ref")(until C++17*)  
[mem_fun_ref_tmem_fun1_ref_tconst_mem_fun_ref_tconst_mem_fun1_ref_t](mem_fun_ref_t.html "cpp/utility/functional/mem fun ref t")(until C++17*)(until C++17*)(until C++17*)(until C++17*)  
[unary_negate](unary_negate.html "cpp/utility/functional/unary negate")(until C++20*)  
[binary_negate](binary_negate.html "cpp/utility/functional/binary negate")(until C++20*)  
  


Defined in header `[<functional>](../../header/functional.html "cpp/header/functional")` |  |   
---|---|---  
template< class F, class... Args >  
/* unspecified */ bind( F&& f, Args&&... args ); |  (1) | (since C++11)   
(constexpr since C++20)  
template< class R, class F, class... Args >  
/* unspecified */ bind( F&& f, Args&&... args ); |  (2) | (since C++11)   
(constexpr since C++20)  
| |   
  
The function template `std::bind` generates a forwarding call wrapper for f. Calling this wrapper is equivalent to invoking f with some of its arguments [bound](bind.html#Bound_arguments) to args. 

If [std::is_constructible](../../types/is_constructible.html)<[std::decay](../../types/decay.html)<F>::type, F>::value is false, or [std::is_constructible](../../types/is_constructible.html)<[std::decay](../../types/decay.html)<Arg_i>::type, Arg_i>::value is false for any type `Arg_i` in `Args`, the program is ill-formed. 

If [std::decay](../../types/decay.html)<Ti>::type or any type in `Args` is not [MoveConstructible](../../named_req/MoveConstructible.html "cpp/named req/MoveConstructible") or [Destructible](../../named_req/Destructible.html "cpp/named req/Destructible"), the behavior is undefined. 

## Contents

  * [1 Parameters](bind.html#Parameters)
  * [2 Return value](bind.html#Return_value)
  * [3 std::bind _return type_](bind.html#std::bind_return_type)
    * [3.1 Member objects](bind.html#Member_objects)
    * [3.2 Constructors](bind.html#Constructors)
    * [3.3 Member type result_type](bind.html#Member_type_result_type)
    * [3.4 Member function operator()](bind.html#Member_function_operator.28.29)
    * [3.5 Bound arguments](bind.html#Bound_arguments)
      * [3.5.1 Case 1: reference wrappers](bind.html#Case_1:_reference_wrappers)
      * [3.5.2 Case 2: bind expressions](bind.html#Case_2:_bind_expressions)
      * [3.5.3 Case 3: placeholders](bind.html#Case_3:_placeholders)
      * [3.5.4 Case 4: ordinary arguments](bind.html#Case_4:_ordinary_arguments)
    * [3.6 Exceptions](bind.html#Exceptions)
    * [3.7 Notes](bind.html#Notes)
    * [3.8 Example](bind.html#Example)
    * [3.9 Defect reports](bind.html#Defect_reports)
    * [3.10 See also](bind.html#See_also)

  
---  
  
### Parameters

f  |  \-  |  [Callable](../../named_req/Callable.html "cpp/named req/Callable") object (function object, pointer to function, reference to function, pointer to member function, or pointer to data member) that will be bound to some arguments   
---|---|---  
args  |  \-  |  list of arguments to bind, with the unbound arguments replaced by the [placeholders](placeholders.html "cpp/utility/functional/placeholders") _1, _2, _3... of namespace `std::placeholders`  
  
### Return value

A function object g of unspecified type `T`, for which [std::is_bind_expression](is_bind_expression.html)<T>::value is true. It has the following members: 

##  std::bind _return type_

####  Member objects

The return type of `std::bind` holds a member object of type [std::decay](../../types/decay.html)<F>::type constructed from [std::forward](../forward.html)<F>(f), and one object per each of args..., of type [std::decay](../../types/decay.html)<Arg_i>::type, similarly constructed from [std::forward](../forward.html)<Arg_i>(arg_i). 

####  Constructors

The return type of `std::bind` is [CopyConstructible](../../named_req/CopyConstructible.html "cpp/named req/CopyConstructible") if all of its member objects (specified above) are CopyConstructible, and is [MoveConstructible](../../named_req/MoveConstructible.html "cpp/named req/MoveConstructible") otherwise. The type defines the following members: 

####  Member type `result_type`

1) (deprecated in C++17) If `F` is a pointer to function or a pointer to member function, `result_type` is the return type of `F`. If `F` is a class type with nested typedef `result_type`, then `result_type` is `F::result_type`. Otherwise no `result_type` is defined. 2) (deprecated in C++17) `result_type` is exactly `R`. | (until C++20)  
---|---  
  
####  Member function `operator()`

When g is invoked in a function call expression g(u1, u2, ... uM), an invocation of the stored object takes place, as if by 

1) [`_INVOKE_`](../../functional.html "cpp/utility/functional")(fd, [std::forward](../forward.html)<V1>(v1), [std::forward](../forward.html)<V2>(v2), ..., [std::forward](../forward.html)<VN>(vN)), or

2) [`_INVOKE <R>_`](../../functional.html "cpp/utility/functional")(fd, [std::forward](../forward.html)<V1>(v1), [std::forward](../forward.html)<V2>(v2), ..., [std::forward](../forward.html)<VN>(vN)),

where fd is a value of type [std::decay](../../types/decay.html)<F>::type, the values and types of the bound arguments v1`, `v2`, ..., `vN are determined as specified [below](bind.html#Bound_arguments). 

If some of the arguments that are supplied in the call to g() are not matched by any placeholders stored in g, the unused arguments are evaluated and discarded. 

An invocation of operator() is [non-throwing](../../language/noexcept.html "cpp/language/noexcept") or is a [constant subexpression](../../language/constant_expression.html "cpp/language/constant expression")(since C++20) if and only if so is the underlying `_INVOKE_` operation. operator() participates in overload resolution only if the `_INVOKE_` operation is well-formed when treated as an unevaluated operand. 

If g is [volatile](../../language/cv.html "cpp/language/cv")-qualified, the program is ill-formed. 

If [`_INVOKE_`](../../functional.html "cpp/utility/functional")(fd, w1, w2, ..., wN) can never be a valid expression for any possible values w1`, `w2`, ..., `wN, the behavior is undefined. 

### Bound arguments

For each stored argument arg_i, the corresponding bound argument v_i in the [`_INVOKE_`](../../functional.html "cpp/utility/functional") or [`_INVOKE <R>_`](../../functional.html "cpp/utility/functional") operation is determined as follows: 

#### Case 1: reference wrappers

If arg_i is of type [std::reference_wrapper](reference_wrapper.html)<T> (for example, [std::ref](ref.html "cpp/utility/functional/ref") or [std::cref](ref.html "cpp/utility/functional/ref") was used in the initial call to `std::bind`), then v_i is arg_i.get() and its type `V_i` is `T&`: the stored argument is passed by reference into the invoked function object. 

#### Case 2: bind expressions

If arg_i is of type `T` for which [std::is_bind_expression](is_bind_expression.html)<T>::value is true (for example, another `std::bind` expression was passed directly into the initial call to `std::bind`), then `std::bind` performs function composition: instead of passing the function object that the bind subexpression would return, the subexpression is invoked eagerly, and its return value is passed to the outer invokable object. If the bind subexpression has any placeholder arguments, they are shared with the outer bind (picked out of u1`, `u2`, ...`). Specifically, v_i is arg_i([std::forward](../forward.html)<Uj>(uj)...) and its type `V_i` is [std::result_of](../../types/result_of.html)<T _cv_ ﻿&(Uj&&...)>::type&&(until C++17)[std::invoke_result_t](../../types/result_of.html)<T _cv_ ﻿&, Uj&&...>&&(since C++17) (cv-qualification is the same as that of g). 

#### Case 3: placeholders

If arg_i is of type `T`, for which [std::is_placeholder](is_placeholder.html)<T>::value is not ​0​ (meaning, a placeholder such as `std::placeholders::_1, _2, _3, ...` was used as the argument to the initial call to `std::bind`), then the argument indicated by the placeholder (u1 for _1, u2 for _2, etc) is passed to the invokable object: v_i is [std::forward](../forward.html)<Uj>(uj) and its type `V_i` is `Uj&&`. 

#### Case 4: ordinary arguments

Otherwise, arg_i is passed to the invokable object as lvalue argument: v_i is simply arg_i and its type `V_i` is `T` _cv_ ﻿`&`, where _cv_ is the same cv-qualification as that of g. 

### Exceptions

Only throws if construction of [std::decay](../../types/decay.html)<F>::type from [std::forward](../forward.html)<F>(f) throws, or any of the constructors for [std::decay](../../types/decay.html)<Arg_i>::type from the corresponding [std::forward](../forward.html)<Arg_i>(arg_i) throws where `Arg_i` is the ith type and arg_i is the ith argument in `Args... args`. 

### Notes

As described in [Callable](../../named_req/Callable.html "cpp/named req/Callable"), when invoking a pointer to non-static member function or pointer to non-static data member, the first argument has to be a reference or pointer (including, possibly, smart pointer such as [std::shared_ptr](../../memory/shared_ptr.html "cpp/memory/shared ptr") and [std::unique_ptr](../../memory/unique_ptr.html "cpp/memory/unique ptr")) to an object whose member will be accessed. 

The arguments to bind are copied or moved, and are never passed by reference unless wrapped in [std::ref](ref.html "cpp/utility/functional/ref") or [std::cref](ref.html "cpp/utility/functional/ref"). 

Duplicate placeholders in the same bind expression (multiple _1's for example) are allowed, but the results are only well defined if the corresponding argument (u1) is an lvalue or non-movable rvalue. 

### Example

Run this code
    
    
    #include <functional>
    #include <iostream>
    #include <memory>
    #include <random>
     
    void f(int n1, int n2, int n3, const int& n4, int n5)
    {
        [std::cout](../../io/cout.html) << n1 << ' ' << n2 << ' ' << n3 << ' ' << n4 << ' ' << n5 << '\n';
    }
     
    int g(int n1)
    {
        return n1;
    }
     
    struct Foo
    {
        void print_sum(int n1, int n2)
        {
            [std::cout](../../io/cout.html) << n1 + n2 << '\n';
        }
     
        int data = 10;
    };
     
    int main()
    {
        using namespace [std::placeholders](placeholders.html);  // for _1, _2, _3...
     
        [std::cout](../../io/cout.html) << "1) argument reordering and pass-by-reference: ";
        int n = 7;
        // (_1 and _2 are from std::placeholders, and represent future
        // arguments that will be passed to f1)
        auto f1 = std::bind(f, _2, 42, _1, [std::cref](ref.html)(n), n);
        n = 10;
        f1(1, 2, 1001); // 1 is bound by _1, 2 is bound by _2, 1001 is unused
                        // makes a call to f(2, 42, 1, n, 7)
     
        [std::cout](../../io/cout.html) << "2) achieving the same effect using a lambda: ";
        n = 7;
        auto lambda = [&ncref = n, n](auto a, auto b, auto /*unused*/)
        {
            f(b, 42, a, ncref, n);
        };
        n = 10;
        lambda(1, 2, 1001); // same as a call to f1(1, 2, 1001)
     
        [std::cout](../../io/cout.html) << "3) nested bind subexpressions share the placeholders: ";
        auto f2 = std::bind(f, _3, std::bind(g, _3), _3, 4, 5);
        f2(10, 11, 12); // makes a call to f(12, g(12), 12, 4, 5);
     
        [std::cout](../../io/cout.html) << "4) bind a RNG with a distribution: ";
        [std::default_random_engine](../../numeric/random.html) e;
        [std::uniform_int_distribution](../../numeric/random/uniform_int_distribution.html)<> d(0, 10);
        auto rnd = std::bind(d, e); // a copy of e is stored in rnd
        for (int n = 0; n < 10; ++n)
            [std::cout](../../io/cout.html) << rnd() << ' ';
        [std::cout](../../io/cout.html) << '\n';
     
        [std::cout](../../io/cout.html) << "5) bind to a pointer to member function: ";
        Foo foo;
        auto f3 = std::bind(&Foo::print_sum, &foo, 95, _1);
        f3(5);
     
        [std::cout](../../io/cout.html) << "6) bind to a mem_fn that is a pointer to member function: ";
        auto ptr_to_print_sum = [std::mem_fn](mem_fn.html)(&Foo::print_sum);
        auto f4 = std::bind(ptr_to_print_sum, &foo, 95, _1);
        f4(5);
     
        [std::cout](../../io/cout.html) << "7) bind to a pointer to data member: ";
        auto f5 = std::bind(&Foo::data, _1);
        [std::cout](../../io/cout.html) << f5(foo) << '\n';
     
        [std::cout](../../io/cout.html) << "8) bind to a mem_fn that is a pointer to data member: ";
        auto ptr_to_data = [std::mem_fn](mem_fn.html)(&Foo::data);
        auto f6 = std::bind(ptr_to_data, _1);
        [std::cout](../../io/cout.html) << f6(foo) << '\n';
     
        [std::cout](../../io/cout.html) << "9) use smart pointers to call members of the referenced objects: ";
        [std::cout](../../io/cout.html) << f6([std::make_shared](../../memory/shared_ptr/make_shared.html)<Foo>(foo)) << ' '
                  << f6([std::make_unique](../../memory/unique_ptr/make_unique.html)<Foo>(foo)) << '\n';
    }

Output: 
    
    
    1) argument reordering and pass-by-reference: 2 42 1 10 7
    2) achieving the same effect using a lambda: 2 42 1 10 7
    3) nested bind subexpressions share the placeholders: 12 12 12 4 5
    4) bind a RNG with a distribution: 0 1 8 5 5 2 0 7 7 10 
    5) bind to a pointer to member function: 100
    6) bind to a mem_fn that is a pointer to member function: 100
    7) bind to a pointer to data member: 10
    8) bind to a mem_fn that is a pointer to data member: 10
    9) use smart pointers to call members of the referenced objects: 10 10

### Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[LWG 2021](https://cplusplus.github.io/LWG/issue2021) | C++11  | 1\. the bounded arguments  
were not forwarded to fd  
2\. in case 2, the type of `V_i` was  
[std::result_of](../../types/result_of.html)<T _cv_ ﻿(Uj...)>::type | 1\. forwarded  
2\. changed to  
[std::result_of](../../types/result_of.html)<T _cv_ ﻿&(Uj&&...)>::type&&  
  
### See also

[ bind_frontbind_back](bind_front.html "cpp/utility/functional/bind front")(C++20)(C++23) |  bind a variable number of arguments, in order, to a function object   
(function template)   
---|---  
[ _1, _2, _3, _4, ...](placeholders.html "cpp/utility/functional/placeholders")(C++11) |  placeholders for the unbound arguments in a `std::bind` expression   
(constant)   
[ mem_fn](mem_fn.html "cpp/utility/functional/mem fn")(C++11) |  creates a function object out of a pointer to a member   
(function template) 
