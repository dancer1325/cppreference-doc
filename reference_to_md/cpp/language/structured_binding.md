[C++](../../cpp.html "cpp")

[Compiler support](../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../freestanding.html "cpp/freestanding")  
[Language](../language.html "cpp/language")  
[Standard library](../standard_library.html "cpp/standard library")  
[Standard library headers](../headers.html "cpp/header")  
[Named requirements](../iterator/concepts.html "cpp/named req")  
[Feature test macros](../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../utility.html#Language_support "cpp/utility")  
[Concepts library](../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../error.html "cpp/error")  
[Memory management library](../memory.html "cpp/memory")  
[Metaprogramming library](../meta.html "cpp/meta") (C++11)  
[General utilities library](../utility.html "cpp/utility")  
[Containers library](../container.html "cpp/container")  
[Iterators library](../iterator.html "cpp/iterator")  
[Ranges library](../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../algorithm.html "cpp/algorithm")  
[Strings library](../string.html "cpp/string")  
[Text processing library](../text.html "cpp/text")  
[Numerics library](../numeric.html "cpp/numeric")  
[Date and time library](../chrono.html "cpp/chrono")  
[Input/output library](../io.html "cpp/io")  
[Filesystem library](../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../atomic.html "cpp/thread") (C++11)  
[Execution control library](../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../experimental.html "cpp/experimental")  
[Symbols index](../symbol_index.html "cpp/symbol index")  
[External libraries](../links/libs.html "cpp/links/libs")  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/navbar_content&action=edit)

[C++ language](../language.html "cpp/language")

General topics  
---  
| [Preprocessor](../preprocessor.html "cpp/preprocessor")  
---  
[Comments](../comments.html "cpp/comment")  
  
| [Keywords](../keywords.html "cpp/keyword")  
---  
[Escape sequences](escape.html "cpp/language/escape")  
  
[Flow control](statements.html "cpp/language/statements")  
Conditional execution statements  
| [`if`](if.html "cpp/language/if")  
---  
  
| [`switch`](switch.html "cpp/language/switch")  
---  
  
Iteration statements (loops)  
| [`for`](for.html "cpp/language/for")  
---  
[range-`for`](range-for.html "cpp/language/range-for") (C++11)  
  
| [`while`](while.html "cpp/language/while")  
---  
[`do-while`](do.html "cpp/language/do")  
  
Jump statements  
| [`continue`](continue.html "cpp/language/continue") \- [`break`](break.html "cpp/language/break")  
---  
  
| [`goto`](goto.html "cpp/language/goto") \- [`return`](return.html "cpp/language/return")  
---  
  
[Functions](functions.html "cpp/language/functions")  
[Function declaration](function.html "cpp/language/function")  
[Lambda function expression](lambda.html "cpp/language/lambda")  
[`inline` specifier](inline.html "cpp/language/inline")  
[Dynamic exception specifications](except_spec.html "cpp/language/except spec") (until C++17*)  
[`noexcept` specifier](noexcept_spec.html "cpp/language/noexcept spec") (C++11)  
Exceptions  
| [`throw`-expression](throw.html "cpp/language/throw")  
---  
[`try` block](try.html "cpp/language/try")  
  
|   
  
---  
[`catch` handler](catch.html "cpp/language/catch")  
  
Namespaces  
| [Namespace declaration](namespace.html "cpp/language/namespace")` `  
---  
  
| [Namespace aliases](namespace_alias.html "cpp/language/namespace alias")  
---  
  
Types  
| [Fundamental types](types.html "cpp/language/types")  
---  
[Enumeration types](enum.html "cpp/language/enum")  
[Function types](function.html "cpp/language/function")  
  
| [Class/struct types](class.html "cpp/language/class")  
---  
[Union types](union.html "cpp/language/union")  
  
  
  
Specifiers  
| [`const`/`volatile`](cv.html "cpp/language/cv")  
---  
[`decltype`](decltype.html "cpp/language/decltype") (C++11)  
[`auto`](auto.html "cpp/language/auto") (C++11)  
  
| [`constexpr`](constexpr.html "cpp/language/constexpr") (C++11)  
---  
[`consteval`](consteval.html "cpp/language/consteval") (C++20)  
[`constinit`](constinit.html "cpp/language/constinit") (C++20)  
  
[Storage duration specifiers](storage_duration.html "cpp/language/storage duration")  
[Initialization](initialization.html "cpp/language/initialization")  
| [Default-initialization](default_initialization.html "cpp/language/default initialization")  
---  
[Value-initialization](value_initialization.html "cpp/language/value initialization")  
[Zero-initialization](zero_initialization.html "cpp/language/zero initialization")  
[Copy-initialization](copy_initialization.html "cpp/language/copy initialization")  
[Direct-initialization](direct_initialization.html "cpp/language/direct initialization")  
  
| [Aggregate initialization](aggregate_initialization.html "cpp/language/aggregate initialization")  
---  
[List-initialization](list_initialization.html "cpp/language/list initialization") (C++11)` `  
[Constant initialization](constant_initialization.html "cpp/language/constant initialization")  
[Reference initialization](reference_initialization.html "cpp/language/reference initialization")  
  
  
  
[Expressions](expressions.html "cpp/language/expressions")  
---  
| [Value categories](value_category.html "cpp/language/value category")  
---  
[Order of evaluation](eval_order.html "cpp/language/eval order")  
  
| [Operators](operators.html "cpp/language/operators")  
---  
[Operator precedence](operator_precedence.html "cpp/language/operator precedence")  
  
[Alternative representations](operator_alternative.html "cpp/language/operator alternative")  
[Literals](expressions.html#Literals "cpp/language/expressions")  
[Boolean](bool_literal.html "cpp/language/bool literal") \- [Integer](integer_literal.html "cpp/language/integer literal") \- [Floating-point](floating_literal.html "cpp/language/floating literal")  
[Character](character_literal.html "cpp/language/character literal") \- [String](string_literal.html "cpp/language/string literal") \- [`nullptr`](nullptr.html "cpp/language/nullptr") (C++11)  
[User-defined](user_literal.html "cpp/language/user literal") (C++11)  
Utilities  
[Attributes](attributes.html "cpp/language/attributes") (C++11)  
Types  
[`typedef` declaration](typedef.html "cpp/language/typedef")  
[Type alias declaration](type_alias.html "cpp/language/type alias") (C++11)  
Casts  
| [Implicit conversions](implicit_cast.html "cpp/language/implicit conversion")  
---  
[`static_cast`](static_cast.html "cpp/language/static cast")  
[`const_cast`](const_cast.html "cpp/language/const cast")  
  
| [Explicit conversions](explicit_cast.html "cpp/language/explicit cast")  
---  
[`dynamic_cast`](dynamic_cast.html "cpp/language/dynamic cast")  
[`reinterpret_cast`](reinterpret_cast.html "cpp/language/reinterpret cast")  
  
Memory allocation  
| [`new` expression](new.html "cpp/language/new")  
---  
  
| [`delete` expression](delete.html "cpp/language/delete")  
---  
  
[Classes](classes.html "cpp/language/classes")  
| [Class declaration](class.html "cpp/language/class")  
---  
[Constructors](initializer_list.html "cpp/language/constructor")  
[`this` pointer](this.html "cpp/language/this")  
  
| [Access specifiers](access.html "cpp/language/access")  
---  
[`friend` specifier](friend.html "cpp/language/friend")  
  
  
  
Class-specific function properties  
| [Virtual function](virtual.html "cpp/language/virtual")  
---  
[`override` specifier](override.html "cpp/language/override") (C++11)` `  
[`final` specifier](final.html "cpp/language/final") (C++11)  
  
| [`explicit`](explicit.html "cpp/language/explicit") (C++11)  
---  
[`static`](static.html "cpp/language/static")  
  
  
  
Special member functions  
| [Default constructor](default_constructor.html "cpp/language/default constructor")  
---  
[Copy constructor](copy_constructor.html "cpp/language/copy constructor")  
[Move constructor](move_constructor.html "cpp/language/move constructor") (C++11)  
  
| [Copy assignment](as_operator.html "cpp/language/as operator")  
---  
[Move assignment](move_operator.html "cpp/language/move operator") (C++11)  
[Destructor](destructor.html "cpp/language/destructor")  
  
[Templates](templates.html "cpp/language/templates")  
| [Class template](class_template.html "cpp/language/class template")  
---  
[Function template](function_template.html "cpp/language/function template")  
  
| [Template specialization](template_specialization.html "cpp/language/template specialization")  
---  
[Parameter packs](parameter_pack.html "cpp/language/pack") (C++11)  
  
Miscellaneous  
| [Inline assembly](asm.html "cpp/language/asm")  
---  
  
| [History of C++](history.html "cpp/language/history")  
---  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/navbar_content&action=edit)

[Declarations](declarations.html "cpp/language/declarations")

| Overview  
---  
[Declaration syntax](declarations.html "cpp/language/declarations")  
[_decl-specifier-seq_](declarations.html#Specifiers "cpp/language/declarations")  
[Declarator](declarations.html#Declarators "cpp/language/declarations")  
[Conflicting declarations](conflicting_declarations.html "cpp/language/conflicting declarations")  
Specifiers  
[typedef](typedef.html "cpp/language/typedef")  
[inline](inline.html "cpp/language/inline")  
[virtual function specifier](virtual.html "cpp/language/virtual")  
[explicit function specifier](explicit.html "cpp/language/explicit")  
[friend](friend.html "cpp/language/friend")  
[constexpr](constexpr.html "cpp/language/constexpr")(C++11)  
[consteval](consteval.html "cpp/language/consteval")(C++20)  
[constinit](constinit.html "cpp/language/constinit")(C++20)  
[Storage class specifiers](storage_duration.html "cpp/language/storage duration")  
[Translation-unit-local](tu_local.html "cpp/language/tu local") (C++20)  
[class/struct](class.html "cpp/language/class")  
[union](union.html "cpp/language/union")  
[enum](enum.html "cpp/language/enum")  
[decltype](decltype.html "cpp/language/decltype")(C++11)  
[auto](auto.html "cpp/language/auto")(C++11)  
[alignas](alignas.html "cpp/language/alignas")(C++11)  
[constvolatile](cv.html "cpp/language/cv")  
[Pack indexing specifier](pack_indexing.html#Pack_indexing_specifier "cpp/language/pack indexing") (C++26)  
[Elaborated type specifier](elaborated_type_specifier.html "cpp/language/elaborated type specifier")  
[Attributes](attributes.html "cpp/language/attributes") (C++11)  
  
| Declarators  
---  
[Reference](reference.html "cpp/language/reference")  
[Pointer](pointer.html "cpp/language/pointer")  
[Array](array.html "cpp/language/array")  
Block declarations  
[Simple-declaration](declarations.html "cpp/language/declarations")  
→**Structured binding declaration** (C++17)  
[Alias declaration](type_alias.html "cpp/language/type alias") (C++11)  
[Namespace alias definition](namespace_alias.html "cpp/language/namespace alias")  
[using declaration](using_declaration.html "cpp/language/using declaration")  
[`using` directive](namespace.html#Using-directives "cpp/language/namespace")  
[static_assert declaration](static_assert.html "cpp/language/static assert") (C++11)  
[asm declaration](asm.html "cpp/language/asm")  
[Opaque enum declaration](enum.html "cpp/language/enum") (C++11)  
Other declarations  
[Namespace definition](namespace.html "cpp/language/namespace")  
[Function declaration](function.html "cpp/language/function")  
[Class template declaration](class_template.html "cpp/language/class template")  
[Function template declaration](function_template.html "cpp/language/function template")  
[Explicit template instantiation](class_template.html#Explicit_instantiation "cpp/language/class template") (C++11)  
[Explicit template specialization](template_specialization.html "cpp/language/template specialization")  
[Linkage specification](language_linkage.html "cpp/language/language linkage")  
[Attribute declaration](declarations.html "cpp/language/declarations") (C++11)  
[Empty declaration](declarations.html "cpp/language/declarations")  
  
  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/declarations/navbar_content&action=edit)

Binds the specified names to subobjects or elements of the initializer. 

Like a reference, a structured binding is an alias to an existing object. Unlike a reference, a structured binding does not have to be of a reference type.   
  
---  
attr ﻿(optional) decl-specifier-seq ref-qualifier ﻿(optional) `**[**` sb-identifier-list `**]**` initializer ﻿`**;**` |  |   
attr |  \-  |  sequence of any number of [attributes](attributes.html "cpp/language/attributes")  
---|---|---  
decl-specifier-seq |  \-  |  sequence of the following specifiers (following the rules of [simple declaration](declarations.html#Simple_declaration "cpp/language/declarations")):  | 

  * [`constexpr`](constexpr.html "cpp/language/constexpr")
  * [`constinit`](constinit.html "cpp/language/constinit")

| (since C++26)  
---|---  
  
  * [`static`](../keywords/static.html "cpp/keyword/static")
  * [`thread_local`](../keyword/thread_local.html "cpp/keyword/thread local")
  * [`const`](../keyword/const.html "cpp/keyword/const")
  * [`volatile`](../keyword/volatile.html "cpp/keyword/volatile") (deprecated in C++20)
  * [`auto`](auto.html "cpp/language/auto")

  
ref-qualifier |  \-  |  either `**&**` or `**& &**`  
sb-identifier-list |  \-  |  list of comma-separated identifiers introduced by this declaration, each identifier may be followed by an [attribute specifier sequence](attributes.html "cpp/language/attributes")(since C++26)  
initializer |  \-  |  an initializer (see below)   
  
  
initializer may be one of the following:   
  
---  
`**=**` expression |  (1)  |   
`**{**` expression ``}  |  (2)  |   
`**(**` expression `**)**` |  (3)  |   
expression |  \-  |  any expression (except unparenthesized [comma expressions](operator_other.html#Built-in_comma_operator "cpp/language/operator other"))   
---|---|---  
  
  
A structured binding declaration introduces all identifiers in the sb-identifier-list as names in the surrounding scope and binds them to subobjects or elements of the object denoted by expression. The bindings so introduced are called _structured bindings_. 

One of the identifiers in the sb-identifier-list can be preceded by an ellipsis. Such an identifier introduces a _structured binding pack_. The identifier must declare a [templated entity](templates.html#Templated_entity "cpp/language/templates").  | (since C++26)  
---|---  
  
A structured binding is an identifier in the sb-identifier-list ﻿ that is not preceded by an ellipsis, or an element of a structured binding pack introduced in the same identifier list(since C++26). 

## Contents

  * [1 Binding process](structured_binding.html#Binding_process)
    * [1.1 Case 1: binding an array](structured_binding.html#Case_1:_binding_an_array)
    * [1.2 Case 2: binding a type implementing the tuple operations](structured_binding.html#Case_2:_binding_a_type_implementing_the_tuple_operations)
    * [1.3 Case 3: binding to data members](structured_binding.html#Case_3:_binding_to_data_members)
    * [1.4 Initialization order](structured_binding.html#Initialization_order)
  * [2 Notes](structured_binding.html#Notes)
  * [3 Keywords](structured_binding.html#Keywords)
  * [4 Example](structured_binding.html#Example)
  * [5 Defect reports](structured_binding.html#Defect_reports)
  * [6 References](structured_binding.html#References)
  * [7 See also](structured_binding.html#See_also)

  
---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/structured_binding&action=edit&section=1 "Edit section: Binding process")] Binding process

A structured binding declaration first introduces a uniquely-named variable (here denoted by e) to hold the value of the initializer, as follows: 

  * If expression has array type _cv1_ `A` and no ref-qualifier is present, define e as attr ﻿(optional) specifiers `A e;`, where specifiers is a sequence of the specifiers in decl-specifier-seq excluding auto. 



     Then each element of e is initialized from the corresponding element of expression as specified by the form of initializer ﻿: 

  * For initializer syntax (1), the elements are [copy-initialized](copy_initialization.html "cpp/language/copy initialization"). 
  * For initializer syntaxes (2,3), the elements are [direct-initialized](direct_initialization.html "cpp/language/direct initialization"). 



  * Otherwise, define e as attr ﻿(optional) decl-specifier-seq ref-qualifier ﻿(optional) `e` initializer ﻿`;`. 



We use `E` to denote the type of the identifier expression e (i.e., `E` is the equivalent of [std::remove_reference_t](../types/remove_reference.html)<decltype((e))>). 

A _structured binding size_ of `E` is the number of structured bindings that need to be introduced by the structured binding declaration. 

The number of identifiers in sb-identifier-list must be equal to the structured binding size of `E`.  | (until C++26)  
---|---  
Given the number of identifiers in sb-identifier-list as N and the structured binding size of `E` as S: 

  * If there is no structured binding pack, N must be equal to S. 
  * Otherwise, the number of non-pack elements (i.e., N - 1) must be less than or equal to S, and the number of elements of the structured binding pack is S - N + 1 (which can be zero). 

| (since C++26)  
      
    
    struct C { int x, y, z; };
     
    template<class T>
    void now_i_know_my() 
    {
        auto [a, b, c] = C(); // OK: a, b, c refer to x, y, z, respectively
        auto [d, ...e] = C(); // OK: d refers to x; ...e refers to y and z
        auto [...f, g] = C(); // OK: ...f refers x and y; g refers to z
        auto [h, i, j, ...k] = C();    // OK: the pack k is empty
        auto [l, m, n, o, ...p] = C(); // error: structured binding size is too small
    }

A structured binding declaration performs the binding in one of three possible ways, depending on `E`: 

  * Case 1: If `E` is an array type, then the names are bound to the array elements. 
  * Case 2: If `E` is a non-union class type and [std::tuple_size](../utility/tuple_size.html)<E> is a complete type with a member named `value` (regardless of the type or accessibility of such member), then the "tuple-like" binding protocol is used. 
  * Case 3: If `E` is a non-union class type but [std::tuple_size](../utility/tuple_size.html)<E> is not a complete type, then the names are bound to the accessible data members of `E`. 



Each of the three cases is described in more detail below. 

Each structured binding has a _referenced type_ , defined in the description below. This type is the type returned by [`decltype`](decltype.html "cpp/language/decltype") when applied to an unparenthesized structured binding. 

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/structured_binding&action=edit&section=2 "Edit section: Case 1: binding an array")] Case 1: binding an array

Each structured binding in the sb-identifier-list becomes the name of an lvalue that refers to the corresponding element of the array. The structured binding size of `E` is equal to the number of array elements. 

The _referenced type_ for each structured binding is the array element type. Note that if the array type `E` is cv-qualified, so is its element type. 
    
    
    int a[2] = {1, 2};
     
    auto [x, y] = a;    // creates e[2], copies a into e,
                        // then x refers to e[0], y refers to e[1]
    auto& [xr, yr] = a; // xr refers to a[0], yr refers to a[1]

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/structured_binding&action=edit&section=3 "Edit section: Case 2: binding a type implementing the tuple operations")] Case 2: binding a type implementing the tuple operations

The expression [std::tuple_size](../utility/tuple_size.html)<E>::value must be a well-formed [integral constant expression](constant_expression.html#Integral_constant_expression "cpp/language/constant expression"), and the structured binding size of `E` is equal to [std::tuple_size](../utility/tuple_size.html)<E>::value. 

For each structured binding, a variable whose type is "reference to [std::tuple_element](../utility/tuple_element.html)<I, E>::type" is introduced: lvalue reference if its corresponding initializer is an lvalue, rvalue reference otherwise. The initializer for the Ith variable is 

  * e.get<I>(), if lookup for the identifier `get` in the scope of `E` by class member access lookup finds at least one declaration that is a function template whose first template parameter is a constant parameter 
  * Otherwise, get<I>(e), where get is looked up by [argument-dependent lookup](adl.html "cpp/language/adl") only, ignoring non-ADL lookup. 



In these initializer expressions, e is an lvalue if the type of the entity e is an lvalue reference (this only happens if the ref-qualifier is `**&**` or if it is `**& &**` and the initializer expression is an lvalue) and an xvalue otherwise (this effectively performs a kind of perfect forwarding), I is a [std::size_t](../types/size_t.html "cpp/types/size t") prvalue, and <I> is always interpreted as a template parameter list. 

The variable has the same [storage duration](storage_duration.html "cpp/language/storage duration") as e. 

The structured binding then becomes the name of an lvalue that refers to the object bound to said variable. 

The _referenced type_ for the Ith structured binding is [std::tuple_element](../utility/tuple_element.html)<I, E>::type. 
    
    
    float x{};
    char  y{};
    int   z{};
     
    [std::tuple](../utility/tuple.html)<float&, char&&, int> tpl(x, std::move(y), z);
    const auto& [a, b, c] = tpl;
    // using Tpl = const std::tuple<float&, char&&, int>;
    // a names a structured binding that refers to x (initialized from get<0>(tpl))
    // decltype(a) is std::tuple_element<0, Tpl>::type, i.e. float&
    // b names a structured binding that refers to y (initialized from get<1>(tpl))
    // decltype(b) is std::tuple_element<1, Tpl>::type, i.e. char&&
    // c names a structured binding that refers to the third component of tpl, get<2>(tpl)
    // decltype(c) is std::tuple_element<2, Tpl>::type, i.e. const int

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/structured_binding&action=edit&section=4 "Edit section: Case 3: binding to data members")] Case 3: binding to data members

Every non-static data member of `E` must be a direct member of `E` or the same base class of `E`, and must be well-formed in the context of the structured binding when named as e.name. `E` may not have an anonymous union member. The structured binding size of `E` is equal to the number of non-static data members. 

Each structured binding in sb-identifier-list becomes the name of an lvalue that refers to the next member of e in declaration order (bit-fields are supported); the type of the lvalue is that of e.mI, where `mI` refers to the Ith member. 

The _referenced type_ of the Ith structured binding is the type of e.mI if it is not a reference type, or the declared type of `mI` otherwise. 
    
    
    #include <iostream>
     
    struct S
    {
        mutable int x1 : 2;
        volatile double y1;
    };
     
    S f() { return S{1, 2.3}; }
     
    int main()
    {
        const auto [x, y] = f(); // x is an int lvalue identifying the 2-bit bit-field
                                 // y is a const volatile double lvalue
        [std::cout](../io/cout.html) << x << ' ' << y << '\n';  // 1 2.3
        x = -2;   // OK
    //  y = -2.;  // Error: y is const-qualified
        [std::cout](../io/cout.html) << x << ' ' << y << '\n';  // -2 2.3
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/structured_binding&action=edit&section=5 "Edit section: Initialization order")] Initialization order

Let valI be the object or reference named by the Ith structured binding in sb-identifier-list ﻿: 

  * The initialization of e is [sequenced before](eval_order.html "cpp/language/eval order") the initialization of any valI. 
  * The initialization of each valI is sequenced before the initialization of any valJ where I is less than J. 



### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/structured_binding&action=edit&section=6 "Edit section: Notes")] Notes

Structured bindings cannot be [constrained](constraints.html "cpp/language/constraints"): 
    
    
    template<class T>
    concept C = true;
     
    C auto [x, y] = [std::pair](../utility/pair.html){1, 2}; // error: constrained

| (since C++20)  
---|---  
  
The lookup for member `get` ignores accessibility as usual and also ignores the exact type of the constant template parameter. A private template<char*> void get(); member will cause the member interpretation to be used, even though it is ill-formed. 

The portion of the declaration preceding `**[**` applies to the hidden variable e, not to the introduced structured bindings: 
    
    
    int a = 1, b = 2;
    const auto& [x, y] = [std::tie](../utility/tuple/tie.html)(a, b); // x and y are of type int&
    auto [z, w] = [std::tie](../utility/tuple/tie.html)(a, b);        // z and w are still of type int&
    [assert](../error/assert.html)(&z == &a);                    // passes

The tuple-like interpretation is always used if [std::tuple_size](../utility/tuple_size.html)<E> is a complete type with a member named `value`, even if that would cause the program to be ill-formed: 
    
    
    struct A { int x; };
     
    namespace std
    {
        template<>
        struct tuple_size<::A> { void value(); };
    }
     
    auto [x] = A{}; // error; the "data member" interpretation is not considered.

The usual rules for reference-binding to temporaries (including lifetime-extension) apply if a ref-qualifier is present and the expression is a prvalue. In those cases the hidden variable e is a reference that binds to the temporary variable [materialized](implicit_cast.html#Temporary_materialization "cpp/language/implicit conversion") from the prvalue expression, extending its lifetime. As usual, the binding will fail if e is a non-const lvalue reference: 
    
    
    int a = 1;
     
    const auto& [x] = [std::make_tuple](../utility/tuple/make_tuple.html)(a); // OK, not dangling
    auto&       [y] = [std::make_tuple](../utility/tuple/make_tuple.html)(a); // error, cannot bind auto& to rvalue std::tuple
    auto&&      [z] = [std::make_tuple](../utility/tuple/make_tuple.html)(a); // also OK

decltype(x), where x denotes a structured binding, names the _referenced type_ of that structured binding. In the tuple-like case, this is the type returned by std::tuple_element, which may not be a reference even though a hidden reference is always introduced in this case. This effectively emulates the behavior of binding to a struct whose non-static data members have the types returned by std::tuple_element, with the referenceness of the binding itself being a mere implementation detail. 
    
    
    [std::tuple](../utility/tuple.html)<int, int&> f();
     
    auto [x, y] = f();       // decltype(x) is int
                             // decltype(y) is int&
     
    const auto [z, w] = f(); // decltype(z) is const int
                             // decltype(w) is int&

Structured bindings cannot be captured by [lambda expressions](lambda.html "cpp/language/lambda"): 
    
    
    #include <cassert>
     
    int main()
    {
        struct S { int p{6}, q{7}; };
        const auto& [b, d] = S{};
        auto l = [b, d] { return b * d; }; // valid since C++20
        [assert](../error/assert.html)(l() == 42);
    }

| (until C++20)  
---|---  
  
  


A structured binding size is allowed to be ​0​ as long as the sb-identifier-list contains exactly one identifier that can only introduce an empty structured binding pack. 
    
    
    auto return_empty() -> [std::tuple](../utility/tuple.html)<>;
     
    template <class>
    void test_empty()
    {
        auto [] = return_empty(); // error
        auto [...args] = return_empty(); // OK, args is an empty pack
        auto [one, ...rest] = return_empty(); // error, structured binding size is too small
    }

| (since C++26)  
---|---  
Feature-test macro  | Value | Std | Feature   
---|---|---|---  
[`__cpp_structured_bindings`](../experimental/feature_test.html#cpp_structured_bindings "cpp/feature test") | [`201606L`](../compiler_support/17.html#cpp_structured_bindings_201606L "cpp/compiler support/17") | (C++17) | Structured bindings   
[`202403L`](../compiler_support/26.html#cpp_structured_bindings_202403L "cpp/compiler support/26") | (C++26) | Structured bindings with attributes   
[`202406L`](../compiler_support/26.html#cpp_structured_bindings_202406L "cpp/compiler support/26") | (C++26) | Structured binding declaration as a condition   
[`202411L`](../compiler_support/26.html#cpp_structured_bindings_202411L "cpp/compiler support/26") | (C++26) | Structured bindings can introduce a pack   
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/structured_binding&action=edit&section=7 "Edit section: Keywords")] Keywords

[`auto`](../keyword/auto.html "cpp/keyword/auto")

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/structured_binding&action=edit&section=8 "Edit section: Example")] Example

Run this code
    
    
    #include <iomanip>
    #include <iostream>
    #include <set>
    #include <string>
     
    int main()
    {
        [std::set](../container/set.html)<[std::string](../string/basic_string.html)> myset{"hello"};
     
        for (int i{2}; i; --i)
        {
            if (auto [iter, success] = myset.insert("Hello"); success) 
                [std::cout](../io/cout.html) << "Insert is successful. The value is "
                          << [std::quoted](../io/manip/quoted.html)(*iter) << ".\n";
            else
                [std::cout](../io/cout.html) << "The value " << [std::quoted](../io/manip/quoted.html)(*iter)
                          << " already exists in the set.\n";
        }
     
        struct BitFields
        {
            // C++20: default member initializer for bit-fields
            int b : 4 {1}, d : 4 {2}, p : 4 {3}, q : 4 {4};
        };
     
        {
            const auto [b, d, p, q] = BitFields{};
            [std::cout](../io/cout.html) << b << ' ' << d << ' ' << p << ' ' << q << '\n';
        }
     
        {
            const auto [b, d, p, q] = []{ return BitFields{4, 3, 2, 1}; }();
            [std::cout](../io/cout.html) << b << ' ' << d << ' ' << p << ' ' << q << '\n';
        }
     
        {
            BitFields s;
     
            auto& [b, d, p, q] = s;
            [std::cout](../io/cout.html) << b << ' ' << d << ' ' << p << ' ' << q << '\n';
     
            b = 4, d = 3, p = 2, q = 1;
            [std::cout](../io/cout.html) << s.b << ' ' << s.d << ' ' << s.p << ' ' << s.q << '\n';
        }
    }

Output: 
    
    
    Insert is successful. The value is "Hello".
    The value "Hello" already exists in the set.
    1 2 3 4
    4 3 2 1
    1 2 3 4
    4 3 2 1

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/structured_binding&action=edit&section=9 "Edit section: Defect reports")] Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[CWG 2285](https://cplusplus.github.io/CWG/issues/2285.html) | C++17  | expression could refer to the names from identifier-list | the declaration is  
ill-formed in this case   
[CWG 2312](https://cplusplus.github.io/CWG/issues/2312.html) | C++17  | the meaning of mutable was lost in case 3  | its meaning is still kept   
[CWG 2313](https://cplusplus.github.io/CWG/issues/2313.html) | C++17  | in case 2, the structure binding variables could be redeclared  | cannot be redeclared   
[CWG 2339](https://cplusplus.github.io/CWG/issues/2339.html) | C++17  | in case 2, the definition of I was missing  | added the definition   
[CWG 2341](https://cplusplus.github.io/CWG/issues/2341.html)  
([P1091R3](https://wg21.link/P1091R3))  | C++17  | structured bindings could not be  
declared with static storage duration  | allowed   
[CWG 2386](https://cplusplus.github.io/CWG/issues/2386.html) | C++17  | the “tuple-like” binding protocol was used  
whenever [std::tuple_size](../utility/tuple_size.html)<E> is a complete type  | used only when [std::tuple_size](../utility/tuple_size.html)<E>  
has a member `value`  
[CWG 2506](https://cplusplus.github.io/CWG/issues/2506.html) | C++17  | if expression is of a cv-qualified array type,  
the cv-qualification was carried over to `E` | discards that cv-qualification   
[CWG 2635](https://cplusplus.github.io/CWG/issues/2635.html) | C++20  | structured bindings could be constrained  | prohibited   
[CWG 2867](https://cplusplus.github.io/CWG/issues/2867.html) | C++17  | the initialization order was unclear  | made clear   
[P0961R1](https://wg21.link/P0961R1) | C++17  | in case 2, member `get` was used  
if lookup finds a `get` of any kind  | only if lookup finds a function  
template with a constant parameter   
[P0969R0](https://wg21.link/P0969R0) | C++17  | in case 3, the members were required to be public  | only required to be accessible  
in the context of the declaration   
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/structured_binding&action=edit&section=10 "Edit section: References")] References

  * C++23 standard (ISO/IEC 14882:2024): 



    

  * 9.6 Structured binding declarations [dcl.struct.bind] (p: 228-229) 



  * C++20 standard (ISO/IEC 14882:2020): 



    

  * 9.6 Structured binding declarations [dcl.struct.bind] (p: 219-220) 



  * C++17 standard (ISO/IEC 14882:2017): 



    

  * 11.5 Structured binding declarations [dcl.struct.bind] (p: 219-220) 



### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/structured_binding&action=edit&section=11 "Edit section: See also")] See also

[ tie](../utility/tuple/tie.html "cpp/utility/tuple/tie")(C++11) |  creates a [tuple](../utility/tuple.html "cpp/utility/tuple") of lvalue references or unpacks a tuple into individual objects   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/tuple/dsc_tie&action=edit)  
---|---
  *[Value]: The year/month in which the feature was adopted. The hyperlink under each value opens a compiler support page with entry for given feature.
  *[Std]: Standard in which the feature is introduced; DR means defect report against that revision
