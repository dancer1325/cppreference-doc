[C++](../../cpp.html "cpp")

[Compiler support](../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../freestanding.html "cpp/freestanding")  
[Language](../language.html "cpp/language")  
[Standard library](../standard_library.html "cpp/standard library")  
[Standard library headers](../headers.html "cpp/header")  
[Named requirements](../iterator/concepts.html "cpp/named req")  
[Feature test macros](../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../utility.html#Language_support "cpp/utility")  
[Concepts library](../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../error.html "cpp/error")  
[Memory management library](../memory.html "cpp/memory")  
[Metaprogramming library](../meta.html "cpp/meta") (C++11)  
[General utilities library](../utility.html "cpp/utility")  
[Containers library](../container.html "cpp/container")  
[Iterators library](../iterator.html "cpp/iterator")  
[Ranges library](../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../algorithm.html "cpp/algorithm")  
[Strings library](../string.html "cpp/string")  
[Text processing library](../text.html "cpp/text")  
[Numerics library](../numeric.html "cpp/numeric")  
[Date and time library](../chrono.html "cpp/chrono")  
[Input/output library](../io.html "cpp/io")  
[Filesystem library](../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../atomic.html "cpp/thread") (C++11)  
[Execution control library](../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../experimental.html "cpp/experimental")  
[Symbols index](../symbol_index.html "cpp/symbol index")  
[External libraries](../links/libs.html "cpp/links/libs")  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/navbar_content&action=edit)

[C++ language](../language.html "cpp/language")

General topics  
---  
| [Preprocessor](../preprocessor.html "cpp/preprocessor")  
---  
[Comments](../comments.html "cpp/comment")  
  
| [Keywords](../keywords.html "cpp/keyword")  
---  
[Escape sequences](escape.html "cpp/language/escape")  
  
[Flow control](statements.html "cpp/language/statements")  
Conditional execution statements  
| [`if`](if.html "cpp/language/if")  
---  
  
| [`switch`](switch.html "cpp/language/switch")  
---  
  
Iteration statements (loops)  
| [`for`](for.html "cpp/language/for")  
---  
[range-`for`](range-for.html "cpp/language/range-for") (C++11)  
  
| [`while`](while.html "cpp/language/while")  
---  
[`do-while`](do.html "cpp/language/do")  
  
Jump statements  
| [`continue`](continue.html "cpp/language/continue") \- [`break`](break.html "cpp/language/break")  
---  
  
| [`goto`](goto.html "cpp/language/goto") \- [`return`](return.html "cpp/language/return")  
---  
  
[Functions](functions.html "cpp/language/functions")  
[Function declaration](function.html "cpp/language/function")  
[Lambda function expression](lambda.html "cpp/language/lambda")  
[`inline` specifier](inline.html "cpp/language/inline")  
[Dynamic exception specifications](except_spec.html "cpp/language/except spec") (until C++17*)  
[`noexcept` specifier](noexcept_spec.html "cpp/language/noexcept spec") (C++11)  
Exceptions  
| [`throw`-expression](throw.html "cpp/language/throw")  
---  
[`try` block](try.html "cpp/language/try")  
  
|   
  
---  
[`catch` handler](catch.html "cpp/language/catch")  
  
Namespaces  
| [Namespace declaration](namespace.html "cpp/language/namespace")` `  
---  
  
| [Namespace aliases](namespace_alias.html "cpp/language/namespace alias")  
---  
  
Types  
| [Fundamental types](types.html "cpp/language/types")  
---  
[Enumeration types](enum.html "cpp/language/enum")  
[Function types](function.html "cpp/language/function")  
  
| [Class/struct types](class.html "cpp/language/class")  
---  
[Union types](union.html "cpp/language/union")  
  
  
  
Specifiers  
| [`const`/`volatile`](cv.html "cpp/language/cv")  
---  
[`decltype`](decltype.html "cpp/language/decltype") (C++11)  
[`auto`](auto.html "cpp/language/auto") (C++11)  
  
| [`constexpr`](constexpr.html "cpp/language/constexpr") (C++11)  
---  
[`consteval`](consteval.html "cpp/language/consteval") (C++20)  
[`constinit`](constinit.html "cpp/language/constinit") (C++20)  
  
[Storage duration specifiers](storage_duration.html "cpp/language/storage duration")  
[Initialization](initialization.html "cpp/language/initialization")  
| [Default-initialization](default_initialization.html "cpp/language/default initialization")  
---  
[Value-initialization](value_initialization.html "cpp/language/value initialization")  
[Zero-initialization](zero_initialization.html "cpp/language/zero initialization")  
[Copy-initialization](copy_initialization.html "cpp/language/copy initialization")  
[Direct-initialization](direct_initialization.html "cpp/language/direct initialization")  
  
| [Aggregate initialization](aggregate_initialization.html "cpp/language/aggregate initialization")  
---  
[List-initialization](list_initialization.html "cpp/language/list initialization") (C++11)` `  
[Constant initialization](constant_initialization.html "cpp/language/constant initialization")  
[Reference initialization](reference_initialization.html "cpp/language/reference initialization")  
  
  
  
[Expressions](expressions.html "cpp/language/expressions")  
---  
| [Value categories](value_category.html "cpp/language/value category")  
---  
[Order of evaluation](eval_order.html "cpp/language/eval order")  
  
| [Operators](operators.html "cpp/language/operators")  
---  
[Operator precedence](operator_precedence.html "cpp/language/operator precedence")  
  
[Alternative representations](operator_alternative.html "cpp/language/operator alternative")  
[Literals](expressions.html#Literals "cpp/language/expressions")  
[Boolean](bool_literal.html "cpp/language/bool literal") \- [Integer](integer_literal.html "cpp/language/integer literal") \- [Floating-point](floating_literal.html "cpp/language/floating literal")  
[Character](character_literal.html "cpp/language/character literal") \- [String](string_literal.html "cpp/language/string literal") \- [`nullptr`](nullptr.html "cpp/language/nullptr") (C++11)  
[User-defined](user_literal.html "cpp/language/user literal") (C++11)  
Utilities  
[Attributes](attributes.html "cpp/language/attributes") (C++11)  
Types  
[`typedef` declaration](typedef.html "cpp/language/typedef")  
[Type alias declaration](type_alias.html "cpp/language/type alias") (C++11)  
Casts  
| [Implicit conversions](implicit_cast.html "cpp/language/implicit conversion")  
---  
[`static_cast`](static_cast.html "cpp/language/static cast")  
[`const_cast`](const_cast.html "cpp/language/const cast")  
  
| [Explicit conversions](explicit_cast.html "cpp/language/explicit cast")  
---  
[`dynamic_cast`](dynamic_cast.html "cpp/language/dynamic cast")  
[`reinterpret_cast`](reinterpret_cast.html "cpp/language/reinterpret cast")  
  
Memory allocation  
| [`new` expression](new.html "cpp/language/new")  
---  
  
| [`delete` expression](delete.html "cpp/language/delete")  
---  
  
[Classes](classes.html "cpp/language/classes")  
| [Class declaration](class.html "cpp/language/class")  
---  
[Constructors](initializer_list.html "cpp/language/constructor")  
[`this` pointer](this.html "cpp/language/this")  
  
| [Access specifiers](access.html "cpp/language/access")  
---  
[`friend` specifier](friend.html "cpp/language/friend")  
  
  
  
Class-specific function properties  
| [Virtual function](virtual.html "cpp/language/virtual")  
---  
[`override` specifier](override.html "cpp/language/override") (C++11)` `  
[`final` specifier](final.html "cpp/language/final") (C++11)  
  
| [`explicit`](explicit.html "cpp/language/explicit") (C++11)  
---  
[`static`](static.html "cpp/language/static")  
  
  
  
Special member functions  
| [Default constructor](default_constructor.html "cpp/language/default constructor")  
---  
[Copy constructor](copy_constructor.html "cpp/language/copy constructor")  
[Move constructor](move_constructor.html "cpp/language/move constructor") (C++11)  
  
| [Copy assignment](as_operator.html "cpp/language/as operator")  
---  
[Move assignment](move_operator.html "cpp/language/move operator") (C++11)  
[Destructor](destructor.html "cpp/language/destructor")  
  
[Templates](templates.html "cpp/language/templates")  
| [Class template](class_template.html "cpp/language/class template")  
---  
[Function template](function_template.html "cpp/language/function template")  
  
| [Template specialization](template_specialization.html "cpp/language/template specialization")  
---  
[Parameter packs](parameter_pack.html "cpp/language/pack") (C++11)  
  
Miscellaneous  
| [Inline assembly](asm.html "cpp/language/asm")  
---  
  
| [History of C++](history.html "cpp/language/history")  
---  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/navbar_content&action=edit)

[ Templates](templates.html "cpp/language/templates")

**Template parameters**  
---  
[Template arguments](template_arguments.html "cpp/language/template arguments")  
[Class templates](class_template.html "cpp/language/class template")  
[Function templates](function_template.html "cpp/language/function template")  
[Class member templates](member_template.html "cpp/language/member template")  
[Variable templates](variable_template.html "cpp/language/variable template") (C++14)  
[Template argument deduction](template_argument_deduction.html "cpp/language/template argument deduction")  
[Class template argument deduction](ctad.html "cpp/language/class template argument deduction") (C++17)  
[Explicit (full) specialization](template_specialization.html "cpp/language/template specialization")  
[Partial specialization](partial_specialization.html "cpp/language/partial specialization")  
[Dependent names](dependent_name.html "cpp/language/dependent name")  
[Packs](parameter_pack.html "cpp/language/pack") (C++11)  
[sizeof...](sizeof....html "cpp/language/sizeof...") (C++11)  
[Fold expressions](fold.html "cpp/language/fold") (C++17)  
[Pack indexing](pack_indexing.html "cpp/language/pack indexing") (C++26)  
[SFINAE](sfinae.html "cpp/language/sfinae")  
[Constraints and concepts](constraints.html "cpp/language/constraints") (C++20)  
[requires expression](requires.html "cpp/language/requires") (C++20)  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/templates/navbar_content&action=edit)

Every [template](templates.html "cpp/language/templates") is parameterized by one or more template parameters. 

Each parameter in template-parameter-list (see [template declaration syntax](templates.html#Syntax "cpp/language/templates")) belongs to one of the following categories: 

  * constant template parameter 
  * type template parameter 
  * template template parameter 



## Contents

  * [1 Constant template parameter](template_parameters.html#Constant_template_parameter)
  * [2 Type template parameter](template_parameters.html#Type_template_parameter)
  * [3 Template template parameter](template_parameters.html#Template_template_parameter)
  * [4 Name resolution for template parameters](template_parameters.html#Name_resolution_for_template_parameters)
  * [5 Default template arguments](template_parameters.html#Default_template_arguments)
  * [6 Notes](template_parameters.html#Notes)
  * [7 Examples](template_parameters.html#Examples)
  * [8 Defect reports](template_parameters.html#Defect_reports)

  
---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/template_parameters&action=edit&section=1 "Edit section: Constant template parameter")] Constant template parameter

Also known as _non-type template parameter_ (see [below](template_parameters.html#Notes)).   
  
---  
type name ﻿(optional) |  (1)  |   
type name ﻿(optional) `**=**` default |  (2)  |   
type `**...**` name ﻿(optional) |  (3)  |  (since C++11)  
type |  \-  |  one of the following types: 

  * a structural type (see below) 

| 

  * a type that contains a [placeholder type](auto.html "cpp/language/auto")

| (since C++17)  
---|---  
  
  * a [placeholder for a deduced class type](ctad.html "cpp/language/class template argument deduction")

| (since C++20)  
name |  \-  |  the name of the constant template parameter   
default |  \-  |  the [default template argument](template_parameters.html#Default_template_arguments)  
  
1) A constant template parameter.

2) A constant template parameter with a default template argument.

3) A constant template [parameter pack](parameter_pack.html "cpp/language/parameter pack").

  
A _structural type_ is one of the following types (optionally cv-qualified, the qualifiers are ignored): 

  * [lvalue reference type](reference.html#lvalue_references "cpp/language/reference") (to object or to function); 
  * an [integral type](type-id.html "cpp/language/type"); 
  * a [pointer type](pointer.html "cpp/language/pointer") (to object or to function); 
  * a [pointer to member type](pointer.html#Pointers_to_members "cpp/language/pointer") (to member object or to member function); 
  * an [enumeration type](enum.html "cpp/language/enum"); 



  * [std::nullptr_t](../types/nullptr_t.html "cpp/types/nullptr t"); 

| (since C++11)  
---|---  
  
  * a [floating-point type](type-id.html "cpp/language/type"); 
  * a [lambda closure type](lambda.html#Closure_type "cpp/language/lambda") whose lambda expression has no capture; 
  * a non-closure [literal class type](../named_req/LiteralType.html "cpp/named req/LiteralType") with the following properties: 



    

  * all base classes and non-static data members are public and non-mutable and 
  * the types of all base classes and non-static data members are structural types or (possibly multi-dimensional) array thereof. 


| (since C++20)  
---|---  
  
Array and function types may be written in a template declaration, but they are automatically replaced by pointer to object and pointer to function as appropriate. 

When the name of a constant template parameter is used in an expression within the body of the class template, it is an unmodifiable [prvalue](value_category.html "cpp/language/value category") unless its type was an lvalue reference type, or unless its type is a class type(since C++20). 

A template parameter of the form class Foo is not an unnamed constant template parameter of type `Foo`, even if otherwise class Foo is an [elaborated type specifier](elaborated_type_specifier.html "cpp/language/elaborated type specifier") and class Foo x; declares x to be of type `Foo`. 

An [identifier](name.html "cpp/language/identifiers") that names a constant template parameter of class type `T` denotes a static storage duration object of type const T, called a _template parameter object_ , which is [Template argument equivalence](template_arguments.html#Template_argument_equivalence "cpp/language/template arguments") to the corresponding template argument after it has been converted to the type of the template parameter. No two template parameter objects are template-argument-equivalent. 
    
    
    struct A
    {
        friend bool operator==(const A&, const A&) = default;
    };
     
    template<A a>
    void f()
    {
        &a;                       // OK
        const A& ra = a, &rb = a; // Both bound to the same template parameter object
        [assert](../error/assert.html)(&ra == &rb);       // passes
    }

| (since C++20)  
---|---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/template_parameters&action=edit&section=2 "Edit section: Type template parameter")] Type template parameter  
  
---  
type-parameter-key name ﻿(optional) |  (1)  |   
type-parameter-key name ﻿(optional) `**=**` default |  (2)  |   
type-parameter-key `**...**` name ﻿(optional) |  (3)  |  (since C++11)  
type-constraint name ﻿(optional) |  (4)  |  (since C++20)  
type-constraint name ﻿(optional) `**=**` default |  (5)  |  (since C++20)  
type-constraint `**...**` name ﻿(optional) |  (6)  |  (since C++20)  
type-parameter-key |  \-  |  either `**typename**` or `**class**`. There is no difference between these keywords in a type template parameter declaration   
---|---|---  
type-constraint |  \-  |  either the name of a [concept](constraints.html "cpp/language/constraints") or the name of a concept followed by a list of template arguments (in angle brackets). Either way, the concept name may be optionally qualified   
name |  \-  |  the name of the type template parameter   
default |  \-  |  the [default template argument](template_parameters.html#Default_template_arguments)  
  
1) A type template parameter without a default. 
    
    
    template<class T>
    class My_vector { /* ... */ };

2) A type template parameter with a default. 
    
    
    template<class T = void>
    struct My_op_functor { /* ... */ };

3) A type template [parameter pack](parameter_pack.html "cpp/language/parameter pack"). 
    
    
    template<typename... Ts>
    class My_tuple { /* ... */ };

4) A constrained type template parameter without a default. 
    
    
    template<My_concept T>
    class My_constrained_vector { /* ... */ };

5) A constrained type template parameter with a default. 
    
    
    template<My_concept T = void>
    class My_constrained_op_functor { /* ... */ };

6) A constrained type template [parameter pack](parameter_pack.html "cpp/language/parameter pack"). 
    
    
    template<My_concept... Ts>
    class My_constrained_tuple { /* ... */ };

  
The name of the parameter is optional: 
    
    
    // Declarations of the templates shown above:
    template<class>
    class My_vector;
    template<class = void>
    struct My_op_functor;
    template<typename...>
    class My_tuple;

In the body of the template declaration, the name of a type parameter is a typedef-name which aliases the type supplied when the template is instantiated. 

Each constrained parameter `P` whose type-constraint is Q designating the concept `C` introduces a [constraint-expression](constraints.html "cpp/language/constraints") `E` according to the following rules: 

  * if `Q` is `C` (without an argument list), 



    

  * if `P` is not a parameter pack, `E` is simply `C<P>`
  * otherwise, `P` is a parameter pack, `E` is a fold-expression `(C<P> && ...)`



  * if `Q` is `C<A1,A2...,AN>`, then `E` is `C<P,A1,A2,...AN>` or `(C<P,A1,A2,...AN> && ...)`, respectively. 


    
    
    template<typename T>
    concept C1 = true;
    template<typename... Ts> // variadic concept
    concept C2 = true;
    template<typename T, typename U>
    concept C3 = true;
     
    template<C1 T>         struct s1; // constraint-expression is C1<T>
    template<C1... T>      struct s2; // constraint-expression is (C1<T> && ...)
    template<C2... T>      struct s3; // constraint-expression is (C2<T> && ...)
    template<C3<int> T>    struct s4; // constraint-expression is C3<T, int>
    template<C3<int>... T> struct s5; // constraint-expression is (C3<T, int> && ...)

| (since C++20)  
---|---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/template_parameters&action=edit&section=3 "Edit section: Template template parameter")] Template template parameter  
  
---  
`**template**` `**<**` parameter-list `**>**` type-parameter-key name ﻿(optional) |  (1)  |   
`**template**` `**<**` parameter-list `**>**` type-parameter-key name ﻿(optional) `**=**` default |  (2)  |   
`**template**` `**<**` parameter-list `**>**` type-parameter-key `**...**` name ﻿(optional) |  (3)  |  (since C++11)  
type-parameter-key |  \-  |  `**class**` or `**typename**`(since C++17)  
---|---|---  
  
1) A template template parameter with an optional name.

2) A template template parameter with an optional name and a default.

3) A template template [parameter pack](parameter_pack.html "cpp/language/parameter pack") with an optional name.

  
In the body of the template declaration, the name of this parameter is a template-name (and needs arguments to be instantiated). 
    
    
    template<typename T>
    class my_array {};
     
    // two type template parameters and one template template parameter:
    template<typename K, typename V, template<typename> typename C = my_array>
    class Map
    {
        C<K> key;
        C<V> value;
    };

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/template_parameters&action=edit&section=4 "Edit section: Name resolution for template parameters")] Name resolution for template parameters

The name of a template parameter is not allowed to be redeclared within its scope (including nested scopes). A template parameter is not allowed to have the same name as the template name. 
    
    
    template<class T, int N>
    class Y
    {
        int T;      // error: template parameter redeclared
        void f()
        {
            char T; // error: template parameter redeclared
        }
    };
     
    template<class X>
    class X; // error: template parameter redeclared

In the definition of a member of a class template that appears outside of the class template definition, the name of a member of the class template hides the name of a template parameter of any enclosing class templates, but not a template parameter of the member if the member is a class or function template. 
    
    
    template<class T>
    struct A
    {
        struct B {};
        typedef void C;
        void f();
     
        template<class U>
        void g(U);
    };
     
    template<class B>
    void A<B>::f()
    {
        B b; // A's B, not the template parameter
    }
     
    template<class B>
    template<class C>
    void A<B>::g(C)
    {
        B b; // A's B, not the template parameter
        C c; // the template parameter C, not A's C
    }

In the definition of a member of a class template that appears outside of the namespace containing the class template definition, the name of a template parameter hides the name of a member of this namespace. 
    
    
    namespace N
    {
        class C {};
     
        template<class T>
        class B
        {
            void f(T);
        };
    }
     
    template<class C>
    void N::B<C>::f(C)
    {
        C b; // C is the template parameter, not N::C
    }

In the definition of a class template or in the definition of a member of such a template that appears outside of the template definition, for each non-[dependent](dependent_name.html#Dependent_types "cpp/language/dependent name") base class, if the name of the base class or the name of a member of the base class is the same as the name of a template parameter, the base class name or member name hides the template parameter name. 
    
    
    struct A
    {
        struct B {};
        int C;
        int Y;
    };
     
    template<class B, class C>
    struct X : A
    {
        B b; // A's B
        C b; // error: A's C isn't a type name
    };

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/template_parameters&action=edit&section=5 "Edit section: Default template arguments")] Default template arguments

Default template arguments are specified in the parameter lists after the = sign. Defaults can be specified for any kind of template parameter (type, constant, or template), but not to parameter packs(since C++11). 

If the default is specified for a template parameter of a primary class template, primary variable template,(since C++14) or alias template, each subsequent template parameter must have a default argument, except the very last one may be a template parameter pack(since C++11). In a function template, there are no restrictions on the parameters that follow a default, and a parameter pack may be followed by more type parameters only if they have defaults or can be deduced from the function arguments(since C++11). 

Default parameters are not allowed 

  * in the out-of-class definition of a member of a [class template](class_template.html "cpp/language/class template") (they have to be provided in the declaration inside the class body). Note that [member templates](member_template.html "cpp/language/member template") of non-template classes can use default parameters in their out-of-class definitions (see [GCC bug 53856](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=53856)) 
  * in [friend class template](friend.html#Template_friends "cpp/language/friend") declarations 



  * in any [function template](function_template.html "cpp/language/function template") declaration or definition 

| (until C++11)  
---|---  
On a friend function template declaration, default template arguments are allowed only if the declaration is a definition, and no other declarations of this function appear in this translation unit.  | (since C++11)  
---|---  
  
Default template arguments that appear in the declarations are merged similarly to default function arguments: 
    
    
    template<typename T1, typename T2 = int> class A;
    template<typename T1 = int, typename T2> class A;
     
    // the above is the same as the following:
    template<typename T1 = int, typename T2 = int> class A;

But the same parameter cannot be given default arguments twice in the same scope: 
    
    
    template<typename T = int> class X;
    template<typename T = int> class X {}; // error

When parsing a default template argument for a constant template parameter, the first non-nested > is taken as the end of the template parameter list rather than a greater-than operator: 
    
    
    template<int i = 3 > 4>   // syntax error
    class X { /* ... */ };
     
    template<int i = (3 > 4)> // OK
    class Y { /* ... */ };

The template parameter lists of template template parameters can have their own default arguments, which are only in effect where the template template parameter itself is in scope: 
    
    
    // class template, with a type template parameter with a default
    template<typename T = float>
    struct B {};
     
    // template template parameter T has a parameter list, which
    // consists of one type template parameter with a default
    template<template<typename = float> typename T>
    struct A
    {
        void f();
        void g();
    };
     
    // out-of-body member function template definitions
     
    template<template<typename TT> class T>
    void A<T>::f()
    {
        T<> t; // error: TT has no default in scope
    }
     
    template<template<typename TT = char> class T>
    void A<T>::g()
    {
        T<> t; // OK: t is T<char>
    }

[Member access](access.html "cpp/language/access") for the names used in a default template parameter is checked at the declaration, not at the point of use: 
    
    
    class B {};
     
    template<typename T>
    class C
    {
    protected:
        typedef T TT;
    };
     
    template<typename U, typename V = typename U::TT>
    class D: public U {};
     
    D<C<B>>* d; // error: C::TT is protected

The default template argument is implicitly instantiated when the value of that default argument is needed, except if the template is used to name a function: 
    
    
    template<typename T, typename U = int>
    struct S {};
     
    S<bool>* p; // The default argument for U is instantiated at this point
                // the type of p is S<bool, int>*

| (since C++14)  
---|---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/template_parameters&action=edit&section=6 "Edit section: Notes")] Notes

Before C++26, constant template parameter were called non-type template parameter in the standard wording. The terminology was changed by [P2841R6](https://wg21.link/P2841R6) / [PR#7587](https://wg21.link/EDIT7587). 

In template parameters, type constraints could be used for both type and constant parameters, depending on whether auto is present. 
    
    
    template<typename>
    concept C = true;
     
    template<C,     // type parameter 
             C auto // constant parameter
            >
    struct S{};
     
    S<int, 0> s;

  
| (since C++20)  
---|---  
Feature-test macro  | Value | Std | Feature   
---|---|---|---  
[`__cpp_nontype_template_parameter_auto`](../experimental/feature_test.html#cpp_nontype_template_parameter_auto "cpp/feature test") | [`201606L`](../compiler_support/17.html#cpp_nontype_template_parameter_auto_201606L "cpp/compiler support/17") | (C++17) | Declaring [constant template parameters](template_parameters.html#Constant_template_parameter) with auto  
[`__cpp_nontype_template_args`](../experimental/feature_test.html#cpp_nontype_template_args "cpp/feature test") | [`201411L`](../compiler_support/17.html#cpp_nontype_template_args_201411L "cpp/compiler support/17") | (C++17) | Allow constant evaluation for all [constant template arguments](template_arguments.html#Constant_template_arguments "cpp/language/template arguments")  
[`201911L`](../compiler_support/20.html#cpp_nontype_template_args_201911L "cpp/compiler support/20") | (C++20) | Class types and floating-point types in [constant template parameters](template_parameters.html#Constant_template_parameter)  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/template_parameters&action=edit&section=7 "Edit section: Examples")] Examples

Run this code
    
    
    #include <array>
    #include <iostream>
    #include <numeric>
     
    // simple constant template parameter
    template<int N>
    struct S { int a[N]; };
     
    template<const char*>
    struct S2 {};
     
    // complicated constant example
    template
    <
        char c,             // integral type
        int (&ra)[5],       // lvalue reference to object (of array type)
        int (*pf)(int),     // pointer to function
        int (S<10>::*a)[10] // pointer to member object (of type int[10])
    >
    struct Complicated
    {
        // calls the function selected at compile time
        // and stores the result in the array selected at compile time
        void foo(char base)
        {
            ra[4] = pf(c - base);
        }
    };
     
    //  S2<"fail"> s2;        // error: string literal cannot be used
        char okay[] = "okay"; // static object with linkage
    //  S2<&okay[0]> s3;      // error: array element has no linkage
        S2<okay> s4;          // works
     
    int a[5];
    int f(int n) { return n; }
     
    // C++20: NTTP can be a literal class type
    template<[std::array](../container/array.html) arr>
    constexpr
    auto sum() { return [std::accumulate](../algorithm/accumulate.html)(arr.cbegin(), arr.cend(), 0); }
     
    // C++20: class template arguments are deduced at the call site
    static_assert(sum<[std::array](../container/array.html)<double, 8>{3, 1, 4, 1, 5, 9, 2, 6}>() == 31.0);
    // C++20: NTTP argument deduction and CTAD
    static_assert(sum<[std::array](../container/array.html){2, 7, 1, 8, 2, 8}>() == 28);
     
    int main()
    {
        S<10> s; // s.a is an array of 10 int
        s.a[9] = 4;
     
        Complicated<'2', a, f, &S<10>::a> c;
        c.foo('0');
     
        [std::cout](../io/cout.html) << s.a[9] << a[4] << '\n';
    }

Output: 
    
    
    42

| This section is incomplete  
Reason: more examples   
---|---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/template_parameters&action=edit&section=8 "Edit section: Defect reports")] Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[CWG 184](https://cplusplus.github.io/CWG/issues/184.html) | C++98  | whether the template parameters of template template  
parameters are allowed to have default arguments is unspecified  | specification added   
[CWG 1922](https://cplusplus.github.io/CWG/issues/1922.html) | C++98  | it was unclear whether a class template whose name is an  
injected-class-name can use the default arguments in prior declarations  | allowed   
[CWG 2032](https://cplusplus.github.io/CWG/issues/2032.html) | C++14  | for variable templates, there was no restriction on the template  
parameters after a template parameter with a default argument  | apply the same restriction  
as on class templates  
and alias templates   
[CWG 2542](https://cplusplus.github.io/CWG/issues/2542.html) | C++20  | it was unclear whether the closure type is structural  | it is not structural   
[CWG 2845](https://cplusplus.github.io/CWG/issues/2845.html) | C++20  | the closure type was not structural  | it is structural  
if capture-less 
  *[Value]: The year/month in which the feature was adopted. The hyperlink under each value opens a compiler support page with entry for given feature.
  *[Std]: Standard in which the feature is introduced; DR means defect report against that revision
