[C++](../../cpp.html "cpp")

[Compiler support](../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../freestanding.html "cpp/freestanding")  
[Language](../language.html "cpp/language")  
[Standard library](../standard_library.html "cpp/standard library")  
[Standard library headers](../headers.html "cpp/header")  
[Named requirements](../iterator/concepts.html "cpp/named req")  
[Feature test macros](../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../utility.html#Language_support "cpp/utility")  
[Concepts library](../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../error.html "cpp/error")  
[Memory management library](../memory.html "cpp/memory")  
[Metaprogramming library](../meta.html "cpp/meta") (C++11)  
[General utilities library](../utility.html "cpp/utility")  
[Containers library](../container.html "cpp/container")  
[Iterators library](../iterator.html "cpp/iterator")  
[Ranges library](../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../algorithm.html "cpp/algorithm")  
[Strings library](../string.html "cpp/string")  
[Text processing library](../text.html "cpp/text")  
[Numerics library](../numeric.html "cpp/numeric")  
[Date and time library](../chrono.html "cpp/chrono")  
[Input/output library](../io.html "cpp/io")  
[Filesystem library](../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../atomic.html "cpp/thread") (C++11)  
[Execution control library](../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../experimental.html "cpp/experimental")  
[Symbols index](../symbol_index.html "cpp/symbol index")  
[External libraries](../links/libs.html "cpp/links/libs")  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/navbar_content&action=edit)

[C++ language](../language.html "cpp/language")

General topics  
---  
| [Preprocessor](../preprocessor.html "cpp/preprocessor")  
---  
[Comments](../comments.html "cpp/comment")  
  
| [Keywords](../keywords.html "cpp/keyword")  
---  
[Escape sequences](escape.html "cpp/language/escape")  
  
[Flow control](statements.html "cpp/language/statements")  
Conditional execution statements  
| [`if`](if.html "cpp/language/if")  
---  
  
| [`switch`](switch.html "cpp/language/switch")  
---  
  
Iteration statements (loops)  
| [`for`](for.html "cpp/language/for")  
---  
[range-`for`](range-for.html "cpp/language/range-for") (C++11)  
  
| [`while`](while.html "cpp/language/while")  
---  
[`do-while`](do.html "cpp/language/do")  
  
Jump statements  
| [`continue`](continue.html "cpp/language/continue") \- [`break`](break.html "cpp/language/break")  
---  
  
| [`goto`](goto.html "cpp/language/goto") \- [`return`](return.html "cpp/language/return")  
---  
  
[Functions](functions.html "cpp/language/functions")  
[Function declaration](function.html "cpp/language/function")  
[Lambda function expression](lambda.html "cpp/language/lambda")  
[`inline` specifier](inline.html "cpp/language/inline")  
[Dynamic exception specifications](except_spec.html "cpp/language/except spec") (until C++17*)  
[`noexcept` specifier](noexcept_spec.html "cpp/language/noexcept spec") (C++11)  
Exceptions  
| [`throw`-expression](throw.html "cpp/language/throw")  
---  
[`try` block](try.html "cpp/language/try")  
  
|   
  
---  
**`catch` handler**  
  
Namespaces  
| [Namespace declaration](namespace.html "cpp/language/namespace")` `  
---  
  
| [Namespace aliases](namespace_alias.html "cpp/language/namespace alias")  
---  
  
Types  
| [Fundamental types](types.html "cpp/language/types")  
---  
[Enumeration types](enum.html "cpp/language/enum")  
[Function types](function.html "cpp/language/function")  
  
| [Class/struct types](class.html "cpp/language/class")  
---  
[Union types](union.html "cpp/language/union")  
  
  
  
Specifiers  
| [`const`/`volatile`](cv.html "cpp/language/cv")  
---  
[`decltype`](decltype.html "cpp/language/decltype") (C++11)  
[`auto`](auto.html "cpp/language/auto") (C++11)  
  
| [`constexpr`](constexpr.html "cpp/language/constexpr") (C++11)  
---  
[`consteval`](consteval.html "cpp/language/consteval") (C++20)  
[`constinit`](constinit.html "cpp/language/constinit") (C++20)  
  
[Storage duration specifiers](storage_duration.html "cpp/language/storage duration")  
[Initialization](initialization.html "cpp/language/initialization")  
| [Default-initialization](default_initialization.html "cpp/language/default initialization")  
---  
[Value-initialization](value_initialization.html "cpp/language/value initialization")  
[Zero-initialization](zero_initialization.html "cpp/language/zero initialization")  
[Copy-initialization](copy_initialization.html "cpp/language/copy initialization")  
[Direct-initialization](direct_initialization.html "cpp/language/direct initialization")  
  
| [Aggregate initialization](aggregate_initialization.html "cpp/language/aggregate initialization")  
---  
[List-initialization](list_initialization.html "cpp/language/list initialization") (C++11)` `  
[Constant initialization](constant_initialization.html "cpp/language/constant initialization")  
[Reference initialization](reference_initialization.html "cpp/language/reference initialization")  
  
  
  
[Expressions](expressions.html "cpp/language/expressions")  
---  
| [Value categories](value_category.html "cpp/language/value category")  
---  
[Order of evaluation](eval_order.html "cpp/language/eval order")  
  
| [Operators](operators.html "cpp/language/operators")  
---  
[Operator precedence](operator_precedence.html "cpp/language/operator precedence")  
  
[Alternative representations](operator_alternative.html "cpp/language/operator alternative")  
[Literals](expressions.html#Literals "cpp/language/expressions")  
[Boolean](bool_literal.html "cpp/language/bool literal") \- [Integer](integer_literal.html "cpp/language/integer literal") \- [Floating-point](floating_literal.html "cpp/language/floating literal")  
[Character](character_literal.html "cpp/language/character literal") \- [String](string_literal.html "cpp/language/string literal") \- [`nullptr`](nullptr.html "cpp/language/nullptr") (C++11)  
[User-defined](user_literal.html "cpp/language/user literal") (C++11)  
Utilities  
[Attributes](attributes.html "cpp/language/attributes") (C++11)  
Types  
[`typedef` declaration](typedef.html "cpp/language/typedef")  
[Type alias declaration](type_alias.html "cpp/language/type alias") (C++11)  
Casts  
| [Implicit conversions](implicit_cast.html "cpp/language/implicit conversion")  
---  
[`static_cast`](static_cast.html "cpp/language/static cast")  
[`const_cast`](const_cast.html "cpp/language/const cast")  
  
| [Explicit conversions](explicit_cast.html "cpp/language/explicit cast")  
---  
[`dynamic_cast`](dynamic_cast.html "cpp/language/dynamic cast")  
[`reinterpret_cast`](reinterpret_cast.html "cpp/language/reinterpret cast")  
  
Memory allocation  
| [`new` expression](new.html "cpp/language/new")  
---  
  
| [`delete` expression](delete.html "cpp/language/delete")  
---  
  
[Classes](classes.html "cpp/language/classes")  
| [Class declaration](class.html "cpp/language/class")  
---  
[Constructors](initializer_list.html "cpp/language/constructor")  
[`this` pointer](this.html "cpp/language/this")  
  
| [Access specifiers](access.html "cpp/language/access")  
---  
[`friend` specifier](friend.html "cpp/language/friend")  
  
  
  
Class-specific function properties  
| [Virtual function](virtual.html "cpp/language/virtual")  
---  
[`override` specifier](override.html "cpp/language/override") (C++11)` `  
[`final` specifier](final.html "cpp/language/final") (C++11)  
  
| [`explicit`](explicit.html "cpp/language/explicit") (C++11)  
---  
[`static`](static.html "cpp/language/static")  
  
  
  
Special member functions  
| [Default constructor](default_constructor.html "cpp/language/default constructor")  
---  
[Copy constructor](copy_constructor.html "cpp/language/copy constructor")  
[Move constructor](move_constructor.html "cpp/language/move constructor") (C++11)  
  
| [Copy assignment](as_operator.html "cpp/language/as operator")  
---  
[Move assignment](move_operator.html "cpp/language/move operator") (C++11)  
[Destructor](destructor.html "cpp/language/destructor")  
  
[Templates](templates.html "cpp/language/templates")  
| [Class template](class_template.html "cpp/language/class template")  
---  
[Function template](function_template.html "cpp/language/function template")  
  
| [Template specialization](template_specialization.html "cpp/language/template specialization")  
---  
[Parameter packs](parameter_pack.html "cpp/language/pack") (C++11)  
  
Miscellaneous  
| [Inline assembly](asm.html "cpp/language/asm")  
---  
  
| [History of C++](history.html "cpp/language/history")  
---  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/navbar_content&action=edit)

[ Expressions](expressions.html "cpp/language/expressions")

General  
---  
| [Value categories](value_category.html "cpp/language/value category")  
---  
[Order of evaluation](eval_order.html "cpp/language/eval order")  
[Constant expressions](constant_expression.html "cpp/language/constant expression")  
[Primary expressions](expressions.html#Primary_expressions "cpp/language/expressions")  
  
| [Lambda expressions](lambda.html "cpp/language/lambda") (C++11)  
---  
[Requires expressions](requires.html "cpp/language/requires") (C++20)  
[Pack indexing expression](pack_indexing.html#Pack_indexing_expression "cpp/language/pack indexing") (C++26)  
[Potentially-evaluated expressions](expressions.html#Potentially-evaluated_expressions "cpp/language/expressions")  
  
Literals  
| [Integer literals](integer_literal.html "cpp/language/integer literal")  
---  
[Floating-point literals](floating_literal.html "cpp/language/floating literal")  
[Boolean literals](bool_literal.html "cpp/language/bool literal")  
[Character literals](character_literal.html "cpp/language/character literal")  
  
| [Escape sequences](escape.html "cpp/language/escape")  
---  
[String literals](string_literal.html "cpp/language/string literal")  
[Null pointer literal](nullptr.html "cpp/language/nullptr") (C++11)  
[User-defined literal](user_literal.html "cpp/language/user literal") (C++11)  
  
Operators  
| [Assignment operators](operator_assignment.html "cpp/language/operator assignment")  
---  
[Increment and decrement](operator_incdec.html "cpp/language/operator incdec")  
[Arithmetic operators](operator_arithmetic.html "cpp/language/operator arithmetic")  
[Logical operators](operator_logical.html "cpp/language/operator logical")  
[Comparison operators](operator_comparison.html "cpp/language/operator comparison")  
[Member access operators](operator_member_access.html "cpp/language/operator member access")  
[Other operators](operator_other.html "cpp/language/operator other")  
[`new`-expression](new.html "cpp/language/new")  
[`delete`-expression](delete.html "cpp/language/delete")  
[`throw`-expression](throw.html "cpp/language/throw")  
  
| [`alignof`](alignof.html "cpp/language/alignof")  
---  
[`sizeof`](sizeof.html "cpp/language/sizeof")  
[`sizeof...`](sizeof....html "cpp/language/sizeof...") (C++11)  
[`typeid`](typeid.html "cpp/language/typeid")  
[`noexcept`](noexcept.html "cpp/language/noexcept") (C++11)  
[Fold expressions](fold.html "cpp/language/fold") (C++17)  
[Alternative representations of operators](operator_alternative.html "cpp/language/operator alternative")  
[Precedence and associativity](operator_precedence.html "cpp/language/operator precedence")  
[Operator overloading](operators.html "cpp/language/operators")  
[Default comparisons](default_comparisons.html "cpp/language/default comparisons") (C++20)  
  
Conversions  
| [Implicit conversions](implicit_cast.html "cpp/language/implicit conversion")  
---  
[Explicit conversions](explicit_cast.html "cpp/language/explicit cast")  
[Usual arithmetic conversions](usual_arithmetic_conversions.html "cpp/language/usual arithmetic conversions")  
[User-defined conversion](cast_operator.html "cpp/language/cast operator")  
  
| [`const_cast`](const_cast.html "cpp/language/const cast")  
---  
[`static_cast`](static_cast.html "cpp/language/static cast")  
[`dynamic_cast`](dynamic_cast.html "cpp/language/dynamic cast")  
[`reinterpret_cast`](reinterpret_cast.html "cpp/language/reinterpret cast")  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/expressions/navbar_content&action=edit)

[ Exceptions](exceptions.html "cpp/language/exceptions")

[try block](try.html "cpp/language/try")  
---  
[Throwing exceptions](throw.html "cpp/language/throw")  
**Handling exceptions**  
Exception specification  
[noexcept specification](noexcept_spec.html "cpp/language/noexcept spec") (C++11)  
[dynamic specification](except_spec.html "cpp/language/except spec") (until C++17*)  
[noexcept operator](noexcept.html "cpp/language/noexcept") (C++11)  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/exceptions/navbar_content&action=edit)

An [exception](exceptions.html "cpp/language/exceptions") can be handled by a handler. 

## Contents

  * [1 Handler](catch.html#Handler)
  * [2 Matching exceptions](catch.html#Matching_exceptions)
  * [3 Handling exceptions](catch.html#Handling_exceptions)
    * [3.1 Initializing the handler parameter](catch.html#Initializing_the_handler_parameter)
    * [3.2 Activating the handler](catch.html#Activating_the_handler)
  * [4 Control flow](catch.html#Control_flow)
  * [5 Notes](catch.html#Notes)
  * [6 Keywords](catch.html#Keywords)
  * [7 Example](catch.html#Example)
  * [8 Defect reports](catch.html#Defect_reports)
  * [9 References](catch.html#References)
  * [10 See also](catch.html#See_also)

  
---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/catch&action=edit&section=1 "Edit section: Handler")] Handler  
  
---  
`**catch**` `**(**` attr ﻿(optional) type-specifier-seq declarator `**)**` compound-statement |  (1)  |   
`**catch**` `**(**` attr ﻿(optional) type-specifier-seq abstract-declarator ﻿(optional) `**)**` compound-statement |  (2)  |   
`**catch**` `**(**` `**...**` `**)**` compound-statement |  (3)  |   
  
1) A handler with a named parameter.

2) A handler with an unnamed parameter.

3) A handler matching all kinds of exceptions.

attr |  \-  |  (since C++11) any number of [attributes](attributes.html "cpp/language/attributes"), applies to the parameter   
---|---|---  
type-specifier-seq |  \-  |  part of a formal parameter declaration, same as in a function [parameter list](function.html#Parameter_list "cpp/language/function")  
declarator |  \-  |  part of a parameter declaration, same as in a function [parameter list](function.html#Parameter_list "cpp/language/function")  
abstract-declarator |  \-  |  part of an unnamed parameter declaration, same as in function [parameter list](function.html#Parameter_list "cpp/language/function")  
compound-statement |  \-  |  a [compound statement](statements.html#Compound_statements "cpp/language/statements")  
  
  
The parameter declaration in a handler describes the type(s) of exceptions that can cause that handler to be entered. 

If the parameter is declared to have one of the following types, the program is ill-formed: 

  * an [incomplete type](type-id.html#Incomplete_type "cpp/language/type")
  * an [abstract class type](abstract_class.html "cpp/language/abstract class")



  * an [rvalue reference](reference.html#Rvalue_reference "cpp/language/reference") type 

| (since C++11)  
---|---  
  
  * a pointer to an incomplete type other than (possibly cv-qualified) void
  * an lvalue reference to an incomplete type 



If the parameter is declared to have type “array of `T`” or function type `T`, the type is adjusted to “pointer to `T`”. 

A handler with parameter type `T` can be abbreviated as “a handler of type `T`”. 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/catch&action=edit&section=2 "Edit section: Matching exceptions")] Matching exceptions

Each try block associates with a number of handlers, these handlers form a handler sequence. When an exception is thrown from a try block, the handlers in the sequence are tried in order of appearance to match the exception. 

A handler is a match for an [exception object](throw.html#Exception_object "cpp/language/throw") of type `E` if any of the following conditions is satisfied: 

  * The handler is of type “possibly cv-qualified `T`” or “lvalue reference to possibly cv-qualified `T`”, and any of the following conditions is satisfied: 



    

  * `E` and `T` are the same type (ignoring the top-level cv-qualifiers). 
  * `T` is an unambiguous public base class of `E`. 



  * The handler is of type “possibly cv-qualified `T`” or const T& where `T` is a pointer or pointer-to-member type, and any of the following conditions is satisfied: 



    

  * `E` is a pointer or pointer-to-member type that can be converted to `T` by at least one of the following conversions: 



    

  * A [standard pointer conversion](implicit_cast.html#Pointer_conversions "cpp/language/implicit conversion") not involving conversions to pointers to private or protected or ambiguous classes. 



    

    

  * A [function pointer conversion](implicit_cast.html#Function_pointer_conversions "cpp/language/implicit conversion"). 


| (since C++17)  
---|---  
  
    

    

  * A [qualification conversion](implicit_cast.html#Qualification_conversions "cpp/language/implicit conversion"). 



    

  * `E` is [std::nullptr_t](../types/nullptr_t.html "cpp/types/nullptr t"). 


| (since C++11)  
---|---  
  
The catch (...) handler matches exceptions of any type. If present, it can only be the last handler in a handler sequence. This handler may be used to ensure that no uncaught exceptions can possibly escape from a function that offers [nothrow exception guarantee](exceptions.html "cpp/language/exceptions"). 
    
    
    try
    {
        f();
    }
    catch (const [std::overflow_error](../error/overflow_error.html)& e)
    {} // this executes if f() throws std::overflow_error (same type rule)
    catch (const [std::runtime_error](../error/runtime_error.html)& e)
    {} // this executes if f() throws std::underflow_error (base class rule)
    catch (const [std::exception](../error/exception.html)& e)
    {} // this executes if f() throws std::logic_error (base class rule)
    catch (...)
    {} // this executes if f() throws std::string or int or any other unrelated type

If no match is found among the handlers for a try block, the search for a matching handler continues in a dynamically surrounding try block of the same thread(since C++11). 

If no matching handler is found, [std::terminate](../error/terminate.html "cpp/error/terminate") is invoked; whether or not the stack is [unwound](throw.html#Stack_unwinding "cpp/language/throw") before this invocation of [std::terminate](../error/terminate.html "cpp/error/terminate") is implementation-defined. 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/catch&action=edit&section=3 "Edit section: Handling exceptions")] Handling exceptions

When an exception is thrown, control is transferred to the nearest handler with a matching type; “nearest” means the handler for which the compound statement or the member initializer list (if present) following the try keyword was most recently entered by the thread of control and not yet exited. 

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/catch&action=edit&section=4 "Edit section: Initializing the handler parameter")] Initializing the handler parameter

The parameter declared in the parameter list (if any), of type “possibly cv-qualified `T`” or “lvalue reference to possibly cv-qualified `T`”, is initialized from the [exception object](throw.html#Exception_object "cpp/language/throw"), of type `E`, as follows: 

  * If `T` is a base class of `E`, the parameter is [copy-initialized](copy_initialization.html "cpp/language/copy initialization") from an lvalue of type `T` designating the corresponding base class subobject of the exception object. 
  * Otherwise, the parameter is copy-initialized from an lvalue of type `E` designating the exception object. 



The lifetime of the parameter ends when the handler exits, after the destruction of any objects with automatic [storage duration](storage_duration.html "cpp/language/storage duration") initialized within the handler. 

When the parameter is declared as an object, any changes to that object will not affect the exception object. 

When the parameter is declared as a reference to an object, any changes to the referenced object are changes to the exception object and will have effect should that object be rethrown. 

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/catch&action=edit&section=5 "Edit section: Activating the handler")] Activating the handler

A handler is considered _active_ when initialization is complete for the parameter (if any) of the handler. 

Also, an implicit handler is considered active when [std::terminate](../error/terminate.html "cpp/error/terminate") is entered due to a throw. 

A handler is no longer considered active when the handler exits. 

The exception with the most recently activated handler that is still active is called the _currently handled exception_. Such an exception can be [rethrown](throw.html#throw_expressions "cpp/language/throw"). 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/catch&action=edit&section=6 "Edit section: Control flow")] Control flow

The compound-statement of a handler is a [control-flow-limited statement](statements.html#Control-flow-limited_statements "cpp/language/statements"): 
    
    
    void f()
    {
        goto label;     // error
        try
        {
            goto label; // error
        }
        catch (...)
        {
            goto label: // OK
            label: ;
        }
    }

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/catch&action=edit&section=7 "Edit section: Notes")] Notes

[Stack unwinding](throw.html#Stack_unwinding "cpp/language/throw") occurs while control is transferring to a handler. When a handler becomes active, stack unwinding is already completed. 

The exception thrown by the throw expression throw 0 does not match a handler of pointer or pointer-to-member type. 

  * throw nullptr can be used instead to throw a null pointer that matches such handlers. 

| (since C++11)  
---|---  
  
[Exception objects](throw.html#Exception_object "cpp/language/throw") can never have array or function types, therefore a handler of reference to array or function type is never a match for any exception object. 

It is possible to write handlers that can never be executed, for example by placing a handler for a final derived class after a handler for a corresponding unambiguous public base class: 
    
    
    try
    {
        f();
    }
    catch (const [std::exception](../error/exception.html)& e)
    {} // will be executed if f() throws std::runtime_error
    catch (const [std::runtime_error](../error/runtime_error.html)& e)
    {} // dead code!

Many implementations overly extend the resolution of [CWG issue 388](https://cplusplus.github.io/CWG/issues/388.html) to handlers of reference to non-const pointer types: 
    
    
    int i;
    try
    {
        try
        {
            throw static_cast<float*>(nullptr);
        }
        catch (void*& pv)
        {
            pv = &i;
            throw;
        }
    }
    catch (const float* pf)
    {
        [assert](../error/assert.html)(pf == nullptr); // should pass, but fails on MSVC and Clang
    }

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/catch&action=edit&section=8 "Edit section: Keywords")] Keywords

[`catch`](../keyword/catch.html "cpp/keyword/catch")

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/catch&action=edit&section=9 "Edit section: Example")] Example

The following example demonstrates several usage cases of the handlers:

Run this code
    
    
    #include <iostream>
    #include <vector>
     
    int main()
    {
        try
        {
            [std::cout](../io/cout.html) << "Throwing an integer exception...\n";
            throw 42;
        }
        catch (int i)
        {
            [std::cout](../io/cout.html) << " the integer exception was caught, with value: " << i << '\n';
        }
     
        try
        {
            [std::cout](../io/cout.html) << "Creating a vector of size 5... \n";
            [std::vector](../container/vector.html)<int> v(5);
            [std::cout](../io/cout.html) << "Accessing the 11th element of the vector...\n";
            [std::cout](../io/cout.html) << v.at(10); // vector::at() throws std::out_of_range
        }
        catch (const [std::exception](../error/exception.html)& e) // caught by reference to base
        {
            [std::cout](../io/cout.html) << " a standard exception was caught, with message: '"
                      << e.what() << "'\n";
        }
    }

Possible output: 
    
    
    Throwing an integer exception...
     the integer exception was caught, with value: 42
    Creating a vector of size 5...
    Accessing the 11th element of the vector...
     a standard exception was caught, with message: 'out_of_range'

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/catch&action=edit&section=10 "Edit section: Defect reports")] Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[CWG 98](https://cplusplus.github.io/CWG/issues/98.html) | C++98  | a switch statement can transfer control into a handler  | prohibited   
[CWG 210](https://cplusplus.github.io/CWG/issues/210.html) | C++98  | throw expressions were matched against the handlers  | exception objects are  
matched against the handlers   
[CWG 388](https://cplusplus.github.io/CWG/issues/388.html) | C++98  | an exception of pointer or pointer to member type could  
not be matched by a const reference to a different type  | made matchable  
when convertible   
[CWG 1166](https://cplusplus.github.io/CWG/issues/1166.html) | C++98  | the behavior was unspecified when a handler whose  
type is a reference to an abstract class type is matched  | abstract class types are  
not allowed for handlers   
[CWG 1769](https://cplusplus.github.io/CWG/issues/1769.html) | C++98  | when the type of the handler is a base of the type of  
the exception object, a converting constructor might  
be used for the initialization of the handler parameter  | the parameter is copy-initialized  
from the corresponding base class  
subobject of the exception object   
[CWG 2093](https://cplusplus.github.io/CWG/issues/2093.html) | C++98  | an exception object of pointer to object type could not match a  
handler of pointer to object type through qualification conversion  | allowed   
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/catch&action=edit&section=11 "Edit section: References")] References

  * C++23 standard (ISO/IEC 14882:2024): 



    

  * 14.4 Handling an exception [except.handle] 



  * C++20 standard (ISO/IEC 14882:2020): 



    

  * 14.4 Handling an exception [except.handle] 



  * C++17 standard (ISO/IEC 14882:2017): 



    

  * 18.3 Handling an exception [except.handle] 



  * C++14 standard (ISO/IEC 14882:2014): 



    

  * 15.3 Handling an exception [except.handle] 



  * C++11 standard (ISO/IEC 14882:2011): 



    

  * 15.3 Handling an exception [except.handle] 



  * C++03 standard (ISO/IEC 14882:2003): 



    

  * 15.3 Handling an exception [except.handle] 



  * C++98 standard (ISO/IEC 14882:1998): 



    

  * 15.3 Handling an exception [except.handle] 



### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/catch&action=edit&section=12 "Edit section: See also")] See also

  * [try block](try.html "cpp/language/try")
  * [Throwing exceptions](throw.html "cpp/language/throw")
  * [Exception handling](../error.html#Exception_handling "cpp/error")


