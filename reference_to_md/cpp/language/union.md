[C++](../../cpp.html "cpp")

[Compiler support](../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../freestanding.html "cpp/freestanding")  
[Language](../language.html "cpp/language")  
[Standard library](../standard_library.html "cpp/standard library")  
[Standard library headers](../headers.html "cpp/header")  
[Named requirements](../iterator/concepts.html "cpp/named req")  
[Feature test macros](../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../utility.html#Language_support "cpp/utility")  
[Concepts library](../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../error.html "cpp/error")  
[Memory management library](../memory.html "cpp/memory")  
[Metaprogramming library](../meta.html "cpp/meta") (C++11)  
[General utilities library](../utility.html "cpp/utility")  
[Containers library](../container.html "cpp/container")  
[Iterators library](../iterator.html "cpp/iterator")  
[Ranges library](../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../algorithm.html "cpp/algorithm")  
[Strings library](../string.html "cpp/string")  
[Text processing library](../text.html "cpp/text")  
[Numerics library](../numeric.html "cpp/numeric")  
[Date and time library](../chrono.html "cpp/chrono")  
[Input/output library](../io.html "cpp/io")  
[Filesystem library](../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../atomic.html "cpp/thread") (C++11)  
[Execution control library](../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../experimental.html "cpp/experimental")  
[Symbols index](../symbol_index.html "cpp/symbol index")  
[External libraries](../links/libs.html "cpp/links/libs")  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/navbar_content&action=edit)

[C++ language](../language.html "cpp/language")

General topics  
---  
| [Preprocessor](../preprocessor.html "cpp/preprocessor")  
---  
[Comments](../comments.html "cpp/comment")  
  
| [Keywords](../keywords.html "cpp/keyword")  
---  
[Escape sequences](escape.html "cpp/language/escape")  
  
[Flow control](statements.html "cpp/language/statements")  
Conditional execution statements  
| [`if`](if.html "cpp/language/if")  
---  
  
| [`switch`](switch.html "cpp/language/switch")  
---  
  
Iteration statements (loops)  
| [`for`](for.html "cpp/language/for")  
---  
[range-`for`](range-for.html "cpp/language/range-for") (C++11)  
  
| [`while`](while.html "cpp/language/while")  
---  
[`do-while`](do.html "cpp/language/do")  
  
Jump statements  
| [`continue`](continue.html "cpp/language/continue") \- [`break`](break.html "cpp/language/break")  
---  
  
| [`goto`](goto.html "cpp/language/goto") \- [`return`](return.html "cpp/language/return")  
---  
  
[Functions](functions.html "cpp/language/functions")  
[Function declaration](function.html "cpp/language/function")  
[Lambda function expression](lambda.html "cpp/language/lambda")  
[`inline` specifier](inline.html "cpp/language/inline")  
[Dynamic exception specifications](except_spec.html "cpp/language/except spec") (until C++17*)  
[`noexcept` specifier](noexcept_spec.html "cpp/language/noexcept spec") (C++11)  
Exceptions  
| [`throw`-expression](throw.html "cpp/language/throw")  
---  
[`try` block](try.html "cpp/language/try")  
  
|   
  
---  
[`catch` handler](catch.html "cpp/language/catch")  
  
Namespaces  
| [Namespace declaration](namespace.html "cpp/language/namespace")` `  
---  
  
| [Namespace aliases](namespace_alias.html "cpp/language/namespace alias")  
---  
  
Types  
| [Fundamental types](types.html "cpp/language/types")  
---  
[Enumeration types](enum.html "cpp/language/enum")  
[Function types](function.html "cpp/language/function")  
  
| [Class/struct types](class.html "cpp/language/class")  
---  
**Union types**  
  
  
  
Specifiers  
| [`const`/`volatile`](cv.html "cpp/language/cv")  
---  
[`decltype`](decltype.html "cpp/language/decltype") (C++11)  
[`auto`](auto.html "cpp/language/auto") (C++11)  
  
| [`constexpr`](constexpr.html "cpp/language/constexpr") (C++11)  
---  
[`consteval`](consteval.html "cpp/language/consteval") (C++20)  
[`constinit`](constinit.html "cpp/language/constinit") (C++20)  
  
[Storage duration specifiers](storage_duration.html "cpp/language/storage duration")  
[Initialization](initialization.html "cpp/language/initialization")  
| [Default-initialization](default_initialization.html "cpp/language/default initialization")  
---  
[Value-initialization](value_initialization.html "cpp/language/value initialization")  
[Zero-initialization](zero_initialization.html "cpp/language/zero initialization")  
[Copy-initialization](copy_initialization.html "cpp/language/copy initialization")  
[Direct-initialization](direct_initialization.html "cpp/language/direct initialization")  
  
| [Aggregate initialization](aggregate_initialization.html "cpp/language/aggregate initialization")  
---  
[List-initialization](list_initialization.html "cpp/language/list initialization") (C++11)` `  
[Constant initialization](constant_initialization.html "cpp/language/constant initialization")  
[Reference initialization](reference_initialization.html "cpp/language/reference initialization")  
  
  
  
[Expressions](expressions.html "cpp/language/expressions")  
---  
| [Value categories](value_category.html "cpp/language/value category")  
---  
[Order of evaluation](eval_order.html "cpp/language/eval order")  
  
| [Operators](operators.html "cpp/language/operators")  
---  
[Operator precedence](operator_precedence.html "cpp/language/operator precedence")  
  
[Alternative representations](operator_alternative.html "cpp/language/operator alternative")  
[Literals](expressions.html#Literals "cpp/language/expressions")  
[Boolean](bool_literal.html "cpp/language/bool literal") \- [Integer](integer_literal.html "cpp/language/integer literal") \- [Floating-point](floating_literal.html "cpp/language/floating literal")  
[Character](character_literal.html "cpp/language/character literal") \- [String](string_literal.html "cpp/language/string literal") \- [`nullptr`](nullptr.html "cpp/language/nullptr") (C++11)  
[User-defined](user_literal.html "cpp/language/user literal") (C++11)  
Utilities  
[Attributes](attributes.html "cpp/language/attributes") (C++11)  
Types  
[`typedef` declaration](typedef.html "cpp/language/typedef")  
[Type alias declaration](type_alias.html "cpp/language/type alias") (C++11)  
Casts  
| [Implicit conversions](implicit_cast.html "cpp/language/implicit conversion")  
---  
[`static_cast`](static_cast.html "cpp/language/static cast")  
[`const_cast`](const_cast.html "cpp/language/const cast")  
  
| [Explicit conversions](explicit_cast.html "cpp/language/explicit cast")  
---  
[`dynamic_cast`](dynamic_cast.html "cpp/language/dynamic cast")  
[`reinterpret_cast`](reinterpret_cast.html "cpp/language/reinterpret cast")  
  
Memory allocation  
| [`new` expression](new.html "cpp/language/new")  
---  
  
| [`delete` expression](delete.html "cpp/language/delete")  
---  
  
[Classes](classes.html "cpp/language/classes")  
| [Class declaration](class.html "cpp/language/class")  
---  
[Constructors](initializer_list.html "cpp/language/constructor")  
[`this` pointer](this.html "cpp/language/this")  
  
| [Access specifiers](access.html "cpp/language/access")  
---  
[`friend` specifier](friend.html "cpp/language/friend")  
  
  
  
Class-specific function properties  
| [Virtual function](virtual.html "cpp/language/virtual")  
---  
[`override` specifier](override.html "cpp/language/override") (C++11)` `  
[`final` specifier](final.html "cpp/language/final") (C++11)  
  
| [`explicit`](explicit.html "cpp/language/explicit") (C++11)  
---  
[`static`](static.html "cpp/language/static")  
  
  
  
Special member functions  
| [Default constructor](default_constructor.html "cpp/language/default constructor")  
---  
[Copy constructor](copy_constructor.html "cpp/language/copy constructor")  
[Move constructor](move_constructor.html "cpp/language/move constructor") (C++11)  
  
| [Copy assignment](as_operator.html "cpp/language/as operator")  
---  
[Move assignment](move_operator.html "cpp/language/move operator") (C++11)  
[Destructor](destructor.html "cpp/language/destructor")  
  
[Templates](templates.html "cpp/language/templates")  
| [Class template](class_template.html "cpp/language/class template")  
---  
[Function template](function_template.html "cpp/language/function template")  
  
| [Template specialization](template_specialization.html "cpp/language/template specialization")  
---  
[Parameter packs](parameter_pack.html "cpp/language/pack") (C++11)  
  
Miscellaneous  
| [Inline assembly](asm.html "cpp/language/asm")  
---  
  
| [History of C++](history.html "cpp/language/history")  
---  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/navbar_content&action=edit)

[ Classes](classes.html "cpp/language/classes")

General  
---  
[Overview](classes.html "cpp/language/classes")  
[`class`/`struct` types](class.html "cpp/language/class")  
**`union` types**  
[Injected-class-name](injected-class-name.html "cpp/language/injected-class-name")  
[Class property specifiers](class_property_specifiers.html "cpp/language/class property specifiers") (C++26)  
Members  
[Data members](data_members.html "cpp/language/data members")  
[Static members](static.html "cpp/language/static")  
[The `this` pointer](this.html "cpp/language/this")  
[Nested classes](nested_classes.html "cpp/language/nested types")  
[Member templates](member_template.html "cpp/language/member template")  
[Bit-fields](bit_field.html "cpp/language/bit field")  
[`using`-declarations](using_declaration.html "cpp/language/using declaration")  
[Member functions](member_functions.html "cpp/language/member functions")  
[Member access specifiers](access.html "cpp/language/access")  
[Constructors and member initializer lists](initializer_list.html "cpp/language/constructor")  
[Default member initializer](data_members.html#Member_initialization "cpp/language/data members") (C++11)  
[`friend` specifier](friend.html "cpp/language/friend")  
[`explicit` specifier](explicit.html "cpp/language/explicit")  
[Converting constructor](converting_constructor.html "cpp/language/converting constructor")  
Special member functions  
[Default constructor](default_constructor.html "cpp/language/default constructor")  
[Copy constructor](copy_constructor.html "cpp/language/copy constructor")  
[Move constructor](move_constructor.html "cpp/language/move constructor") (C++11)  
[Copy assignment operator](as_operator.html "cpp/language/copy assignment")  
[Move assignment operator](move_operator.html "cpp/language/move assignment") (C++11)  
[Destructor](destructor.html "cpp/language/destructor")  
Inheritance  
[Base and derived classes](derived_class.html "cpp/language/derived class")  
[Empty base optimization (EBO)](ebo.html "cpp/language/ebo")  
[Virtual member functions](virtual.html "cpp/language/virtual")  
[Pure virtual functions and abstract classes](abstract_class.html "cpp/language/abstract class")  
[`override` specifier](override.html "cpp/language/override") (C++11)  
[`final` specifier](final.html "cpp/language/final") (C++11)  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/classes/navbar_content&action=edit)

A union is a special class type that can hold only one of its non-static [data members](data_members.html "cpp/language/data members") at a time. 

## Contents

  * [1 Syntax](union.html#Syntax)
  * [2 Explanation](union.html#Explanation)
    * [2.1 Member lifetime](union.html#Member_lifetime)
    * [2.2 Anonymous unions](union.html#Anonymous_unions)
    * [2.3 Union-like classes](union.html#Union-like_classes)
  * [3 Keywords](union.html#Keywords)
  * [4 Defect reports](union.html#Defect_reports)
  * [5 References](union.html#References)
  * [6 See also](union.html#See_also)

  
---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/union&action=edit&section=1 "Edit section: Syntax")] Syntax

The class specifier for a union declaration is similar to [class or struct](class.html "cpp/language/class") declaration:   
  
---  
`**union**` attr class-head-name `**{**` member-specification `**}**` |  |   
attr |  \-  |  (since C++11) optional sequence of any number of [attributes](attributes.html "cpp/language/attributes")  
---|---|---  
class-head-name |  \-  |  the name of the union that's being defined. Optionally prepended by nested-name-specifier (sequence of names and scope-resolution operators, ending with scope-resolution operator). The name may be omitted, in which case the union is _unnamed_  
member-specification |  \-  |  list of access specifiers, member object and member function declarations and definitions.   
  
A union can have member functions (including constructors and destructors), but not virtual functions. 

A union cannot have base classes and cannot be used as a base class. 

At most one [variant member](union.html#Union-like_classes) can have a [default member initializer](data_members.html#Member_initialization "cpp/language/data members").  | (since C++11)  
---|---  
  
A union cannot have non-static data members of reference types. 

Unions cannot contain a non-static data member with a non-trivial [special member function](member_functions.html#Special_member_functions "cpp/language/member functions").  | (until C++11)  
---|---  
If a union contains a non-static data member with a non-trivial [special member function](member_functions.html#Special_member_functions "cpp/language/member functions"), the corresponding special member function of the union may be defined as deleted, see the corresponding special member function page for details.  | (since C++11)  
  
Just like in [struct](classes.html "cpp/language/classes") declaration, the default member access in a union is [public](access.html "cpp/language/access"). 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/union&action=edit&section=2 "Edit section: Explanation")] Explanation

The union is at least as big as necessary to hold its largest data member, but is usually not larger. The other data members are intended to be allocated in the same bytes as part of that largest member. The details of that allocation are implementation-defined, except that all non-static data members have the same address. It is undefined behavior to read from the member of the union that wasn't most recently written. Many compilers implement, as a non-standard language extension, the ability to read inactive members of a union. 

Run this code
    
    
    #include <cstdint>
    #include <iostream>
     
    union S
    {
        [std::int32_t](../types/integer.html) n;     // occupies 4 bytes
        [std::uint16_t](../types/integer.html) s[2]; // occupies 4 bytes
        [std::uint8_t](../types/integer.html) c;     // occupies 1 byte
    };                      // the whole union occupies 4 bytes
     
    int main()
    {
        S s = {0x12345678}; // initializes the first member, s.n is now the active member
        // At this point, reading from s.s or s.c is undefined behavior,
        // but most compilers define it.
        [std::cout](../io/cout.html) << [std::hex](../io/manip/hex.html) << "s.n = " << s.n << '\n';
     
        s.s[0] = 0x0011; // s.s is now the active member
        // At this point, reading from s.n or s.c is undefined behavior,
        // but most compilers define it.
        [std::cout](../io/cout.html) << "s.c is now " << +s.c << '\n' // 11 or 00, depending on platform
                  << "s.n is now " << s.n << '\n'; // 12340011 or 00115678
    }

Possible output: 
    
    
    s.n = 12345678
    s.c is now 0
    s.n is now 115678

Each member is allocated as if it is the only member of the class. 

If members of a union are classes with user-defined constructors and destructors, to switch the active member, explicit destructor and placement new are generally needed:  Run this code
    
    
    #include <iostream>
    #include <string>
    #include <vector>
     
    union S
    {
        [std::string](../string/basic_string.html) str;
        [std::vector](../container/vector.html)<int> vec;
        ~S() {} // needs to know which member is active, only possible in union-like class 
    };          // the whole union occupies max(sizeof(string), sizeof(vector<int>))
     
    int main()
    {
        S s = {"Hello, world"};
        // at this point, reading from s.vec is undefined behavior
        [std::cout](../io/cout.html) << "s.str = " << s.str << '\n';
        s.str.~basic_string();
        new (&s.vec) [std::vector](../container/vector.html)<int>;
        // now, s.vec is the active member of the union
        s.vec.push_back(10);
        [std::cout](../io/cout.html) << s.vec.size() << '\n';
        s.vec.~vector();
    }

Output: 
    
    
    s.str = Hello, world
    1

| (since C++11)  
---|---  
  
If two union members are [standard-layout](../named_req/StandardLayoutType.html "cpp/named req/StandardLayoutType") types, it's well-defined to examine their common subsequence on any compiler. 

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/union&action=edit&section=3 "Edit section: Member lifetime")] Member lifetime

The [lifetime](lifetime.html "cpp/language/lifetime") of a union member begins when the member is made active. If another member was active previously, its lifetime ends. 

When active member of a union is switched by an assignment expression of the form `E1 = E2` that uses either the built-in assignment operator or a trivial assignment operator, for each union member X that appears in the member access and array subscript subexpressions of `E1` that is not a class with non-trivial or deleted default constructors, if modification of X would have undefined behavior under type aliasing rules, an object of the type of X is implicitly created in the nominated storage; no initialization is performed and the beginning of its lifetime is sequenced after the value computation of the left and right operands and before the assignment. 
    
    
    union A { int x; int y[4]; };
    struct B { A a; };
    union C { B b; int k; };
     
    int f()
    {
        C c;               // does not start lifetime of any union member
        c.b.a.y[3] = 4;    // OK: "c.b.a.y[3]", names union members c.b and c.b.a.y;
                           // This creates objects to hold union members c.b and c.b.a.y
        return c.b.a.y[3]; // OK: c.b.a.y refers to newly created object
    }
     
    struct X { const int a; int b; };
    union Y { X x; int k; };
     
    void g()
    {
        Y y = {{1, 2}}; // OK, y.x is active union member
        int n = y.x.a;
        y.k = 4;   // OK: ends lifetime of y.x, y.k is active member of union
        y.x.b = n; // undefined behavior: y.x.b modified outside its lifetime,
                   // "y.x.b" names y.x, but X's default constructor is deleted,
                   // so union member y.x's lifetime does not implicitly start
    }

Trivial move constructor, move assignment operator, (since C++11)copy constructor and copy assignment operator of union types copy object representations. If the source and the destination are not the same object, these special member functions start lifetime of every object (except for objects that are neither subobjects of the destination nor of [implicit-lifetime type](lifetime.html#Implicit-lifetime_types "cpp/language/lifetime")) nested in the destination corresponding to the one nested in the source before the copy is performed. Otherwise, they do nothing. Two union objects have the same corresponding active member (if any) after construction or assignment via trivial special functions. 

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/union&action=edit&section=4 "Edit section: Anonymous unions")] Anonymous unions

An _anonymous union_ is an unnamed union definition that does not simultaneously define any variables (including objects of the union type, references, or pointers to the union).   
  
---  
`**union**` `**{**` member-specification `**}**` `**;**` |  |   
  
Anonymous unions have further restrictions: they cannot have member functions, cannot have static data members, and all their data members must be public. The only declarations allowed are non-static data members  and [`static_assert`](static_assert.html "cpp/language/static assert") declarations(since C++11). 

Members of an anonymous union are injected in the enclosing scope (and must not conflict with other names declared there). 
    
    
    int main()
    {
        union
        {
            int a;
            const char* p;
        };
        a = 1;
        p = "Jennifer";
    }

Namespace-scope anonymous unions must be declared static unless they appear in an unnamed namespace. 

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/union&action=edit&section=5 "Edit section: Union-like classes")] Union-like classes

A _union-like class_ is either a union, or a (non-union) class that has at least one anonymous union as a member. A union-like class has a set of _variant members ﻿_ : 

  * the non-static data members of its member anonymous unions; 
  * in addition, if the union-like class is a union, its non-static data members that are not anonymous unions. 



Union-like classes can be used to implement [tagged union](https://en.wikipedia.org/wiki/tagged_union "enwiki:tagged union"). 

Run this code
    
    
    #include <iostream>
     
    // S has one non-static data member (tag), three enumerator members (CHAR, INT, DOUBLE), 
    // and three variant members (c, i, d)
    struct S
    {
        enum{CHAR, INT, DOUBLE} tag;
        union
        {
            char c;
            int i;
            double d;
        };
    };
     
    void print_s(const S& s)
    {
        switch(s.tag)
        {
            case S::CHAR: [std::cout](../io/cout.html) << s.c << '\n'; break;
            case S::INT: [std::cout](../io/cout.html) << s.i << '\n'; break;
            case S::DOUBLE: [std::cout](../io/cout.html) << s.d << '\n'; break;
        }
    }
     
    int main()
    {
        S s = {S::CHAR, 'a'};
        print_s(s);
        s.tag = S::INT;
        s.i = 123;
        print_s(s);
    }

Output: 
    
    
    a
    123

The C++ standard library includes [std::variant](../utility/variant.html "cpp/utility/variant"), which can replace many uses of unions and union-like classes. The example above can be re-written as  Run this code
    
    
    #include <iostream>
    #include <variant>
     
    int main()
    {
        [std::variant](../utility/variant.html)<char, int, double> s = 'a';
        [std::visit](../utility/variant/visit.html)([](auto x){ [std::cout](../io/cout.html) << x << '\n';}, s);
        s = 123;
        [std::visit](../utility/variant/visit.html)([](auto x){ [std::cout](../io/cout.html) << x << '\n';}, s);
    }

Output: 
    
    
    a
    123

| (since C++17)  
---|---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/union&action=edit&section=6 "Edit section: Keywords")] Keywords

[`union`](../keyword/union.html "cpp/keyword/union")

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/union&action=edit&section=7 "Edit section: Defect reports")] Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[CWG 1940](https://cplusplus.github.io/CWG/issues/1940.html) | C++11  | anonymous unions only allowed non-static data members  | `static_assert` also allowed   
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/union&action=edit&section=8 "Edit section: References")] References

  * C++23 standard (ISO/IEC 14882:2024): 



    

  * 11.5 Unions [class.union] 



  * C++20 standard (ISO/IEC 14882:2020): 



    

  * 11.5 Unions [class.union] 



  * C++17 standard (ISO/IEC 14882:2017): 



    

  * 12.3 Unions [class.union] 



  * C++14 standard (ISO/IEC 14882:2014): 



    

  * 9.5 Unions [class.union] 



  * C++11 standard (ISO/IEC 14882:2011): 



    

  * 9.5 Unions [class.union] 



  * C++03 standard (ISO/IEC 14882:2003): 



    

  * 9.5 Unions [class.union] 



  * C++98 standard (ISO/IEC 14882:1998): 



    

  * 9.5 Unions [class.union] 



### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/union&action=edit&section=9 "Edit section: See also")] See also

[ variant](../utility/variant.html "cpp/utility/variant")(C++17) |  a type-safe discriminated union   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/dsc_variant&action=edit)  
---|---  
[C documentation](../../c/language/union.html "c/language/union") for Union declaration
