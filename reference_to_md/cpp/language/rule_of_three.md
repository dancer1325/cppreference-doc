[C++](../../cpp.html "cpp")

[Compiler support](../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../freestanding.html "cpp/freestanding")  
[Language](../language.html "cpp/language")  
[Standard library](../standard_library.html "cpp/standard library")  
[Standard library headers](../headers.html "cpp/header")  
[Named requirements](../iterator/concepts.html "cpp/named req")  
[Feature test macros](../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../utility.html#Language_support "cpp/utility")  
[Concepts library](../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../error.html "cpp/error")  
[Memory management library](../memory.html "cpp/memory")  
[Metaprogramming library](../meta.html "cpp/meta") (C++11)  
[General utilities library](../utility.html "cpp/utility")  
[Containers library](../container.html "cpp/container")  
[Iterators library](../iterator.html "cpp/iterator")  
[Ranges library](../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../algorithm.html "cpp/algorithm")  
[Strings library](../string.html "cpp/string")  
[Text processing library](../text.html "cpp/text")  
[Numerics library](../numeric.html "cpp/numeric")  
[Date and time library](../chrono.html "cpp/chrono")  
[Input/output library](../io.html "cpp/io")  
[Filesystem library](../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../atomic.html "cpp/thread") (C++11)  
[Execution control library](../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../experimental.html "cpp/experimental")  
[Symbols index](../symbol_index.html "cpp/symbol index")  
[External libraries](../links/libs.html "cpp/links/libs")  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/navbar_content&action=edit)

[C++ language](../language.html "cpp/language")

General topics  
---  
| [Preprocessor](../preprocessor.html "cpp/preprocessor")  
---  
[Comments](../comments.html "cpp/comment")  
  
| [Keywords](../keywords.html "cpp/keyword")  
---  
[Escape sequences](escape.html "cpp/language/escape")  
  
[Flow control](statements.html "cpp/language/statements")  
Conditional execution statements  
| [`if`](if.html "cpp/language/if")  
---  
  
| [`switch`](switch.html "cpp/language/switch")  
---  
  
Iteration statements (loops)  
| [`for`](for.html "cpp/language/for")  
---  
[range-`for`](range-for.html "cpp/language/range-for") (C++11)  
  
| [`while`](while.html "cpp/language/while")  
---  
[`do-while`](do.html "cpp/language/do")  
  
Jump statements  
| [`continue`](continue.html "cpp/language/continue") \- [`break`](break.html "cpp/language/break")  
---  
  
| [`goto`](goto.html "cpp/language/goto") \- [`return`](return.html "cpp/language/return")  
---  
  
[Functions](functions.html "cpp/language/functions")  
[Function declaration](function.html "cpp/language/function")  
[Lambda function expression](lambda.html "cpp/language/lambda")  
[`inline` specifier](inline.html "cpp/language/inline")  
[Dynamic exception specifications](except_spec.html "cpp/language/except spec") (until C++17*)  
[`noexcept` specifier](noexcept_spec.html "cpp/language/noexcept spec") (C++11)  
Exceptions  
| [`throw`-expression](throw.html "cpp/language/throw")  
---  
[`try` block](try.html "cpp/language/try")  
  
|   
  
---  
[`catch` handler](catch.html "cpp/language/catch")  
  
Namespaces  
| [Namespace declaration](namespace.html "cpp/language/namespace")` `  
---  
  
| [Namespace aliases](namespace_alias.html "cpp/language/namespace alias")  
---  
  
Types  
| [Fundamental types](types.html "cpp/language/types")  
---  
[Enumeration types](enum.html "cpp/language/enum")  
[Function types](function.html "cpp/language/function")  
  
| [Class/struct types](class.html "cpp/language/class")  
---  
[Union types](union.html "cpp/language/union")  
  
  
  
Specifiers  
| [`const`/`volatile`](cv.html "cpp/language/cv")  
---  
[`decltype`](decltype.html "cpp/language/decltype") (C++11)  
[`auto`](auto.html "cpp/language/auto") (C++11)  
  
| [`constexpr`](constexpr.html "cpp/language/constexpr") (C++11)  
---  
[`consteval`](consteval.html "cpp/language/consteval") (C++20)  
[`constinit`](constinit.html "cpp/language/constinit") (C++20)  
  
[Storage duration specifiers](storage_duration.html "cpp/language/storage duration")  
[Initialization](initialization.html "cpp/language/initialization")  
| [Default-initialization](default_initialization.html "cpp/language/default initialization")  
---  
[Value-initialization](value_initialization.html "cpp/language/value initialization")  
[Zero-initialization](zero_initialization.html "cpp/language/zero initialization")  
[Copy-initialization](copy_initialization.html "cpp/language/copy initialization")  
[Direct-initialization](direct_initialization.html "cpp/language/direct initialization")  
  
| [Aggregate initialization](aggregate_initialization.html "cpp/language/aggregate initialization")  
---  
[List-initialization](list_initialization.html "cpp/language/list initialization") (C++11)` `  
[Constant initialization](constant_initialization.html "cpp/language/constant initialization")  
[Reference initialization](reference_initialization.html "cpp/language/reference initialization")  
  
  
  
[Expressions](expressions.html "cpp/language/expressions")  
---  
| [Value categories](value_category.html "cpp/language/value category")  
---  
[Order of evaluation](eval_order.html "cpp/language/eval order")  
  
| [Operators](operators.html "cpp/language/operators")  
---  
[Operator precedence](operator_precedence.html "cpp/language/operator precedence")  
  
[Alternative representations](operator_alternative.html "cpp/language/operator alternative")  
[Literals](expressions.html#Literals "cpp/language/expressions")  
[Boolean](bool_literal.html "cpp/language/bool literal") \- [Integer](integer_literal.html "cpp/language/integer literal") \- [Floating-point](floating_literal.html "cpp/language/floating literal")  
[Character](character_literal.html "cpp/language/character literal") \- [String](string_literal.html "cpp/language/string literal") \- [`nullptr`](nullptr.html "cpp/language/nullptr") (C++11)  
[User-defined](user_literal.html "cpp/language/user literal") (C++11)  
Utilities  
[Attributes](attributes.html "cpp/language/attributes") (C++11)  
Types  
[`typedef` declaration](typedef.html "cpp/language/typedef")  
[Type alias declaration](type_alias.html "cpp/language/type alias") (C++11)  
Casts  
| [Implicit conversions](implicit_cast.html "cpp/language/implicit conversion")  
---  
[`static_cast`](static_cast.html "cpp/language/static cast")  
[`const_cast`](const_cast.html "cpp/language/const cast")  
  
| [Explicit conversions](explicit_cast.html "cpp/language/explicit cast")  
---  
[`dynamic_cast`](dynamic_cast.html "cpp/language/dynamic cast")  
[`reinterpret_cast`](reinterpret_cast.html "cpp/language/reinterpret cast")  
  
Memory allocation  
| [`new` expression](new.html "cpp/language/new")  
---  
  
| [`delete` expression](delete.html "cpp/language/delete")  
---  
  
[Classes](classes.html "cpp/language/classes")  
| [Class declaration](class.html "cpp/language/class")  
---  
[Constructors](initializer_list.html "cpp/language/constructor")  
[`this` pointer](this.html "cpp/language/this")  
  
| [Access specifiers](access.html "cpp/language/access")  
---  
[`friend` specifier](friend.html "cpp/language/friend")  
  
  
  
Class-specific function properties  
| [Virtual function](virtual.html "cpp/language/virtual")  
---  
[`override` specifier](override.html "cpp/language/override") (C++11)` `  
[`final` specifier](final.html "cpp/language/final") (C++11)  
  
| [`explicit`](explicit.html "cpp/language/explicit") (C++11)  
---  
[`static`](static.html "cpp/language/static")  
  
  
  
Special member functions  
| [Default constructor](default_constructor.html "cpp/language/default constructor")  
---  
[Copy constructor](copy_constructor.html "cpp/language/copy constructor")  
[Move constructor](move_constructor.html "cpp/language/move constructor") (C++11)  
  
| [Copy assignment](as_operator.html "cpp/language/as operator")  
---  
[Move assignment](move_operator.html "cpp/language/move operator") (C++11)  
[Destructor](destructor.html "cpp/language/destructor")  
  
[Templates](templates.html "cpp/language/templates")  
| [Class template](class_template.html "cpp/language/class template")  
---  
[Function template](function_template.html "cpp/language/function template")  
  
| [Template specialization](template_specialization.html "cpp/language/template specialization")  
---  
[Parameter packs](parameter_pack.html "cpp/language/pack") (C++11)  
  
Miscellaneous  
| [Inline assembly](asm.html "cpp/language/asm")  
---  
  
| [History of C++](history.html "cpp/language/history")  
---  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/navbar_content&action=edit)

## Contents

  * [1 Rule of three](rule_of_three.html#Rule_of_three)
  * [2 Rule of five](rule_of_three.html#Rule_of_five)
  * [3 Rule of zero](rule_of_three.html#Rule_of_zero)
  * [4 External links](rule_of_three.html#External_links)

  
---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/rule_of_three&action=edit&section=1 "Edit section: Rule of three")] Rule of three

If a class requires a user-defined [destructor](destructor.html "cpp/language/destructor"), a user-defined [copy constructor](copy_constructor.html "cpp/language/copy constructor"), or a user-defined [copy assignment operator](as_operator.html "cpp/language/as operator"), it almost certainly requires all three. 

Because C++ copies and copy-assigns objects of user-defined types in various situations (passing/returning by value, manipulating a container, etc), these special member functions will be called, if accessible, and if they are not user-defined, they are implicitly-defined by the compiler. 

The implicitly-defined special member functions should not be used if the class [manages a resource](raii.html "cpp/language/raii") whose handle is an object of non-class type (raw pointer, POSIX file descriptor, etc), whose destructor does nothing and copy constructor/assignment operator performs a "shallow copy" (copies the value of the handle, without duplicating the underlying resource). 

Run this code
    
    
    #include <cstddef>
    #include <cstring>
    #include <iostream>
    #include <utility>
     
    class rule_of_three
    {
        char* cstring; // raw pointer used as a handle to a
                       // dynamically-allocated memory block
     
    public:
        explicit rule_of_three(const char* s = "") : cstring(nullptr)
        {   
            if (s)
            {   
                cstring = new char[[std::strlen](../string/byte/strlen.html)(s) + 1]; // allocate
                [std::strcpy](../string/byte/strcpy.html)(cstring, s); // populate
            }
        }
     
        ~rule_of_three() // I. destructor
        {
            delete[] cstring; // deallocate
        }
     
        rule_of_three(const rule_of_three& other) // II. copy constructor
            : rule_of_three(other.cstring) {}
     
        rule_of_three& operator=(const rule_of_three& other) // III. copy assignment
        {
            // implemented through copy-and-swap for brevity
            // note that this prevents potential storage reuse
            rule_of_three temp(other);
            [std::swap](../algorithm/swap.html)(cstring, temp.cstring);
            return *this;
        }
     
        const char* c_str() const // accessor
        {
            return cstring;
        }
    };
     
    int main()
    {
        rule_of_three o1{"abc"};
        [std::cout](../io/cout.html) << o1.c_str() << ' ';
        auto o2{o1}; // II. uses copy constructor
        [std::cout](../io/cout.html) << o2.c_str() << ' ';
        rule_of_three o3("def");
        [std::cout](../io/cout.html) << o3.c_str() << ' ';
        o3 = o2; // III. uses copy assignment
        [std::cout](../io/cout.html) << o3.c_str() << '\n';
    }   // I. all destructors are called here

Output: 
    
    
    abc abc def abc

Classes that manage non-copyable resources through copyable handles may have to declare copy assignment and copy constructor private and not provide their definitions(until C++11)define copy assignment and copy constructor as = delete(since C++11). This is another application of the rule of three: deleting one and leaving the other to be implicitly-defined typically incorrect. 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/rule_of_three&action=edit&section=2 "Edit section: Rule of five")] Rule of five

Because the presence of a user-defined (include = default or = delete declared) destructor, copy-constructor, or copy-assignment operator prevents implicit definition of the [move constructor](move_constructor.html "cpp/language/move constructor") and the [move assignment operator](move_operator.html "cpp/language/move operator"), any class for which move semantics are desirable, has to declare all five special member functions: 
    
    
    class rule_of_five
    {
        char* cstring; // raw pointer used as a handle to a
                       // dynamically-allocated memory block
    public:
        explicit rule_of_five(const char* s = "") : cstring(nullptr)
        { 
            if (s)
            {
                cstring = new char[[std::strlen](../string/byte/strlen.html)(s) + 1]; // allocate
                [std::strcpy](../string/byte/strcpy.html)(cstring, s); // populate 
            } 
        }
     
        ~rule_of_five()
        {
            delete[] cstring; // deallocate
        }
     
        rule_of_five(const rule_of_five& other) // copy constructor
            : rule_of_five(other.cstring) {}
     
        rule_of_five(rule_of_five&& other) noexcept // move constructor
            : cstring([std::exchange](../utility/exchange.html)(other.cstring, nullptr)) {}
     
        rule_of_five& operator=(const rule_of_five& other) // copy assignment
        {
            // implemented as move-assignment from a temporary copy for brevity
            // note that this prevents potential storage reuse
            return *this = rule_of_five(other);
        }
     
        rule_of_five& operator=(rule_of_five&& other) noexcept // move assignment
        {
            [std::swap](../algorithm/swap.html)(cstring, other.cstring);
            return *this;
        }
     
    // alternatively, replace both assignment operators with copy-and-swap
    // implementation, which also fails to reuse storage in copy-assignment.
    //  rule_of_five& operator=(rule_of_five other) noexcept
    //  {
    //      std::swap(cstring, other.cstring);
    //      return *this;
    //  }
    };

Unlike Rule of Three, failing to provide move constructor and move assignment is usually not an error, but a missed optimization opportunity. 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/rule_of_three&action=edit&section=3 "Edit section: Rule of zero")] Rule of zero

Classes that have custom destructors, copy/move constructors or copy/move assignment operators should deal exclusively with ownership (which follows from the [Single Responsibility Principle](https://en.wikipedia.org/wiki/Single_responsibility_principle "enwiki:Single responsibility principle")). Other classes should not have custom destructors, copy/move constructors or copy/move assignment operators[[1]](rule_of_three.html#cite_note-1). 

This rule also appears in the C++ Core Guidelines as [C.20: If you can avoid defining default operations, do](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-zero). 
    
    
    class rule_of_zero
    {
        [std::string](../string/basic_string.html) cppstring;
    public:
        rule_of_zero(const [std::string](../string/basic_string.html)& arg) : cppstring(arg) {}
    };

When a base class is intended for polymorphic use, its destructor may have to be declared public and virtual. This blocks implicit moves (and deprecates implicit copies), and so the special member functions have to be defined as = default[[2]](rule_of_three.html#cite_note-2). 
    
    
    class base_of_five_defaults
    {
    public:
        base_of_five_defaults(const base_of_five_defaults&) = default;
        base_of_five_defaults(base_of_five_defaults&&) = default;
        base_of_five_defaults& operator=(const base_of_five_defaults&) = default;
        base_of_five_defaults& operator=(base_of_five_defaults&&) = default;
        virtual ~base_of_five_defaults() = default;
    };

However, this makes the class prone to slicing, which is why polymorphic classes often define copy as = delete (see [C.67: A polymorphic class should suppress public copy/move](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c67-a-polymorphic-class-should-suppress-public-copymove) in C++ Core Guidelines), which leads to the following generic wording for the Rule of Five: 

    [C.21: If you define or =delete any copy, move, or destructor function, define or =delete them all.](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c21-if-you-define-or-delete-any-copy-move-or-destructor-function-define-or-delete-them-all)

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/rule_of_three&action=edit&section=4 "Edit section: External links")] External links

  1. [↑](rule_of_three.html#cite_ref-1) ["Rule of Zero", R. Martinho Fernandes 08/15/2012](https://web.archive.org/web/20130211035910/http://flamingdangerzone.com/cxx11/2012/08/15/rule-of-zero.html)
  2. [↑](rule_of_three.html#cite_ref-2) ["A Concern about the Rule of Zero", Scott Meyers, 3/13/2014](https://scottmeyers.blogspot.fr/2014/03/a-concern-about-rule-of-zero.html).

  
---
