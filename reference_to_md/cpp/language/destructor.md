[C++](../../cpp.html "cpp")

[Compiler support](../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../freestanding.html "cpp/freestanding")  
[Language](../language.html "cpp/language")  
[Standard library](../standard_library.html "cpp/standard library")  
[Standard library headers](../headers.html "cpp/header")  
[Named requirements](../iterator/concepts.html "cpp/named req")  
[Feature test macros](../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../utility.html#Language_support "cpp/utility")  
[Concepts library](../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../error.html "cpp/error")  
[Memory management library](../memory.html "cpp/memory")  
[Metaprogramming library](../meta.html "cpp/meta") (C++11)  
[General utilities library](../utility.html "cpp/utility")  
[Containers library](../container.html "cpp/container")  
[Iterators library](../iterator.html "cpp/iterator")  
[Ranges library](../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../algorithm.html "cpp/algorithm")  
[Strings library](../string.html "cpp/string")  
[Text processing library](../text.html "cpp/text")  
[Numerics library](../numeric.html "cpp/numeric")  
[Date and time library](../chrono.html "cpp/chrono")  
[Input/output library](../io.html "cpp/io")  
[Filesystem library](../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../atomic.html "cpp/thread") (C++11)  
[Execution control library](../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../experimental.html "cpp/experimental")  
[Symbols index](../symbol_index.html "cpp/symbol index")  
[External libraries](../links/libs.html "cpp/links/libs")  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/navbar_content&action=edit)

[C++ language](../language.html "cpp/language")

General topics  
---  
| [Preprocessor](../preprocessor.html "cpp/preprocessor")  
---  
[Comments](../comments.html "cpp/comment")  
  
| [Keywords](../keywords.html "cpp/keyword")  
---  
[Escape sequences](escape.html "cpp/language/escape")  
  
[Flow control](statements.html "cpp/language/statements")  
Conditional execution statements  
| [`if`](if.html "cpp/language/if")  
---  
  
| [`switch`](switch.html "cpp/language/switch")  
---  
  
Iteration statements (loops)  
| [`for`](for.html "cpp/language/for")  
---  
[range-`for`](range-for.html "cpp/language/range-for") (C++11)  
  
| [`while`](while.html "cpp/language/while")  
---  
[`do-while`](do.html "cpp/language/do")  
  
Jump statements  
| [`continue`](continue.html "cpp/language/continue") \- [`break`](break.html "cpp/language/break")  
---  
  
| [`goto`](goto.html "cpp/language/goto") \- [`return`](return.html "cpp/language/return")  
---  
  
[Functions](functions.html "cpp/language/functions")  
[Function declaration](function.html "cpp/language/function")  
[Lambda function expression](lambda.html "cpp/language/lambda")  
[`inline` specifier](inline.html "cpp/language/inline")  
[Dynamic exception specifications](except_spec.html "cpp/language/except spec") (until C++17*)  
[`noexcept` specifier](noexcept_spec.html "cpp/language/noexcept spec") (C++11)  
Exceptions  
| [`throw`-expression](throw.html "cpp/language/throw")  
---  
[`try` block](try.html "cpp/language/try")  
  
|   
  
---  
[`catch` handler](catch.html "cpp/language/catch")  
  
Namespaces  
| [Namespace declaration](namespace.html "cpp/language/namespace")` `  
---  
  
| [Namespace aliases](namespace_alias.html "cpp/language/namespace alias")  
---  
  
Types  
| [Fundamental types](types.html "cpp/language/types")  
---  
[Enumeration types](enum.html "cpp/language/enum")  
[Function types](function.html "cpp/language/function")  
  
| [Class/struct types](class.html "cpp/language/class")  
---  
[Union types](union.html "cpp/language/union")  
  
  
  
Specifiers  
| [`const`/`volatile`](cv.html "cpp/language/cv")  
---  
[`decltype`](decltype.html "cpp/language/decltype") (C++11)  
[`auto`](auto.html "cpp/language/auto") (C++11)  
  
| [`constexpr`](constexpr.html "cpp/language/constexpr") (C++11)  
---  
[`consteval`](consteval.html "cpp/language/consteval") (C++20)  
[`constinit`](constinit.html "cpp/language/constinit") (C++20)  
  
[Storage duration specifiers](storage_duration.html "cpp/language/storage duration")  
[Initialization](initialization.html "cpp/language/initialization")  
| [Default-initialization](default_initialization.html "cpp/language/default initialization")  
---  
[Value-initialization](value_initialization.html "cpp/language/value initialization")  
[Zero-initialization](zero_initialization.html "cpp/language/zero initialization")  
[Copy-initialization](copy_initialization.html "cpp/language/copy initialization")  
[Direct-initialization](direct_initialization.html "cpp/language/direct initialization")  
  
| [Aggregate initialization](aggregate_initialization.html "cpp/language/aggregate initialization")  
---  
[List-initialization](list_initialization.html "cpp/language/list initialization") (C++11)` `  
[Constant initialization](constant_initialization.html "cpp/language/constant initialization")  
[Reference initialization](reference_initialization.html "cpp/language/reference initialization")  
  
  
  
[Expressions](expressions.html "cpp/language/expressions")  
---  
| [Value categories](value_category.html "cpp/language/value category")  
---  
[Order of evaluation](eval_order.html "cpp/language/eval order")  
  
| [Operators](operators.html "cpp/language/operators")  
---  
[Operator precedence](operator_precedence.html "cpp/language/operator precedence")  
  
[Alternative representations](operator_alternative.html "cpp/language/operator alternative")  
[Literals](expressions.html#Literals "cpp/language/expressions")  
[Boolean](bool_literal.html "cpp/language/bool literal") \- [Integer](integer_literal.html "cpp/language/integer literal") \- [Floating-point](floating_literal.html "cpp/language/floating literal")  
[Character](character_literal.html "cpp/language/character literal") \- [String](string_literal.html "cpp/language/string literal") \- [`nullptr`](nullptr.html "cpp/language/nullptr") (C++11)  
[User-defined](user_literal.html "cpp/language/user literal") (C++11)  
Utilities  
[Attributes](attributes.html "cpp/language/attributes") (C++11)  
Types  
[`typedef` declaration](typedef.html "cpp/language/typedef")  
[Type alias declaration](type_alias.html "cpp/language/type alias") (C++11)  
Casts  
| [Implicit conversions](implicit_cast.html "cpp/language/implicit conversion")  
---  
[`static_cast`](static_cast.html "cpp/language/static cast")  
[`const_cast`](const_cast.html "cpp/language/const cast")  
  
| [Explicit conversions](explicit_cast.html "cpp/language/explicit cast")  
---  
[`dynamic_cast`](dynamic_cast.html "cpp/language/dynamic cast")  
[`reinterpret_cast`](reinterpret_cast.html "cpp/language/reinterpret cast")  
  
Memory allocation  
| [`new` expression](new.html "cpp/language/new")  
---  
  
| [`delete` expression](delete.html "cpp/language/delete")  
---  
  
[Classes](classes.html "cpp/language/classes")  
| [Class declaration](class.html "cpp/language/class")  
---  
[Constructors](initializer_list.html "cpp/language/constructor")  
[`this` pointer](this.html "cpp/language/this")  
  
| [Access specifiers](access.html "cpp/language/access")  
---  
[`friend` specifier](friend.html "cpp/language/friend")  
  
  
  
Class-specific function properties  
| [Virtual function](virtual.html "cpp/language/virtual")  
---  
[`override` specifier](override.html "cpp/language/override") (C++11)` `  
[`final` specifier](final.html "cpp/language/final") (C++11)  
  
| [`explicit`](explicit.html "cpp/language/explicit") (C++11)  
---  
[`static`](static.html "cpp/language/static")  
  
  
  
Special member functions  
| [Default constructor](default_constructor.html "cpp/language/default constructor")  
---  
[Copy constructor](copy_constructor.html "cpp/language/copy constructor")  
[Move constructor](move_constructor.html "cpp/language/move constructor") (C++11)  
  
| [Copy assignment](as_operator.html "cpp/language/as operator")  
---  
[Move assignment](move_operator.html "cpp/language/move operator") (C++11)  
**Destructor**  
  
[Templates](templates.html "cpp/language/templates")  
| [Class template](class_template.html "cpp/language/class template")  
---  
[Function template](function_template.html "cpp/language/function template")  
  
| [Template specialization](template_specialization.html "cpp/language/template specialization")  
---  
[Parameter packs](parameter_pack.html "cpp/language/pack") (C++11)  
  
Miscellaneous  
| [Inline assembly](asm.html "cpp/language/asm")  
---  
  
| [History of C++](history.html "cpp/language/history")  
---  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/navbar_content&action=edit)

[ Classes](classes.html "cpp/language/classes")

General  
---  
[Overview](classes.html "cpp/language/classes")  
[`class`/`struct` types](class.html "cpp/language/class")  
[`union` types](union.html "cpp/language/union")  
[Injected-class-name](injected-class-name.html "cpp/language/injected-class-name")  
[Class property specifiers](class_property_specifiers.html "cpp/language/class property specifiers") (C++26)  
Members  
[Data members](data_members.html "cpp/language/data members")  
[Static members](static.html "cpp/language/static")  
[The `this` pointer](this.html "cpp/language/this")  
[Nested classes](nested_classes.html "cpp/language/nested types")  
[Member templates](member_template.html "cpp/language/member template")  
[Bit-fields](bit_field.html "cpp/language/bit field")  
[`using`-declarations](using_declaration.html "cpp/language/using declaration")  
[Member functions](member_functions.html "cpp/language/member functions")  
[Member access specifiers](access.html "cpp/language/access")  
[Constructors and member initializer lists](initializer_list.html "cpp/language/constructor")  
[Default member initializer](data_members.html#Member_initialization "cpp/language/data members") (C++11)  
[`friend` specifier](friend.html "cpp/language/friend")  
[`explicit` specifier](explicit.html "cpp/language/explicit")  
[Converting constructor](converting_constructor.html "cpp/language/converting constructor")  
Special member functions  
[Default constructor](default_constructor.html "cpp/language/default constructor")  
[Copy constructor](copy_constructor.html "cpp/language/copy constructor")  
[Move constructor](move_constructor.html "cpp/language/move constructor") (C++11)  
[Copy assignment operator](as_operator.html "cpp/language/copy assignment")  
[Move assignment operator](move_operator.html "cpp/language/move assignment") (C++11)  
**Destructor**  
Inheritance  
[Base and derived classes](derived_class.html "cpp/language/derived class")  
[Empty base optimization (EBO)](ebo.html "cpp/language/ebo")  
[Virtual member functions](virtual.html "cpp/language/virtual")  
[Pure virtual functions and abstract classes](abstract_class.html "cpp/language/abstract class")  
[`override` specifier](override.html "cpp/language/override") (C++11)  
[`final` specifier](final.html "cpp/language/final") (C++11)  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/classes/navbar_content&action=edit)

A destructor is a special [member function](member_functions.html "cpp/language/member functions") that is called when the [lifetime of an object](lifetime.html "cpp/language/lifetime") ends. The purpose of the destructor is to free the resources that the object may have acquired during its lifetime. 

A destructor cannot be a [coroutine](coroutines.html "cpp/language/coroutines").  | (since C++20)  
---|---  
  
## Contents

  * [1 Syntax](destructor.html#Syntax)
  * [2 Explanation](destructor.html#Explanation)
  * [3 Prospective destructor](destructor.html#Prospective_destructor)
  * [4 Potentially-invoked destructor](destructor.html#Potentially-invoked_destructor)
  * [5 Implicitly-declared destructor](destructor.html#Implicitly-declared_destructor)
  * [6 Implicitly-defined destructor](destructor.html#Implicitly-defined_destructor)
  * [7 Deleted destructor](destructor.html#Deleted_destructor)
  * [8 Trivial destructor](destructor.html#Trivial_destructor)
  * [9 Destruction sequence](destructor.html#Destruction_sequence)
  * [10 Virtual destructors](destructor.html#Virtual_destructors)
  * [11 Pure virtual destructors](destructor.html#Pure_virtual_destructors)
  * [12 Exceptions](destructor.html#Exceptions)
  * [13 Notes](destructor.html#Notes)
  * [14 Example](destructor.html#Example)
  * [15 Defect reports](destructor.html#Defect_reports)
  * [16 See also](destructor.html#See_also)

  
---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/destructor&action=edit&section=1 "Edit section: Syntax")] Syntax

Destructors(until C++20)[Prospective destructors](destructor.html#Prospective_destructor)(since C++20) are declared using member [function declarators](function.html "cpp/language/function") of the following form:   
  
---  
class-name-with-tilde `**(**` parameter-list ﻿(optional) `**)**` except ﻿(optional) attr ﻿(optional) |  |   
class-name-with-tilde |  \-  |  an [identifier expression](expressions.html#Primary_expressions "cpp/language/expressions"), possibly followed by a list of [attributes](attributes.html "cpp/language/attributes"), and(since C++11) possibly enclosed by a pair parentheses   
---|---|---  
parameter-list |  \-  |  [parameter list](function.html#Parameter_list "cpp/language/function") (must be either empty or void)   
except |  \-  |  |  [dynamic exception specification](except_spec.html "cpp/language/except spec") | (until C++11)  
---|---  
either [dynamic exception specification](except_spec.html "cpp/language/except spec")  
or [noexcept specification](noexcept_spec.html "cpp/language/noexcept spec") | (since C++11)  
(until C++17)  
[noexcept specification](noexcept_spec.html "cpp/language/noexcept spec") | (since C++17)  
attr |  \-  |  (since C++11) a list of [attributes](attributes.html "cpp/language/attributes")  
  
The only specifiers allowed in the [declaration specifiers](declarations.html#Specifiers "cpp/language/declarations") of a prospective(since C++20) destructor declaration are[`constexpr`](constexpr.html "cpp/language/constexpr"),(since C++11) [`friend`](friend.html "cpp/language/friend"), [`inline`](inline.html "cpp/language/inline") and [`virtual`](virtual.html "cpp/language/virtual") (in particular, no return type is allowed). 

The identifier expression of class-name-with-tilde must have one of the following forms: 

  * In a member declaration that belongs to the [member specification](class.html#Member_specification "cpp/language/class") of a class or class template, but is not a [friend declaration](friend.html "cpp/language/friend"): 



    

  * For classes, the identifier expression is ~ followed by the [injected-class-name](injected-class-name.html "cpp/language/injected-class-name") of the immediately-enclosing class. 
  * For class templates, the identifier expression is ~ followed by a class name that names the [current instantiation](dependent_name.html#Current_instantiation "cpp/language/dependent name")(until C++20)the injected-class-name(since C++20) of the immediately-enclosing class template. 



  * Otherwise, the identifier expression is a qualified identifier whose terminal unqualified identifier is ~ followed by the injected-class name of the class nominated by the non-terminal parts of the qualified identifier. 



### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/destructor&action=edit&section=2 "Edit section: Explanation")] Explanation

The destructor is implicitly invoked whenever an object's [lifetime](lifetime.html "cpp/language/lifetime") ends, which includes 

  * [program termination](../utility/program/exit.html "cpp/utility/program/exit"), for objects with static [storage duration](storage_duration.html "cpp/language/storage duration")



  * thread exit, for objects with thread-local storage duration 

| (since C++11)  
---|---  
  
  * end of scope, for objects with automatic storage duration and for temporaries whose life was extended by binding to a reference 
  * [delete expression](delete.html "cpp/language/delete"), for objects with dynamic storage duration 
  * end of the full [expression](expressions.html "cpp/language/expressions"), for nameless temporaries 
  * [stack unwinding](throw.html#Stack_unwinding "cpp/language/throw"), for objects with automatic storage duration when an exception escapes their block, uncaught. 



The destructor can also be invoked explicitly. 

###  Prospective destructor

A class may have one or more prospective destructors, one of which is selected as the destructor for the class. In order to determine which prospective destructor is the destructor, at the end of the definition of the class, [overload resolution](overload_resolution.html "cpp/language/overload resolution") is performed among prospective destructors declared in the class with an empty argument list. If the overload resolution fails, the program is ill-formed. Destructor selection does not [odr-use](definition.html#One_Definition_Rule "cpp/language/definition") the selected destructor, and the selected destructor may be deleted. All prospective destructors are special member functions. If no user-declared prospective destructor is provided for class `T`, the compiler will always [implicitly declare](destructor.html#Implicitly-declared_destructor) one, and the implicitly-declared prospective destructor is also the destructor for `T`.  Run this code
    
    
    #include <cstdio>
    #include <type_traits>
     
    template<typename T>
    struct A
    {
        ~A() requires [std::is_integral_v](../types/is_integral.html)<T> { [std::puts](../io/c/puts.html)("~A, T is integral"); }
        ~A() requires [std::is_pointer_v](../types/is_pointer.html)<T> { [std::puts](../io/c/puts.html)("~A, T is a pointer"); }
        ~A() { [std::puts](../io/c/puts.html)("~A, T is anything else"); }
    };
     
    int main()
    {
        A<int> a;
        A<int*> b;
        A<float> c;
    }

Output: 
    
    
    ~A, T is anything else
    ~A, T is a pointer
    ~A, T is integral

| (since C++20)  
---|---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/destructor&action=edit&section=4 "Edit section: Potentially-invoked destructor")] Potentially-invoked destructor

The destructor for class `T` is _potentially invoked_ in the following situations: 

  * It is invoked explicitly or implicitly. 
  * A [new expression](new.html "cpp/language/new") creates an array of objects of type `T`. 
  * The result object of a [return statement](return.html "cpp/language/return") is of type `T`. 
  * An array is under [aggregate initialization](aggregate_initialization.html "cpp/language/aggregate initialization"), and its element type is `T`. 
  * A class object is under aggregate initialization, and it has a member of type `T` where `T` is not an [anonymous union](union.html#Anonymous_unions "cpp/language/union") type. 
  * A [potentially constructed subobject](objects.html#Potentially_constructed_subobjects "cpp/language/object") is of type `T` in a non-[delegating](initializer_list.html#Delegating_constructor "cpp/language/constructor")(since C++11) constructor. 
  * An [exception object](throw.html#Exception_object "cpp/language/throw") of type `T` is constructed. 



If a potentially-invoked destructor is deleted or(since C++11) not accessible from the context of the invocation, the program is ill-formed. 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/destructor&action=edit&section=5 "Edit section: Implicitly-declared destructor")] Implicitly-declared destructor

If no user-declared prospective(since C++20) destructor is provided for a [class type](class.html "cpp/language/class"), the compiler will always declare a destructor as an inline public member of its class. 

As with any implicitly-declared special member function, the exception specification of the implicitly-declared destructor is non-throwing unless the destructor of any potentially-constructed base or member is [potentially-throwing](noexcept_spec.html "cpp/language/noexcept spec")(since C++17)implicit definition would directly invoke a function with a different exception specification(until C++17). In practice, implicit destructors are noexcept unless the class is "poisoned" by a base or member whose destructor is noexcept(false). 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/destructor&action=edit&section=6 "Edit section: Implicitly-defined destructor")] Implicitly-defined destructor

If an implicitly-declared destructor is not deleted, it is implicitly defined (that is, a function body is generated and compiled) by the compiler when it is [odr-used](definition.html#ODR-use "cpp/language/definition"). This implicitly-defined destructor has an empty body. 

If this satisfies the requirements of a [constexpr destructor](constexpr.html#constexpr_destructor "cpp/language/constexpr")(until C++23)[constexpr function](constexpr.html#constexpr_function "cpp/language/constexpr")(since C++23), the generated destructor is constexpr.  | (since C++20)  
---|---  
  
  


###  Deleted destructor

The implicitly-declared or explicitly-defaulted destructor for class `T` is defined as deleted if any of the following conditions is satisfied:  | 

  * `T` has a [potentially constructed subobject](objects.html#Potentially_constructed_subobject "cpp/language/object") of class type `M` (or possibly multi-dimensional array thereof) such that `M` has a destructor that 



    

  * is deleted or inaccessible from the destructor of `T`, or 
  * in the case of the subobject being a [variant member](union.html#Union-like_classes "cpp/language/union"), is non-trivial. 


| (until C++26)  
---|---  
  
  * `T` is not a union, and has a non-[variant](union.html#Union-like_classes "cpp/language/union") [potentially constructed subobject](objects.html#Potentially_constructed_subobject "cpp/language/object") of class type `M` (or possibly multidimensional array thereof) such that `M` has a destructor that is deleted or inaccessible from the destructor of `T`. 
  * `T` is a union, and any of the following conditions is satisfied: 



    

  * The overload resolution to select a constructor to default-initialize an object of type `T` either fails or selects a constructor that is either deleted or non-trivial. 
  * `T` has a variant member `V` of class type `M` (or possibly multidimensional array thereof) where `V` has a default initializer and `M` has a destructor that is non-trivial. 


| (since C++26)  
  
  * The destructor is virtual and the lookup for the [deallocation function](../memory/new/operator_delete.html "cpp/memory/new/operator delete") results in 



    

  * an ambiguity, or 
  * a function that is deleted or inaccessible from the destructor. 


An explicitly-defaulted prospective destructor for `T` is defined as deleted if it is not the destructor for `T`.  | (since C++20)  
---|---  
(since C++11)  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/destructor&action=edit&section=8 "Edit section: Trivial destructor")] Trivial destructor

The destructor for class `T` is trivial if all following conditions are satisfied: 

  * The destructor is implicitly-declared(until C++11)not [user-provided](function.html#User-provided_functions "cpp/language/function")(since C++11). 
  * The destructor is not virtual. 
  * All direct base classes have trivial destructors. 



  * Every non-static data member of class type (or array of class type) has a trivial destructor. 

| (until C++26)  
---|---  
  
  * Either `T` is a union, or every non-variant non-static data member of class type (or array of class type) has a trivial destructor. 

| (since C++26)  
  
A trivial destructor is a destructor that performs no action. Objects with trivial destructors don't require a delete expression and may be disposed of by simply deallocating their storage. All data types compatible with the C language (POD types) are trivially destructible. 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/destructor&action=edit&section=9 "Edit section: Destruction sequence")] Destruction sequence

For both user-defined or implicitly-defined destructors, after executing the body of the destructor and destroying any automatic objects allocated within the body, the compiler calls the destructors for all non-static non-variant data members of the class, in reverse order of declaration, then it calls the destructors of all direct non-virtual base classes in [reverse order of construction](initializer_list.html#Initialization_order "cpp/language/initializer list") (which in turn call the destructors of their members and their base classes, etc), and then, if this object is of [most derived class](objects.html#Subobjects "cpp/language/object"), it calls the destructors of all virtual bases. 

Even when the destructor is called directly (e.g. obj.~Foo();), the return statement in ~Foo() does not return control to the caller immediately: it calls all those member and base destructors first. 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/destructor&action=edit&section=10 "Edit section: Virtual destructors")] Virtual destructors

Deleting an object through pointer to base invokes undefined behavior unless the destructor in the base class is [virtual](virtual.html "cpp/language/virtual"): 
    
    
    class Base
    {
    public:
        virtual ~Base() {}
    };
     
    class Derived : public Base {};
     
    Base* b = new Derived;
    delete b; // safe

A common guideline is that a destructor for a base class must be [either public and virtual or protected and nonvirtual](http://www.gotw.ca/publications/mill18.htm). 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/destructor&action=edit&section=11 "Edit section: Pure virtual destructors")] Pure virtual destructors

A prospective(since C++20) destructor may be declared [pure virtual](abstract_class.html "cpp/language/abstract class"), for example in a base class which needs to be made abstract, but has no other suitable functions that could be declared pure virtual. A pure virtual destructor must have a definition, since all base class destructors are always called when the derived class is destroyed: 
    
    
    class AbstractBase
    {
    public:
        virtual ~AbstractBase() = 0;
    };
    AbstractBase::~AbstractBase() {}
     
    class Derived : public AbstractBase {};
     
    // AbstractBase obj; // compiler error
    Derived obj;         // OK

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/destructor&action=edit&section=12 "Edit section: Exceptions")] Exceptions

As any other function, a destructor may terminate by throwing an [exception](exceptions.html "cpp/language/exceptions") (this usually requires it to be explicitly declared noexcept(false))(since C++11), however if this destructor happens to be called during [stack unwinding](throw.html#Stack_unwinding "cpp/language/throw"), [std::terminate](../error/terminate.html "cpp/error/terminate") is called instead. 

Although [std::uncaught_exceptions](../error/exception/uncaught_exception.html "cpp/error/uncaught exception") may sometimes be used to detect stack unwinding in progress, it is generally considered bad practice to allow any destructor to terminate by throwing an exception. This functionality is nevertheless used by some libraries, such as [SOCI](https://github.com/SOCI/soci) and [Galera 3](https://galeracluster.com/downloads/), which rely on the ability of the destructors of nameless temporaries to throw exceptions at the end of the full expression that constructs the temporary. 

[`std::experimental::scope_success`](../experimental/scope_success.html "cpp/experimental/scope success") in Library fundamental TS v3 may have [a potentially-throwing destructor](../experimental/scope_success/~scope_success.html "cpp/experimental/scope success/~scope success"), which throws an exception when the scope is exited normally and the exit function throws an exception. 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/destructor&action=edit&section=13 "Edit section: Notes")] Notes

Calling a destructor directly for an ordinary object, such as a local variable, invokes undefined behavior when the destructor is called again, at the end of scope. 

In generic contexts, the destructor call syntax can be used with an object of non-class type; this is known as pseudo-destructor call: see [member access operator](operator_member_access.html#Built-in_member_access_operators "cpp/language/operator member access"). 

Feature-test macro | Value | Std | Feature   
---|---|---|---  
[`__cpp_trivial_union`](../experimental/feature_test.html#cpp_trivial_union "cpp/feature test") | [`202502L`](../compiler_support/26.html#cpp_trivial_union_202502L "cpp/compiler support/26") | (C++26) | Relaxing the triviality requirements for special member functions of unions   
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/destructor&action=edit&section=14 "Edit section: Example")] Example

Run this code
    
    
    #include <iostream>
     
    struct A
    {
        int i;
     
        A(int num) : i(num)
        {
            [std::cout](../io/cout.html) << "ctor a" << i << '\n';
        }
     
        (~A)() // but usually ~A()
        {
            [std::cout](../io/cout.html) << "dtor a" << i << '\n';
        }
    };
     
    A a0(0);
     
    int main()
    {
        A a1(1);
        A* p;
     
        { // nested scope
            A a2(2);
            p = new A(3);
        } // a2 out of scope
     
        delete p; // calls the destructor of a3
    }

Output: 
    
    
    ctor a0
    ctor a1
    ctor a2
    ctor a3
    dtor a2
    dtor a3
    dtor a1
    dtor a0

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/destructor&action=edit&section=15 "Edit section: Defect reports")] Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[CWG 193](https://cplusplus.github.io/CWG/issues/193.html) | C++98  | whether automatic objects in a destructor are  
destroyed before or after the destruction of the  
class's base and member subobjects was unspecified  | they are destroyed  
before destroying  
those subobjects   
[CWG 344](https://cplusplus.github.io/CWG/issues/344.html) | C++98  | the declarator syntax of destructor was defective (had the  
same problem as [CWG issue 194](https://cplusplus.github.io/CWG/issues/194.html) and [CWG issue 263](https://cplusplus.github.io/CWG/issues/263.html) | changed the syntax to a specialized  
function declarator syntax   
[CWG 1241](https://cplusplus.github.io/CWG/issues/1241.html) | C++98  | static members might be destroyed  
right after destructor execution  | only destroy non-  
static members   
[CWG 1353](https://cplusplus.github.io/CWG/issues/1353.html) | C++98  | the conditions where implicitly-declared destructors are  
undefined did not consider multi-dimensional array types  | consider these types   
[CWG 1435](https://cplusplus.github.io/CWG/issues/1435.html) | C++98  | the meaning of “class name” in the  
declarator syntax of destructor was unclear  | changed the syntax to a specialized  
function declarator syntax   
[CWG 2180](https://cplusplus.github.io/CWG/issues/2180.html) | C++98  | the destructor of a class that is not a most derived class  
would call the destructors of its virtual direct base classes  | it will not call those destructors   
[CWG 2807](https://cplusplus.github.io/CWG/issues/2807.html) | C++20  | the declaration specifiers could contain consteval | prohibited   
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/destructor&action=edit&section=16 "Edit section: See also")] See also

  * [copy elision](copy_elision.html "cpp/language/copy elision")
  * [`new`](new.html "cpp/language/new")
  * [`delete`](delete.html "cpp/language/delete")


  *[Value]: The year/month in which the feature was adopted. The hyperlink under each value opens a compiler support page with entry for given feature.
  *[Std]: Standard in which the feature is introduced; DR means defect report against that revision
