[C++](../../cpp.html "cpp")

[Compiler support](../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../freestanding.html "cpp/freestanding")  
[Language](../language.html "cpp/language")  
[Standard library](../standard_library.html "cpp/standard library")  
[Standard library headers](../headers.html "cpp/header")  
[Named requirements](../iterator/concepts.html "cpp/named req")  
[Feature test macros](../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../utility.html#Language_support "cpp/utility")  
[Concepts library](../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../error.html "cpp/error")  
[Memory management library](../memory.html "cpp/memory")  
[Metaprogramming library](../meta.html "cpp/meta") (C++11)  
[General utilities library](../utility.html "cpp/utility")  
[Containers library](../container.html "cpp/container")  
[Iterators library](../iterator.html "cpp/iterator")  
[Ranges library](../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../algorithm.html "cpp/algorithm")  
[Strings library](../string.html "cpp/string")  
[Text processing library](../text.html "cpp/text")  
[Numerics library](../numeric.html "cpp/numeric")  
[Date and time library](../chrono.html "cpp/chrono")  
[Input/output library](../io.html "cpp/io")  
[Filesystem library](../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../atomic.html "cpp/thread") (C++11)  
[Execution control library](../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../experimental.html "cpp/experimental")  
[Symbols index](../symbol_index.html "cpp/symbol index")  
[External libraries](../links/libs.html "cpp/links/libs")  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/navbar_content&action=edit)

[C++ language](../language.html "cpp/language")

General topics  
---  
| [Preprocessor](../preprocessor.html "cpp/preprocessor")  
---  
[Comments](../comments.html "cpp/comment")  
  
| [Keywords](../keywords.html "cpp/keyword")  
---  
[Escape sequences](escape.html "cpp/language/escape")  
  
[Flow control](statements.html "cpp/language/statements")  
Conditional execution statements  
| [`if`](if.html "cpp/language/if")  
---  
  
| [`switch`](switch.html "cpp/language/switch")  
---  
  
Iteration statements (loops)  
| [`for`](for.html "cpp/language/for")  
---  
[range-`for`](range-for.html "cpp/language/range-for") (C++11)  
  
| [`while`](while.html "cpp/language/while")  
---  
[`do-while`](do.html "cpp/language/do")  
  
Jump statements  
| [`continue`](continue.html "cpp/language/continue") \- [`break`](break.html "cpp/language/break")  
---  
  
| [`goto`](goto.html "cpp/language/goto") \- [`return`](return.html "cpp/language/return")  
---  
  
[Functions](functions.html "cpp/language/functions")  
[Function declaration](function.html "cpp/language/function")  
[Lambda function expression](lambda.html "cpp/language/lambda")  
[`inline` specifier](inline.html "cpp/language/inline")  
[Dynamic exception specifications](except_spec.html "cpp/language/except spec") (until C++17*)  
[`noexcept` specifier](noexcept_spec.html "cpp/language/noexcept spec") (C++11)  
Exceptions  
| [`throw`-expression](throw.html "cpp/language/throw")  
---  
[`try` block](try.html "cpp/language/try")  
  
|   
  
---  
[`catch` handler](catch.html "cpp/language/catch")  
  
Namespaces  
| [Namespace declaration](namespace.html "cpp/language/namespace")` `  
---  
  
| [Namespace aliases](namespace_alias.html "cpp/language/namespace alias")  
---  
  
Types  
| [Fundamental types](types.html "cpp/language/types")  
---  
[Enumeration types](enum.html "cpp/language/enum")  
[Function types](function.html "cpp/language/function")  
  
| [Class/struct types](class.html "cpp/language/class")  
---  
[Union types](union.html "cpp/language/union")  
  
  
  
Specifiers  
| [`const`/`volatile`](cv.html "cpp/language/cv")  
---  
[`decltype`](decltype.html "cpp/language/decltype") (C++11)  
[`auto`](auto.html "cpp/language/auto") (C++11)  
  
| [`constexpr`](constexpr.html "cpp/language/constexpr") (C++11)  
---  
[`consteval`](consteval.html "cpp/language/consteval") (C++20)  
[`constinit`](constinit.html "cpp/language/constinit") (C++20)  
  
[Storage duration specifiers](storage_duration.html "cpp/language/storage duration")  
[Initialization](initialization.html "cpp/language/initialization")  
| [Default-initialization](default_initialization.html "cpp/language/default initialization")  
---  
[Value-initialization](value_initialization.html "cpp/language/value initialization")  
[Zero-initialization](zero_initialization.html "cpp/language/zero initialization")  
[Copy-initialization](copy_initialization.html "cpp/language/copy initialization")  
[Direct-initialization](direct_initialization.html "cpp/language/direct initialization")  
  
| [Aggregate initialization](aggregate_initialization.html "cpp/language/aggregate initialization")  
---  
[List-initialization](list_initialization.html "cpp/language/list initialization") (C++11)` `  
[Constant initialization](constant_initialization.html "cpp/language/constant initialization")  
[Reference initialization](reference_initialization.html "cpp/language/reference initialization")  
  
  
  
[Expressions](expressions.html "cpp/language/expressions")  
---  
| [Value categories](value_category.html "cpp/language/value category")  
---  
[Order of evaluation](eval_order.html "cpp/language/eval order")  
  
| [Operators](operators.html "cpp/language/operators")  
---  
[Operator precedence](operator_precedence.html "cpp/language/operator precedence")  
  
[Alternative representations](operator_alternative.html "cpp/language/operator alternative")  
[Literals](expressions.html#Literals "cpp/language/expressions")  
[Boolean](bool_literal.html "cpp/language/bool literal") \- [Integer](integer_literal.html "cpp/language/integer literal") \- [Floating-point](floating_literal.html "cpp/language/floating literal")  
[Character](character_literal.html "cpp/language/character literal") \- [String](string_literal.html "cpp/language/string literal") \- [`nullptr`](nullptr.html "cpp/language/nullptr") (C++11)  
[User-defined](user_literal.html "cpp/language/user literal") (C++11)  
Utilities  
[Attributes](attributes.html "cpp/language/attributes") (C++11)  
Types  
[`typedef` declaration](typedef.html "cpp/language/typedef")  
[Type alias declaration](type_alias.html "cpp/language/type alias") (C++11)  
Casts  
| [Implicit conversions](implicit_cast.html "cpp/language/implicit conversion")  
---  
[`static_cast`](static_cast.html "cpp/language/static cast")  
[`const_cast`](const_cast.html "cpp/language/const cast")  
  
| [Explicit conversions](explicit_cast.html "cpp/language/explicit cast")  
---  
[`dynamic_cast`](dynamic_cast.html "cpp/language/dynamic cast")  
[`reinterpret_cast`](reinterpret_cast.html "cpp/language/reinterpret cast")  
  
Memory allocation  
| [`new` expression](new.html "cpp/language/new")  
---  
  
| [`delete` expression](delete.html "cpp/language/delete")  
---  
  
[Classes](classes.html "cpp/language/classes")  
| [Class declaration](class.html "cpp/language/class")  
---  
[Constructors](initializer_list.html "cpp/language/constructor")  
[`this` pointer](this.html "cpp/language/this")  
  
| [Access specifiers](access.html "cpp/language/access")  
---  
[`friend` specifier](friend.html "cpp/language/friend")  
  
  
  
Class-specific function properties  
| [Virtual function](virtual.html "cpp/language/virtual")  
---  
[`override` specifier](override.html "cpp/language/override") (C++11)` `  
[`final` specifier](final.html "cpp/language/final") (C++11)  
  
| [`explicit`](explicit.html "cpp/language/explicit") (C++11)  
---  
[`static`](static.html "cpp/language/static")  
  
  
  
Special member functions  
| [Default constructor](default_constructor.html "cpp/language/default constructor")  
---  
[Copy constructor](copy_constructor.html "cpp/language/copy constructor")  
[Move constructor](move_constructor.html "cpp/language/move constructor") (C++11)  
  
| [Copy assignment](as_operator.html "cpp/language/as operator")  
---  
[Move assignment](move_operator.html "cpp/language/move operator") (C++11)  
[Destructor](destructor.html "cpp/language/destructor")  
  
[Templates](templates.html "cpp/language/templates")  
| [Class template](class_template.html "cpp/language/class template")  
---  
[Function template](function_template.html "cpp/language/function template")  
  
| [Template specialization](template_specialization.html "cpp/language/template specialization")  
---  
[Parameter packs](parameter_pack.html "cpp/language/pack") (C++11)  
  
Miscellaneous  
| [Inline assembly](asm.html "cpp/language/asm")  
---  
  
| [History of C++](history.html "cpp/language/history")  
---  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/navbar_content&action=edit)

[ Basic Concepts](basics.html "cpp/language/basic concepts")

[Comments](../comments.html "cpp/comment")  
---  
[ASCII](ascii.html "cpp/language/ascii")  
[Punctuation](punctuators.html "cpp/language/punctuators")  
[Names and identifiers](name.html "cpp/language/identifiers")  
[Types](type-id.html "cpp/language/type")  
[Fundamental types](types.html "cpp/language/types")  
[Objects](objects.html "cpp/language/object")  
[Scope](scope.html "cpp/language/scope")  
[Object lifetime](lifetime.html "cpp/language/lifetime")  
[Storage duration and linkage](storage_duration.html "cpp/language/storage duration")  
[Definitions and ODR](definition.html "cpp/language/definition")  
[Name lookup](lookup.html "cpp/language/lookup")  
[ Qualified name lookup](qualified_lookup.html "cpp/language/qualified lookup")  
[ Unqualified name lookup](unqualified_lookup.html "cpp/language/unqualified lookup")  
[The as-if rule](as_if.html "cpp/language/as if")  
[Undefined behavior](ub.html "cpp/language/ub")  
[Memory model](memory_model.html "cpp/language/memory model")  
**Multi-threaded executions and data races** (C++11)  
[Character sets and encodings](charset.html "cpp/language/charset")  
[Phases of translation](translation_phases.html "cpp/language/translation phases")  
[The `main` function](main_function.html "cpp/language/main function")  
[Modules](modules.html "cpp/language/modules") (C++20)  
[Contracts](contracts.html "cpp/language/contracts") (C++26)  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/basics/navbar_content&action=edit)

A _thread of execution_ is a flow of control within a program that begins with the invocation of a specific top-level function (by [std::thread](../thread/thread.html "cpp/thread/thread"), [std::async](../thread/async.html "cpp/thread/async"), [std::jthread](../thread/jthread.html "cpp/thread/jthread")(since C++20) or other means), and recursively including every function invocation subsequently executed by the thread. 

  * When one thread creates another, the initial call to the top-level function of the new thread is executed by the new thread, not by the creating thread. 



Any thread can potentially access any object and function in the program: 

  * Objects with automatic and thread-local [storage duration](storage_duration.html "cpp/language/storage duration") may still be accessed by another thread through a pointer or by reference. 
  * Under a [hosted implementation](../freestanding.html "cpp/freestanding"), a C++ program can have more than one thread running concurrently. The execution of each thread proceeds as defined by the rest of this page. The execution of the entire program consists of an execution of all of its threads. 
  * Under a [freestanding implementation](../freestanding.html "cpp/freestanding"), it is implementation-defined whether a program can have more than one thread of execution. 



For a [signal handler](../utility/program/signal.html#Signal_handler "cpp/utility/program/signal") that is not executed as a result of a call to [std::raise](../utility/program/raise.html "cpp/utility/program/raise"), it is unspecified which thread of execution contains the signal handler invocation. 

## Contents

  * [1 Data races](multithread.html#Data_races)
    * [1.1 Container data races](multithread.html#Container_data_races)
  * [2 Memory order](multithread.html#Memory_order)
  * [3 Forward progress](multithread.html#Forward_progress)
    * [3.1 Obstruction freedom](multithread.html#Obstruction_freedom)
    * [3.2 Lock freedom](multithread.html#Lock_freedom)
    * [3.3 Progress guarantee](multithread.html#Progress_guarantee)
    * [3.4 Trivial infinite loops](multithread.html#Trivial_infinite_loops)
    * [3.5 Concurrent forward progress](multithread.html#Concurrent_forward_progress)
    * [3.6 Parallel forward progress](multithread.html#Parallel_forward_progress)
    * [3.7 Weakly parallel forward progress](multithread.html#Weakly_parallel_forward_progress)
  * [4 Defect reports](multithread.html#Defect_reports)

  
---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/multithread&action=edit&section=1 "Edit section: Data races")] Data races

Different threads of execution are always allowed to access (read and modify) different [memory locations](memory_model.html#Memory_location "cpp/language/memory model") concurrently, with no interference and no synchronization requirements. 

Two expression [evaluations](eval_order.html "cpp/language/eval order") _conflict_ if one of them modifies a memory location or starts/ends the lifetime of an object in a memory location, and the other one reads or modifies the same memory location or starts/ends the lifetime of an object occupying storage that overlaps with the memory location. 

A program that has two conflicting evaluations has a _data race_ unless 

  * both evaluations execute on the same thread or in the same [signal handler](../utility/program/signal.html#Signal_handler "cpp/utility/program/signal"), or 
  * both conflicting evaluations are atomic operations (see [std::atomic](../atomic/atomic.html "cpp/atomic/atomic")), or 
  * one of the conflicting evaluations _happens-before_ another (see [std::memory_order](../atomic/memory_order.html "cpp/atomic/memory order")). 



If a data race occurs, the behavior of the program is undefined. 

(In particular, release of a [std::mutex](../thread/mutex.html "cpp/thread/mutex") is _synchronized-with_ , and therefore, _happens-before_ acquisition of the same mutex by another thread, which makes it possible to use mutex locks to guard against data races.) 
    
    
    int cnt = 0;
    auto f = [&] { cnt++; };
    [std::thread](../thread/thread.html) t1{f}, t2{f}, t3{f}; // undefined behavior
    
    
    [std::atomic](../atomic/atomic.html)<int> cnt{0};
    auto f = [&] { cnt++; };
    [std::thread](../thread/thread.html) t1{f}, t2{f}, t3{f}; // OK

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/multithread&action=edit&section=2 "Edit section: Container data races")] Container data races

All [containers](../container.html "cpp/container") in the standard library except [`std`::vector<bool>](../container/vector_bool.html "cpp/container/vector bool") guarantee that concurrent modifications on contents of the contained object in different elements in the same container will never result in data races. 
    
    
    [std::vector](../container/vector.html)<int> vec = {1, 2, 3, 4};
    auto f = [&](int index) { vec[index] = 5; };
    [std::thread](../thread/thread.html) t1{f, 0}, t2{f, 1}; // OK
    [std::thread](../thread/thread.html) t3{f, 2}, t4{f, 2}; // undefined behavior
    
    
    [std::vector](../container/vector.html)<bool> vec = {false, false};
    auto f = [&](int index) { vec[index] = true; };
    [std::thread](../thread/thread.html) t1{f, 0}, t2{f, 1}; // undefined behavior

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/multithread&action=edit&section=3 "Edit section: Memory order")] Memory order

When a thread reads a value from a memory location, it may see the initial value, the value written in the same thread, or the value written in another thread. See [std::memory_order](../atomic/memory_order.html "cpp/atomic/memory order") for details on the order in which writes made from threads become visible to other threads. 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/multithread&action=edit&section=4 "Edit section: Forward progress")] Forward progress

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/multithread&action=edit&section=5 "Edit section: Obstruction freedom")] Obstruction freedom

When only one thread that is not blocked in a standard library function executes an [atomic function](../atomic.html#Atomic_operations "cpp/thread") that is lock-free, that execution is guaranteed to complete (all standard library lock-free operations are [obstruction-free](https://en.wikipedia.org/wiki/Non-blocking_algorithm#Obstruction-freedom "enwiki:Non-blocking algorithm")). 

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/multithread&action=edit&section=6 "Edit section: Lock freedom")] Lock freedom

When one or more lock-free atomic functions run concurrently, at least one of them is guaranteed to complete (all standard library lock-free operations are [lock-free](https://en.wikipedia.org/wiki/Non-blocking_algorithm#Lock-freedom "enwiki:Non-blocking algorithm") — it is the job of the implementation to ensure they cannot be live-locked indefinitely by other threads, such as by continuously stealing the cache line). 

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/multithread&action=edit&section=7 "Edit section: Progress guarantee")] Progress guarantee

In a valid C++ program, every thread eventually does one of the following: 

  * Terminates. 
  * Invokes [std::this_thread::yield](../thread/yield.html "cpp/thread/yield"). 
  * Makes a call to an library I/O function. 
  * Performs an access through a [volatile](cv.html "cpp/language/cv") glvalue. 
  * Performs an atomic operation or a synchronization operation. 
  * Continues execution of a trivial infinite loop (see below). 



A thread is said to _make progress_ if it performs one of the execution steps above, blocks in a standard library function, or calls an atomic lock-free function that does not complete because of a non-blocked concurrent thread. 

This allows the compilers to remove, merge and reorder all loops that have no observable behavior, without having to prove that they would eventually terminate because it can assume that no thread of execution can execute forever without performing any of these observable behaviors. An affordance is made for trivial infinite loops, which cannot be removed nor reordered. 

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/multithread&action=edit&section=8 "Edit section: Trivial infinite loops")] Trivial infinite loops

A _trivially empty iteration statement_ is an iteration statement matching one of the following forms:   
  
---  
`**while (**` condition `**) ;**` |  (1)  |   
`**while (**` condition `**) { }**` |  (2)  |   
`**do ; while (**` condition `**) ;**` |  (3)  |   
`**do { } while (**` condition `**) ;**` |  (4)  |   
`**for (**` init-statement condition ﻿(optional) `**; ) ;**` |  (5)  |   
`**for (**` init-statement condition ﻿(optional) `**; ) { }**` |  (6)  |   
  
1) A [while statement](while.html "cpp/language/while") whose loop body is an empty simple statement.

2) A [while statement](while.html "cpp/language/while") whose loop body is an empty compound statement.

3) A [do-while statement](do.html "cpp/language/do") whose loop body is an empty simple statement.

4) A [do-while statement](do.html "cpp/language/do") whose loop body is an empty compound statement.

5) A [for statement](for.html "cpp/language/for") whose loop body is an empty simple statement, the for statement does not have an iteration-expression.

6) A [for statement](for.html "cpp/language/for") whose loop body is an empty compound statement, the for statement does not have an iteration-expression.

The _controlling expression_ of a trivially empty iteration statement is: 

1-4) condition.

5,6) condition if present, otherwise true.

A _trivial infinite loop_ is a trivially empty iteration statement for which the converted controlling expression is a [constant expression](constant_expression.html "cpp/language/constant expression"), when [manifestly constant-evaluated](constant_expression.html#Manifestly_constant-evaluated_expressions "cpp/language/constant expression"), and evaluates to true. 

The loop body of a trivial infinite loop is replaced with a call to the function [std::this_thread::yield](../thread/yield.html "cpp/thread/yield"). It is implementation-defined whether this replacement occurs on [freestanding implementations](../freestanding.html "cpp/freestanding"). 
    
    
    for (;;); // trivial infinite loop, well defined as of P2809
    for (;;) { int x; } // undefined behavior

####  Concurrent forward progress

If a thread offers _concurrent forward progress guarantee_ , it will _make progress_ (as defined above) in finite amount of time, for as long as it has not terminated, regardless of whether other threads (if any) are making progress. The standard encourages, but doesn't require that the main thread and the threads started by [std::thread](../thread/thread.html "cpp/thread/thread") and [std::jthread](../thread/jthread.html "cpp/thread/jthread")(since C++20) offer concurrent forward progress guarantee. 

####  Parallel forward progress

If a thread offers _parallel forward progress guarantee_ , the implementation is not required to ensure that the thread will eventually make progress if it has not yet executed any execution step (I/O, volatile, atomic, or synchronization), but once this thread has executed a step, it provides _concurrent forward progress_ guarantees (this rule describes a thread in a thread pool that executes tasks in arbitrary order). 

####  Weakly parallel forward progress

If a thread offers _weakly parallel forward progress guarantee_ , it does not guarantee to eventually make progress, regardless of whether other threads make progress or not. Such threads can still be guaranteed to make progress by blocking with forward progress guarantee delegation: if a thread `P` blocks in this manner on the completion of a set of threads `S`, then at least one thread in `S` will offer a forward progress guarantee that is same or stronger than `P`. Once that thread completes, another thread in `S` will be similarly strengthened. Once the set is empty, `P` will unblock. The [parallel algorithms](../algorithm.html "cpp/algorithm") from the C++ standard library block with forward progress delegation on the completion of an unspecified set of library-managed threads.  | (since C++17)  
---|---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/multithread&action=edit&section=12 "Edit section: Defect reports")] Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[CWG 1953](https://cplusplus.github.io/CWG/issues/1953.html) | C++11  | two expression evaluations that start/end the lifetimes  
of objects with overlapping storages did not conflict  | they conflict   
[LWG 2200](https://cplusplus.github.io/LWG/issue2200) | C++11  | it was unclear whether the container data race  
requirement only applies to sequence containers  | applies to all containers   
[P2809R3](https://wg21.link/P2809R3) | C++11  | the behavior of executing “trivial”[[1]](multithread.html#cite_note-1)  
infinite loops was undefined  | properly defines “trivial infinite loops”  
and made the behavior well-defined   
  
  1. [↑](multithread.html#cite_ref-1) “Trivial” here means executing the infinite loop never makes any progress.


