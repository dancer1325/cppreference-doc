[C++](../../cpp.html "cpp")

[Compiler support](../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../freestanding.html "cpp/freestanding")  
[Language](../language.html "cpp/language")  
[Standard library](../standard_library.html "cpp/standard library")  
[Standard library headers](../headers.html "cpp/header")  
[Named requirements](../iterator/concepts.html "cpp/named req")  
[Feature test macros](../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../utility.html#Language_support "cpp/utility")  
[Concepts library](../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../error.html "cpp/error")  
[Memory management library](../memory.html "cpp/memory")  
[Metaprogramming library](../meta.html "cpp/meta") (C++11)  
[General utilities library](../utility.html "cpp/utility")  
[Containers library](../container.html "cpp/container")  
[Iterators library](../iterator.html "cpp/iterator")  
[Ranges library](../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../algorithm.html "cpp/algorithm")  
[Strings library](../string.html "cpp/string")  
[Text processing library](../text.html "cpp/text")  
[Numerics library](../numeric.html "cpp/numeric")  
[Date and time library](../chrono.html "cpp/chrono")  
[Input/output library](../io.html "cpp/io")  
[Filesystem library](../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../atomic.html "cpp/thread") (C++11)  
[Execution control library](../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../experimental.html "cpp/experimental")  
[Symbols index](../symbol_index.html "cpp/symbol index")  
[External libraries](../links/libs.html "cpp/links/libs")  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/navbar_content&action=edit)

[C++ language](../language.html "cpp/language")

General topics  
---  
| [Preprocessor](../preprocessor.html "cpp/preprocessor")  
---  
[Comments](../comments.html "cpp/comment")  
  
| [Keywords](../keywords.html "cpp/keyword")  
---  
[Escape sequences](escape.html "cpp/language/escape")  
  
[Flow control](statements.html "cpp/language/statements")  
Conditional execution statements  
| [`if`](if.html "cpp/language/if")  
---  
  
| [`switch`](switch.html "cpp/language/switch")  
---  
  
Iteration statements (loops)  
| [`for`](for.html "cpp/language/for")  
---  
[range-`for`](range-for.html "cpp/language/range-for") (C++11)  
  
| [`while`](while.html "cpp/language/while")  
---  
[`do-while`](do.html "cpp/language/do")  
  
Jump statements  
| [`continue`](continue.html "cpp/language/continue") \- [`break`](break.html "cpp/language/break")  
---  
  
| [`goto`](goto.html "cpp/language/goto") \- [`return`](return.html "cpp/language/return")  
---  
  
[Functions](functions.html "cpp/language/functions")  
[Function declaration](function.html "cpp/language/function")  
[Lambda function expression](lambda.html "cpp/language/lambda")  
[`inline` specifier](inline.html "cpp/language/inline")  
[Dynamic exception specifications](except_spec.html "cpp/language/except spec") (until C++17*)  
[`noexcept` specifier](noexcept_spec.html "cpp/language/noexcept spec") (C++11)  
Exceptions  
| [`throw`-expression](throw.html "cpp/language/throw")  
---  
[`try` block](try.html "cpp/language/try")  
  
|   
  
---  
[`catch` handler](catch.html "cpp/language/catch")  
  
Namespaces  
| [Namespace declaration](namespace.html "cpp/language/namespace")` `  
---  
  
| [Namespace aliases](namespace_alias.html "cpp/language/namespace alias")  
---  
  
Types  
| [Fundamental types](types.html "cpp/language/types")  
---  
**Enumeration types**  
[Function types](function.html "cpp/language/function")  
  
| [Class/struct types](class.html "cpp/language/class")  
---  
[Union types](union.html "cpp/language/union")  
  
  
  
Specifiers  
| [`const`/`volatile`](cv.html "cpp/language/cv")  
---  
[`decltype`](decltype.html "cpp/language/decltype") (C++11)  
[`auto`](auto.html "cpp/language/auto") (C++11)  
  
| [`constexpr`](constexpr.html "cpp/language/constexpr") (C++11)  
---  
[`consteval`](consteval.html "cpp/language/consteval") (C++20)  
[`constinit`](constinit.html "cpp/language/constinit") (C++20)  
  
[Storage duration specifiers](storage_duration.html "cpp/language/storage duration")  
[Initialization](initialization.html "cpp/language/initialization")  
| [Default-initialization](default_initialization.html "cpp/language/default initialization")  
---  
[Value-initialization](value_initialization.html "cpp/language/value initialization")  
[Zero-initialization](zero_initialization.html "cpp/language/zero initialization")  
[Copy-initialization](copy_initialization.html "cpp/language/copy initialization")  
[Direct-initialization](direct_initialization.html "cpp/language/direct initialization")  
  
| [Aggregate initialization](aggregate_initialization.html "cpp/language/aggregate initialization")  
---  
[List-initialization](list_initialization.html "cpp/language/list initialization") (C++11)` `  
[Constant initialization](constant_initialization.html "cpp/language/constant initialization")  
[Reference initialization](reference_initialization.html "cpp/language/reference initialization")  
  
  
  
[Expressions](expressions.html "cpp/language/expressions")  
---  
| [Value categories](value_category.html "cpp/language/value category")  
---  
[Order of evaluation](eval_order.html "cpp/language/eval order")  
  
| [Operators](operators.html "cpp/language/operators")  
---  
[Operator precedence](operator_precedence.html "cpp/language/operator precedence")  
  
[Alternative representations](operator_alternative.html "cpp/language/operator alternative")  
[Literals](expressions.html#Literals "cpp/language/expressions")  
[Boolean](bool_literal.html "cpp/language/bool literal") \- [Integer](integer_literal.html "cpp/language/integer literal") \- [Floating-point](floating_literal.html "cpp/language/floating literal")  
[Character](character_literal.html "cpp/language/character literal") \- [String](string_literal.html "cpp/language/string literal") \- [`nullptr`](nullptr.html "cpp/language/nullptr") (C++11)  
[User-defined](user_literal.html "cpp/language/user literal") (C++11)  
Utilities  
[Attributes](attributes.html "cpp/language/attributes") (C++11)  
Types  
[`typedef` declaration](typedef.html "cpp/language/typedef")  
[Type alias declaration](type_alias.html "cpp/language/type alias") (C++11)  
Casts  
| [Implicit conversions](implicit_cast.html "cpp/language/implicit conversion")  
---  
[`static_cast`](static_cast.html "cpp/language/static cast")  
[`const_cast`](const_cast.html "cpp/language/const cast")  
  
| [Explicit conversions](explicit_cast.html "cpp/language/explicit cast")  
---  
[`dynamic_cast`](dynamic_cast.html "cpp/language/dynamic cast")  
[`reinterpret_cast`](reinterpret_cast.html "cpp/language/reinterpret cast")  
  
Memory allocation  
| [`new` expression](new.html "cpp/language/new")  
---  
  
| [`delete` expression](delete.html "cpp/language/delete")  
---  
  
[Classes](classes.html "cpp/language/classes")  
| [Class declaration](class.html "cpp/language/class")  
---  
[Constructors](initializer_list.html "cpp/language/constructor")  
[`this` pointer](this.html "cpp/language/this")  
  
| [Access specifiers](access.html "cpp/language/access")  
---  
[`friend` specifier](friend.html "cpp/language/friend")  
  
  
  
Class-specific function properties  
| [Virtual function](virtual.html "cpp/language/virtual")  
---  
[`override` specifier](override.html "cpp/language/override") (C++11)` `  
[`final` specifier](final.html "cpp/language/final") (C++11)  
  
| [`explicit`](explicit.html "cpp/language/explicit") (C++11)  
---  
[`static`](static.html "cpp/language/static")  
  
  
  
Special member functions  
| [Default constructor](default_constructor.html "cpp/language/default constructor")  
---  
[Copy constructor](copy_constructor.html "cpp/language/copy constructor")  
[Move constructor](move_constructor.html "cpp/language/move constructor") (C++11)  
  
| [Copy assignment](as_operator.html "cpp/language/as operator")  
---  
[Move assignment](move_operator.html "cpp/language/move operator") (C++11)  
[Destructor](destructor.html "cpp/language/destructor")  
  
[Templates](templates.html "cpp/language/templates")  
| [Class template](class_template.html "cpp/language/class template")  
---  
[Function template](function_template.html "cpp/language/function template")  
  
| [Template specialization](template_specialization.html "cpp/language/template specialization")  
---  
[Parameter packs](parameter_pack.html "cpp/language/pack") (C++11)  
  
Miscellaneous  
| [Inline assembly](asm.html "cpp/language/asm")  
---  
  
| [History of C++](history.html "cpp/language/history")  
---  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/navbar_content&action=edit)

[Declarations](declarations.html "cpp/language/declarations")

| Overview  
---  
[Declaration syntax](declarations.html "cpp/language/declarations")  
[_decl-specifier-seq_](declarations.html#Specifiers "cpp/language/declarations")  
[Declarator](declarations.html#Declarators "cpp/language/declarations")  
[Conflicting declarations](conflicting_declarations.html "cpp/language/conflicting declarations")  
Specifiers  
[typedef](typedef.html "cpp/language/typedef")  
[inline](inline.html "cpp/language/inline")  
[virtual function specifier](virtual.html "cpp/language/virtual")  
[explicit function specifier](explicit.html "cpp/language/explicit")  
[friend](friend.html "cpp/language/friend")  
[constexpr](constexpr.html "cpp/language/constexpr")(C++11)  
[consteval](consteval.html "cpp/language/consteval")(C++20)  
[constinit](constinit.html "cpp/language/constinit")(C++20)  
[Storage class specifiers](storage_duration.html "cpp/language/storage duration")  
[Translation-unit-local](tu_local.html "cpp/language/tu local") (C++20)  
[class/struct](class.html "cpp/language/class")  
[union](union.html "cpp/language/union")  
**enum**  
[decltype](decltype.html "cpp/language/decltype")(C++11)  
[auto](auto.html "cpp/language/auto")(C++11)  
[alignas](alignas.html "cpp/language/alignas")(C++11)  
[constvolatile](cv.html "cpp/language/cv")  
[Pack indexing specifier](pack_indexing.html#Pack_indexing_specifier "cpp/language/pack indexing") (C++26)  
[Elaborated type specifier](elaborated_type_specifier.html "cpp/language/elaborated type specifier")  
[Attributes](attributes.html "cpp/language/attributes") (C++11)  
  
| Declarators  
---  
[Reference](reference.html "cpp/language/reference")  
[Pointer](pointer.html "cpp/language/pointer")  
[Array](array.html "cpp/language/array")  
Block declarations  
[Simple-declaration](declarations.html "cpp/language/declarations")  
→[Structured binding declaration](structured_binding.html "cpp/language/structured binding") (C++17)  
[Alias declaration](type_alias.html "cpp/language/type alias") (C++11)  
[Namespace alias definition](namespace_alias.html "cpp/language/namespace alias")  
[using declaration](using_declaration.html "cpp/language/using declaration")  
[`using` directive](namespace.html#Using-directives "cpp/language/namespace")  
[static_assert declaration](static_assert.html "cpp/language/static assert") (C++11)  
[asm declaration](asm.html "cpp/language/asm")  
**Opaque enum declaration** (C++11)  
Other declarations  
[Namespace definition](namespace.html "cpp/language/namespace")  
[Function declaration](function.html "cpp/language/function")  
[Class template declaration](class_template.html "cpp/language/class template")  
[Function template declaration](function_template.html "cpp/language/function template")  
[Explicit template instantiation](class_template.html#Explicit_instantiation "cpp/language/class template") (C++11)  
[Explicit template specialization](template_specialization.html "cpp/language/template specialization")  
[Linkage specification](language_linkage.html "cpp/language/language linkage")  
[Attribute declaration](declarations.html "cpp/language/declarations") (C++11)  
[Empty declaration](declarations.html "cpp/language/declarations")  
  
  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/declarations/navbar_content&action=edit)

An _enumeration_ is a distinct type whose value is restricted to a range of values (see below for details), which may include several explicitly named constants ("_enumerators_ "). 

The values of the constants are values of an integral type known as the _underlying type_ of the enumeration. An enumeration has the same [size](sizeof.html "cpp/language/sizeof"), [value representation](objects.html#Object_representation_and_value_representation "cpp/language/object"), and [alignment requirements](objects.html#Alignment "cpp/language/object") as its underlying type. Furthermore, each value of an enumeration has the same representation as the corresponding value of the underlying type. 

An enumeration is (re)declared using the following syntax:   
  
---  
enum-key attr ﻿(optional) enum-head-name ﻿(optional) enum-base ﻿(optional)  
`**{**` enumerator-list ﻿(optional) `**}**` |  (1)  |   
enum-key attr ﻿(optional) enum-head-name ﻿(optional) enum-base ﻿(optional)  
`**{**` enumerator-list `**, }**` |  (2)  |   
enum-key attr ﻿(optional) enum-head-name enum-base ﻿(optional) `**;**` |  (3)  |  (since C++11)  
  
1) enum-specifier, which appears in decl-specifier-seq of the [declaration](declarations.html "cpp/language/declarations") syntax: defines the enumeration type and its enumerators.

2) A trailing comma can follow the enumerator-list.

3) Opaque enum declaration: defines the enumeration type but not its enumerators: after this declaration, the type is a complete type and its size is known.

enum-key |  \-  |  |  `**enum**` | (until C++11)  
---|---  
one of `**enum**`, `**enum class**`, or `**enum struct**` | (since C++11)  
attr |  \-  |  (since C++11) optional sequence of any number of [attributes](attributes.html "cpp/language/attributes")  
enum-head-name |  \-  |  |  the name of the enumeration that's being declared, it can be omitted.  | (until C++11)  
---|---  
the name of the enumeration that's being declared, optionally preceded by a nested-name-specifier: sequence of names and scope-resolution operators `::`, ending with scope-resolution operator. It can only be omitted in unscoped non-opaque enumeration declarations.  
nested-name-specifier may only appear if the enumeration name is present and this declaration is a redeclaration. For opaque enumeration declarations, nested-name-specifier can only appear before the name of the enumeration in [explicit specialization declarations](template_specialization.html "cpp/language/template specialization").  
If nested-name-specifier is present, the _enum-specifier_ cannot refer to an enumeration merely inherited or introduced by a [using declaration](using_declaration.html "cpp/language/using declaration"), and the _enum-specifier_ can only appear in a namespace enclosing the previous declaration. In such cases, nested-name-specifier cannot begin with a [decltype](decltype.html "cpp/language/decltype") specifier.  | (since C++11)  
enum-base |  \-  |  (since C++11) colon (`**:**`), followed by a type-specifier-seq that names an integral type (if it is cv-qualified, qualifications are ignored) that will serve as the fixed underlying type for this enumeration type   
enumerator-list |  \-  |  comma-separated list of enumerator definitions, each of which is either simply a unique identifier, which becomes the name of the enumerator, or a unique identifier with a constant expression: identifier `**=**` constant-expression. In either case, the identifier can be directly followed by an optional [attribute specifier sequence](attributes.html "cpp/language/attributes").(since C++17)  
  
There are two distinct kinds of enumerations: _unscoped enumeration_ (declared with the enum-key `**enum**`) and _scoped enumeration_ (declared with the enum-key `**enum class**` or `**enum struct**`). 

## Contents

  * [1 Unscoped enumerations](enum.html#Unscoped_enumerations)
    * [1.1 Enumeration name for linkage purposes](enum.html#Enumeration_name_for_linkage_purposes)
  * [2 Scoped enumerations](enum.html#Scoped_enumerations)
  * [3 using enum declaration](enum.html#using_enum_declaration)
  * [4 Notes](enum.html#Notes)
  * [5 Keywords](enum.html#Keywords)
  * [6 Example](enum.html#Example)
  * [7 Defect reports](enum.html#Defect_reports)
  * [8 References](enum.html#References)
  * [9 See also](enum.html#See_also)

  
---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/enum&action=edit&section=1 "Edit section: Unscoped enumerations")] Unscoped enumerations  
  
---  
`**enum**` name ﻿(optional) `**{**` enumerator `**=**` constant-expression `**,**` enumerator `**=**` constant-expression `**,**` ... `**}**` |  (1)  |   
`**enum**` name ﻿(optional) `**:**` type `**{**` enumerator `**=**` constant-expression `**,**` enumerator `**=**` constant-expression `**,**` ... `**}**` |  (2)  |  (since C++11)  
`**enum**` name `**:**` type `**;**` |  (3)  |  (since C++11)  
  
1) Declares an unscoped enumeration type whose underlying type is not fixed (in this case, the underlying type is an implementation-defined integral type that can represent all enumerator values; this type is not larger than int unless the value of an enumerator cannot fit in an int or unsigned int. If the enumerator-list is empty, the underlying type is as if the enumeration had a single enumerator with value ​0​. If no integral type can represent all the enumerator values, the enumeration is ill-formed).

2) Declares an unscoped enumeration type whose underlying type is fixed.

3) Opaque enum declaration for an unscoped enumeration must specify the name and the underlying type.

Each enumerator becomes a named constant of the enumeration's type (that is, name), visible in the enclosing scope, and can be used whenever constants are required. 
    
    
    enum Color { red, green, blue };
    Color r = red;
     
    switch(r)
    {
        case red  : [std::cout](../io/cout.html) << "red\n";   break;
        case green: [std::cout](../io/cout.html) << "green\n"; break;
        case blue : [std::cout](../io/cout.html) << "blue\n";  break;
    }

Each enumerator is associated with a value of the underlying type. When `**=**` are provided in an enumerator-list, the values of enumerators are defined by those associated constant-expressions. If the first enumerator does not have `**=**`, the associated value is zero. For any other enumerator whose definition does not have an `**=**`, the associated value is the value of the previous enumerator plus one. 
    
    
    enum Foo { a, b, c = 10, d, e = 1, f, g = f + c };
    //a = 0, b = 1, c = 10, d = 11, e = 1, f = 2, g = 12

The name of an unscoped enumeration may be omitted: such declaration only introduces the enumerators into the enclosing scope: 
    
    
    enum { a, b, c = 0, d = a + 2 }; // defines a = 0, b = 1, c = 0, d = 2

When an unscoped enumeration is a class member, its enumerators may be accessed using class member access operators `**.**` and `**- >**`: 
    
    
    struct X
    {
        enum direction { left = 'l', right = 'r' };
    };
    X x;
    X* p = &x;
     
    int a = X::direction::left; // allowed only in C++11 and later
    int b = X::left;
    int c = x.left;
    int d = p->left;

In the [declaration specifiers](declarations.html#Specifiers "cpp/language/declarations") of a [member declaration](class.html#Member_specification "cpp/language/class"), the sequence 

    `**enum**` enum-head-name `**:**`
is always parsed as a part of enumeration declaration: 
    
    
    struct S
    {
        enum E1 : int {};
        enum E1 : int {}; // error: redeclaration of enumeration,
                          // NOT parsed as a zero-length bit-field of type enum E1
    };
     
    enum E2 { e1 };
     
    void f()
    {
        false ? new enum E2 : int(); // OK: 'int' is NOT parsed as the underlying type
    }

| (since C++11)  
---|---  
  
#### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/enum&action=edit&section=2 "Edit section: Enumeration name for linkage purposes")] Enumeration name for linkage purposes

An unnamed enumeration that does not have a [typedef name for linkage purposes](typedef.html#typedef_name_for_linkage_purposes "cpp/language/typedef") and that has an enumerator is denoted, for [linkage purposes](storage_duration.html "cpp/language/storage duration"), by its underlying type and its first enumerator; such an enumeration is said to have an enumerator as a _name for linkage purposes_. 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/enum&action=edit&section=3 "Edit section: Scoped enumerations")] Scoped enumerations

|   
---  
`**enum struct|class**` name `**{**` enumerator `**=**` constant-expression `**,**` enumerator `**=**` constant-expression `**,**` ... `**}**` |  (1)  |   
`**enum struct|class**` name `**:**` type `**{**` enumerator `**=**` constant-expression `**,**` enumerator `**=**` constant-expression `**,**` ... `**}**` |  (2)  |   
`**enum struct|class**` name `**;**` |  (3)  |   
`**enum struct|class**` name `**:**` type `**;**` |  (4)  |   
  
1) declares a scoped enumeration type whose underlying type is int (the keywords class and struct are exactly equivalent)

2) declares a scoped enumeration type whose underlying type is type

3) opaque enum declaration for a scoped enumeration whose underlying type is int

4) opaque enum declaration for a scoped enumeration whose underlying type is type

Each enumerator becomes a named constant of the enumeration's type (that is, name), which is contained within the scope of the enumeration, and can be accessed using scope resolution operator. There are no implicit conversions from the values of a scoped enumerator to integral types, although [`static_cast`](static_cast.html "cpp/language/static cast") may be used to obtain the numeric value of the enumerator. 

Run this code
    
    
    #include <iostream>
     
    int main()
    {
        enum class Color { red, green = 20, blue };
        Color r = Color::blue;
     
        switch(r)
        {
            case Color::red  : [std::cout](../io/cout.html) << "red\n";   break;
            case Color::green: [std::cout](../io/cout.html) << "green\n"; break;
            case Color::blue : [std::cout](../io/cout.html) << "blue\n";  break;
        }
     
        // int n = r; // error: no implicit conversion from scoped enum to int
        int n = static_cast<int>(r); // OK, n = 21
        [std::cout](../io/cout.html) << n << '\n'; // prints 21
    }

(since C++11)  
  
An enumeration can be initialized from an integer without a cast, using [list initialization](list_initialization.html "cpp/language/list initialization"), if all of the following are true: 

  * The initialization is direct-list-initialization. 
  * The initializer list has only a single element. 
  * The enumeration is either scoped or unscoped with underlying type fixed. 
  * The conversion is non-narrowing. 

This makes it possible to introduce new integer types (e.g. `SafeInt`) that enjoy the same existing calling conventions as their underlying integer types, even on ABIs that penalize passing/returning structures by value. 
    
    
    enum byte : unsigned char {}; // byte is a new integer type; see also std::byte (C++17)
    byte b{42};        // OK as of C++17 (direct-list-initialization)
    byte c = {42};     // error
    byte d = byte{42}; // OK as of C++17; same value as b
    byte e{-1};        // error
     
    struct A { byte b; };
    A a1 = {{42}};     // error (copy-list-initialization of a constructor parameter)
    A a2 = {byte{42}}; // OK as of C++17
     
    void f(byte);
    f({42}); // error (copy-list-initialization of a function parameter)
     
    enum class Handle : [std::uint32_t](../types/integer.html) { Invalid = 0 };
    Handle h{42}; // OK as of C++17

| (since C++17)  
---|---  
  
  


###  using enum declaration

|   
---  
`**using enum**` using-enum-declarator `**;**` |  |  (since C++20)  
declarator |  \-  |  a (possibly qualified) [identifier](name.html "cpp/language/identifiers") or [simple template identifiers](templates.html#Template_identifiers "cpp/language/templates")  
---|---|---  
  
  
declarator must name a non-[dependent](dependent_name.html#Dependent_types "cpp/language/dependent name") enumeration type. The enumeration declarations are found by type-only ordinary [qualified](qualified_lookup.html "cpp/language/qualified lookup") or [unqualified](unqualified_lookup.html "cpp/language/unqualified lookup") lookup, depending on whether declarator is qualified. 
    
    
    enum E { x };
     
    void f()
    {
        int E;
        using enum E; // OK
    }
     
    using F = E;
    using enum F; // OK
     
    template<class T>
    using EE = T;
     
    void g()
    {
        using enum EE<E>; // OK
    }

A using enum declaration introduces the enumerator names of the named enumeration as if by a [using declaration](using_declaration.html "cpp/language/using declaration") for each enumerator. When in class scope, a using enum declaration adds the enumerators of the named enumeration as members to the scope, making them accessible for member lookup. 
    
    
    enum class fruit { orange, apple };
     
    struct S
    {
        using enum fruit; // OK: introduces orange and apple into S
    };
     
    void f()
    {
        S s;
        s.orange;  // OK: names fruit::orange
        S::orange; // OK: names fruit::orange
    }

Two using enum declarations that introduce two enumerators of the same name conflict. 
    
    
    enum class fruit { orange, apple };
    enum class color { red, orange };
     
    void f()
    {
        using enum fruit;    // OK
        // using enum color; // error: color::orange and fruit::orange conflict
    }

(since C++20)  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/enum&action=edit&section=5 "Edit section: Notes")] Notes

Values of unscoped enumeration type can be [promoted](implicit_cast.html#Promotion_from_enumeration_types "cpp/language/implicit conversion") or [converted](implicit_cast.html#Integral_conversions "cpp/language/implicit conversion") to integral types: 
    
    
    enum color { red, yellow, green = 20, blue };
    color col = red;
    int n = blue; // n == 21

Values of integer, floating-point, and enumeration types can be converted to any enumeration type by using [`static_cast`](static_cast.html "cpp/language/static cast"). Note that the value after such conversion may not necessarily equal any of the named enumerators defined for the enumeration: 
    
    
    enum access_t { read = 1, write = 2, exec = 4 }; // enumerators: 1, 2, 4 range: 0..7
    access_t rwe = static_cast<access_t>(7);
    [assert](../error/assert.html)((rwe & read) && (rwe & write) && (rwe & exec));
     
    access_t x = static_cast<access_t>(8.0); // undefined behavior since CWG 1766
    access_t y = static_cast<access_t>(8);   // undefined behavior since CWG 1766
     
    enum foo { a = 0, b = [UINT_MAX](../types/climits.html) }; // range: [0, UINT_MAX]
    foo x = foo(-1); // undefined behavior since CWG 1766,
                     // even if foo's underlying type is unsigned int

Feature-test macro  | Value | Std | Feature   
---|---|---|---  
[`__cpp_enumerator_attributes`](../experimental/feature_test.html#cpp_enumerator_attributes "cpp/feature test") | [`201411L`](../compiler_support/17.html#cpp_enumerator_attributes_201411L "cpp/compiler support/17") | (C++17) | [Attributes](attributes.html "cpp/language/attributes") for enumerators   
[`__cpp_using_enum`](../experimental/feature_test.html#cpp_using_enum "cpp/feature test") | [`201907L`](../compiler_support/20.html#cpp_using_enum_201907L "cpp/compiler support/20") | (C++20) | [`using enum`](enum.html#Using-enum-declaration)  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/enum&action=edit&section=6 "Edit section: Keywords")] Keywords

[`enum`](../keyword/enum.html "cpp/keyword/enum"), [`struct`](../keyword/struct.html "cpp/keyword/struct"), [`class`](../keyword/class.html "cpp/keyword/class"), [`using`](../keyword/using.html "cpp/keyword/using")

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/enum&action=edit&section=7 "Edit section: Example")] Example

Run this code
    
    
    #include <cstdint>
    #include <iostream>
     
    // enum that takes 16 bits
    enum smallenum: [std::int16_t](../types/integer.html)
    {
        a,
        b,
        c
    };
     
    // color may be red (value 0), yellow (value 1), green (value 20), or blue (value 21)
    enum color
    {
        red,
        yellow,
        green = 20,
        blue
    };
     
    // altitude may be altitude::high or altitude::low
    enum class altitude: char
    {
        high = 'h',
        low = 'l', // trailing comma only allowed after CWG 518
    }; 
     
    // the constant d is 0, the constant e is 1, the constant f is 3
    enum
    {
        d,
        e,
        f = e + 2
    };
     
    // enumeration types (both scoped and unscoped) can have overloaded operators
    [std::ostream](../io/basic_ostream.html)& operator<<([std::ostream](../io/basic_ostream.html)& os, color c)
    {
        switch(c)
        {
            case red   : os << "red";    break;
            case yellow: os << "yellow"; break;
            case green : os << "green";  break;
            case blue  : os << "blue";   break;
            default    : os.setstate([std::ios_base::failbit](../io/ios_base/iostate.html));
        }
        return os;
    }
     
    [std::ostream](../io/basic_ostream.html)& operator<<([std::ostream](../io/basic_ostream.html)& os, altitude al)
    {
        return os << static_cast<char>(al);
    }
     
    // The scoped enum (C++11) can be partially emulated in earlier C++ revisions:
     
    enum struct E11 { x, y }; // since C++11
     
    struct E98 { enum { x, y }; }; // OK in pre-C++11
     
    namespace N98 { enum { x, y }; } // OK in pre-C++11
     
    struct S98 { static const int x = 0, y = 1; }; // OK in pre-C++11
     
    void emu()
    {
        [std::cout](../io/cout.html) << (static_cast<int>(E11::y) + E98::y + N98::y + S98::y) << '\n'; // 4
    }
     
    namespace cxx20
    {
        enum class long_long_long_name { x, y };
     
        void using_enum_demo()
        {
            [std::cout](../io/cout.html) << "C++20 `using enum`: __cpp_using_enum == ";
            switch (auto rnd = []{return long_long_long_name::x;}; rnd())
            {
    #if defined(__cpp_using_enum)
                using enum long_long_long_name;
                case x: [std::cout](../io/cout.html) << __cpp_using_enum << "; x\n"; break;
                case y: [std::cout](../io/cout.html) << __cpp_using_enum << "; y\n"; break;
    #else
                case long_long_long_name::x: [std::cout](../io/cout.html) << "?; x\n"; break;
                case long_long_long_name::y: [std::cout](../io/cout.html) << "?; y\n"; break;
    #endif
            }
        }
    }
     
    int main()
    {
        color col = red;
        altitude a;
        a = altitude::low;
     
        [std::cout](../io/cout.html) << "col = " << col << '\n'
                  << "a = "   << a   << '\n'
                  << "f = "   << f   << '\n';
     
        cxx20::using_enum_demo();
    }

Possible output: 
    
    
    col = red
    a = l
    f = 3
    C++20 `using enum`: __cpp_using_enum == 201907; x

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/enum&action=edit&section=8 "Edit section: Defect reports")] Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[CWG 377](https://cplusplus.github.io/CWG/issues/377.html) | C++98  | the behavior was unspecified when no integral  
type can represent all the enumerator values  | the enumeration is ill-  
formed in this case   
[CWG 518](https://cplusplus.github.io/CWG/issues/518.html) | C++98  | a trailing comma was not allowed after the enumerator list  | allowed   
[CWG 1514](https://cplusplus.github.io/CWG/issues/1514.html) | C++11  | a redefinition of enumeration with fixed underlying type  
could be parsed as a bit-field in a class member declaration  | always parsed as a redefinition   
[CWG 1638](https://cplusplus.github.io/CWG/issues/1638.html) | C++11  | grammar of opaque enumeration declaration  
prohibited use for template specializations  | nested-name-specifier  
permitted   
[CWG 1766](https://cplusplus.github.io/CWG/issues/1766.html) | C++98  | casting an out-of-range value to an enumeration  
without fixed underlying type had an unspecified result  | the behavior is undefined   
[CWG 1966](https://cplusplus.github.io/CWG/issues/1966.html) | C++11  | the resolution of [CWG issue 1514](https://cplusplus.github.io/CWG/issues/1514.html) made the `:`  
of a conditional expression part of enum-base | only apply the resolution to  
member declaration specifiers   
[CWG 2156](https://cplusplus.github.io/CWG/issues/2156.html) | C++11  | enum definitions could define  
enumeration types by using-declarations  | prohibited   
[CWG 2157](https://cplusplus.github.io/CWG/issues/2157.html) | C++11  | the resolution of [CWG issue 1966](https://cplusplus.github.io/CWG/issues/1966.html) did  
not cover qualified enumeration names  | covered   
[CWG 2530](https://cplusplus.github.io/CWG/issues/2530.html) | C++98  | an enumerator list could contain multiple  
enumerators with the same identifier  | prohibited   
[CWG 2590](https://cplusplus.github.io/CWG/issues/2590.html) | C++98  | the size, value representation and alignment requirements  
of an enumeration did not depend on its underlying type  | all of them are identical to  
those of the underlying type   
[CWG 2621](https://cplusplus.github.io/CWG/issues/2621.html) | C++20  | the enumeration name lookup used in  
using enum declarations was unclear  | made clear   
[CWG 2877](https://cplusplus.github.io/CWG/issues/2877.html) | C++20  | the enumeration name lookup used in  
using enum declarations was not type-only  | made type-only   
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/enum&action=edit&section=9 "Edit section: References")] References

  * C++23 standard (ISO/IEC 14882:2024): 



    

  * 9.7.1 Enumeration declarations [dcl.enum] 



  * C++20 standard (ISO/IEC 14882:2020): 



    

  * 9.7.1 Enumeration declarations [dcl.enum] 



  * C++17 standard (ISO/IEC 14882:2017): 



    

  * 10.2 Enumeration declarations [dcl.enum] 



  * C++14 standard (ISO/IEC 14882:2014): 



    

  * 7.2 Enumeration declarations [dcl.enum] 



  * C++11 standard (ISO/IEC 14882:2011): 



    

  * 7.2 Enumeration declarations [dcl.enum] 



  * C++03 standard (ISO/IEC 14882:2003): 



    

  * 7.2 Enumeration declarations [dcl.enum] 



  * C++98 standard (ISO/IEC 14882:1998): 



    

  * 7.2 Enumeration declarations [dcl.enum] 



### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/enum&action=edit&section=10 "Edit section: See also")] See also

[ is_enum](../types/is_enum.html "cpp/types/is enum")(C++11) |  checks if a type is an enumeration type   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/types/dsc_is_enum&action=edit)  
---|---  
[ is_scoped_enum](../types/is_scoped_enum.html "cpp/types/is scoped enum")(C++23) |  checks if a type is a scoped enumeration type   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/types/dsc_is_scoped_enum&action=edit)  
[ underlying_type](../types/underlying_type.html "cpp/types/underlying type")(C++11) |  obtains the underlying integer type for a given enumeration type   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/types/dsc_underlying_type&action=edit)  
[ to_underlying](../utility/to_underlying.html "cpp/utility/to underlying")(C++23) |  converts an enumeration to its underlying type   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/dsc_to_underlying&action=edit)  
[C documentation](../../c/language/enum.html "c/language/enum") for Enumerations
  *[Value]: The year/month in which the feature was adopted. The hyperlink under each value opens a compiler support page with entry for given feature.
  *[Std]: Standard in which the feature is introduced; DR means defect report against that revision
