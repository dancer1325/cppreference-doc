[C++](../../cpp.html "cpp")

[Compiler support](../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../freestanding.html "cpp/freestanding")  
[Language](../language.html "cpp/language")  
[Standard library](../standard_library.html "cpp/standard library")  
[Standard library headers](../headers.html "cpp/header")  
[Named requirements](../iterator/concepts.html "cpp/named req")  
[Feature test macros](../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../utility.html#Language_support "cpp/utility")  
[Concepts library](../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../error.html "cpp/error")  
[Memory management library](../memory.html "cpp/memory")  
[Metaprogramming library](../meta.html "cpp/meta") (C++11)  
[General utilities library](../utility.html "cpp/utility")  
[Containers library](../container.html "cpp/container")  
[Iterators library](../iterator.html "cpp/iterator")  
[Ranges library](../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../algorithm.html "cpp/algorithm")  
[Strings library](../string.html "cpp/string")  
[Text processing library](../text.html "cpp/text")  
[Numerics library](../numeric.html "cpp/numeric")  
[Date and time library](../chrono.html "cpp/chrono")  
[Input/output library](../io.html "cpp/io")  
[Filesystem library](../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../atomic.html "cpp/thread") (C++11)  
[Execution control library](../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../experimental.html "cpp/experimental")  
[Symbols index](../symbol_index.html "cpp/symbol index")  
[External libraries](../links/libs.html "cpp/links/libs")  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/navbar_content&action=edit)

[C++ language](../language.html "cpp/language")

General topics  
---  
| [Preprocessor](../preprocessor.html "cpp/preprocessor")  
---  
[Comments](../comments.html "cpp/comment")  
  
| [Keywords](../keywords.html "cpp/keyword")  
---  
[Escape sequences](escape.html "cpp/language/escape")  
  
[Flow control](statements.html "cpp/language/statements")  
Conditional execution statements  
| [`if`](if.html "cpp/language/if")  
---  
  
| [`switch`](switch.html "cpp/language/switch")  
---  
  
Iteration statements (loops)  
| [`for`](for.html "cpp/language/for")  
---  
[range-`for`](range-for.html "cpp/language/range-for") (C++11)  
  
| [`while`](while.html "cpp/language/while")  
---  
[`do-while`](do.html "cpp/language/do")  
  
Jump statements  
| [`continue`](continue.html "cpp/language/continue") \- [`break`](break.html "cpp/language/break")  
---  
  
| [`goto`](goto.html "cpp/language/goto") \- [`return`](return.html "cpp/language/return")  
---  
  
[Functions](functions.html "cpp/language/functions")  
[Function declaration](function.html "cpp/language/function")  
[Lambda function expression](lambda.html "cpp/language/lambda")  
[`inline` specifier](inline.html "cpp/language/inline")  
[Dynamic exception specifications](except_spec.html "cpp/language/except spec") (until C++17*)  
[`noexcept` specifier](noexcept_spec.html "cpp/language/noexcept spec") (C++11)  
Exceptions  
| [`throw`-expression](throw.html "cpp/language/throw")  
---  
[`try` block](try.html "cpp/language/try")  
  
|   
  
---  
[`catch` handler](catch.html "cpp/language/catch")  
  
Namespaces  
| [Namespace declaration](namespace.html "cpp/language/namespace")` `  
---  
  
| [Namespace aliases](namespace_alias.html "cpp/language/namespace alias")  
---  
  
Types  
| [Fundamental types](types.html "cpp/language/types")  
---  
[Enumeration types](enum.html "cpp/language/enum")  
[Function types](function.html "cpp/language/function")  
  
| [Class/struct types](class.html "cpp/language/class")  
---  
[Union types](union.html "cpp/language/union")  
  
  
  
Specifiers  
| [`const`/`volatile`](cv.html "cpp/language/cv")  
---  
[`decltype`](decltype.html "cpp/language/decltype") (C++11)  
[`auto`](auto.html "cpp/language/auto") (C++11)  
  
| [`constexpr`](constexpr.html "cpp/language/constexpr") (C++11)  
---  
[`consteval`](consteval.html "cpp/language/consteval") (C++20)  
[`constinit`](constinit.html "cpp/language/constinit") (C++20)  
  
[Storage duration specifiers](storage_duration.html "cpp/language/storage duration")  
[Initialization](initialization.html "cpp/language/initialization")  
| [Default-initialization](default_initialization.html "cpp/language/default initialization")  
---  
[Value-initialization](value_initialization.html "cpp/language/value initialization")  
[Zero-initialization](zero_initialization.html "cpp/language/zero initialization")  
**Copy-initialization**  
[Direct-initialization](direct_initialization.html "cpp/language/direct initialization")  
  
| [Aggregate initialization](aggregate_initialization.html "cpp/language/aggregate initialization")  
---  
[List-initialization](list_initialization.html "cpp/language/list initialization") (C++11)` `  
[Constant initialization](constant_initialization.html "cpp/language/constant initialization")  
[Reference initialization](reference_initialization.html "cpp/language/reference initialization")  
  
  
  
[Expressions](expressions.html "cpp/language/expressions")  
---  
| [Value categories](value_category.html "cpp/language/value category")  
---  
[Order of evaluation](eval_order.html "cpp/language/eval order")  
  
| [Operators](operators.html "cpp/language/operators")  
---  
[Operator precedence](operator_precedence.html "cpp/language/operator precedence")  
  
[Alternative representations](operator_alternative.html "cpp/language/operator alternative")  
[Literals](expressions.html#Literals "cpp/language/expressions")  
[Boolean](bool_literal.html "cpp/language/bool literal") \- [Integer](integer_literal.html "cpp/language/integer literal") \- [Floating-point](floating_literal.html "cpp/language/floating literal")  
[Character](character_literal.html "cpp/language/character literal") \- [String](string_literal.html "cpp/language/string literal") \- [`nullptr`](nullptr.html "cpp/language/nullptr") (C++11)  
[User-defined](user_literal.html "cpp/language/user literal") (C++11)  
Utilities  
[Attributes](attributes.html "cpp/language/attributes") (C++11)  
Types  
[`typedef` declaration](typedef.html "cpp/language/typedef")  
[Type alias declaration](type_alias.html "cpp/language/type alias") (C++11)  
Casts  
| [Implicit conversions](implicit_cast.html "cpp/language/implicit conversion")  
---  
[`static_cast`](static_cast.html "cpp/language/static cast")  
[`const_cast`](const_cast.html "cpp/language/const cast")  
  
| [Explicit conversions](explicit_cast.html "cpp/language/explicit cast")  
---  
[`dynamic_cast`](dynamic_cast.html "cpp/language/dynamic cast")  
[`reinterpret_cast`](reinterpret_cast.html "cpp/language/reinterpret cast")  
  
Memory allocation  
| [`new` expression](new.html "cpp/language/new")  
---  
  
| [`delete` expression](delete.html "cpp/language/delete")  
---  
  
[Classes](classes.html "cpp/language/classes")  
| [Class declaration](class.html "cpp/language/class")  
---  
[Constructors](initializer_list.html "cpp/language/constructor")  
[`this` pointer](this.html "cpp/language/this")  
  
| [Access specifiers](access.html "cpp/language/access")  
---  
[`friend` specifier](friend.html "cpp/language/friend")  
  
  
  
Class-specific function properties  
| [Virtual function](virtual.html "cpp/language/virtual")  
---  
[`override` specifier](override.html "cpp/language/override") (C++11)` `  
[`final` specifier](final.html "cpp/language/final") (C++11)  
  
| [`explicit`](explicit.html "cpp/language/explicit") (C++11)  
---  
[`static`](static.html "cpp/language/static")  
  
  
  
Special member functions  
| [Default constructor](default_constructor.html "cpp/language/default constructor")  
---  
[Copy constructor](copy_constructor.html "cpp/language/copy constructor")  
[Move constructor](move_constructor.html "cpp/language/move constructor") (C++11)  
  
| [Copy assignment](as_operator.html "cpp/language/as operator")  
---  
[Move assignment](move_operator.html "cpp/language/move operator") (C++11)  
[Destructor](destructor.html "cpp/language/destructor")  
  
[Templates](templates.html "cpp/language/templates")  
| [Class template](class_template.html "cpp/language/class template")  
---  
[Function template](function_template.html "cpp/language/function template")  
  
| [Template specialization](template_specialization.html "cpp/language/template specialization")  
---  
[Parameter packs](parameter_pack.html "cpp/language/pack") (C++11)  
  
Miscellaneous  
| [Inline assembly](asm.html "cpp/language/asm")  
---  
  
| [History of C++](history.html "cpp/language/history")  
---  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/navbar_content&action=edit)

[ Initialization](initialization.html "cpp/language/initialization")

[Initializer](initialization.html "cpp/language/initialization")  
---  
[Default initialization](default_initialization.html "cpp/language/default initialization")  
[Value initialization](value_initialization.html "cpp/language/value initialization")  
[Direct initialization](direct_initialization.html "cpp/language/direct initialization")  
**Copy-initialization**  
[List initialization](list_initialization.html "cpp/language/list initialization") (C++11)  
[Aggregate initialization](aggregate_initialization.html "cpp/language/aggregate initialization")  
[Reference initialization](reference_initialization.html "cpp/language/reference initialization")  
[Copy elision](copy_elision.html "cpp/language/copy elision")  
[Static initialization](initialization.html#Static_initialization "cpp/language/initialization")  
[Zero initialization](zero_initialization.html "cpp/language/zero initialization")  
[Constant initialization](constant_initialization.html "cpp/language/constant initialization")  
[Dynamic non-local initialization](initialization.html#Dynamic_initialization "cpp/language/initialization")  
[Ordered dynamic initialization](initialization.html#Dynamic_initialization "cpp/language/initialization")  
[Unordered dynamic initialization](initialization.html#Dynamic_initialization "cpp/language/initialization")  
[Class member initialization](initialization.html#Class_member_initialization "cpp/language/initialization")  
[Member initializer list](initializer_list.html "cpp/language/initializer list")  
[Default member initializer](data_members.html#Member_initialization "cpp/language/data members") (C++11)  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/initialization/navbar_content&action=edit)

Initializes an object from another object. 

## Contents

  * [1 Syntax](copy_initialization.html#Syntax)
  * [2 Explanation](copy_initialization.html#Explanation)
  * [3 Notes](copy_initialization.html#Notes)
  * [4 Example](copy_initialization.html#Example)
  * [5 Defect reports](copy_initialization.html#Defect_reports)
  * [6 See also](copy_initialization.html#See_also)

  
---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/copy_initialization&action=edit&section=1 "Edit section: Syntax")] Syntax  
  
---  
T object `**=**` other`**;**` |  (1)  |   
T object `**=**` `**{**` other`**};**` |  (2)  |  (until C++11)  
f`**(**` other`**)**` |  (3)  |   
`**return**` other`**;**` |  (4)  |   
`**throw**` object`**;**` `**catch (**` T object`**)**` |  (5)  |   
T array`**[**` N`**] = {**` other-sequence`**};**` |  (6)  |   
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/copy_initialization&action=edit&section=2 "Edit section: Explanation")] Explanation

Copy-initialization is performed in the following situations: 

1) When a named variable (automatic, static, or thread-local) of a non-reference type `T` is declared with the initializer consisting of an equals sign followed by an expression.

2) (until C++11) When a named variable of a scalar type `T` is declared with the initializer consisting of an equals sign followed by a brace-enclosed expression (Note: as of C++11, this is classified as [list initialization](list_initialization.html "cpp/language/list initialization"), and narrowing conversion is not allowed).

3) When [passing an argument](operator_other.html#Built-in_function_call_operator "cpp/language/operator other") to a function by value.

4) When [returning](return.html "cpp/language/return") from a function that returns by value.

5) When [throwing](throw.html "cpp/language/throw") or [catching](catch.html "cpp/language/catch") an exception by value.

6) As part of [aggregate initialization](aggregate_initialization.html "cpp/language/aggregate initialization"), to initialize each element for which an initializer is provided.

The effects of copy-initialization are: 

  * First, if `T` is a class type and the initializer is a [prvalue](value_category.html "cpp/language/value category") expression whose cv-unqualified type is the same class as `T`, the initializer expression itself, rather than a temporary materialized from it, is used to initialize the destination object: see [copy elision](copy_elision.html "cpp/language/copy elision"). 

| (since C++17)  
---|---  
  
  * First(until C++17)Otherwise(since C++17), if `T` is a class type and the cv-unqualified version of the type of other is `T` or a class derived from `T`, the [non-explicit constructors](converting_constructor.html "cpp/language/converting constructor") of `T` are examined and the best match is selected by overload resolution. That constructor is then called to initialize the object. 


  * Otherwise, if `T` is a class type, and the cv-unqualified version of the type of other is not `T` or derived from `T`, or if `T` is non-class type, but the type of other is a class type, [user-defined conversion sequences](implicit_cast.html "cpp/language/implicit cast") that can convert from the type of other to `T` (or to a type derived from `T` if `T` is a class type and a conversion function is available) are examined and the best one is selected through overload resolution. The result of the conversion, which is a rvalue temporary(until C++11)prvalue temporary(since C++11)(until C++17)prvalue expression(since C++17) of the cv-unqualified version of `T` if a [converting constructor](converting_constructor.html "cpp/language/converting constructor") was used, is then used to [direct-initialize](direct_initialization.html "cpp/language/direct initialization") the object. The last step is usually [optimized out](copy_elision.html "cpp/language/copy elision") and the result of the conversion is constructed directly in the memory allocated for the target object, but the appropriate constructor (move or copy) is required to be accessible even though it's not used.(until C++17)


  * Otherwise (if neither `T` nor the type of other are class types), [standard conversions](implicit_cast.html "cpp/language/implicit cast") are used, if necessary, to convert the value of other to the cv-unqualified version of `T`. 



### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/copy_initialization&action=edit&section=3 "Edit section: Notes")] Notes

Copy-initialization is less permissive than direct-initialization: [explicit constructors](explicit.html "cpp/language/explicit") are not [converting constructors](converting_constructor.html "cpp/language/converting constructor") and are not considered for copy-initialization. 
    
    
    struct Exp { explicit Exp(const char*) {} }; // not convertible from const char*
    Exp e1("abc");  // OK
    Exp e2 = "abc"; // Error, copy-initialization does not consider explicit constructor
     
    struct Imp { Imp(const char*) {} }; // convertible from const char*
    Imp i1("abc");  // OK
    Imp i2 = "abc"; // OK

In addition, the implicit conversion in copy-initialization must produce `T` directly from the initializer, while, e.g. direct-initialization expects an implicit conversion from the initializer to an argument of `T`'s constructor. 
    
    
    struct S { S([std::string](../string/basic_string.html)) {} }; // implicitly convertible from std::string
    S s("abc");   // OK: conversion from const char[4] to std::string
    S s = "abc";  // Error: no conversion from const char[4] to S
    S s = "abc"s; // OK: conversion from std::string to S

If other is an rvalue expression, a [move constructor](move_constructor.html "cpp/language/move constructor") will be selected by overload resolution and called during copy-initialization. This is still considered copy-initialization; there is no special term (e.g., move-initialization) for this case. 

[Implicit conversion](implicit_cast.html "cpp/language/implicit cast") is defined in terms of copy-initialization: if an object of type `T` can be copy-initialized with expression `E`, then `E` is implicitly convertible to `T`. 

The equals sign, `**=**`, in copy-initialization of a named variable is not related to the assignment operator. Assignment operator overloads have no effect on copy-initialization. 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/copy_initialization&action=edit&section=4 "Edit section: Example")] Example

Run this code
    
    
    #include <memory>
    #include <string>
    #include <utility>
     
    struct A
    {
        operator int() { return 12;}
    };
     
    struct B
    {
        B(int) {}
    };
     
    int main()
    {
        [std::string](../string/basic_string.html) s = "test";        // OK: constructor is non-explicit
        [std::string](../string/basic_string.html) s2 = std::move(s); // this copy-initialization performs a move
     
    //  std::unique_ptr<int> p = new int(1); // error: constructor is explicit
        [std::unique_ptr](../memory/unique_ptr.html)<int> p(new int(1));  // OK: direct-initialization
     
        int n = 3.14;    // floating-integral conversion
        const int b = n; // const doesn't matter
        int c = b;       // ...either way
     
        A a;
        B b0 = 12;
    //  B b1 = a;       // < error: conversion from 'A' to non-scalar type 'B' requested
        B b2{a};        // < identical, calling A::operator int(), then B::B(int)
        B b3 = {a};     // <
        auto b4 = B{a}; // <
     
    //  b0 = a;         // < error, assignment operator overload needed
     
        [](...){}(c, b0, b3, b4); // pretend these variables are used
    }

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/copy_initialization&action=edit&section=5 "Edit section: Defect reports")] Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[CWG 5](https://cplusplus.github.io/CWG/issues/5.html) | C++98  | the cv-qualification of the destination type is applied to  
the temporary initialized by a converting constructor  | the temporary is not cv-qualified   
[CWG 177](https://cplusplus.github.io/CWG/issues/177.html) | C++98  | the value category of the temporary created during  
copy-initialization of a class object is unspecified  | specified as rvalue   
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/copy_initialization&action=edit&section=6 "Edit section: See also")] See also

  * [copy elision](copy_elision.html "cpp/language/copy elision")
  * [converting constructor](converting_constructor.html "cpp/language/converting constructor")
  * [copy assignment](as_operator.html "cpp/language/copy assignment")
  * [copy constructor](copy_constructor.html "cpp/language/copy constructor")
  * [default constructor](default_constructor.html "cpp/language/default constructor")
  * [destructor](destructor.html "cpp/language/destructor")
  * [`explicit`](explicit.html "cpp/language/explicit")
  * [initialization](initialization.html "cpp/language/initialization")
    * [aggregate initialization](aggregate_initialization.html "cpp/language/aggregate initialization")
    * [constant initialization](constant_initialization.html "cpp/language/constant initialization")
    * [default initialization](default_initialization.html "cpp/language/default initialization")
    * [direct initialization](direct_initialization.html "cpp/language/direct initialization")
    * [initializer list](initializer_list.html "cpp/language/initializer list")
    * [list initialization](list_initialization.html "cpp/language/list initialization")
    * [reference initialization](reference_initialization.html "cpp/language/reference initialization")
    * [value initialization](value_initialization.html "cpp/language/value initialization")
    * [zero initialization](zero_initialization.html "cpp/language/zero initialization")
  * [move assignment](move_operator.html "cpp/language/move assignment")
  * [move constructor](move_constructor.html "cpp/language/move constructor")
  * [`new`](new.html "cpp/language/new")


