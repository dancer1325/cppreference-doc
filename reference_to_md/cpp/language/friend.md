[C++](../../cpp.html "cpp")

[Compiler support](../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../freestanding.html "cpp/freestanding")  
[Language](../language.html "cpp/language")  
[Standard library](../standard_library.html "cpp/standard library")  
[Standard library headers](../headers.html "cpp/header")  
[Named requirements](../iterator/concepts.html "cpp/named req")  
[Feature test macros](../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../utility.html#Language_support "cpp/utility")  
[Concepts library](../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../error.html "cpp/error")  
[Memory management library](../memory.html "cpp/memory")  
[Metaprogramming library](../meta.html "cpp/meta") (C++11)  
[General utilities library](../utility.html "cpp/utility")  
[Containers library](../container.html "cpp/container")  
[Iterators library](../iterator.html "cpp/iterator")  
[Ranges library](../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../algorithm.html "cpp/algorithm")  
[Strings library](../string.html "cpp/string")  
[Text processing library](../text.html "cpp/text")  
[Numerics library](../numeric.html "cpp/numeric")  
[Date and time library](../chrono.html "cpp/chrono")  
[Input/output library](../io.html "cpp/io")  
[Filesystem library](../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../atomic.html "cpp/thread") (C++11)  
[Execution control library](../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../experimental.html "cpp/experimental")  
[Symbols index](../symbol_index.html "cpp/symbol index")  
[External libraries](../links/libs.html "cpp/links/libs")  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/navbar_content&action=edit)

[C++ language](../language.html "cpp/language")

General topics  
---  
| [Preprocessor](../preprocessor.html "cpp/preprocessor")  
---  
[Comments](../comments.html "cpp/comment")  
  
| [Keywords](../keywords.html "cpp/keyword")  
---  
[Escape sequences](escape.html "cpp/language/escape")  
  
[Flow control](statements.html "cpp/language/statements")  
Conditional execution statements  
| [`if`](if.html "cpp/language/if")  
---  
  
| [`switch`](switch.html "cpp/language/switch")  
---  
  
Iteration statements (loops)  
| [`for`](for.html "cpp/language/for")  
---  
[range-`for`](range-for.html "cpp/language/range-for") (C++11)  
  
| [`while`](while.html "cpp/language/while")  
---  
[`do-while`](do.html "cpp/language/do")  
  
Jump statements  
| [`continue`](continue.html "cpp/language/continue") \- [`break`](break.html "cpp/language/break")  
---  
  
| [`goto`](goto.html "cpp/language/goto") \- [`return`](return.html "cpp/language/return")  
---  
  
[Functions](functions.html "cpp/language/functions")  
[Function declaration](function.html "cpp/language/function")  
[Lambda function expression](lambda.html "cpp/language/lambda")  
[`inline` specifier](inline.html "cpp/language/inline")  
[Dynamic exception specifications](except_spec.html "cpp/language/except spec") (until C++17*)  
[`noexcept` specifier](noexcept_spec.html "cpp/language/noexcept spec") (C++11)  
Exceptions  
| [`throw`-expression](throw.html "cpp/language/throw")  
---  
[`try` block](try.html "cpp/language/try")  
  
|   
  
---  
[`catch` handler](catch.html "cpp/language/catch")  
  
Namespaces  
| [Namespace declaration](namespace.html "cpp/language/namespace")` `  
---  
  
| [Namespace aliases](namespace_alias.html "cpp/language/namespace alias")  
---  
  
Types  
| [Fundamental types](types.html "cpp/language/types")  
---  
[Enumeration types](enum.html "cpp/language/enum")  
[Function types](function.html "cpp/language/function")  
  
| [Class/struct types](class.html "cpp/language/class")  
---  
[Union types](union.html "cpp/language/union")  
  
  
  
Specifiers  
| [`const`/`volatile`](cv.html "cpp/language/cv")  
---  
[`decltype`](decltype.html "cpp/language/decltype") (C++11)  
[`auto`](auto.html "cpp/language/auto") (C++11)  
  
| [`constexpr`](constexpr.html "cpp/language/constexpr") (C++11)  
---  
[`consteval`](consteval.html "cpp/language/consteval") (C++20)  
[`constinit`](constinit.html "cpp/language/constinit") (C++20)  
  
[Storage duration specifiers](storage_duration.html "cpp/language/storage duration")  
[Initialization](initialization.html "cpp/language/initialization")  
| [Default-initialization](default_initialization.html "cpp/language/default initialization")  
---  
[Value-initialization](value_initialization.html "cpp/language/value initialization")  
[Zero-initialization](zero_initialization.html "cpp/language/zero initialization")  
[Copy-initialization](copy_initialization.html "cpp/language/copy initialization")  
[Direct-initialization](direct_initialization.html "cpp/language/direct initialization")  
  
| [Aggregate initialization](aggregate_initialization.html "cpp/language/aggregate initialization")  
---  
[List-initialization](list_initialization.html "cpp/language/list initialization") (C++11)` `  
[Constant initialization](constant_initialization.html "cpp/language/constant initialization")  
[Reference initialization](reference_initialization.html "cpp/language/reference initialization")  
  
  
  
[Expressions](expressions.html "cpp/language/expressions")  
---  
| [Value categories](value_category.html "cpp/language/value category")  
---  
[Order of evaluation](eval_order.html "cpp/language/eval order")  
  
| [Operators](operators.html "cpp/language/operators")  
---  
[Operator precedence](operator_precedence.html "cpp/language/operator precedence")  
  
[Alternative representations](operator_alternative.html "cpp/language/operator alternative")  
[Literals](expressions.html#Literals "cpp/language/expressions")  
[Boolean](bool_literal.html "cpp/language/bool literal") \- [Integer](integer_literal.html "cpp/language/integer literal") \- [Floating-point](floating_literal.html "cpp/language/floating literal")  
[Character](character_literal.html "cpp/language/character literal") \- [String](string_literal.html "cpp/language/string literal") \- [`nullptr`](nullptr.html "cpp/language/nullptr") (C++11)  
[User-defined](user_literal.html "cpp/language/user literal") (C++11)  
Utilities  
[Attributes](attributes.html "cpp/language/attributes") (C++11)  
Types  
[`typedef` declaration](typedef.html "cpp/language/typedef")  
[Type alias declaration](type_alias.html "cpp/language/type alias") (C++11)  
Casts  
| [Implicit conversions](implicit_cast.html "cpp/language/implicit conversion")  
---  
[`static_cast`](static_cast.html "cpp/language/static cast")  
[`const_cast`](const_cast.html "cpp/language/const cast")  
  
| [Explicit conversions](explicit_cast.html "cpp/language/explicit cast")  
---  
[`dynamic_cast`](dynamic_cast.html "cpp/language/dynamic cast")  
[`reinterpret_cast`](reinterpret_cast.html "cpp/language/reinterpret cast")  
  
Memory allocation  
| [`new` expression](new.html "cpp/language/new")  
---  
  
| [`delete` expression](delete.html "cpp/language/delete")  
---  
  
[Classes](classes.html "cpp/language/classes")  
| [Class declaration](class.html "cpp/language/class")  
---  
[Constructors](initializer_list.html "cpp/language/constructor")  
[`this` pointer](this.html "cpp/language/this")  
  
| [Access specifiers](access.html "cpp/language/access")  
---  
**`friend` specifier**  
  
  
  
Class-specific function properties  
| [Virtual function](virtual.html "cpp/language/virtual")  
---  
[`override` specifier](override.html "cpp/language/override") (C++11)` `  
[`final` specifier](final.html "cpp/language/final") (C++11)  
  
| [`explicit`](explicit.html "cpp/language/explicit") (C++11)  
---  
[`static`](static.html "cpp/language/static")  
  
  
  
Special member functions  
| [Default constructor](default_constructor.html "cpp/language/default constructor")  
---  
[Copy constructor](copy_constructor.html "cpp/language/copy constructor")  
[Move constructor](move_constructor.html "cpp/language/move constructor") (C++11)  
  
| [Copy assignment](as_operator.html "cpp/language/as operator")  
---  
[Move assignment](move_operator.html "cpp/language/move operator") (C++11)  
[Destructor](destructor.html "cpp/language/destructor")  
  
[Templates](templates.html "cpp/language/templates")  
| [Class template](class_template.html "cpp/language/class template")  
---  
[Function template](function_template.html "cpp/language/function template")  
  
| [Template specialization](template_specialization.html "cpp/language/template specialization")  
---  
[Parameter packs](parameter_pack.html "cpp/language/pack") (C++11)  
  
Miscellaneous  
| [Inline assembly](asm.html "cpp/language/asm")  
---  
  
| [History of C++](history.html "cpp/language/history")  
---  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/navbar_content&action=edit)

[ Classes](classes.html "cpp/language/classes")

General  
---  
[Overview](classes.html "cpp/language/classes")  
[`class`/`struct` types](class.html "cpp/language/class")  
[`union` types](union.html "cpp/language/union")  
[Injected-class-name](injected-class-name.html "cpp/language/injected-class-name")  
[Class property specifiers](class_property_specifiers.html "cpp/language/class property specifiers") (C++26)  
Members  
[Data members](data_members.html "cpp/language/data members")  
[Static members](static.html "cpp/language/static")  
[The `this` pointer](this.html "cpp/language/this")  
[Nested classes](nested_classes.html "cpp/language/nested types")  
[Member templates](member_template.html "cpp/language/member template")  
[Bit-fields](bit_field.html "cpp/language/bit field")  
[`using`-declarations](using_declaration.html "cpp/language/using declaration")  
[Member functions](member_functions.html "cpp/language/member functions")  
[Member access specifiers](access.html "cpp/language/access")  
[Constructors and member initializer lists](initializer_list.html "cpp/language/constructor")  
[Default member initializer](data_members.html#Member_initialization "cpp/language/data members") (C++11)  
**`friend` specifier**  
[`explicit` specifier](explicit.html "cpp/language/explicit")  
[Converting constructor](converting_constructor.html "cpp/language/converting constructor")  
Special member functions  
[Default constructor](default_constructor.html "cpp/language/default constructor")  
[Copy constructor](copy_constructor.html "cpp/language/copy constructor")  
[Move constructor](move_constructor.html "cpp/language/move constructor") (C++11)  
[Copy assignment operator](as_operator.html "cpp/language/copy assignment")  
[Move assignment operator](move_operator.html "cpp/language/move assignment") (C++11)  
[Destructor](destructor.html "cpp/language/destructor")  
Inheritance  
[Base and derived classes](derived_class.html "cpp/language/derived class")  
[Empty base optimization (EBO)](ebo.html "cpp/language/ebo")  
[Virtual member functions](virtual.html "cpp/language/virtual")  
[Pure virtual functions and abstract classes](abstract_class.html "cpp/language/abstract class")  
[`override` specifier](override.html "cpp/language/override") (C++11)  
[`final` specifier](final.html "cpp/language/final") (C++11)  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/classes/navbar_content&action=edit)

The friend declaration appears in a [class body](class.html "cpp/language/class") and grants a function or another class access to private and protected members of the class where the friend declaration appears. 

## Contents

  * [1 Syntax](friend.html#Syntax)
  * [2 Description](friend.html#Description)
  * [3 Template friends](friend.html#Template_friends)
  * [4 Template friend operators](friend.html#Template_friend_operators)
  * [5 Linkage](friend.html#Linkage)
  * [6 Notes](friend.html#Notes)
  * [7 Keywords](friend.html#Keywords)
  * [8 Example](friend.html#Example)
  * [9 Defect reports](friend.html#Defect_reports)
  * [10 References](friend.html#References)
  * [11 See also](friend.html#See_also)

  
---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/friend&action=edit&section=1 "Edit section: Syntax")] Syntax  
  
---  
`**friend**` function-declaration |  (1)  |   
`**friend**` function-definition |  (2)  |   
`**friend**` elaborated-type-specifier `**;**` |  (3)  |  (until C++26)  
`**friend**` simple-type-specifier `**;**` `**friend**` typename-specifier `**;**` |  (4)  |  (since C++11)  
(until C++26)  
`**friend**` friend-type-specifier-list `**;**` |  (5)  |  (since C++26)  
  
1,2) A function friend declaration.

3-5) A class friend declaration.

function-declaration |  \-  |  a [function declaration](function.html "cpp/language/function")  
---|---|---  
function-definition |  \-  |  a [function definition](function.html#Function_definition "cpp/language/function")  
elaborated-type-specifier |  \-  |  an [elaborated type specifier](elaborated_type_specifier.html "cpp/language/elaborated type specifier")  
simple-type-specifier |  \-  |  a [simple type specifier](declarations.html#Specifiers "cpp/language/declarations")  
typename-specifier |  \-  |  the keyword typename followed by a qualified identifier or qualified [simple template identifier](templates.html#Template_identifiers "cpp/language/templates")  
friend-type-specifier-list |  \-  |  a non-empty comma-separated list of simple-type-specifier, elaborated-type-specifier, and typename-specifier ﻿s, each specifier can be followed by an ellipsis (`...`)   
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/friend&action=edit&section=2 "Edit section: Description")] Description

1) Designates a function or several functions as friends of this class: 
    
    
    class Y
    {
        int data; // private member
     
        // the non-member function operator<< will have access to Y's private members
        friend [std::ostream](../io/basic_ostream.html)& operator<<([std::ostream](../io/basic_ostream.html)& out, const Y& o);
        friend char* X::foo(int); // members of other classes can be friends too
        friend X::X(char), X::~X(); // constructors and destructors can be friends
    };
     
    // friend declaration does not declare a member function
    // this operator<< still needs to be defined, as a non-member
    [std::ostream](../io/basic_ostream.html)& operator<<([std::ostream](../io/basic_ostream.html)& out, const Y& y)
    {
        return out << y.data; // can access private member Y::data
    }

2) (only allowed in non-[local](class.html#Local_classes "cpp/language/class") class definitions) Defines a non-member function, and makes it a friend of this class at the same time. Such non-member function is always [inline](inline.html "cpp/language/inline"), unless it is attached to a [named module](modules.html "cpp/language/modules")(since C++20). 
    
    
    class X
    {
        int a;
     
        friend void friend_set(X& p, int i)
        {
            p.a = i; // this is a non-member function
        }
    public:
        void member_set(int i)
        {
            a = i; // this is a member function
        }
    };

3,4) Designates a class as a friend of this class. This means that the friend's member declarations and definitions can access private and protected members of this class and also that the friend can inherit from private and protected members of this class.

3) The class is named by elaborated-type-specifier. The name of the class that is used in this friend declaration does not need to be previously declared.

4) The class is named by simple-type-specifier or typename-specifier. If the named type is not a class type, this friend declaration is ignored. This declaration will not forward declare a new type.

5) Designates all classes in friend-type-specifier-list as a friend of this class. This means that the friends' member declarations and definitions can access private and protected members of this class and also that the friends can inherit from private and protected members of this class. If a named type is not a class type, it is ignored in this friend declaration.

Each specifier in friend-type-specifier-list names a class if the specifier is not followed by an ellipsis, otherwise [pack expansion](parameter_pack.html#Friend_declarations "cpp/language/parameter pack") applies. 
    
    
    class Y {};
     
    class A
    {
        int data; // private data member
     
        class B {}; // private nested type
     
        enum { a = 100 }; // private enumerator
     
        friend class X; // friend class forward declaration (elaborated class specifier)
        friend Y; // friend class declaration (simple type specifier) (since C++11)
     
        // the two friend declarations above can be merged since C++26:
        // friend class X, Y;
    };
     
    class X : A::B // OK: A::B accessible to friend
    {
        A::B mx; // OK: A::B accessible to member of friend
     
        class Y
        {
            A::B my; // OK: A::B accessible to nested member of friend
        };
     
        int v[A::a]; // OK: A::a accessible to member of friend
    };

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/friend&action=edit&section=3 "Edit section: Template friends")] Template friends

Both [function template](function_template.html "cpp/language/function template") and [class template](class_template.html "cpp/language/class template") declarations may appear with the `friend` specifier in any non-local class or class template (although only function templates may be defined within the class or class template that is granting friendship). In this case, every specialization of the template becomes a friend, whether it is implicitly instantiated, partially specialized, or explicitly specialized. 
    
    
    class A
    {
        template<typename T>
        friend class B; // every B<T> is a friend of A
     
        template<typename T>
        friend void f(T) {} // every f<T> is a friend of A
    };

Friend declarations cannot refer to partial specializations, but can refer to full specializations: 
    
    
    template<class T>
    class A {};      // primary
     
    template<class T>
    class A<T*> {};  // partial
     
    template<>
    class A<int> {}; // full
     
    class X
    {
        template<class T>
        friend class A<T*>;  // Error
     
        friend class A<int>; // OK
    };

When a friend declaration refers to a full specialization of a function template, the keyword inline, constexpr(since C++11), consteval(since C++20) and default arguments cannot be used: 
    
    
    template<class T>
    void f(int);
     
    template<>
    void f<int>(int);
     
    class X
    {
        friend void f<int>(int x = 1); // error: default args not allowed
    };

A template friend declaration can name a member of a class template A, which can be either a member function or a member type (the type must use [elaborated-type-specifier](elaborated_type_specifier.html "cpp/language/elaborated type specifier")). Such declaration is only well-formed if the last component in its nested-name-specifier (the name to the left of the last `**::**`) is a simple-template-id (template name followed by argument list in angle brackets) that names the class template. The template parameters of such template friend declaration must be deducible from the simple-template-id. 

In this case, the member of any specialization of either A or partial specializations of A becomes a friend. This does not involve instantiating the primary template A or partial specializations of A: the only requirements are that the deduction of the template parameters of A from that specialization succeeds, and that substitution of the deduced template arguments into the friend declaration produces a declaration that would be a valid redeclaration of the member of the specialization: 
    
    
    // primary template
    template<class T>
    struct A
    { 
        struct B {};
     
        void f();
     
        struct D { void g(); };
     
        T h();
     
        template<T U>
        T i();
    };
     
    // full specialization
    template<>
    struct A<int>
    {
        struct B {};
     
        int f();
     
        struct D { void g(); };
     
        template<int U>
        int i();
    };
     
    // another full specialization
    template<>
    struct A<float*>
    {
        int *h();
    };
     
    // the non-template class granting friendship to members of class template A
    class X
    {
        template<class T>
        friend struct A<T>::B; // all A<T>::B are friends, including A<int>::B
     
        template<class T>
        friend void A<T>::f(); // A<int>::f() is not a friend because its signature
                               // does not match, but e.g. A<char>::f() is a friend
     
    //  template<class T>
    //  friend void A<T>::D::g(); // ill-formed, the last part of the nested-name-specifier,
    //                            // D in A<T>::D::, is not simple-template-id
     
        template<class T>
        friend int* A<T*>::h(); // all A<T*>::h are friends:
                                // A<float*>::h(), A<int*>::h(), etc
     
        template<class T> 
        template<T U>       // all instantiations of A<T>::i() and A<int>::i() are friends, 
        friend T A<T>::i(); // and thereby all specializations of those function templates
    };

[Default template arguments](template_parameters.html#Default_template_arguments "cpp/language/template parameters") are only allowed on template friend declarations if the declaration is a definition and no other declarations of this function template appear in this translation unit.  | (since C++11)  
---|---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/friend&action=edit&section=4 "Edit section: Template friend operators")] Template friend operators

A common use case for template friends is declaration of a non-member operator overload that acts on a class template, e.g. operator<<([std::ostream](../io/basic_ostream.html)&, const Foo<T>&) for some user-defined Foo<T>. 

Such operator can be defined in the class body, which has the effect of generating a separate non-template operator<< for each `T` and makes that non-template operator<< a friend of its Foo<T>: 

Run this code
    
    
    #include <iostream>
     
    template<typename T>
    class Foo
    {
    public:
        Foo(const T& val) : data(val) {}
    private:
        T data;
     
        // generates a non-template operator<< for this T
        friend [std::ostream](../io/basic_ostream.html)& operator<<([std::ostream](../io/basic_ostream.html)& os, const Foo& obj)
        {
            return os << obj.data;
        }
    };
     
    int main()
    {
        Foo<double> obj(1.23);
        [std::cout](../io/cout.html) << obj << '\n';
    }

Output: 
    
    
    1.23

or the function template has to be declared as a template before the class body, in which case the friend declaration within Foo<T> can refer to the full specialization of operator<< for its `T`: 

Run this code
    
    
    #include <iostream>
     
    template<typename T>
    class Foo; // forward declare to make function declaration possible
     
    template<typename T> // declaration
    [std::ostream](../io/basic_ostream.html)& operator<<([std::ostream](../io/basic_ostream.html)&, const Foo<T>&);
     
    template<typename T>
    class Foo
    {
    public:
        Foo(const T& val) : data(val) {}
    private:
        T data;
     
        // refers to a full specialization for this particular T 
        friend [std::ostream](../io/basic_ostream.html)& operator<< <> ([std::ostream](../io/basic_ostream.html)&, const Foo&);
     
        // note: this relies on template argument deduction in declarations
        // can also specify the template argument with operator<< <T>"
    };
     
    // definition
    template<typename T>
    [std::ostream](../io/basic_ostream.html)& operator<<([std::ostream](../io/basic_ostream.html)& os, const Foo<T>& obj)
    {
        return os << obj.data;
    }
     
    int main()
    {
        Foo<double> obj(1.23);
        [std::cout](../io/cout.html) << obj << '\n';
    }

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/friend&action=edit&section=5 "Edit section: Linkage")] Linkage

[Storage class specifiers](storage_duration.html "cpp/language/storage duration") are not allowed in friend declarations. 

If a function or function template is first declared and defined in a friend declaration, and the enclosing class is defined within an [exporting declarations](modules.html#Exporting_declarations_and_definitions "cpp/language/modules"), its name has the same linkage as the name of the enclosing class.  | (since C++20)  
---|---  
  
If(until C++20)Otherwise, if(since C++20) a function or function template is declared in a friend declaration, and a [corresponding non-friend declaration](conflicting_declarations.html#Corresponding_declarations "cpp/language/conflicting declarations") is reachable, the name has the linkage determined from that prior declaration. 

Otherwise, the linkage of the name introduced by a friend declaration is determined as usual. 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/friend&action=edit&section=6 "Edit section: Notes")] Notes

Friendship is not transitive (a friend of your friend is not your friend). 

Friendship is not inherited (your friend's children are not your friends, and your friends are not your children's friends). 

[Access specifiers](access.html "cpp/language/access") have no effect on the meaning of friend declarations (they can appear in private: or in public: sections, with no difference). 

A friend class declaration cannot define a new class (friend class X {}; is an error). 

When a local class declares an unqualified function or class as a friend, only functions and classes in the innermost non-class scope are [looked up](lookup.html "cpp/language/lookup"), not the global functions: 
    
    
    class F {};
     
    int f();
     
    int main()
    {
        extern int g();
     
        class Local // Local class in the main() function
        {
            friend int f(); // Error, no such function declared in main()
            friend int g(); // OK, there is a declaration for g in main()
            friend class F; // friends a local F (defined later)
            friend class ::F; // friends the global F
        };
     
        class F {}; // local F
    }

A name first declared in a friend declaration within a class or class template `X` becomes a member of the innermost enclosing namespace of `X`, but is not visible for lookup (except argument-dependent lookup that considers `X`) unless a matching declaration at namespace scope is provided - see [namespaces](namespace.html#Namespaces "cpp/language/namespace") for details. 

Feature-test macro | Value | Std | Feature   
---|---|---|---  
[`__cpp_variadic_friend`](../experimental/feature_test.html#cpp_variadic_friend "cpp/feature test") | [`202403L`](../compiler_support/26.html#cpp_variadic_friend_202403L "cpp/compiler support/26") | (C++26) | Variadic friend declarations   
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/friend&action=edit&section=7 "Edit section: Keywords")] Keywords

[`friend`](../keyword/friend.html "cpp/keyword/friend")

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/friend&action=edit&section=8 "Edit section: Example")] Example

Stream insertion and extraction operators are often declared as non-member friends:

Run this code
    
    
    #include <iostream>
    #include <sstream>
     
    class MyClass
    {
        int i;                   // friends have access to non-public, non-static
        static inline int id{6}; // and static (possibly inline) members
     
        friend [std::ostream](../io/basic_ostream.html)& operator<<([std::ostream](../io/basic_ostream.html)& out, const MyClass&);
        friend [std::istream](../io/basic_istream.html)& operator>>([std::istream](../io/basic_istream.html)& in, MyClass&);
        friend void change_id(int);
    public:
        MyClass(int i = 0) : i(i) {}
    };
     
    [std::ostream](../io/basic_ostream.html)& operator<<([std::ostream](../io/basic_ostream.html)& out, const MyClass& mc)
    {
        return out << "MyClass::id = " << MyClass::id << "; i = " << mc.i;
    }
     
    [std::istream](../io/basic_istream.html)& operator>>([std::istream](../io/basic_istream.html)& in, MyClass& mc)
    {
        return in >> mc.i;
    }
     
    void change_id(int id) { MyClass::id = id; }
     
    int main()
    {
        MyClass mc(7);
        [std::cout](../io/cout.html) << mc << '\n';
    //  mc.i = 333*2;  // error: i is a private member
        [std::istringstream](../io/basic_istringstream.html)("100") >> mc;
        [std::cout](../io/cout.html) << mc << '\n';
    //  MyClass::id = 222*3;  // error: id is a private member
        change_id(9);
        [std::cout](../io/cout.html) << mc << '\n';
    }

Output: 
    
    
    MyClass::id = 6; i = 7
    MyClass::id = 6; i = 100
    MyClass::id = 9; i = 100

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/friend&action=edit&section=9 "Edit section: Defect reports")] Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[CWG 45](https://cplusplus.github.io/CWG/issues/45.html) | C++98  | members of a class nested in a friend  
class of `T` have no special access to `T` | a nested class has the same  
access as the enclosing class   
[CWG 500](https://cplusplus.github.io/CWG/issues/500.html) | C++98  | friend class of `T` cannot inherit from private or  
protected members of `T`, but its nested class can  | both can inherit  
from such members   
[CWG 1439](https://cplusplus.github.io/CWG/issues/1439.html) | C++98  | the rule targeting friend declarations in non-local  
classes did not cover template declarations  | covered   
[CWG 1477](https://cplusplus.github.io/CWG/issues/1477.html) | C++98  | a name first declared in a friend declaration within a class  
or class template was not visible for lookup if the matching  
declaration is provided in another namespace scope  | it is visible for  
lookup in this case   
[CWG 1804](https://cplusplus.github.io/CWG/issues/1804.html) | C++98  | when a member of a class template is friended, the corresponding  
member of specializations of partial specializations of the class  
template was not a friend of the class granting friendship  | such members  
are also friends   
[CWG 2379](https://cplusplus.github.io/CWG/issues/2379.html) | C++11  | friend declarations referring to full specializations  
of function templates could be declared constexpr  | prohibited   
[CWG 2588](https://cplusplus.github.io/CWG/issues/2588.html) | C++98  | the linkages of names introduced by friend declarations were unclear  | made clear   
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/friend&action=edit&section=10 "Edit section: References")] References

  * C++23 standard (ISO/IEC 14882:2024): 



    

  * 11.8.4 Friends [class.friend] 



    

  * 13.7.5 Friends [temp.friend] 



  * C++20 standard (ISO/IEC 14882:2020): 



    

  * 11.9.3 Friends [class.friend] 



    

  * 13.7.4 Friends [temp.friend] 



  * C++17 standard (ISO/IEC 14882:2017): 



    

  * 14.3 Friends [class.friend] 



    

  * 17.5.4 Friends [temp.friend] 



  * C++14 standard (ISO/IEC 14882:2014): 



    

  * 11.3 Friends [class.friend] 



    

  * 14.5.4 Friends [temp.friend] 



  * C++11 standard (ISO/IEC 14882:2011): 



    

  * 11.3 Friends [class.friend] 



    

  * 14.5.4 Friends [temp.friend] 



  * C++98 standard (ISO/IEC 14882:1998): 



    

  * 11.3 Friends [class.friend] 



    

  * 14.5.3 Friends [temp.friend] 



### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/friend&action=edit&section=11 "Edit section: See also")] See also

[ Class types ](class.html "cpp/language/class") |  defines types holding several data members [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/dsc_class&action=edit)  
---|---  
[ Access specifiers ](access.html "cpp/language/access") |  defines visibility of class members[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/dsc_access&action=edit)
  *[Value]: The year/month in which the feature was adopted. The hyperlink under each value opens a compiler support page with entry for given feature.
  *[Std]: Standard in which the feature is introduced; DR means defect report against that revision
