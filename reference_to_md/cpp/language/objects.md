[C++](../../cpp.html "cpp")

[Compiler support](../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../freestanding.html "cpp/freestanding")  
[Language](../language.html "cpp/language")  
[Standard library](../standard_library.html "cpp/standard library")  
[Standard library headers](../headers.html "cpp/header")  
[Named requirements](../iterator/concepts.html "cpp/named req")  
[Feature test macros](../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../utility.html#Language_support "cpp/utility")  
[Concepts library](../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../error.html "cpp/error")  
[Memory management library](../memory.html "cpp/memory")  
[Metaprogramming library](../meta.html "cpp/meta") (C++11)  
[General utilities library](../utility.html "cpp/utility")  
[Containers library](../container.html "cpp/container")  
[Iterators library](../iterator.html "cpp/iterator")  
[Ranges library](../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../algorithm.html "cpp/algorithm")  
[Strings library](../string.html "cpp/string")  
[Text processing library](../text.html "cpp/text")  
[Numerics library](../numeric.html "cpp/numeric")  
[Date and time library](../chrono.html "cpp/chrono")  
[Input/output library](../io.html "cpp/io")  
[Filesystem library](../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../atomic.html "cpp/thread") (C++11)  
[Execution control library](../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../experimental.html "cpp/experimental")  
[Symbols index](../symbol_index.html "cpp/symbol index")  
[External libraries](../links/libs.html "cpp/links/libs")  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/navbar_content&action=edit)

[C++ language](../language.html "cpp/language")

General topics  
---  
| [Preprocessor](../preprocessor.html "cpp/preprocessor")  
---  
[Comments](../comments.html "cpp/comment")  
  
| [Keywords](../keywords.html "cpp/keyword")  
---  
[Escape sequences](escape.html "cpp/language/escape")  
  
[Flow control](statements.html "cpp/language/statements")  
Conditional execution statements  
| [`if`](if.html "cpp/language/if")  
---  
  
| [`switch`](switch.html "cpp/language/switch")  
---  
  
Iteration statements (loops)  
| [`for`](for.html "cpp/language/for")  
---  
[range-`for`](range-for.html "cpp/language/range-for") (C++11)  
  
| [`while`](while.html "cpp/language/while")  
---  
[`do-while`](do.html "cpp/language/do")  
  
Jump statements  
| [`continue`](continue.html "cpp/language/continue") \- [`break`](break.html "cpp/language/break")  
---  
  
| [`goto`](goto.html "cpp/language/goto") \- [`return`](return.html "cpp/language/return")  
---  
  
[Functions](functions.html "cpp/language/functions")  
[Function declaration](function.html "cpp/language/function")  
[Lambda function expression](lambda.html "cpp/language/lambda")  
[`inline` specifier](inline.html "cpp/language/inline")  
[Dynamic exception specifications](except_spec.html "cpp/language/except spec") (until C++17*)  
[`noexcept` specifier](noexcept_spec.html "cpp/language/noexcept spec") (C++11)  
Exceptions  
| [`throw`-expression](throw.html "cpp/language/throw")  
---  
[`try` block](try.html "cpp/language/try")  
  
|   
  
---  
[`catch` handler](catch.html "cpp/language/catch")  
  
Namespaces  
| [Namespace declaration](namespace.html "cpp/language/namespace")` `  
---  
  
| [Namespace aliases](namespace_alias.html "cpp/language/namespace alias")  
---  
  
Types  
| [Fundamental types](types.html "cpp/language/types")  
---  
[Enumeration types](enum.html "cpp/language/enum")  
[Function types](function.html "cpp/language/function")  
  
| [Class/struct types](class.html "cpp/language/class")  
---  
[Union types](union.html "cpp/language/union")  
  
  
  
Specifiers  
| [`const`/`volatile`](cv.html "cpp/language/cv")  
---  
[`decltype`](decltype.html "cpp/language/decltype") (C++11)  
[`auto`](auto.html "cpp/language/auto") (C++11)  
  
| [`constexpr`](constexpr.html "cpp/language/constexpr") (C++11)  
---  
[`consteval`](consteval.html "cpp/language/consteval") (C++20)  
[`constinit`](constinit.html "cpp/language/constinit") (C++20)  
  
[Storage duration specifiers](storage_duration.html "cpp/language/storage duration")  
[Initialization](initialization.html "cpp/language/initialization")  
| [Default-initialization](default_initialization.html "cpp/language/default initialization")  
---  
[Value-initialization](value_initialization.html "cpp/language/value initialization")  
[Zero-initialization](zero_initialization.html "cpp/language/zero initialization")  
[Copy-initialization](copy_initialization.html "cpp/language/copy initialization")  
[Direct-initialization](direct_initialization.html "cpp/language/direct initialization")  
  
| [Aggregate initialization](aggregate_initialization.html "cpp/language/aggregate initialization")  
---  
[List-initialization](list_initialization.html "cpp/language/list initialization") (C++11)` `  
[Constant initialization](constant_initialization.html "cpp/language/constant initialization")  
[Reference initialization](reference_initialization.html "cpp/language/reference initialization")  
  
  
  
[Expressions](expressions.html "cpp/language/expressions")  
---  
| [Value categories](value_category.html "cpp/language/value category")  
---  
[Order of evaluation](eval_order.html "cpp/language/eval order")  
  
| [Operators](operators.html "cpp/language/operators")  
---  
[Operator precedence](operator_precedence.html "cpp/language/operator precedence")  
  
[Alternative representations](operator_alternative.html "cpp/language/operator alternative")  
[Literals](expressions.html#Literals "cpp/language/expressions")  
[Boolean](bool_literal.html "cpp/language/bool literal") \- [Integer](integer_literal.html "cpp/language/integer literal") \- [Floating-point](floating_literal.html "cpp/language/floating literal")  
[Character](character_literal.html "cpp/language/character literal") \- [String](string_literal.html "cpp/language/string literal") \- [`nullptr`](nullptr.html "cpp/language/nullptr") (C++11)  
[User-defined](user_literal.html "cpp/language/user literal") (C++11)  
Utilities  
[Attributes](attributes.html "cpp/language/attributes") (C++11)  
Types  
[`typedef` declaration](typedef.html "cpp/language/typedef")  
[Type alias declaration](type_alias.html "cpp/language/type alias") (C++11)  
Casts  
| [Implicit conversions](implicit_cast.html "cpp/language/implicit conversion")  
---  
[`static_cast`](static_cast.html "cpp/language/static cast")  
[`const_cast`](const_cast.html "cpp/language/const cast")  
  
| [Explicit conversions](explicit_cast.html "cpp/language/explicit cast")  
---  
[`dynamic_cast`](dynamic_cast.html "cpp/language/dynamic cast")  
[`reinterpret_cast`](reinterpret_cast.html "cpp/language/reinterpret cast")  
  
Memory allocation  
| [`new` expression](new.html "cpp/language/new")  
---  
  
| [`delete` expression](delete.html "cpp/language/delete")  
---  
  
[Classes](classes.html "cpp/language/classes")  
| [Class declaration](class.html "cpp/language/class")  
---  
[Constructors](initializer_list.html "cpp/language/constructor")  
[`this` pointer](this.html "cpp/language/this")  
  
| [Access specifiers](access.html "cpp/language/access")  
---  
[`friend` specifier](friend.html "cpp/language/friend")  
  
  
  
Class-specific function properties  
| [Virtual function](virtual.html "cpp/language/virtual")  
---  
[`override` specifier](override.html "cpp/language/override") (C++11)` `  
[`final` specifier](final.html "cpp/language/final") (C++11)  
  
| [`explicit`](explicit.html "cpp/language/explicit") (C++11)  
---  
[`static`](static.html "cpp/language/static")  
  
  
  
Special member functions  
| [Default constructor](default_constructor.html "cpp/language/default constructor")  
---  
[Copy constructor](copy_constructor.html "cpp/language/copy constructor")  
[Move constructor](move_constructor.html "cpp/language/move constructor") (C++11)  
  
| [Copy assignment](as_operator.html "cpp/language/as operator")  
---  
[Move assignment](move_operator.html "cpp/language/move operator") (C++11)  
[Destructor](destructor.html "cpp/language/destructor")  
  
[Templates](templates.html "cpp/language/templates")  
| [Class template](class_template.html "cpp/language/class template")  
---  
[Function template](function_template.html "cpp/language/function template")  
  
| [Template specialization](template_specialization.html "cpp/language/template specialization")  
---  
[Parameter packs](parameter_pack.html "cpp/language/pack") (C++11)  
  
Miscellaneous  
| [Inline assembly](asm.html "cpp/language/asm")  
---  
  
| [History of C++](history.html "cpp/language/history")  
---  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/navbar_content&action=edit)

[ Basic Concepts](basics.html "cpp/language/basic concepts")

[Comments](../comments.html "cpp/comment")  
---  
[ASCII](ascii.html "cpp/language/ascii")  
[Punctuation](punctuators.html "cpp/language/punctuators")  
[Names and identifiers](name.html "cpp/language/identifiers")  
[Types](type-id.html "cpp/language/type")  
[Fundamental types](types.html "cpp/language/types")  
**Objects**  
[Scope](scope.html "cpp/language/scope")  
[Object lifetime](lifetime.html "cpp/language/lifetime")  
[Storage duration and linkage](storage_duration.html "cpp/language/storage duration")  
[Definitions and ODR](definition.html "cpp/language/definition")  
[Name lookup](lookup.html "cpp/language/lookup")  
[ Qualified name lookup](qualified_lookup.html "cpp/language/qualified lookup")  
[ Unqualified name lookup](unqualified_lookup.html "cpp/language/unqualified lookup")  
[The as-if rule](as_if.html "cpp/language/as if")  
[Undefined behavior](ub.html "cpp/language/ub")  
[Memory model](memory_model.html "cpp/language/memory model")  
[Multi-threaded executions and data races](multithread.html "cpp/language/multithread") (C++11)  
[Character sets and encodings](charset.html "cpp/language/charset")  
[Phases of translation](translation_phases.html "cpp/language/translation phases")  
[The `main` function](main_function.html "cpp/language/main function")  
[Modules](modules.html "cpp/language/modules") (C++20)  
[Contracts](contracts.html "cpp/language/contracts") (C++26)  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/basics/navbar_content&action=edit)

C++ programs create, destroy, refer to, access, and manipulate _objects_. 

An object, in C++, has 

  * size (can be determined with [`sizeof`](sizeof.html "cpp/language/sizeof")); 
  * alignment requirement (can be determined with [`alignof`](alignof.html "cpp/language/alignof")); 
  * [storage duration](storage_duration.html "cpp/language/storage duration") (automatic, static, dynamic, thread-local); 
  * [lifetime](lifetime.html "cpp/language/lifetime") (bounded by storage duration or temporary); 
  * [type](type-id.html "cpp/language/type"); 
  * value (which may be indeterminate, e.g. for [default-initialized](default_initialization.html "cpp/language/default initialization") non-class types); 
  * optionally, a [name](name.html "cpp/language/name"). 



The following entities are not objects: value, reference, function, enumerator, type, non-static class member, template, class or function template specialization, namespace, parameter pack, and this. 

A _variable_ is an object or a reference that is not a non-static data member, that is introduced by a [declaration](declarations.html "cpp/language/declarations"). 

## Contents

  * [1 Object creation](objects.html#Object_creation)
  * [2 Object representation and value representation](objects.html#Object_representation_and_value_representation)
  * [3 Subobjects](objects.html#Subobjects)
  * [4 Size](objects.html#Size)
  * [5 Address](objects.html#Address)
  * [6 Polymorphic objects](objects.html#Polymorphic_objects)
  * [7 Strict aliasing](objects.html#Strict_aliasing)
  * [8 Alignment](objects.html#Alignment)
  * [9 Notes](objects.html#Notes)
  * [10 Defect reports](objects.html#Defect_reports)
  * [11 See also](objects.html#See_also)

  
---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/object&action=edit&section=1 "Edit section: Object creation")] Object creation

Objects can be explicitly created by [definitions](definition.html "cpp/language/definition"), [new expressions](new.html "cpp/language/new"), [throw expressions](throw.html "cpp/language/throw"), changing the active member of a [union](union.html "cpp/language/union") and evaluating expressions that require [temporary objects](lifetime.html#Temporary_object_lifetime "cpp/language/lifetime"). The created object is uniquely defined in explicit object creation. 

Objects of [implicit-lifetime types](type-id.html#Implicit-lifetime_type "cpp/language/type") can also be implicitly created by 

  * except during constant evaluation, operations that begin lifetime of an array of type unsigned char or [`std::byte`](../types/byte.html "cpp/types/byte")(since C++17), in which case such objects are created in the array, 
  * call to following allocating functions, in which case such objects are created in the allocated storage: 



    

  * [operator new](../memory/new/operator_new.html "cpp/memory/new/operator new") (except during constant evaluation) 
  * [operator new[]](../memory/new/operator_new.html "cpp/memory/new/operator new") (except during constant evaluation) 
  * [std::malloc](../memory/c/malloc.html "cpp/memory/c/malloc")
  * [std::calloc](../memory/c/calloc.html "cpp/memory/c/calloc")
  * [std::realloc](../memory/c/realloc.html "cpp/memory/c/realloc")



    

  * [std::aligned_alloc](../memory/c/aligned_alloc.html "cpp/memory/c/aligned alloc")


| (since C++17)  
---|---  
  
  * call to following [object representation](objects.html#Object_representation_and_value_representation) copying functions, in which case such objects are created in the destination region of storage or the result: 



    

  * [std::memcpy](../string/byte/memcpy.html "cpp/string/byte/memcpy")
  * [std::memmove](../string/byte/memmove.html "cpp/string/byte/memmove")



    

  * [`std::bit_cast`](../numeric/bit_cast.html "cpp/numeric/bit cast")


| (since C++20)  
---|---  
  
  * call to following specific functions, in which case such objects are created in the specified region of storage: 



    

  * std::start_lifetime_as
  * std::start_lifetime_as_array


| (since C++23)  
---|---  
  
Zero or more objects may be created in the same region of storage, as long as doing so would give the program defined behavior. If such creation is impossible, e.g. due to conflicting operations, the behavior of the program is undefined. If multiple such sets of implicitly created objects would give the program defined behavior, it is unspecified which such set of objects is created. In other words, implicitly created objects are not required to be uniquely defined. 

After implicitly creating objects within a specified region of storage, some operations produce a pointer to a _suitable created object_. The suitable created object has the same address as the region of storage. Likewise, the behavior is undefined if only if no such pointer value can give the program defined behavior, and it is unspecified which pointer value is produced if there are multiple values giving the program defined behavior. 
    
    
    #include <cstdlib>
     
    struct X { int a, b; };
     
    X* MakeX()
    {
        // One of possible defined behaviors:
        // the call to std::malloc implicitly creates an object of type X
        // and its subobjects a and b, and returns a pointer to that X object
        X* p = static_cast<X*>([std::malloc](../memory/c/malloc.html)(sizeof(X)));
        p->a = 1;
        p->b = 2;
        return p;
    }

Call to [std::allocator::allocate](../memory/allocator/allocate.html "cpp/memory/allocator/allocate") or implicitly defined copy/move special member functions of [union](union.html "cpp/language/union") types can also create objects. 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/object&action=edit&section=2 "Edit section: Object representation and value representation")] Object representation and value representation

Some types and objects have _object representations_ and _value representations_ , they are defined in the table below: 

Entity  | Object representation  | Value representation   
---|---|---  
a complete object type `T` | the sequence of N unsigned char objects taken up by a non-[bit-field](bit_field.html "cpp/language/bit field") complete object of type `T`, where N is sizeof(T) | the set of bits in the object representation of `T` that participate in representing a value of type `T`  
a non-bit-field complete object obj of type `T` | the bytes of obj corresponding to the object representation of `T` | the bits of obj corresponding to the value representation of `T`  
a bit-field object bf | the sequence of N bits taken up by bf, where N is the width of the bit-field  | the set of bits in the object representation of bf that participate in representing the value of bf  
  
Bits in the object representation of a type or object that are not part of the value representation are _padding bits_. 

For [TriviallyCopyable](../named_req/TriviallyCopyable.html "cpp/named req/TriviallyCopyable") types, value representation is a part of the object representation, which means that copying the bytes occupied by the object in the storage is sufficient to produce another object with the same value (except if the object is a potentially-overlapping subobject, or the value is a _trap representation_ of its type and loading it into the CPU raises a hardware exception, such as SNaN ("signalling not-a-number") floating-point values or NaT ("not-a-thing") integers). 

Although most implementations do not allow trap representations, padding bits, or multiple representations for integer types, there are exceptions; for example a value of an integer type on Itanium [may be a trap representation](https://web.archive.org/web/20170830125905/https://blogs.msdn.microsoft.com/oldnewthing/20040119-00/?p=41003). 

The reverse is not necessarily true: two objects of a [TriviallyCopyable](../named_req/TriviallyCopyable.html "cpp/named req/TriviallyCopyable") type with different object representations may represent the same value. For example, multiple floating-point bit patterns represent the same special value [NaN](../numeric/math/NAN.html "cpp/numeric/math/NAN"). More commonly, padding bits may be introduced to satisfy [alignment requirements](objects.html#Alignment "cpp/language/object"), [bit-field](bit_field.html "cpp/language/bit field") sizes, etc. 
    
    
    #include <cassert>
     
    struct S
    {
        char c;  // 1 byte value
                 // 3 bytes of padding bits (assuming alignof(float) == 4)
        float f; // 4 bytes value (assuming sizeof(float) == 4)
     
        bool operator==(const S& arg) const // value-based equality
        {
            return c == arg.c && f == arg.f;
        }
    };
     
    void f()
    {
        [assert](../error/assert.html)(sizeof(S) == 8);
        S s1 = {'a', 3.14};
        S s2 = s1;
        reinterpret_cast<unsigned char*>(&s1)[2] = 'b'; // modify some padding bits
        [assert](../error/assert.html)(s1 == s2); // value did not change
    }

For the objects of type char, signed char, and unsigned char (unless they are oversize [bit-fields](bit_field.html "cpp/language/bit field")), every bit of the object representation is required to participate in the value representation and each possible bit pattern represents a distinct value (no padding bits, trap bits, or multiple representations allowed). 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/object&action=edit&section=3 "Edit section: Subobjects")] Subobjects

An object can have _subobjects_. These include 

  * member objects 
  * base class subobjects 
  * array elements 



An object that is not a subobject of another object is called _complete object_. 

If a complete object, a member subobject, or an array element is of [class type](classes.html "cpp/language/classes"), its type is considered the _most derived class_ ﻿, to distinguish it from the class type of any base class subobject. An object of a most derived class type or of a non-class type is called a _most derived object_ ﻿. 

For a class, 

  * its non-static [data members](data_members.html "cpp/language/data members"), 
  * its non-virtual direct [base classes](derived_class.html "cpp/language/derived class"), and, 
  * if the class is not [abstract](abstract_class.html "cpp/language/abstract class"), its [virtual base classes](derived_class.html#Virtual_base_classes "cpp/language/derived class")



are called its _potentially constructed subobjects_. 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/object&action=edit&section=4 "Edit section: Size")] Size

A subobject is a _potentially overlapping subobject_ if it is a base class subobject or a non-static data member declared with the `[[[no_unique_address](attributes/no_unique_address.html "cpp/language/attributes/no unique address")]]` attribute(since C++20). 

An object obj can only possibly have zero size if all following conditions are satisfied: 

  * obj is a potentially-overlapping subobject. 
  * obj is of a class type without virtual member functions and virtual base classes. 
  * obj does not have any subobject of nonzero size or unnamed [bit-fields](bit_field.html "cpp/language/bit field") of nonzero length. 



For an object obj satisfying all the conditions above: 

  * If obj is a base class subobject of a [standard-layout](data_members.html#Standard-layout "cpp/language/data members")(since C++11) class type with no non-static data members, it has zero size. 
  * Otherwise, it is implementation-defined under which circumstances where obj has zero size. 



See [empty base optimization](ebo.html "cpp/language/ebo") for more details. 

Any non-bit-field object with nonzero size must occupy one or more bytes of storage, including every byte that is occupied (in full or in part) by any of its subobjects. The storage occupied must be contiguous if the object is of trivially copyable or standard-layout(since C++11) type. 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/object&action=edit&section=5 "Edit section: Address")] Address

Unless an object is a bit-field or a subobject of zero size, the _address_ of that object is the address of the first [byte](memory_model.html#Byte "cpp/language/memory model") it occupies. 

An object can contain other objects, in which case the contained objects are _nested within_ the former object. An object a is nested within another object b if any of the following conditions is satisfied: 

  * a is a subobject of b. 
  * b [provides storage](lifetime.html#Providing_storage "cpp/language/lifetime") for a. 
  * There exists an object c where a is nested within c, and c is nested within b. 



An object is a _potentially non-unique object_ if it is one of the following objects: 

  * A [string literal](string_literal.html "cpp/language/string literal") object. 



  * The [backing array](list_initialization.html#List-initializing_std::initializer_list "cpp/language/list initialization") of an initializer list. 

| (since C++11)  
---|---  
  
  * A subobject of a potentially non-unique object. 



For any two non-bit-field objects with overlapping [lifetimes](lifetime.html "cpp/language/lifetime"): 

  * If any of the following conditions is satisfied, they may have the same address: 



    

  * One of them is nested within the other. 
  * Any of them is a subobject of zero size, and their types are not [similar](implicit_cast.html#Similar_types "cpp/language/implicit conversion"). 
  * They are both potentially non-unique objects. 



  * Otherwise, they always have distinct addresses and occupy disjoint bytes of storage. 


    
    
    // character literals are always unique
    static const char test1 = 'x';
    static const char test2 = 'x';
    const bool b = &test1 != &test2;      // always true
     
    // the character 'x' accessed from “r”, “s” and “il”
    // may have the same address (i.e., these objects may share storage)
    static const char (&r) [] = "x";
    static const char *s = "x";
    static [std::initializer_list](../utility/initializer_list.html)<char> il = {'x'};
    const bool b2 = r != il.begin();      // unspecified result
    const bool b3 = r != s;               // unspecified result
    const bool b4 = il.begin() != &test1; // always true
    const bool b5 = r != &test1;          // always true

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/object&action=edit&section=6 "Edit section: Polymorphic objects")] Polymorphic objects

Objects of a class type that declares or inherits at least one virtual function are polymorphic objects. Within each polymorphic object, the implementation stores additional information (in every existing implementation, it is one pointer unless optimized out), which is used by [virtual function](virtual.html "cpp/language/virtual") calls and by the RTTI features ([`dynamic_cast`](dynamic_cast.html "cpp/language/dynamic cast") and [`typeid`](typeid.html "cpp/language/typeid")) to determine, at run time, the type with which the object was created, regardless of the expression it is used in. 

For non-polymorphic objects, the interpretation of the value is determined from the expression in which the object is used, and is decided at compile time. 

Run this code
    
    
    #include <iostream>
    #include <typeinfo>
     
    struct Base1
    {
        // polymorphic type: declares a virtual member
        virtual ~Base1() {}
    };
     
    struct Derived1 : Base1
    {
         // polymorphic type: inherits a virtual member
    };
     
    struct Base2
    {
         // non-polymorphic type
    };
     
    struct Derived2 : Base2
    {
         // non-polymorphic type
    };
     
    int main()
    {
        Derived1 obj1; // object1 created with type Derived1
        Derived2 obj2; // object2 created with type Derived2
     
        Base1& b1 = obj1; // b1 refers to the object obj1
        Base2& b2 = obj2; // b2 refers to the object obj2
     
        [std::cout](../io/cout.html) << "Expression type of b1: " << typeid(decltype(b1)).name() << '\n'
                  << "Expression type of b2: " << typeid(decltype(b2)).name() << '\n'
                  << "Object type of b1: " << typeid(b1).name() << '\n'
                  << "Object type of b2: " << typeid(b2).name() << '\n'
                  << "Size of b1: " << sizeof b1 << '\n'
                  << "Size of b2: " << sizeof b2 << '\n';
    }

Possible output: 
    
    
    Expression type of b1: Base1
    Expression type of b2: Base2
    Object type of b1: Derived1
    Object type of b2: Base2
    Size of b1: 8
    Size of b2: 1

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/object&action=edit&section=7 "Edit section: Strict aliasing")] Strict aliasing

Accessing an object using an expression of a type other than the type with which it was created is undefined behavior in many cases, see [`reinterpret_cast`](reinterpret_cast.html#Type_aliasing "cpp/language/reinterpret cast") for the list of exceptions and examples. 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/object&action=edit&section=8 "Edit section: Alignment")] Alignment

Every [object type](type-id.html "cpp/language/type") has the property called _alignment requirement_ , which is a nonnegative integer value (of type [std::size_t](../types/size_t.html "cpp/types/size t"), and always a power of two) representing the number of bytes between successive addresses at which objects of this type can be allocated. 

The alignment requirement of a type can be queried with [`alignof`](alignof.html "cpp/language/alignof") or [std::alignment_of](../types/alignment_of.html "cpp/types/alignment of"). The pointer alignment function [std::align](../memory/align.html "cpp/memory/align") can be used to obtain a suitably-aligned pointer within some buffer. [std::aligned_storage](../types/aligned_storage.html "cpp/types/aligned storage") can be used to obtain suitably-aligned storage.(until C++23) | (since C++11)  
---|---  
  
Each object type imposes its alignment requirement on every object of that type; stricter alignment (with larger alignment requirement) can be requested using [`alignas`](alignas.html "cpp/language/alignas")(since C++11). Attempting to create an object in storage that does not meet the alignment requirements of the object's type is undefined behavior. 

In order to satisfy alignment requirements of all non-static members of a [class](class.html "cpp/language/class"), [padding bits](objects.html#Object_representation_and_value_representation) may be inserted after some of its members. 

Run this code
    
    
    #include <iostream>
     
    // objects of type S can be allocated at any address
    // because both S.a and S.b can be allocated at any address
    struct S
    {
        char a; // size: 1, alignment: 1
        char b; // size: 1, alignment: 1
    }; // size: 2, alignment: 1
     
    // objects of type X must be allocated at 4-byte boundaries
    // because X.n must be allocated at 4-byte boundaries
    // because int's alignment requirement is (usually) 4
    struct X
    {
        int n;  // size: 4, alignment: 4
        char c; // size: 1, alignment: 1
        // three bytes of padding bits
    }; // size: 8, alignment: 4 
     
    int main()
    {
        [std::cout](../io/cout.html) << "alignof(S) = " << alignof(S) << '\n'
                  << "sizeof(S)  = " << sizeof(S) << '\n'
                  << "alignof(X) = " << alignof(X) << '\n'
                  << "sizeof(X)  = " << sizeof(X) << '\n';
    }

Possible output: 
    
    
    alignof(S) = 1
    sizeof(S)  = 2
    alignof(X) = 4
    sizeof(X)  = 8

The weakest alignment (the smallest alignment requirement) is the alignment of char, signed char, and unsigned char, which equals 1; the largest _fundamental alignment_ of any type is implementation-defined and equal to the alignment of [std::max_align_t](../types/max_align_t.html "cpp/types/max align t")(since C++11). 

Fundamental alignments are supported for objects of all kinds of storage durations. 

If a type's alignment is made stricter (larger) than [std::max_align_t](../types/max_align_t.html "cpp/types/max align t") using [`alignas`](alignas.html "cpp/language/alignas"), it is known as a type with _extended alignment_ requirement. A type whose alignment is extended or a class type whose non-static data member has extended alignment is an _over-aligned type_. [Allocator](../named_req/Allocator.html "cpp/named req/Allocator") types are required to handle over-aligned types correctly.  | (since C++11)  
---|---  
  
  


It is implementation-defined if [new expressions](new.html "cpp/language/new") and(until C++17) [std::get_temporary_buffer](../memory/get_temporary_buffer.html "cpp/memory/get temporary buffer") support over-aligned types.  | (since C++11)  
(until C++20)  
---|---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/object&action=edit&section=9 "Edit section: Notes")] Notes

Objects in C++ have different meaning from objects in [object-oriented programming (OOP)](https://en.wikipedia.org/wiki/Object-oriented_programming "enwiki:Object-oriented programming"): 

Objects in C++  | Objects in OOP   
---|---  
can have any object type  
(see [std::is_object](../types/is_object.html "cpp/types/is object"))  | must have a class type   
no concept of “instance”  | have the concept of “instance” (and there are mechanisms like `instanceof` to detect “instance-of” relationship)   
no concept of “interface”  | have the concept of “interface” (and there are mechanisms like `instanceof` to detect whether an interface is implemented)   
polymorphism needs to be explicitly enabled via virtual members  | polymorphism is always enabled   
  
In the defect report [P0593R6](https://wg21.link/P0593R6), implicit object creation was considered happening when creating a byte array or invocating an [allocation function](../memory/new/operator_new.html "cpp/memory/new/operator new") (which is possibly user-defined and [`constexpr`](constexpr.html "cpp/language/constexpr")) during constant evaluation. However, such allowance caused indeterminism in constant evaluation which was undesired and uninplementable in some aspects. As a result, [P2747R2](https://wg21.link/P2747R2) disallowed such implicit object creation in constant evaluation. We intentedly treat such change as a defect report although the whole paper is not. 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/object&action=edit&section=10 "Edit section: Defect reports")] Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[CWG 633](https://cplusplus.github.io/CWG/issues/633.html) | C++98  | variables could only be objects  | they can also be references   
[CWG 734](https://cplusplus.github.io/CWG/issues/734.html) | C++98  | it was unspecified whether variables defined  
in the same scope that are guaranteed to have  
the same value can have the same address  | address is guaranteed to be  
different if their lifetimes overlap,  
regardless of their values   
[CWG 1189](https://cplusplus.github.io/CWG/issues/1189.html) | C++98  | two base class subobjects of the same  
type could have the same address  | they always have  
distinct addresses   
[CWG 1861](https://cplusplus.github.io/CWG/issues/1861.html) | C++98  | for oversize bit-fields of narrow character  
types, all bits of the object representation  
still participated in the value representation  | allows padding bits   
[CWG 2489](https://cplusplus.github.io/CWG/issues/2489.html) | C++98  | char[] cannot provide storage, but objects  
could be implicitly created within its storage  | objects cannot be implicitly created  
within the storage of char[]  
[CWG 2519](https://cplusplus.github.io/CWG/issues/2519.html) | C++98  | the definition of object representation did not address bit-fields  | addresses bit-fields   
[CWG 2719](https://cplusplus.github.io/CWG/issues/2719.html) | C++98  | the behavior of creating an object  
in misaligned storage was unclear  | the behavior is  
undefined in this case   
[CWG 2753](https://cplusplus.github.io/CWG/issues/2753.html) | C++11  | it was unclear whether a backing array of an  
initializer list can share storage with a string literal  | they can share storage   
[CWG 2795](https://cplusplus.github.io/CWG/issues/2795.html) | C++98  | when determining whether two objects with overlapping  
lifetimes can have the same address, if any of them is a  
subobject of zero size, they could have similar distinct types  | only allows non-similar types   
[P0593R6](https://wg21.link/P0593R6) | C++98  | previous object model did not support many  
useful idioms required by the standard library  
and was not compatible with effective types in C  | implicit object creation added   
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/object&action=edit&section=11 "Edit section: See also")] See also

[C documentation](../../c/language/object.html "c/language/object") for Object  
---
