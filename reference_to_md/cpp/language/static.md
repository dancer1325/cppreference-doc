[C++](../../cpp.html "cpp")

[Compiler support](../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../freestanding.html "cpp/freestanding")  
[Language](../language.html "cpp/language")  
[Standard library](../standard_library.html "cpp/standard library")  
[Standard library headers](../headers.html "cpp/header")  
[Named requirements](../iterator/concepts.html "cpp/named req")  
[Feature test macros](../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../utility.html#Language_support "cpp/utility")  
[Concepts library](../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../error.html "cpp/error")  
[Memory management library](../memory.html "cpp/memory")  
[Metaprogramming library](../meta.html "cpp/meta") (C++11)  
[General utilities library](../utility.html "cpp/utility")  
[Containers library](../container.html "cpp/container")  
[Iterators library](../iterator.html "cpp/iterator")  
[Ranges library](../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../algorithm.html "cpp/algorithm")  
[Strings library](../string.html "cpp/string")  
[Text processing library](../text.html "cpp/text")  
[Numerics library](../numeric.html "cpp/numeric")  
[Date and time library](../chrono.html "cpp/chrono")  
[Input/output library](../io.html "cpp/io")  
[Filesystem library](../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../atomic.html "cpp/thread") (C++11)  
[Execution control library](../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../experimental.html "cpp/experimental")  
[Symbols index](../symbol_index.html "cpp/symbol index")  
[External libraries](../links/libs.html "cpp/links/libs")  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/navbar_content&action=edit)

[C++ language](../language.html "cpp/language")

General topics  
---  
| [Preprocessor](../preprocessor.html "cpp/preprocessor")  
---  
[Comments](../comments.html "cpp/comment")  
  
| [Keywords](../keywords.html "cpp/keyword")  
---  
[Escape sequences](escape.html "cpp/language/escape")  
  
[Flow control](statements.html "cpp/language/statements")  
Conditional execution statements  
| [`if`](if.html "cpp/language/if")  
---  
  
| [`switch`](switch.html "cpp/language/switch")  
---  
  
Iteration statements (loops)  
| [`for`](for.html "cpp/language/for")  
---  
[range-`for`](range-for.html "cpp/language/range-for") (C++11)  
  
| [`while`](while.html "cpp/language/while")  
---  
[`do-while`](do.html "cpp/language/do")  
  
Jump statements  
| [`continue`](continue.html "cpp/language/continue") \- [`break`](break.html "cpp/language/break")  
---  
  
| [`goto`](goto.html "cpp/language/goto") \- [`return`](return.html "cpp/language/return")  
---  
  
[Functions](functions.html "cpp/language/functions")  
[Function declaration](function.html "cpp/language/function")  
[Lambda function expression](lambda.html "cpp/language/lambda")  
[`inline` specifier](inline.html "cpp/language/inline")  
[Dynamic exception specifications](except_spec.html "cpp/language/except spec") (until C++17*)  
[`noexcept` specifier](noexcept_spec.html "cpp/language/noexcept spec") (C++11)  
Exceptions  
| [`throw`-expression](throw.html "cpp/language/throw")  
---  
[`try` block](try.html "cpp/language/try")  
  
|   
  
---  
[`catch` handler](catch.html "cpp/language/catch")  
  
Namespaces  
| [Namespace declaration](namespace.html "cpp/language/namespace")` `  
---  
  
| [Namespace aliases](namespace_alias.html "cpp/language/namespace alias")  
---  
  
Types  
| [Fundamental types](types.html "cpp/language/types")  
---  
[Enumeration types](enum.html "cpp/language/enum")  
[Function types](function.html "cpp/language/function")  
  
| [Class/struct types](class.html "cpp/language/class")  
---  
[Union types](union.html "cpp/language/union")  
  
  
  
Specifiers  
| [`const`/`volatile`](cv.html "cpp/language/cv")  
---  
[`decltype`](decltype.html "cpp/language/decltype") (C++11)  
[`auto`](auto.html "cpp/language/auto") (C++11)  
  
| [`constexpr`](constexpr.html "cpp/language/constexpr") (C++11)  
---  
[`consteval`](consteval.html "cpp/language/consteval") (C++20)  
[`constinit`](constinit.html "cpp/language/constinit") (C++20)  
  
[Storage duration specifiers](storage_duration.html "cpp/language/storage duration")  
[Initialization](initialization.html "cpp/language/initialization")  
| [Default-initialization](default_initialization.html "cpp/language/default initialization")  
---  
[Value-initialization](value_initialization.html "cpp/language/value initialization")  
[Zero-initialization](zero_initialization.html "cpp/language/zero initialization")  
[Copy-initialization](copy_initialization.html "cpp/language/copy initialization")  
[Direct-initialization](direct_initialization.html "cpp/language/direct initialization")  
  
| [Aggregate initialization](aggregate_initialization.html "cpp/language/aggregate initialization")  
---  
[List-initialization](list_initialization.html "cpp/language/list initialization") (C++11)` `  
[Constant initialization](constant_initialization.html "cpp/language/constant initialization")  
[Reference initialization](reference_initialization.html "cpp/language/reference initialization")  
  
  
  
[Expressions](expressions.html "cpp/language/expressions")  
---  
| [Value categories](value_category.html "cpp/language/value category")  
---  
[Order of evaluation](eval_order.html "cpp/language/eval order")  
  
| [Operators](operators.html "cpp/language/operators")  
---  
[Operator precedence](operator_precedence.html "cpp/language/operator precedence")  
  
[Alternative representations](operator_alternative.html "cpp/language/operator alternative")  
[Literals](expressions.html#Literals "cpp/language/expressions")  
[Boolean](bool_literal.html "cpp/language/bool literal") \- [Integer](integer_literal.html "cpp/language/integer literal") \- [Floating-point](floating_literal.html "cpp/language/floating literal")  
[Character](character_literal.html "cpp/language/character literal") \- [String](string_literal.html "cpp/language/string literal") \- [`nullptr`](nullptr.html "cpp/language/nullptr") (C++11)  
[User-defined](user_literal.html "cpp/language/user literal") (C++11)  
Utilities  
[Attributes](attributes.html "cpp/language/attributes") (C++11)  
Types  
[`typedef` declaration](typedef.html "cpp/language/typedef")  
[Type alias declaration](type_alias.html "cpp/language/type alias") (C++11)  
Casts  
| [Implicit conversions](implicit_cast.html "cpp/language/implicit conversion")  
---  
[`static_cast`](static_cast.html "cpp/language/static cast")  
[`const_cast`](const_cast.html "cpp/language/const cast")  
  
| [Explicit conversions](explicit_cast.html "cpp/language/explicit cast")  
---  
[`dynamic_cast`](dynamic_cast.html "cpp/language/dynamic cast")  
[`reinterpret_cast`](reinterpret_cast.html "cpp/language/reinterpret cast")  
  
Memory allocation  
| [`new` expression](new.html "cpp/language/new")  
---  
  
| [`delete` expression](delete.html "cpp/language/delete")  
---  
  
[Classes](classes.html "cpp/language/classes")  
| [Class declaration](class.html "cpp/language/class")  
---  
[Constructors](initializer_list.html "cpp/language/constructor")  
[`this` pointer](this.html "cpp/language/this")  
  
| [Access specifiers](access.html "cpp/language/access")  
---  
[`friend` specifier](friend.html "cpp/language/friend")  
  
  
  
Class-specific function properties  
| [Virtual function](virtual.html "cpp/language/virtual")  
---  
[`override` specifier](override.html "cpp/language/override") (C++11)` `  
[`final` specifier](final.html "cpp/language/final") (C++11)  
  
| [`explicit`](explicit.html "cpp/language/explicit") (C++11)  
---  
**`static`**  
  
  
  
Special member functions  
| [Default constructor](default_constructor.html "cpp/language/default constructor")  
---  
[Copy constructor](copy_constructor.html "cpp/language/copy constructor")  
[Move constructor](move_constructor.html "cpp/language/move constructor") (C++11)  
  
| [Copy assignment](as_operator.html "cpp/language/as operator")  
---  
[Move assignment](move_operator.html "cpp/language/move operator") (C++11)  
[Destructor](destructor.html "cpp/language/destructor")  
  
[Templates](templates.html "cpp/language/templates")  
| [Class template](class_template.html "cpp/language/class template")  
---  
[Function template](function_template.html "cpp/language/function template")  
  
| [Template specialization](template_specialization.html "cpp/language/template specialization")  
---  
[Parameter packs](parameter_pack.html "cpp/language/pack") (C++11)  
  
Miscellaneous  
| [Inline assembly](asm.html "cpp/language/asm")  
---  
  
| [History of C++](history.html "cpp/language/history")  
---  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/navbar_content&action=edit)

[ Classes](classes.html "cpp/language/classes")

General  
---  
[Overview](classes.html "cpp/language/classes")  
[`class`/`struct` types](class.html "cpp/language/class")  
[`union` types](union.html "cpp/language/union")  
[Injected-class-name](injected-class-name.html "cpp/language/injected-class-name")  
[Class property specifiers](class_property_specifiers.html "cpp/language/class property specifiers") (C++26)  
Members  
[Data members](data_members.html "cpp/language/data members")  
**Static members**  
[The `this` pointer](this.html "cpp/language/this")  
[Nested classes](nested_classes.html "cpp/language/nested types")  
[Member templates](member_template.html "cpp/language/member template")  
[Bit-fields](bit_field.html "cpp/language/bit field")  
[`using`-declarations](using_declaration.html "cpp/language/using declaration")  
[Member functions](member_functions.html "cpp/language/member functions")  
[Member access specifiers](access.html "cpp/language/access")  
[Constructors and member initializer lists](initializer_list.html "cpp/language/constructor")  
[Default member initializer](data_members.html#Member_initialization "cpp/language/data members") (C++11)  
[`friend` specifier](friend.html "cpp/language/friend")  
[`explicit` specifier](explicit.html "cpp/language/explicit")  
[Converting constructor](converting_constructor.html "cpp/language/converting constructor")  
Special member functions  
[Default constructor](default_constructor.html "cpp/language/default constructor")  
[Copy constructor](copy_constructor.html "cpp/language/copy constructor")  
[Move constructor](move_constructor.html "cpp/language/move constructor") (C++11)  
[Copy assignment operator](as_operator.html "cpp/language/copy assignment")  
[Move assignment operator](move_operator.html "cpp/language/move assignment") (C++11)  
[Destructor](destructor.html "cpp/language/destructor")  
Inheritance  
[Base and derived classes](derived_class.html "cpp/language/derived class")  
[Empty base optimization (EBO)](ebo.html "cpp/language/ebo")  
[Virtual member functions](virtual.html "cpp/language/virtual")  
[Pure virtual functions and abstract classes](abstract_class.html "cpp/language/abstract class")  
[`override` specifier](override.html "cpp/language/override") (C++11)  
[`final` specifier](final.html "cpp/language/final") (C++11)  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/classes/navbar_content&action=edit)

Inside a class definition, the keyword [`static`](../keywords/static.html "cpp/keywords/static") declares members that are not bound to class instances. 

Outside a class definition, it has a different meaning: see [storage duration](storage_duration.html "cpp/language/storage duration"). 

## Contents

  * [1 Syntax](static.html#Syntax)
  * [2 Explanation](static.html#Explanation)
    * [2.1 Static member functions](static.html#Static_member_functions)
    * [2.2 Static data members](static.html#Static_data_members)
    * [2.3 Constant static members](static.html#Constant_static_members)
  * [3 Keywords](static.html#Keywords)
  * [4 Defect reports](static.html#Defect_reports)
  * [5 References](static.html#References)
  * [6 See also](static.html#See_also)

  
---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/static&action=edit&section=1 "Edit section: Syntax")] Syntax

A declaration for a static member is a [member declaration](class.html#Member_specification "cpp/language/class") whose declaration specifiers contain the keyword static. The keyword static usually appears before other specifiers (which is why the syntax is often informally described as static data-member or static member-function), but may appear anywhere in the specifier sequence. 

The name of any static data member and static member function must be different from the name of the containing class. 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/static&action=edit&section=2 "Edit section: Explanation")] Explanation

Static members of a class are not associated with the objects of the class: they are independent variables with static or thread(since C++11) [storage duration](storage_duration.html "cpp/language/storage duration") or regular functions. 

The static keyword is only used with the declaration of a static member, inside the class definition, but not with the definition of that static member: 
    
    
    class X { static int n; }; // declaration (uses 'static')
    int X::n = 1;              // definition (does not use 'static')

The declaration inside the class body is not a definition and may declare the member to be of [incomplete type](incomplete_type.html "cpp/language/incomplete type") (other than void), including the type in which the member is declared: 
    
    
    struct Foo;
     
    struct S
    {
        static int a[]; // declaration, incomplete type
        static Foo x;   // declaration, incomplete type
        static S s;     // declaration, incomplete type (inside its own definition)
    };
     
    int S::a[10]; // definition, complete type
    struct Foo {};
    Foo S::x;     // definition, complete type
    S S::s;       // definition, complete type

However, if the declaration uses [`constexpr`](constexpr.html "cpp/language/constexpr") or [`inline`](inline.html "cpp/language/inline")(since C++17) specifier, the member must be declared to have complete type.  | (since C++11)  
---|---  
  
To refer to a static member `m` of class `T`, two forms may be used: qualified name `T::m` or member access expression `E.m` or `E->m`, where `E` is an expression that evaluates to `T` or `T*` respectively. When in the same class scope, the qualification is unnecessary: 
    
    
    struct X
    {
        static void f(); // declaration
        static int n;    // declaration
    };
     
    X g() { return X(); } // some function returning X
     
    void f()
    {
        X::f();  // X::f is a qualified name of static member function
        g().f(); // g().f is member access expression referring to a static member function
    }
     
    int X::n = 7; // definition
     
    void X::f() // definition
    {
        n = 1; // X::n is accessible as just n in this scope
    }

Static members obey the [class member access rules (private, protected, public)](access.html "cpp/language/access"). 

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/static&action=edit&section=3 "Edit section: Static member functions")] Static member functions

Static member functions are not associated with any object. When called, they have no this pointer. 

Static member functions cannot be virtual, const, volatile, or [ref-qualified](member_functions.html#ref-qualified_member_functions "cpp/language/member functions"). 

The address of a static member function may be stored in a regular [pointer to function](pointer.html#Pointers_to_functions "cpp/language/pointer"), but not in a [pointer to member function](pointer.html#Pointers_to_member_functions "cpp/language/pointer"). 

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/static&action=edit&section=4 "Edit section: Static data members")] Static data members

Static data members are not associated with any object. They exist even if no objects of the class have been defined. There is only one instance of the static data member in the entire program with static [storage duration](storage_duration.html "cpp/language/storage duration"), unless the keyword [`thread_local`](../keyword/thread_local.html "cpp/keyword/thread local") is used, in which case there is one such object per thread with thread storage duration(since C++11). 

Static data members cannot be mutable. 

Static data members of a class in namespace scope have [external linkage](storage_duration.html "cpp/language/storage duration") if the class itself has external linkage (is not a member of [unnamed namespace](namespace.html#Unnamed_namespaces "cpp/language/namespace")). Local classes (classes defined inside functions) and unnamed classes, including member classes of unnamed classes, cannot have static data members. 

A static data member may be declared [`inline`](inline.html "cpp/language/inline"). An inline static data member can be defined in the class definition and may specify an initializer. It does not need an out-of-class definition: 
    
    
    struct X
    {
        inline static int fully_usable = 1; // No out-of-class definition required, ODR-usable
        inline static const [std::string](../string/basic_string.html) class_name{"X"}; // Likewise
     
        static const int non_addressable = 1; // C.f. non-inline constants, usable
                                              // for its value, but not ODR-usable
        // static const std::string class_name{"X"}; // Non-integral declaration of this
                                                     // form is disallowed entirely
    };

| (since C++17)  
---|---  
  
#### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/static&action=edit&section=5 "Edit section: Constant static members")] Constant static members

If a static data member of integral or enumeration type is declared const (and not volatile), it can be initialized with an [initializer](initialization.html "cpp/language/initialization") in which every expression is a [constant expression](constexpr.html "cpp/language/constexpr"), right inside the class definition: 
    
    
    struct X
    {
        const static int n = 1;
        const static int m{2}; // since C++11
        const static int k;
    };
    const int X::k = 3;

If a static data member of [LiteralType](../named_req/LiteralType.html "cpp/named req/LiteralType") is declared constexpr, it must be initialized with an initializer in which every expression is a constant expression, right inside the class definition: 
    
    
    struct X
    {
        constexpr static int arr[] = { 1, 2, 3 };        // OK
        constexpr static [std::complex](../numeric/complex.html)<double> n = {1,2}; // OK
        constexpr static int k; // Error: constexpr static requires an initializer
    };

| (since C++11)  
---|---  
  
If a const non-inline(since C++17) static data member or a constexpr static data member(since C++11)(until C++17) is [ODR-use](definition.html#ODR-use "cpp/language/definition"), a definition at namespace scope is still required, but it cannot have an initializer. 

A constexpr static data member is implicitly inline and does not need to be redeclared at namespace scope. This redeclaration without an initializer (formerly required) is still permitted, but is deprecated.  | (since C++17)  
---|---  
      
    
    struct X
    {
        static const int n = 1;
        static constexpr int m = 4;
    };
     
    const int *p = &X::n, *q = &X::m; // X::n and X::m are ODR-used
    const int X::n;             // … so a definition is necessary
    constexpr int X::m;         // … (except for X::m in C++17)

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/static&action=edit&section=6 "Edit section: Keywords")] Keywords

[`static`](../keywords/static.html "cpp/keyword/static")

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/static&action=edit&section=7 "Edit section: Defect reports")] Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[CWG 194](https://cplusplus.github.io/CWG/issues/194.html) | C++98  | (static) member function names can be the same as the class name  | naming restriction added (including  
[non-static member functions](member_functions.html#Defect_report "cpp/language/member functions"))   
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/static&action=edit&section=8 "Edit section: References")] References

  * C++23 standard (ISO/IEC 14882:2024): 



    

  * 11.4.9 Static members [class.static] 



  * C++20 standard (ISO/IEC 14882:2020): 



    

  * 11.4.8 Static members [class.static] 



  * C++17 standard (ISO/IEC 14882:2017): 



    

  * 12.2.3 Static members [class.static] 



  * C++14 standard (ISO/IEC 14882:2014): 



    

  * 9.4 Static members [class.static] 



  * C++11 standard (ISO/IEC 14882:2011): 



    

  * 9.4 Static members [class.static] 



  * C++98 standard (ISO/IEC 14882:1998): 



    

  * 9.4 Static members [class.static] 



### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/static&action=edit&section=9 "Edit section: See also")] See also

  * [`static` storage specifier](storage_duration.html "cpp/language/storage duration")


