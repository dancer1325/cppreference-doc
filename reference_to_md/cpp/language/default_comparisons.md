[C++](../../cpp.html "cpp")

[Compiler support](../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../freestanding.html "cpp/freestanding")  
[Language](../language.html "cpp/language")  
[Standard library](../standard_library.html "cpp/standard library")  
[Standard library headers](../headers.html "cpp/header")  
[Named requirements](../iterator/concepts.html "cpp/named req")  
[Feature test macros](../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../utility.html#Language_support "cpp/utility")  
[Concepts library](../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../error.html "cpp/error")  
[Memory management library](../memory.html "cpp/memory")  
[Metaprogramming library](../meta.html "cpp/meta") (C++11)  
[General utilities library](../utility.html "cpp/utility")  
[Containers library](../container.html "cpp/container")  
[Iterators library](../iterator.html "cpp/iterator")  
[Ranges library](../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../algorithm.html "cpp/algorithm")  
[Strings library](../string.html "cpp/string")  
[Text processing library](../text.html "cpp/text")  
[Numerics library](../numeric.html "cpp/numeric")  
[Date and time library](../chrono.html "cpp/chrono")  
[Input/output library](../io.html "cpp/io")  
[Filesystem library](../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../atomic.html "cpp/thread") (C++11)  
[Execution control library](../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../experimental.html "cpp/experimental")  
[Symbols index](../symbol_index.html "cpp/symbol index")  
[External libraries](../links/libs.html "cpp/links/libs")  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/navbar_content&action=edit)

[C++ language](../language.html "cpp/language")

General topics  
---  
| [Preprocessor](../preprocessor.html "cpp/preprocessor")  
---  
[Comments](../comments.html "cpp/comment")  
  
| [Keywords](../keywords.html "cpp/keyword")  
---  
[Escape sequences](escape.html "cpp/language/escape")  
  
[Flow control](statements.html "cpp/language/statements")  
Conditional execution statements  
| [`if`](if.html "cpp/language/if")  
---  
  
| [`switch`](switch.html "cpp/language/switch")  
---  
  
Iteration statements (loops)  
| [`for`](for.html "cpp/language/for")  
---  
[range-`for`](range-for.html "cpp/language/range-for") (C++11)  
  
| [`while`](while.html "cpp/language/while")  
---  
[`do-while`](do.html "cpp/language/do")  
  
Jump statements  
| [`continue`](continue.html "cpp/language/continue") \- [`break`](break.html "cpp/language/break")  
---  
  
| [`goto`](goto.html "cpp/language/goto") \- [`return`](return.html "cpp/language/return")  
---  
  
[Functions](functions.html "cpp/language/functions")  
[Function declaration](function.html "cpp/language/function")  
[Lambda function expression](lambda.html "cpp/language/lambda")  
[`inline` specifier](inline.html "cpp/language/inline")  
[Dynamic exception specifications](except_spec.html "cpp/language/except spec") (until C++17*)  
[`noexcept` specifier](noexcept_spec.html "cpp/language/noexcept spec") (C++11)  
Exceptions  
| [`throw`-expression](throw.html "cpp/language/throw")  
---  
[`try` block](try.html "cpp/language/try")  
  
|   
  
---  
[`catch` handler](catch.html "cpp/language/catch")  
  
Namespaces  
| [Namespace declaration](namespace.html "cpp/language/namespace")` `  
---  
  
| [Namespace aliases](namespace_alias.html "cpp/language/namespace alias")  
---  
  
Types  
| [Fundamental types](types.html "cpp/language/types")  
---  
[Enumeration types](enum.html "cpp/language/enum")  
[Function types](function.html "cpp/language/function")  
  
| [Class/struct types](class.html "cpp/language/class")  
---  
[Union types](union.html "cpp/language/union")  
  
  
  
Specifiers  
| [`const`/`volatile`](cv.html "cpp/language/cv")  
---  
[`decltype`](decltype.html "cpp/language/decltype") (C++11)  
[`auto`](auto.html "cpp/language/auto") (C++11)  
  
| [`constexpr`](constexpr.html "cpp/language/constexpr") (C++11)  
---  
[`consteval`](consteval.html "cpp/language/consteval") (C++20)  
[`constinit`](constinit.html "cpp/language/constinit") (C++20)  
  
[Storage duration specifiers](storage_duration.html "cpp/language/storage duration")  
[Initialization](initialization.html "cpp/language/initialization")  
| [Default-initialization](default_initialization.html "cpp/language/default initialization")  
---  
[Value-initialization](value_initialization.html "cpp/language/value initialization")  
[Zero-initialization](zero_initialization.html "cpp/language/zero initialization")  
[Copy-initialization](copy_initialization.html "cpp/language/copy initialization")  
[Direct-initialization](direct_initialization.html "cpp/language/direct initialization")  
  
| [Aggregate initialization](aggregate_initialization.html "cpp/language/aggregate initialization")  
---  
[List-initialization](list_initialization.html "cpp/language/list initialization") (C++11)` `  
[Constant initialization](constant_initialization.html "cpp/language/constant initialization")  
[Reference initialization](reference_initialization.html "cpp/language/reference initialization")  
  
  
  
[Expressions](expressions.html "cpp/language/expressions")  
---  
| [Value categories](value_category.html "cpp/language/value category")  
---  
[Order of evaluation](eval_order.html "cpp/language/eval order")  
  
| [Operators](operators.html "cpp/language/operators")  
---  
[Operator precedence](operator_precedence.html "cpp/language/operator precedence")  
  
[Alternative representations](operator_alternative.html "cpp/language/operator alternative")  
[Literals](expressions.html#Literals "cpp/language/expressions")  
[Boolean](bool_literal.html "cpp/language/bool literal") \- [Integer](integer_literal.html "cpp/language/integer literal") \- [Floating-point](floating_literal.html "cpp/language/floating literal")  
[Character](character_literal.html "cpp/language/character literal") \- [String](string_literal.html "cpp/language/string literal") \- [`nullptr`](nullptr.html "cpp/language/nullptr") (C++11)  
[User-defined](user_literal.html "cpp/language/user literal") (C++11)  
Utilities  
[Attributes](attributes.html "cpp/language/attributes") (C++11)  
Types  
[`typedef` declaration](typedef.html "cpp/language/typedef")  
[Type alias declaration](type_alias.html "cpp/language/type alias") (C++11)  
Casts  
| [Implicit conversions](implicit_cast.html "cpp/language/implicit conversion")  
---  
[`static_cast`](static_cast.html "cpp/language/static cast")  
[`const_cast`](const_cast.html "cpp/language/const cast")  
  
| [Explicit conversions](explicit_cast.html "cpp/language/explicit cast")  
---  
[`dynamic_cast`](dynamic_cast.html "cpp/language/dynamic cast")  
[`reinterpret_cast`](reinterpret_cast.html "cpp/language/reinterpret cast")  
  
Memory allocation  
| [`new` expression](new.html "cpp/language/new")  
---  
  
| [`delete` expression](delete.html "cpp/language/delete")  
---  
  
[Classes](classes.html "cpp/language/classes")  
| [Class declaration](class.html "cpp/language/class")  
---  
[Constructors](initializer_list.html "cpp/language/constructor")  
[`this` pointer](this.html "cpp/language/this")  
  
| [Access specifiers](access.html "cpp/language/access")  
---  
[`friend` specifier](friend.html "cpp/language/friend")  
  
  
  
Class-specific function properties  
| [Virtual function](virtual.html "cpp/language/virtual")  
---  
[`override` specifier](override.html "cpp/language/override") (C++11)` `  
[`final` specifier](final.html "cpp/language/final") (C++11)  
  
| [`explicit`](explicit.html "cpp/language/explicit") (C++11)  
---  
[`static`](static.html "cpp/language/static")  
  
  
  
Special member functions  
| [Default constructor](default_constructor.html "cpp/language/default constructor")  
---  
[Copy constructor](copy_constructor.html "cpp/language/copy constructor")  
[Move constructor](move_constructor.html "cpp/language/move constructor") (C++11)  
  
| [Copy assignment](as_operator.html "cpp/language/as operator")  
---  
[Move assignment](move_operator.html "cpp/language/move operator") (C++11)  
[Destructor](destructor.html "cpp/language/destructor")  
  
[Templates](templates.html "cpp/language/templates")  
| [Class template](class_template.html "cpp/language/class template")  
---  
[Function template](function_template.html "cpp/language/function template")  
  
| [Template specialization](template_specialization.html "cpp/language/template specialization")  
---  
[Parameter packs](parameter_pack.html "cpp/language/pack") (C++11)  
  
Miscellaneous  
| [Inline assembly](asm.html "cpp/language/asm")  
---  
  
| [History of C++](history.html "cpp/language/history")  
---  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/navbar_content&action=edit)

[ Expressions](expressions.html "cpp/language/expressions")

General  
---  
| [Value categories](value_category.html "cpp/language/value category")  
---  
[Order of evaluation](eval_order.html "cpp/language/eval order")  
[Constant expressions](constant_expression.html "cpp/language/constant expression")  
[Primary expressions](expressions.html#Primary_expressions "cpp/language/expressions")  
  
| [Lambda expressions](lambda.html "cpp/language/lambda") (C++11)  
---  
[Requires expressions](requires.html "cpp/language/requires") (C++20)  
[Pack indexing expression](pack_indexing.html#Pack_indexing_expression "cpp/language/pack indexing") (C++26)  
[Potentially-evaluated expressions](expressions.html#Potentially-evaluated_expressions "cpp/language/expressions")  
  
Literals  
| [Integer literals](integer_literal.html "cpp/language/integer literal")  
---  
[Floating-point literals](floating_literal.html "cpp/language/floating literal")  
[Boolean literals](bool_literal.html "cpp/language/bool literal")  
[Character literals](character_literal.html "cpp/language/character literal")  
  
| [Escape sequences](escape.html "cpp/language/escape")  
---  
[String literals](string_literal.html "cpp/language/string literal")  
[Null pointer literal](nullptr.html "cpp/language/nullptr") (C++11)  
[User-defined literal](user_literal.html "cpp/language/user literal") (C++11)  
  
Operators  
| [Assignment operators](operator_assignment.html "cpp/language/operator assignment")  
---  
[Increment and decrement](operator_incdec.html "cpp/language/operator incdec")  
[Arithmetic operators](operator_arithmetic.html "cpp/language/operator arithmetic")  
[Logical operators](operator_logical.html "cpp/language/operator logical")  
[Comparison operators](operator_comparison.html "cpp/language/operator comparison")  
[Member access operators](operator_member_access.html "cpp/language/operator member access")  
[Other operators](operator_other.html "cpp/language/operator other")  
[`new`-expression](new.html "cpp/language/new")  
[`delete`-expression](delete.html "cpp/language/delete")  
[`throw`-expression](throw.html "cpp/language/throw")  
  
| [`alignof`](alignof.html "cpp/language/alignof")  
---  
[`sizeof`](sizeof.html "cpp/language/sizeof")  
[`sizeof...`](sizeof....html "cpp/language/sizeof...") (C++11)  
[`typeid`](typeid.html "cpp/language/typeid")  
[`noexcept`](noexcept.html "cpp/language/noexcept") (C++11)  
[Fold expressions](fold.html "cpp/language/fold") (C++17)  
[Alternative representations of operators](operator_alternative.html "cpp/language/operator alternative")  
[Precedence and associativity](operator_precedence.html "cpp/language/operator precedence")  
[Operator overloading](operators.html "cpp/language/operators")  
**Default comparisons** (C++20)  
  
Conversions  
| [Implicit conversions](implicit_cast.html "cpp/language/implicit conversion")  
---  
[Explicit conversions](explicit_cast.html "cpp/language/explicit cast")  
[Usual arithmetic conversions](usual_arithmetic_conversions.html "cpp/language/usual arithmetic conversions")  
[User-defined conversion](cast_operator.html "cpp/language/cast operator")  
  
| [`const_cast`](const_cast.html "cpp/language/const cast")  
---  
[`static_cast`](static_cast.html "cpp/language/static cast")  
[`dynamic_cast`](dynamic_cast.html "cpp/language/dynamic cast")  
[`reinterpret_cast`](reinterpret_cast.html "cpp/language/reinterpret cast")  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/expressions/navbar_content&action=edit)

Comparison operator functions can be explicitly defaulted to request the compiler to generate the corresponding default comparison for a class. 

## Contents

  * [1 Definition](default_comparisons.html#Definition)
  * [2 Default comparison order](default_comparisons.html#Default_comparison_order)
  * [3 Three-way comparison](default_comparisons.html#Three-way_comparison)
    * [3.1 Comparison category types](default_comparisons.html#Comparison_category_types)
    * [3.2 Synthesized three-way comparison](default_comparisons.html#Synthesized_three-way_comparison)
    * [3.3 Placeholder return type](default_comparisons.html#Placeholder_return_type)
    * [3.4 Non-placeholder return type](default_comparisons.html#Non-placeholder_return_type)
    * [3.5 Comparison result](default_comparisons.html#Comparison_result)
  * [4 Equality comparison](default_comparisons.html#Equality_comparison)
    * [4.1 Explicit declaration](default_comparisons.html#Explicit_declaration)
    * [4.2 Implicit declaration](default_comparisons.html#Implicit_declaration)
  * [5 Secondary comparison](default_comparisons.html#Secondary_comparison)
  * [6 Keywords](default_comparisons.html#Keywords)
  * [7 Defect reports](default_comparisons.html#Defect_reports)
  * [8 See also](default_comparisons.html#See_also)

  
---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/default_comparisons&action=edit&section=1 "Edit section: Definition")] Definition

A _defaulted comparison operator function_ is a non-template comparison operator function (i.e. `<=>`, `==`, `!=`, `<`, `>`, `<=`, or `>=`) satisfying all following conditions: 

  * It is a [non-static member](member_functions.html "cpp/language/member functions") or [friend](friend.html "cpp/language/friend") of some class `C`. 
  * It is [defined as defaulted](function.html#Function_definition "cpp/language/function") in `C` or in a context where `C` is [complete](type-id.html#Incomplete_type "cpp/language/type"). 
  * It has two parameters of type const C& or two parameters of type `C`, where the [implicit object parameter](overload_resolution.html#Additional_rules_for_member_function_candidates "cpp/language/overload resolution") (if any) is considered to be the first parameter. 



Such a comparison operator function is termed a _defaulted comparison operator function for class`C`_. 
    
    
    struct X
    {
        bool operator==(const X&) const = default; // OK
        bool operator==(const X&) = default;       // Error: the implicit object
                                                   //        parameter type is X&
        bool operator==(this X, X) = default;      // OK
    };
     
    struct Y
    {
        friend bool operator==(Y, Y) = default;        // OK
        friend bool operator==(Y, const Y&) = default; // Error: different parameter types
    };
     
    bool operator==(const Y&, const Y&) = default;     // Error: not a friend of Y

Name lookups and access checks in the implicit definition of a comparison operator function are performed from a context equivalent to its function body. A definition of a comparison operator function as defaulted that appears in a class must be the first declaration of that function. 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/default_comparisons&action=edit&section=2 "Edit section: Default comparison order")] Default comparison order

Given a class `C`, a subobject list is formed by the following subjects in order: 

  * The direct base class subobjects of `C`, in declaration order. 
  * The non-static [data members](data_members.html "cpp/language/data members") of `C`, in declaration order. 



    

  * If any member subobject is of array type, it is expanded to the sequence of its elements, in the order of increasing subscript. The expansion is recursive: array elements of array types will be expanded again until there is no subobject of array type. 



For any object x of type `C`, in the following descriptions: 

  * Let n be the number of subobjects in the (expanded) subobject list for x. 
  * Let x_i be the ith subobject in the (expanded) subobject list for x, where x_i is formed by a sequence of [derived-to-base conversions](overload_resolution.html#Ranking_of_implicit_conversion_sequences "cpp/language/overload resolution"), [class member access expressions](operator_member_access.html#Built-in_member_access_operators "cpp/language/operator member access"), and [array subscript expressions](operator_member_access.html#Built-in_subscript_operator "cpp/language/operator member access") applied to x. 


    
    
    struct S {};
     
    struct T : S
    {
        int arr[2][2];
    } t;
     
    // The subobject list for “t” consists of the following 5 subobjects in order:
    // (S)t → t[0][0] → t[0][1] → t[1][0] → t[1][1]

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/default_comparisons&action=edit&section=3 "Edit section: Three-way comparison")] Three-way comparison

An operator<=> for a class type can be defined as defaulted with any return type. 

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/default_comparisons&action=edit&section=4 "Edit section: Comparison category types")] Comparison category types

There are three comparison category types: 

  * [`std::strong_ordering`](../utility/compare/strong_ordering.html "cpp/utility/compare/strong ordering")
  * [`std::weak_ordering`](../utility/compare/weak_ordering.html "cpp/utility/compare/weak ordering")
  * [`std::partial_ordering`](../utility/compare/partial_ordering.html "cpp/utility/compare/partial ordering")

Type  |  Equivalent values are..  |  Incomparable values are..   
---|---|---  
[`std::strong_ordering`](../utility/compare/strong_ordering.html "cpp/utility/compare/strong ordering") | indistinguishable  | not allowed   
[`std::weak_ordering`](../utility/compare/weak_ordering.html "cpp/utility/compare/weak ordering") | distinguishable  | not allowed   
[`std::partial_ordering`](../utility/compare/partial_ordering.html "cpp/utility/compare/partial ordering") | distinguishable  | allowed   
  
#### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/default_comparisons&action=edit&section=5 "Edit section: Synthesized three-way comparison")] Synthesized three-way comparison

The _synthesized three-way comparison_ of type `T` between glvalues a and b of the same type is defined as follows: 

  * If the overload resolution for a <=> b results in a usable candidate, and can be explicitly converted to `T` using [`static_cast`](static_cast.html "cpp/language/static cast"), the synthesized comparison is static_cast<T>(a <=> b). 
  * Otherwise, if any of the following condition is satisfied, the synthesized comparison is not defined: 



    

  * The overload resolution for a <=> b finds at least one viable candidate. 
  * `T` is not a comparison category type. 
  * The overload resolution for a == b does not result in a usable candidate. 
  * The overload resolution for a < b does not result in a usable candidate. 



  * Otherwise, if `T` is [`std::strong_ordering`](../utility/compare/strong_ordering.html "cpp/utility/compare/strong ordering"), the synthesized comparison is 


    
    
    a == b ? std::strong_ordering::equal :
    a < b  ? std::strong_ordering::less :
             std::strong_ordering::greater

  * Otherwise, if `T` is [`std::weak_ordering`](../utility/compare/weak_ordering.html "cpp/utility/compare/weak ordering"), the synthesized comparison is 


    
    
    a == b ? std::weak_ordering::equivalent :
    a < b  ? std::weak_ordering::less :
             std::weak_ordering::greater

  * Otherwise (`T` is [`std::partial_ordering`](../utility/compare/partial_ordering.html "cpp/utility/compare/partial ordering")), the synthesized comparison is 


    
    
    a == b ? std::partial_ordering::equivalent :
    a < b  ? std::partial_ordering::less :
    b < a  ? std::partial_ordering::greater : 
             std::partial_ordering::unordered

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/default_comparisons&action=edit&section=6 "Edit section: Placeholder return type")] Placeholder return type

If the declared return type of a defaulted three-way comparison operator function (operator<=>) for a class type `C` is auto, the return type is deduced from the return types of the three-way comparisons between the corresponding subobjects of an object x of type `C`. 

For each subobject x_i in the [(expanded) subobject list](default_comparisons.html#Default_comparison_order) for x: 

  1. Perform overload resolution for x_i <=> x_i, if the overload resolution does not result in a usable candidate, the defaulted operator<=> is defined as deleted. 
  2. Denote the cv-unqualified version of the type of x_i <=> x_i as `R_i`, if `R_i` is not a comparison category type, the defaulted operator<=> is defined as deleted. 



If the defaulted operator<=> is not defined as deleted, its return type is deduced as [std::common_comparison_category_t](../utility/compare/common_comparison_category.html)<R_1, R_2, ..., R_n>. 

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/default_comparisons&action=edit&section=7 "Edit section: Non-placeholder return type")] Non-placeholder return type

If the declared return type of the defaulted operator<=> is not auto, it cannot contain any [placeholder type](auto.html "cpp/language/auto") (e.g. decltype(auto)). 

If there is a subobject x_i in the (expanded) subobject list for x such that the [synthesized three-way comparison](default_comparisons.html#Synthesized_three-way_comparison) of the declared return type between x_i and x_i is not defined, the defaulted operator<=> is defined as deleted. 

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/default_comparisons&action=edit&section=8 "Edit section: Comparison result")] Comparison result

Let x and y be the parameters of a defaulted operator<=>, denote each subobject in the (expanded) subobject list for x and y as x_i and y_i respectively. The default three-way comparison between x and y is performed by comparing corresponding subobjects x_i and y_i with increasing i order. 

Let `R` be the (possibly-deduced) return type, the comparison result between x_i and y_i is the result of the synthesized three-way comparison of type `R` between x_i and y_i. 

  * During the default three-way comparison between x and y, if a subobject-wise comparison between x_i and y_i generates a result v_i such that contextually converting v_i != 0 to bool yields true, the return value is a copy of v_i (the remaining subobjects will not be compared). 
  * Otherwise, the return value is static_cast<R>(std::strong_ordering::equal). 



Run this code
    
    
    #include <compare>
    #include <iostream>
    #include <set>
     
    struct Point
    {
        int x;
        int y;
        auto operator<=>(const Point&) const = default;
        /* non-comparison functions */
    };
     
    int main()
    {
        Point pt1{1, 1}, pt2{1, 2};
        [std::set](../container/set.html)<Point> s; // OK
        s.insert(pt1);     // OK
     
        // two-way comparison operator functions are not required to be explicitly defined:
        // operator== is implicitly declared (see below)
        // the overload resolutions of other candidates will select rewritten candidates 
        [std::cout](../io/cout.html) << [std::boolalpha](../io/manip/boolalpha.html)
            << (pt1 == pt2) << ' '  // false
            << (pt1 != pt2) << ' '  // true
            << (pt1 <  pt2) << ' '  // true
            << (pt1 <= pt2) << ' '  // true
            << (pt1 >  pt2) << ' '  // false
            << (pt1 >= pt2) << ' '; // false
    }

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/default_comparisons&action=edit&section=9 "Edit section: Equality comparison")] Equality comparison

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/default_comparisons&action=edit&section=10 "Edit section: Explicit declaration")] Explicit declaration

An operator== for a class type can be defined as defaulted with return type bool. 

Given a class `C` and an object x of type `C`, if there is a subobject x_i in the (expanded) subobject list for x such that the overload resolution for x_i == x_i does not result in a usable candidate, the defaulted operator== is defined as deleted. 

Let x and y be the parameters of a defaulted operator==, denote each subobject in the (expanded) subobject list for x and y as x_i and y_i respectively. The default equality comparison between x and y is performed by comparing corresponding subobjects x_i and y_i with increasing i order. 

The comparison result between x_i and y_i is the result of x_i == y_i. 

  * During the default equality comparison between x and y, if a subobject-wise comparison between x_i and y_i generates a result v_i such that contextually converting v_i to bool yields false, the return value is false (the remaining subobjects will not be compared). 
  * Otherwise, the return value is true. 



Run this code
    
    
    #include <iostream>
     
    struct Point
    {
        int x;
        int y;
        bool operator==(const Point&) const = default;
        /* non-comparison functions */
    };
     
    int main()
    {
        Point pt1{3, 5}, pt2{2, 5};
        [std::cout](../io/cout.html) << [std::boolalpha](../io/manip/boolalpha.html)
            << (pt1 != pt2) << '\n'  // true
            << (pt1 == pt1) << '\n'; // true
     
        struct [[maybe_unused]] { int x{}, y{}; } p, q;
        // if (p == q) {} // Error: operator== is not defined
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/default_comparisons&action=edit&section=11 "Edit section: Implicit declaration")] Implicit declaration

If a class `C` does not explicitly declare any member or friend named operator==, an `==` operator function is declared implicitly for each operator<=> defined as defaulted. Each implicity-declared operator== have the same access and [function definition](function.html#Function_definition "cpp/language/function") and in the same [class scope](scope.html#Class_scope "cpp/language/scope") as the respective defaulted operator<=>, with the following changes: 

  * The [declarator identifier](declarations.html#Declarators "cpp/language/declarations") is replaced with operator==. 
  * The return type is replaced with bool. 


    
    
    template<typename T>
    struct X
    {
        friend constexpr [std::partial_ordering](../utility/compare/partial_ordering.html) operator<=>(X, X)
            requires (sizeof(T) != 1) = default;
        // implicitly declares: friend constexpr bool operator==(X, X)
        //                          requires (sizeof(T) != 1) = default;
     
        [[nodiscard]] virtual [std::strong_ordering](../utility/compare/strong_ordering.html) operator<=>(const X&) const = default;
        // implicitly declares: [[nodiscard]] virtual bool
        //                          operator==(const X&) const = default;
    };

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/default_comparisons&action=edit&section=12 "Edit section: Secondary comparison")] Secondary comparison

A secondary comparison operator function (`!=`, `<`, `>`, `<=`, or `>=`) for a class type can be defined as defaulted with return type bool. 

Let `@` be one of the five secondary comparison operators, for each defaulted operator@ with parameters x and y, up to two overloads resolutions are performed (not considering the defaulted operator@ as a candidate) to determine whether it is defined as deleted. 

  * The first overload resolution is performed for x @ y. If the overload resolution does not result in a usable candidate, or the selected candidate is not a [rewritten candidate](overload_resolution.html#Call_to_an_overloaded_operator "cpp/language/overload resolution"), the defaulted operator@ is defined as deleted. There is no second overload resolution in these cases. 
  * The second overload resolution is performed for the selected rewritten candidate of x @ y. If the overload resolution does not result in a usable candidate, the defaulted operator@ is defined as deleted. 



If is x @ y cannot be implicitly converted to bool, the defaulted operator@ is defined as deleted. 

If the defaulted operator@ is not defined as deleted, it yields x @ y. 
    
    
    struct HasNoRelational {};
     
    struct C
    {
        friend HasNoRelational operator<=>(const C&, const C&);
        bool operator<(const C&) const = default; // OK, function is defaulted
    };

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/default_comparisons&action=edit&section=13 "Edit section: Keywords")] Keywords

[`default`](../keyword/default.html "cpp/keyword/default")

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/default_comparisons&action=edit&section=14 "Edit section: Defect reports")] Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[CWG 2539](https://cplusplus.github.io/CWG/issues/2539.html) | C++20  | the synthesized three-way comparison would choose  
static_cast even if the explicit conversion is not available  | does not choose  
static_cast in this case   
[CWG 2546](https://cplusplus.github.io/CWG/issues/2546.html) | C++20  | the defaulted secondary operator@ was not  
defined as deleted if the overload resolution of  
x @ y selects a non-usable rewritten candidate  | defined as deleted  
in this case   
[CWG 2547](https://cplusplus.github.io/CWG/issues/2547.html) | C++20  | it was unclear whether comparison operator  
functions for non-classes can be defaulted  | they cannot be defaulted   
[CWG 2568](https://cplusplus.github.io/CWG/issues/2568.html) | C++20  | the implicit definition of comparison operator  
functions might violate member access rules  | access checks are performed  
from a context equivalent  
to their function bodies   
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/default_comparisons&action=edit&section=15 "Edit section: See also")] See also

  * [overload resolution](overload_resolution.html#Call_to_an_overloaded_operator "cpp/language/overload resolution") in a call to an overloaded operator 
  * Built-in [three-way comparison operator](operator_comparison.html#Three-way_comparison "cpp/language/operator comparison")
  * [Operator overloading](operators.html#Comparison_operators "cpp/language/operators") for comparison operators 


