[C++](../../cpp.html "cpp")

[Compiler support](../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../freestanding.html "cpp/freestanding")  
[Language](../language.html "cpp/language")  
[Standard library](../standard_library.html "cpp/standard library")  
[Standard library headers](../headers.html "cpp/header")  
[Named requirements](../iterator/concepts.html "cpp/named req")  
[Feature test macros](../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../utility.html#Language_support "cpp/utility")  
[Concepts library](../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../error.html "cpp/error")  
[Memory management library](../memory.html "cpp/memory")  
[Metaprogramming library](../meta.html "cpp/meta") (C++11)  
[General utilities library](../utility.html "cpp/utility")  
[Containers library](../container.html "cpp/container")  
[Iterators library](../iterator.html "cpp/iterator")  
[Ranges library](../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../algorithm.html "cpp/algorithm")  
[Strings library](../string.html "cpp/string")  
[Text processing library](../text.html "cpp/text")  
[Numerics library](../numeric.html "cpp/numeric")  
[Date and time library](../chrono.html "cpp/chrono")  
[Input/output library](../io.html "cpp/io")  
[Filesystem library](../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../atomic.html "cpp/thread") (C++11)  
[Execution control library](../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../experimental.html "cpp/experimental")  
[Symbols index](../symbol_index.html "cpp/symbol index")  
[External libraries](../links/libs.html "cpp/links/libs")  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/navbar_content&action=edit)

[C++ language](../language.html "cpp/language")

General topics  
---  
| [Preprocessor](../preprocessor.html "cpp/preprocessor")  
---  
[Comments](../comments.html "cpp/comment")  
  
| [Keywords](../keywords.html "cpp/keyword")  
---  
[Escape sequences](escape.html "cpp/language/escape")  
  
[Flow control](statements.html "cpp/language/statements")  
Conditional execution statements  
| [`if`](if.html "cpp/language/if")  
---  
  
| [`switch`](switch.html "cpp/language/switch")  
---  
  
Iteration statements (loops)  
| [`for`](for.html "cpp/language/for")  
---  
[range-`for`](range-for.html "cpp/language/range-for") (C++11)  
  
| [`while`](while.html "cpp/language/while")  
---  
[`do-while`](do.html "cpp/language/do")  
  
Jump statements  
| [`continue`](continue.html "cpp/language/continue") \- [`break`](break.html "cpp/language/break")  
---  
  
| [`goto`](goto.html "cpp/language/goto") \- [`return`](return.html "cpp/language/return")  
---  
  
[Functions](functions.html "cpp/language/functions")  
[Function declaration](function.html "cpp/language/function")  
[Lambda function expression](lambda.html "cpp/language/lambda")  
[`inline` specifier](inline.html "cpp/language/inline")  
[Dynamic exception specifications](except_spec.html "cpp/language/except spec") (until C++17*)  
[`noexcept` specifier](noexcept_spec.html "cpp/language/noexcept spec") (C++11)  
Exceptions  
| [`throw`-expression](throw.html "cpp/language/throw")  
---  
[`try` block](try.html "cpp/language/try")  
  
|   
  
---  
[`catch` handler](catch.html "cpp/language/catch")  
  
Namespaces  
| [Namespace declaration](namespace.html "cpp/language/namespace")` `  
---  
  
| [Namespace aliases](namespace_alias.html "cpp/language/namespace alias")  
---  
  
Types  
| [Fundamental types](types.html "cpp/language/types")  
---  
[Enumeration types](enum.html "cpp/language/enum")  
[Function types](function.html "cpp/language/function")  
  
| [Class/struct types](class.html "cpp/language/class")  
---  
[Union types](union.html "cpp/language/union")  
  
  
  
Specifiers  
| [`const`/`volatile`](cv.html "cpp/language/cv")  
---  
[`decltype`](decltype.html "cpp/language/decltype") (C++11)  
[`auto`](auto.html "cpp/language/auto") (C++11)  
  
| [`constexpr`](constexpr.html "cpp/language/constexpr") (C++11)  
---  
[`consteval`](consteval.html "cpp/language/consteval") (C++20)  
[`constinit`](constinit.html "cpp/language/constinit") (C++20)  
  
[Storage duration specifiers](storage_duration.html "cpp/language/storage duration")  
[Initialization](initialization.html "cpp/language/initialization")  
| [Default-initialization](default_initialization.html "cpp/language/default initialization")  
---  
[Value-initialization](value_initialization.html "cpp/language/value initialization")  
[Zero-initialization](zero_initialization.html "cpp/language/zero initialization")  
[Copy-initialization](copy_initialization.html "cpp/language/copy initialization")  
[Direct-initialization](direct_initialization.html "cpp/language/direct initialization")  
  
| [Aggregate initialization](aggregate_initialization.html "cpp/language/aggregate initialization")  
---  
[List-initialization](list_initialization.html "cpp/language/list initialization") (C++11)` `  
[Constant initialization](constant_initialization.html "cpp/language/constant initialization")  
[Reference initialization](reference_initialization.html "cpp/language/reference initialization")  
  
  
  
[Expressions](expressions.html "cpp/language/expressions")  
---  
| [Value categories](value_category.html "cpp/language/value category")  
---  
[Order of evaluation](eval_order.html "cpp/language/eval order")  
  
| [Operators](operators.html "cpp/language/operators")  
---  
[Operator precedence](operator_precedence.html "cpp/language/operator precedence")  
  
[Alternative representations](operator_alternative.html "cpp/language/operator alternative")  
[Literals](expressions.html#Literals "cpp/language/expressions")  
[Boolean](bool_literal.html "cpp/language/bool literal") \- [Integer](integer_literal.html "cpp/language/integer literal") \- [Floating-point](floating_literal.html "cpp/language/floating literal")  
[Character](character_literal.html "cpp/language/character literal") \- [String](string_literal.html "cpp/language/string literal") \- [`nullptr`](nullptr.html "cpp/language/nullptr") (C++11)  
[User-defined](user_literal.html "cpp/language/user literal") (C++11)  
Utilities  
[Attributes](attributes.html "cpp/language/attributes") (C++11)  
Types  
[`typedef` declaration](typedef.html "cpp/language/typedef")  
[Type alias declaration](type_alias.html "cpp/language/type alias") (C++11)  
Casts  
| [Implicit conversions](implicit_cast.html "cpp/language/implicit conversion")  
---  
[`static_cast`](static_cast.html "cpp/language/static cast")  
[`const_cast`](const_cast.html "cpp/language/const cast")  
  
| [Explicit conversions](explicit_cast.html "cpp/language/explicit cast")  
---  
[`dynamic_cast`](dynamic_cast.html "cpp/language/dynamic cast")  
[`reinterpret_cast`](reinterpret_cast.html "cpp/language/reinterpret cast")  
  
Memory allocation  
| [`new` expression](new.html "cpp/language/new")  
---  
  
| [`delete` expression](delete.html "cpp/language/delete")  
---  
  
[Classes](classes.html "cpp/language/classes")  
| [Class declaration](class.html "cpp/language/class")  
---  
[Constructors](initializer_list.html "cpp/language/constructor")  
[`this` pointer](this.html "cpp/language/this")  
  
| [Access specifiers](access.html "cpp/language/access")  
---  
[`friend` specifier](friend.html "cpp/language/friend")  
  
  
  
Class-specific function properties  
| [Virtual function](virtual.html "cpp/language/virtual")  
---  
[`override` specifier](override.html "cpp/language/override") (C++11)` `  
[`final` specifier](final.html "cpp/language/final") (C++11)  
  
| [`explicit`](explicit.html "cpp/language/explicit") (C++11)  
---  
[`static`](static.html "cpp/language/static")  
  
  
  
Special member functions  
| [Default constructor](default_constructor.html "cpp/language/default constructor")  
---  
[Copy constructor](copy_constructor.html "cpp/language/copy constructor")  
[Move constructor](move_constructor.html "cpp/language/move constructor") (C++11)  
  
| [Copy assignment](as_operator.html "cpp/language/as operator")  
---  
[Move assignment](move_operator.html "cpp/language/move operator") (C++11)  
[Destructor](destructor.html "cpp/language/destructor")  
  
[Templates](templates.html "cpp/language/templates")  
| [Class template](class_template.html "cpp/language/class template")  
---  
[Function template](function_template.html "cpp/language/function template")  
  
| [Template specialization](template_specialization.html "cpp/language/template specialization")  
---  
[Parameter packs](parameter_pack.html "cpp/language/pack") (C++11)  
  
Miscellaneous  
| [Inline assembly](asm.html "cpp/language/asm")  
---  
  
| [History of C++](history.html "cpp/language/history")  
---  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/navbar_content&action=edit)

[Declarations](declarations.html "cpp/language/declarations")

| Overview  
---  
[Declaration syntax](declarations.html "cpp/language/declarations")  
[_decl-specifier-seq_](declarations.html#Specifiers "cpp/language/declarations")  
[Declarator](declarations.html#Declarators "cpp/language/declarations")  
[Conflicting declarations](conflicting_declarations.html "cpp/language/conflicting declarations")  
Specifiers  
[typedef](typedef.html "cpp/language/typedef")  
[inline](inline.html "cpp/language/inline")  
[virtual function specifier](virtual.html "cpp/language/virtual")  
[explicit function specifier](explicit.html "cpp/language/explicit")  
[friend](friend.html "cpp/language/friend")  
[constexpr](constexpr.html "cpp/language/constexpr")(C++11)  
[consteval](consteval.html "cpp/language/consteval")(C++20)  
[constinit](constinit.html "cpp/language/constinit")(C++20)  
[Storage class specifiers](storage_duration.html "cpp/language/storage duration")  
[Translation-unit-local](tu_local.html "cpp/language/tu local") (C++20)  
[class/struct](class.html "cpp/language/class")  
[union](union.html "cpp/language/union")  
[enum](enum.html "cpp/language/enum")  
[decltype](decltype.html "cpp/language/decltype")(C++11)  
[auto](auto.html "cpp/language/auto")(C++11)  
[alignas](alignas.html "cpp/language/alignas")(C++11)  
[constvolatile](cv.html "cpp/language/cv")  
[Pack indexing specifier](pack_indexing.html#Pack_indexing_specifier "cpp/language/pack indexing") (C++26)  
[Elaborated type specifier](elaborated_type_specifier.html "cpp/language/elaborated type specifier")  
[Attributes](attributes.html "cpp/language/attributes") (C++11)  
  
| Declarators  
---  
[Reference](reference.html "cpp/language/reference")  
[Pointer](pointer.html "cpp/language/pointer")  
[Array](array.html "cpp/language/array")  
Block declarations  
[Simple-declaration](declarations.html "cpp/language/declarations")  
→[Structured binding declaration](structured_binding.html "cpp/language/structured binding") (C++17)  
[Alias declaration](type_alias.html "cpp/language/type alias") (C++11)  
[Namespace alias definition](namespace_alias.html "cpp/language/namespace alias")  
[using declaration](using_declaration.html "cpp/language/using declaration")  
[`using` directive](namespace.html#Using-directives "cpp/language/namespace")  
[static_assert declaration](static_assert.html "cpp/language/static assert") (C++11)  
[asm declaration](asm.html "cpp/language/asm")  
[Opaque enum declaration](enum.html "cpp/language/enum") (C++11)  
Other declarations  
[Namespace definition](namespace.html "cpp/language/namespace")  
[Function declaration](function.html "cpp/language/function")  
[Class template declaration](class_template.html "cpp/language/class template")  
[Function template declaration](function_template.html "cpp/language/function template")  
[Explicit template instantiation](class_template.html#Explicit_instantiation "cpp/language/class template") (C++11)  
[Explicit template specialization](template_specialization.html "cpp/language/template specialization")  
[Linkage specification](language_linkage.html "cpp/language/language linkage")  
[Attribute declaration](declarations.html "cpp/language/declarations") (C++11)  
[Empty declaration](declarations.html "cpp/language/declarations")  
  
  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/declarations/navbar_content&action=edit)

[ Expressions](expressions.html "cpp/language/expressions")

General  
---  
| [Value categories](value_category.html "cpp/language/value category")  
---  
[Order of evaluation](eval_order.html "cpp/language/eval order")  
[Constant expressions](constant_expression.html "cpp/language/constant expression")  
[Primary expressions](expressions.html#Primary_expressions "cpp/language/expressions")  
  
| [Lambda expressions](lambda.html "cpp/language/lambda") (C++11)  
---  
[Requires expressions](requires.html "cpp/language/requires") (C++20)  
[Pack indexing expression](pack_indexing.html#Pack_indexing_expression "cpp/language/pack indexing") (C++26)  
[Potentially-evaluated expressions](expressions.html#Potentially-evaluated_expressions "cpp/language/expressions")  
  
Literals  
| [Integer literals](integer_literal.html "cpp/language/integer literal")  
---  
[Floating-point literals](floating_literal.html "cpp/language/floating literal")  
[Boolean literals](bool_literal.html "cpp/language/bool literal")  
[Character literals](character_literal.html "cpp/language/character literal")  
  
| [Escape sequences](escape.html "cpp/language/escape")  
---  
[String literals](string_literal.html "cpp/language/string literal")  
[Null pointer literal](nullptr.html "cpp/language/nullptr") (C++11)  
[User-defined literal](user_literal.html "cpp/language/user literal") (C++11)  
  
Operators  
| [Assignment operators](operator_assignment.html "cpp/language/operator assignment")  
---  
[Increment and decrement](operator_incdec.html "cpp/language/operator incdec")  
[Arithmetic operators](operator_arithmetic.html "cpp/language/operator arithmetic")  
[Logical operators](operator_logical.html "cpp/language/operator logical")  
[Comparison operators](operator_comparison.html "cpp/language/operator comparison")  
[Member access operators](operator_member_access.html "cpp/language/operator member access")  
[Other operators](operator_other.html "cpp/language/operator other")  
[`new`-expression](new.html "cpp/language/new")  
[`delete`-expression](delete.html "cpp/language/delete")  
[`throw`-expression](throw.html "cpp/language/throw")  
  
| [`alignof`](alignof.html "cpp/language/alignof")  
---  
[`sizeof`](sizeof.html "cpp/language/sizeof")  
[`sizeof...`](sizeof....html "cpp/language/sizeof...") (C++11)  
[`typeid`](typeid.html "cpp/language/typeid")  
[`noexcept`](noexcept.html "cpp/language/noexcept") (C++11)  
[Fold expressions](fold.html "cpp/language/fold") (C++17)  
[Alternative representations of operators](operator_alternative.html "cpp/language/operator alternative")  
[Precedence and associativity](operator_precedence.html "cpp/language/operator precedence")  
[Operator overloading](operators.html "cpp/language/operators")  
[Default comparisons](default_comparisons.html "cpp/language/default comparisons") (C++20)  
  
Conversions  
| [Implicit conversions](implicit_cast.html "cpp/language/implicit conversion")  
---  
[Explicit conversions](explicit_cast.html "cpp/language/explicit cast")  
[Usual arithmetic conversions](usual_arithmetic_conversions.html "cpp/language/usual arithmetic conversions")  
[User-defined conversion](cast_operator.html "cpp/language/cast operator")  
  
| [`const_cast`](const_cast.html "cpp/language/const cast")  
---  
[`static_cast`](static_cast.html "cpp/language/static cast")  
[`dynamic_cast`](dynamic_cast.html "cpp/language/dynamic cast")  
[`reinterpret_cast`](reinterpret_cast.html "cpp/language/reinterpret cast")  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/expressions/navbar_content&action=edit)

[ Templates](templates.html "cpp/language/templates")

[Template parameters](template_parameters.html "cpp/language/template parameters")  
---  
[Template arguments](template_arguments.html "cpp/language/template arguments")  
[Class templates](class_template.html "cpp/language/class template")  
[Function templates](function_template.html "cpp/language/function template")  
[Class member templates](member_template.html "cpp/language/member template")  
[Variable templates](variable_template.html "cpp/language/variable template") (C++14)  
[Template argument deduction](template_argument_deduction.html "cpp/language/template argument deduction")  
[Class template argument deduction](ctad.html "cpp/language/class template argument deduction") (C++17)  
[Explicit (full) specialization](template_specialization.html "cpp/language/template specialization")  
[Partial specialization](partial_specialization.html "cpp/language/partial specialization")  
**Dependent names**  
[Packs](parameter_pack.html "cpp/language/pack") (C++11)  
[sizeof...](sizeof....html "cpp/language/sizeof...") (C++11)  
[Fold expressions](fold.html "cpp/language/fold") (C++17)  
[Pack indexing](pack_indexing.html "cpp/language/pack indexing") (C++26)  
[SFINAE](sfinae.html "cpp/language/sfinae")  
[Constraints and concepts](constraints.html "cpp/language/constraints") (C++20)  
[requires expression](requires.html "cpp/language/requires") (C++20)  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/templates/navbar_content&action=edit)

Inside the definition of a [template](templates.html "cpp/language/templates") (both [class template](class_template.html "cpp/language/class template") and [function template](function_template.html "cpp/language/function template")), the meaning of some constructs may differ from one instantiation to another. In particular, types and expressions may depend on types of type template parameters and values of constant template parameters. 
    
    
    template<typename T>
    struct X : B<T> // “B<T>” is dependent on T
    {
        typename T::A* pa; // “T::A” is dependent on T
                           // (see below for the meaning of this use of “typename”)
     
        void f(B<T>* pb)
        {
            static int i = B<T>::i; // “B<T>::i” is dependent on T
            pb->j++; // “pb->j” is dependent on T
        }
    };

Name [lookup](lookup.html "cpp/language/lookup") and binding are different for dependent names and non-dependent names. 

## Contents

  * [1 Binding rules](dependent_name.html#Binding_rules)
  * [2 Lookup rules](dependent_name.html#Lookup_rules)
  * [3 Dependent types](dependent_name.html#Dependent_types)
  * [4 Type-dependent expressions](dependent_name.html#Type-dependent_expressions)
  * [5 Value-dependent expressions](dependent_name.html#Value-dependent_expressions)
  * [6 Dependent names](dependent_name.html#Dependent_names)
  * [7 Current instantiation](dependent_name.html#Current_instantiation)
  * [8 Unknown specializations](dependent_name.html#Unknown_specializations)
  * [9 The typename disambiguator for dependent names](dependent_name.html#The_typename_disambiguator_for_dependent_names)
  * [10 The template disambiguator for dependent names](dependent_name.html#The_template_disambiguator_for_dependent_names)
  * [11 Keywords](dependent_name.html#Keywords)
  * [12 Defect reports](dependent_name.html#Defect_reports)

  
---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/dependent_name&action=edit&section=1 "Edit section: Binding rules")] Binding rules

Non-dependent names are looked up and bound at the point of template definition. This binding holds even if at the point of template instantiation there is a better match: 

Run this code
    
    
    #include <iostream>
     
    void g(double) { [std::cout](../io/cout.html) << "g(double)\n"; }
     
    template<class T>
    struct S
    {
        void f() const
        {
            g(1); // “g” is a non-dependent name, bound now
        }
    };
     
    void g(int) { [std::cout](../io/cout.html) << "g(int)\n"; }
     
    int main()
    {
        g(1);  // calls g(int)
     
        S<int> s;
        s.f(); // calls g(double)
    }

If the meaning of a non-dependent name changes between the definition context and the point of instantiation of a specialization of the template, the program is ill-formed, no diagnostic required. This is possible in the following situations: 

  * a type used in a non-dependent name is [incomplete](incomplete_type.html "cpp/language/incomplete type") at the point of definition but complete at the point of instantiation 



  * lookup for a name in the template definition found a [using-declaration](using_declaration.html "cpp/language/using declaration"), but the lookup in the corresponding scope in the instantiation does not find any declarations because the using-declaration was a pack expansion and the corresponding pack is empty 

| (since C++17)  
---|---  
  
  * an instantiation uses a default argument or default template argument that had not been defined at the point of definition 
  * a [constant expression](constant_expression.html "cpp/language/constant expression") at the point of instantiation uses the value of a const object of integral or unscoped enum type, the value of a constexpr object, the value of a reference, or the definition of a constexpr function(since C++11), and that object/reference/function(since C++11) was not defined at the point of definition 
  * the template uses a non-dependent class template specialization or variable template specialization(since C++14) at the point of instantiation, and this template it uses is either instantiated from a partial specialization that was not defined at the point of definition or names an explicit specialization that was not declared at the point of definition 



Binding of dependent names is postponed until lookup takes place. 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/dependent_name&action=edit&section=2 "Edit section: Lookup rules")] Lookup rules

The [lookup](lookup.html "cpp/language/lookup") of a dependent name used in a template is postponed until the template arguments are known, at which time 

  * non-ADL lookup examines function declarations with external linkage that are visible from the template definition context 
  * [ADL](adl.html "cpp/language/adl") examines function declarations with external linkage that are visible from either the template definition context or the template instantiation context 



(in other words, adding a new function declaration after template definition does not make it visible, except via ADL). 

The purpose of this rule is to help guard against violations of the [ODR](definition.html#One_Definition_Rule "cpp/language/definition") for template instantiations: 
    
    
    // an external library
    namespace E
    {
        template<typename T>
        void writeObject(const T& t)
        {
            [std::cout](../io/cout.html) << "Value = " << t << '\n';
        }
    }
     
    // translation unit 1:
    // Programmer 1 wants to allow E::writeObject to work with vector<int>
    namespace P1
    {
        [std::ostream](../io/basic_ostream.html)& operator<<([std::ostream](../io/basic_ostream.html)& os, const [std::vector](../container/vector.html)<int>& v)
        {
            for (int n : v)
                os << n << ' ';
            return os;
        }
     
        void doSomething()
        {
            [std::vector](../container/vector.html)<int> v;
            E::writeObject(v); // Error: will not find P1::operator<<
        }
    }
     
    // translation unit 2:
    // Programmer 2 wants to allow E::writeObject to work with vector<int>
    namespace P2
    {
        [std::ostream](../io/basic_ostream.html)& operator<<([std::ostream](../io/basic_ostream.html)& os, const [std::vector](../container/vector.html)<int>& v)
        {
            for (int n : v)
                os << n << ':';
            return os << "[]";
        }
     
        void doSomethingElse()
        {
            [std::vector](../container/vector.html)<int> v;
            E::writeObject(v); // Error: will not find P2::operator<<
        }
    }

In the above example, if non-ADL lookup for `operator<<` were allowed from the instantiation context, the instantiation of E::writeObject<vector<int>> would have two different definitions: one using P1::operator<< and one using P2::operator<<. Such ODR violation may not be detected by the linker, leading to one or the other being used in both instances. 

To make ADL examine a user-defined namespace, either [std::vector](../container/vector.html "cpp/container/vector") should be replaced by a user-defined class or its element type should be a user-defined class: 
    
    
    namespace P1
    {
        // if C is a class defined in the P1 namespace
        [std::ostream](../io/basic_ostream.html)& operator<<([std::ostream](../io/basic_ostream.html)& os, const [std::vector](../container/vector.html)<C>& v)
        {
            for (C n : v)
                os << n;
            return os;
        }
     
        void doSomething()
        {
            [std::vector](../container/vector.html)<C> v;
            E::writeObject(v); // OK: instantiates writeObject(std::vector<P1::C>)
                               //     which finds P1::operator<< via ADL
        }
    }

Note: this rule makes it impractical to overload operators for standard library types: 

Run this code
    
    
    #include <iostream>
    #include <iterator>
    #include <utility>
    #include <vector>
     
    // Bad idea: operator in global namespace, but its arguments are in std::
    [std::ostream](../io/basic_ostream.html)& operator<<([std::ostream](../io/basic_ostream.html)& os, [std::pair](../utility/pair.html)<int, double> p)
    {
        return os << p.first << ',' << p.second;
    }
     
    int main()
    {
        typedef [std::pair](../utility/pair.html)<int, double> elem_t;
        [std::vector](../container/vector.html)<elem_t> v(10);
        [std::cout](../io/cout.html) << v[0] << '\n'; // OK, ordinary lookup finds ::operator<<
        [std::copy](../algorithm/copy.html)(v.begin(), v.end(),
                  [std::ostream_iterator](../iterator/ostream_iterator.html)<elem_t>([std::cout](../io/cout.html), " "));
        // Error: both ordinary lookup from the point of definition of
        // std::ostream_iterator and ADL will only consider the std namespace,
        // and will find many overloads of std::operator<<, so the lookup will be done.
        // Overload resolution will then fail to find operator<< for elem_t
        // in the set found by the lookup.
    }

Note: limited lookup (but not binding) of dependent names also takes place at template definition time, as needed to distinguish them from non-dependent names and also to determine whether they are members of the current instantiation or members of unknown specialization. The information obtained by this lookup can be used to detect errors, see below. 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/dependent_name&action=edit&section=3 "Edit section: Dependent types")] Dependent types

The following types are _dependent types_ ﻿: 

  * template parameter 
  * a member of an unknown specialization (see below) 
  * a nested class/enum that is a dependent member of unknown specialization (see below) 
  * a cv-qualified version of a dependent type 
  * a compound type constructed from a dependent type 
  * an array type whose element type is dependent or whose bound (if any) is value-dependent 



  * a function type whose parameters include one or more function [parameter packs](parameter_pack.html "cpp/language/parameter pack")

| (since C++11)  
---|---  
  
  * a function type whose exception specification is value-dependent 
  * a [template-id](templates.html#template-id "cpp/language/templates") where either 



    

  * the template name is a template parameter, or 
  * any of template arguments is type-dependent, or value-dependent, or is a pack expansion(since C++11) (even if the template-id is used without its argument list, as [injected-class-name](injected-class-name.html "cpp/language/injected-class-name")) 



  * the result of [`decltype`](decltype.html "cpp/language/decltype") applied to a type-dependent expression 

The result of decltype applied to a type-dependent expression is a unique dependent type. Two such results refer to the same type only if their expressions are [equivalent](function_template.html#Function_template_overloading "cpp/language/function template").  | (since C++11)  
---|---  
  
  * the [pack indexing specifier](pack_indexing.html#Pack_indexing_specifier "cpp/language/pack indexing") applied to a type-dependent constant expression 

The pack indexing specifier applied to a type-dependent constant expression is a unique dependent type. Two such pack indexing specifiers refer to the same type only if their constant expressions are equivalent. Otherwise, two such pack indexing specifiers refer to the same type only if their indices have the same value.  | (since C++26)  
---|---  
  
Note: a typedef member of a current instantiation is only dependent when the type it refers to is. 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/dependent_name&action=edit&section=4 "Edit section: Type-dependent expressions")] Type-dependent expressions

The following expressions are _type-dependent_ ﻿: 

  * an expression whose any subexpression is a type-dependent expression 
  * this, if the class is a dependent type. 
  * an [identifier expression](name.html "cpp/language/identifiers") that is not a [concept-id](constraints.html "cpp/language/constraints") and(since C++20)



    

  * contains an identifier for which name lookup finds at least one dependent declaration 
  * contains a dependent [template-id](templates.html#template-id "cpp/language/templates")



    

  * contains the special identifier `__func__` (if some enclosing function is a template, a non-template member of a class template, or a generic lambda(since C++14)) 


| (since C++11)  
---|---  
  
    

  * contains the name of [conversion function](cast_operator.html "cpp/language/cast operator") to a dependent type 
  * contains a nested name specifier or [qualified-id](name.html "cpp/language/identifiers") that is a member of unknown specialization 
  * names a dependent member of the current instantiation which is a static data member of type "array of unknown bound" 



    

  * contains an identifier for which name lookup finds one or more declarations of member functions of the current instantiation declared with [return type deduction](function.html#Return_type_deduction "cpp/language/function")


| (since C++14)  
---|---  
  
    

  * contains an identifier for which name lookup finds a [structured binding declaration](structured_binding.html "cpp/language/structured binding") whose initializer is type-dependent 
  * contains an identifier for which name lookup finds a constant template parameter whose type contains the placeholder auto
  * contains an identifier for which by name lookup finds a variable declared with a type that contains a placeholder type (e.g., auto static data member), where the initializer is type-dependent, 


| (since C++17)  
  
    

  * contains an identifier for which name lookup finds a [pack](parameter_pack.html "cpp/language/pack")


| (since C++26)  
  
  * any cast expression to a dependent type 
  * [new expression](new.html "cpp/language/new") that creates an object of a dependent type 
  * member access expression that refers to a member of the current instantiation whose type is dependent 
  * member access expression that refers to a member of unknown specialization 



  * [fold expression](fold.html "cpp/language/fold")

| (since C++17)  
---|---  
  
  * [pack indexing expression](pack_indexing.html#Pack_indexing_expression "cpp/language/pack indexing") if its identifier expression is a type-dependent expression 

| (since C++26)  
---|---  
  
The following expressions are never type-dependent because the types of these expressions cannot be: 

  * [literals](expressions.html#Literals "cpp/language/expressions")
  * pseudo-destructor calls 
  * [`sizeof`](sizeof.html "cpp/language/sizeof")



  * [`sizeof...`](sizeof....html "cpp/language/sizeof...")
  * [`alignof`](alignof.html "cpp/language/alignof")
  * [`noexcept`](noexcept.html "cpp/language/noexcept")

| (since C++11)  
---|---  
  
  * [`throw`](throw.html "cpp/language/throw")
  * [`typeid`](typeid.html "cpp/language/typeid")
  * [`delete`](delete.html "cpp/language/delete")



  * [`requires`](requires.html "cpp/language/requires")

| (since C++20)  
---|---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/dependent_name&action=edit&section=5 "Edit section: Value-dependent expressions")] Value-dependent expressions

The following expressions are _value-dependent_ ﻿: 

  * an expression used in context where [constant expression](constant_expression.html "cpp/language/constant expression") is required, and whose any subexpression is value-dependent 
  * an [identifier expression](name.html "cpp/language/identifiers") that satisfies any of the following conditions: 



    

  * It is a [concept-id](constraints.html "cpp/language/constraints") and any of its arguments are dependent. 


| (since C++20)  
---|---  
  
    

  * It is type-dependent. 
  * It is a name of a constant template parameter. 
  * It names a static data member that is a dependent member of the current instantiation and is not initialized. 
  * It names a static member function that is a dependent member of the current instantiation. 
  * It is a constant with a integer or enumeration(until C++11)literal(since C++11) type, initialized from a value-dependent expression. 



  * the following expressions where the operand is a type-dependent expression: 



    

  * [`sizeof`](sizeof.html "cpp/language/sizeof")
  * [`typeid`](typeid.html "cpp/language/typeid")



    

  * [`alignof`](alignof.html "cpp/language/alignof")


| (since C++11)  
---|---  
  
  * the following expressions where the operand is a dependent type-id: 



    

  * [`sizeof`](sizeof.html "cpp/language/sizeof")
  * [`typeid`](typeid.html "cpp/language/typeid")



  * the following expressions where the target type is dependent or the operand is a type-dependent expression: 



    

  * [C-style cast](explicit_cast.html "cpp/language/explicit cast")
  * [`static_cast`](static_cast.html "cpp/language/static cast")
  * [`const_cast`](const_cast.html "cpp/language/const cast")
  * [`reinterpret_cast`](reinterpret_cast.html "cpp/language/reinterpret cast")
  * [`dynamic_cast`](dynamic_cast.html "cpp/language/dynamic cast")



  * [function-style cast](explicit_cast.html "cpp/language/explicit cast") expression where the target type is dependent or a value-dependent expression is enclosed by parentheses or braces(since C++11)



  * [`sizeof...`](sizeof....html "cpp/language/sizeof...") expression where the operand is not a [structured binding pack](structured_binding.html "cpp/language/structured binding")(since C++26)

| (since C++11)  
---|---  
  
  * [fold expression](fold.html "cpp/language/fold")

| (since C++17)  
  
  * address-of expression where the argument is a [qualified identifier](name.html "cpp/language/identifiers") that names a dependent member of the current instantiation 
  * address-of expression where the argument is any expression which, evaluated as a core [constant expression](constant_expression.html "cpp/language/constant expression"), refers to a [templated entity](templates.html#Templated_entity "cpp/language/templates") that is an object with static or thread storage(since C++11) duration or a member function. 



### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/dependent_name&action=edit&section=6 "Edit section: Dependent names")] Dependent names

| This section is incomplete  
Reason: the lede from [temp.dep], which is missing (identifier expression followed by parenthesized list...   
---|---  
| This section is incomplete  
Reason: reword to maybe make it more clear (or at least less intimidating), and while at it, apply [CWG issue 591](https://cplusplus.github.io/CWG/issues/591.html)  
---|---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/dependent_name&action=edit&section=7 "Edit section: Current instantiation")] Current instantiation

Within a class template definition (including its member functions and nested classes) some names may be deduced to refer to the _current instantiation_. This allows certain errors to be detected at the point of definition, rather than instantiation, and removes the requirement on the typename and template disambiguators for dependent names, see below. 

Only the following names can refer to the current instantiation: 

  * in the definition of a class template, a nested class of a class template, a member of a class template, or a member of a nested class of a class template: 
    * the injected-class-name of the class template or nested class 
  * in the definition of a primary class template or a member of a primary class template: 
    * the name of the class template followed by template argument list (or an equivalent alias template specialization) for the primary template where each argument is equivalent (defined below) to its corresponding parameter. 
  * in the definition of a nested class of a class template: 
    * the name of the nested class used as a member of the current instantiation 
  * in the definition of a class template partial specialization or a member of a class template partial specialization: 
    * the name of the class template followed by template argument list for the partial specialization, where each argument is equivalent to its corresponding parameter 
  * in the definition of a [templated function](templates.html#Templated_entity "cpp/language/templates"): 
    * the name of a [local class](class.html#Local_classes "cpp/language/class")



A template argument is equivalent to a template parameter if 

  * for a [type parameter](template_parameters.html#Type_template_parameter "cpp/language/template parameters"), the template argument denotes the same type as the template parameter. 
  * for a [constant parameter](template_parameters.html#Constant_template_parameter "cpp/language/template parameters"), the template argument is an [identifier](name.html "cpp/language/identifiers") that names a variable that is equivalent to the template parameter. A variable is equivalent to a template parameter if 



    

  * it has the same type as the template parameter (ignoring cv-qualification) and 
  * its initializer consists of a single identifier that names the template parameter or, recursively, such a variable. 


    
    
    template<class T>
    class A
    {
        A* p1;      // A is the current instantiation
        A<T>* p2;   // A<T> is the current instantiation
        ::A<T>* p4; // ::A<T> is the current instantiation
        A<T*> p3;   // A<T*> is not the current instantiation
     
        class B
        {
            B* p1;                 // B is the current instantiation
            A<T>::B* p2;           // A<T>::B is the current instantiation
            typename A<T*>::B* p3; // A<T*>::B is not the current instantiation
        };
    };
     
    template<class T>
    class A<T*>
    {
        A<T*>* p1; // A<T*> is the current instantiation
        A<T>* p2;  // A<T> is not the current instantiation
    };
     
    template<int I>
    struct B
    {
        static const int my_I = I;
        static const int my_I2 = I + 0;
        static const int my_I3 = my_I;
        static const long my_I4 = I;
        static const int my_I5 = (I);
     
        B<my_I>* b1;  // B<my_I> is the current instantiation:
                      //   my_I has the same type as I,
                      //   and it is initialized with only I
        B<my_I2>* b2; // B<my_I2> is not the current instantiation:
                      //   I + 0 is not a single identifier
        B<my_I3>* b3; // B<my_I3> is the current instantiation:
                      //   my_I3 has the same type as I,
                      //   and it is initialized with only my_I (which is equivalent to I)
        B<my_I4>* b4; // B<my_I4> is not the current instantiation:
                      //   the type of my_I4 (long) is not the same as the type of I (int)
        B<my_I5>* b5; // B<my_I5> is not the current instantiation:
                      //   (I) is not a single identifier
    };

Note that a base class can be the current instantiation if a nested class derives from its enclosing class template. Base classes that are dependent types but are not the current instantiation are _dependent base classes_ : 
    
    
    template<class T>
    struct A
    {
        typedef int M;
     
        struct B
        {
            typedef void M;
     
            struct C;
        };
    };
     
    template<class T>
    struct A<T>::B::C : A<T>
    {
        M m; // OK, A<T>::M
    };

A name is classified as a member of the current instantiation if it is 

  * an unqualified name that is found by [unqualified lookup](unqualified_lookup.html "cpp/language/unqualified lookup") in the current instantiation or in its non-dependent base. 
  * [qualified name](qualified_lookup.html "cpp/language/qualified lookup"), if the qualifier (the name to the left of `**::**`) names the current instantiation and lookup finds the name in the current instantiation or in its non-dependent base 
  * a name used in a class member access expression (y in x.y or xp->y), where the object expression (x or *xp) is the current instantiation and lookup finds the name in the current instantiation or in its non-dependent base 


    
    
    template<class T>
    class A
    {
        static const int i = 5;
     
        int n1[i];       // i refers to a member of the current instantiation
        int n2[A::i];    // A::i refers to a member of the current instantiation
        int n3[A<T>::i]; // A<T>::i refers to a member of the current instantiation
     
        int f();
    };
     
    template<class T>
    int A<T>::f()
    {
        return i; // i refers to a member of the current instantiation
    }

Members of the current instantiation may be both dependent and non-dependent. 

If the lookup of a member of current instantiation gives a different result between the point of instantiation and the point of definition, the lookup is ambiguous. Note however that when a member name is used, it is not automatically converted to a class member access expression, only explicit member access expressions indicate members of current instantiation: 
    
    
    struct A { int m; };
    struct B { int m; };
     
    template<typename T>
    struct C : A, T
    {
        int f() { return this->m; } // finds A::m in the template definition context
        int g() { return m; }       // finds A::m in the template definition context
    };
     
    template int C<B>::f(); // error: finds both A::m and B::m
     
    template int C<B>::g(); // OK: transformation to class member access syntax
                            // does not occur in the template definition context

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/dependent_name&action=edit&section=8 "Edit section: Unknown specializations")] Unknown specializations

Within a template definition, certain names are deduced to belong to an _unknown specialization_ , in particular, 

  * a [qualified name](qualified_lookup.html "cpp/language/qualified lookup"), if any name that appears to the left of `**::**` is a dependent type that is not a member of the current instantiation 
  * a [qualified name](qualified_lookup.html "cpp/language/qualified lookup"), whose qualifier is the current instantiation, and the name is not found in the current instantiation or any of its non-dependent base classes, and there is a dependent base class 
  * a name of a member in a class member access expression (the y in x.y or xp->y), if the type of the object expression (x or *xp) is a dependent type and is not the current instantiation 
  * a name of a member in a class member access expression (the y in x.y or xp->y), if the type of the object expression (x or *xp) is the current instantiation, and the name is not found in the current instantiation or any of its non-dependent base classes, and there is a dependent base class 


    
    
    template<typename T>
    struct Base {};
     
    template<typename T>
    struct Derived : Base<T>
    {
        void f()
        {
            // Derived<T> refers to current instantiation
            // there is no “unknown_type” in the current instantiation
            // but there is a dependent base (Base<T>)
            // Therefore, “unknown_type” is a member of unknown specialization
            typename Derived<T>::unknown_type z;
        }
    };
     
    template<>
    struct Base<int> // this specialization provides it
    {
        typedef int unknown_type;
    };

  
This classification allows the following errors to be detected at the point of template definition (rather than instantiation): 

  * If any template definition has a [qualified name](qualified_lookup.html "cpp/language/qualified lookup") in which the qualifier refers to the current instantiation and the name is neither a member of current instantiation nor a member of unknown specialization, the program is ill-formed (no diagnostic required) even if the template is never instantiated. 


    
    
    template<class T>
    class A
    {
        typedef int type;
     
        void f()
        {
            A<T>::type i; // OK: “type” is a member of the current instantiation
            typename A<T>::other j; // Error:
     
            // “other” is not a member of the current instantiation
            // and it is not a member of an unknown specialization
            // because A<T> (which names the current instantiation),
            // has no dependent bases for “other” to hide in.
        }
    };

  * If any template definition has a member access expression where the object expression is the current instantiation, but the name is neither a member of current instantiation nor a member of unknown specialization, the program is ill-formed even if the template is never instantiated. 



Members of unknown specialization are always dependent, and are looked up and bound at the point of instantiation as all dependent names (see above) 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/dependent_name&action=edit&section=9 "Edit section: The typename disambiguator for dependent names")] The typename disambiguator for dependent names

In a declaration or a definition of a template, including alias template, a name that is not a member of the current instantiation and is dependent on a template parameter is not considered to be a type unless the keyword typename is used or unless it was already established as a type name, e.g. with a typedef declaration or by being used to name a base class. 

Run this code
    
    
    #include <iostream>
    #include <vector>
     
    int p = 1;
     
    template<typename T>
    void foo(const [std::vector](../container/vector.html)<T> &v)
    {
        // std::vector<T>::const_iterator is a dependent name,
        typename [std::vector](../container/vector.html)<T>::const_iterator it = v.begin();
     
        // without “typename”, the following is parsed as multiplication
        // of the type-dependent data member “const_iterator”
        // and some variable “p”. Since there is a global “p” visible
        // at this point, this template definition compiles.
        [std::vector](../container/vector.html)<T>::const_iterator* p;
     
        typedef typename [std::vector](../container/vector.html)<T>::const_iterator iter_t;
        iter_t * p2; // “iter_t” is a dependent name, but it is known to be a type name
    }
     
    template<typename T>
    struct S
    {
        typedef int value_t; // member of current instantiation
     
        void f()
        {
            S<T>::value_t n{}; // S<T> is dependent, but “typename” not needed
            [std::cout](../io/cout.html) << n << '\n';
        }
    };
     
    int main()
    {
        [std::vector](../container/vector.html)<int> v;
        foo(v); // template instantiation fails: there is no member variable
                // called “const_iterator” in the type std::vector<int>
        S<int>().f();
    }

The keyword typename may only be used in this way before qualified names (e.g. T::x), but the names need not be dependent. 

Usual [qualified name lookup](qualified_lookup.html "cpp/language/qualified lookup") is used for the identifier prefixed by typename. Unlike the case with [elaborated type specifier](elaborated_type_specifier.html "cpp/language/elaborated type specifier"), the lookup rules do not change despite the qualifier: 
    
    
    struct A // A has a nested variable X and a nested type struct X
    {
        struct X {};
        int X;
    };
     
    struct B
    {
        struct X {}; // B has a nested type struct X
    };
     
    template<class T>
    void f(T t)
    {
        typename T::X x;
    }
     
    void foo()
    {
        A a;
        B b;
        f(b); // OK: instantiates f<B>, T::X refers to B::X
        f(a); // error: cannot instantiate f<A>:
              // because qualified name lookup for A::X finds the data member
    }

The keyword typename can be used even outside of templates. 
    
    
    #include <vector>
     
    int main()
    {
        // Both OK (after resolving CWG 382)
        typedef typename [std::vector](../container/vector.html)<int>::const_iterator iter_t;
        typename [std::vector](../container/vector.html)<int> v;
    }

In some contexts, only type names can validly appear. In these contexts, a dependent qualified name is assumed to name a type and no typename is required: 

  * A qualified name that is used as a [declaration specifier](declarations.html#Specifiers "cpp/language/declarations") in the (top-level) decl-specifier-seq of: 



    

  * a [simple declaration](declarations.html#Simple_declaration "cpp/language/declarations") or [function definition](function.html#Function_definition "cpp/language/function") at namespace scope; 
  * a [class member declaration](class.html#Member_specification "cpp/language/class"); 
  * a [parameter declaration](function.html#Parameter_list "cpp/language/function") in a [class member declaration](class.html#Member_specification "cpp/language/class") (including friend function declarations), outside of default arguments; 
  * a [parameter declaration](function.html#Parameter_list "cpp/language/function") of a [declarator for a function or function template](function.html "cpp/language/function") whose name is qualified, outside of default arguments; 
  * a [parameter declaration](function.html#Parameter_list "cpp/language/function") of a [lambda expression](lambda.html "cpp/language/lambda") outside of default arguments; 
  * a parameter declaration of a [requires expression](constraints.html#Requires_expressions "cpp/language/constraints"); 
  * the type in the declaration of a [constant template parameter](template_parameters.html#Constant_template_parameter "cpp/language/template parameters"); 



  * A qualified name that appears in [type-id](type-id.html#Type_naming "cpp/language/type"), where the smallest enclosing type-id is: 



    

  * the type in a [new expression](new.html "cpp/language/new") that does not parenthesize its type; 
  * the type-id in an [alias declaration](type_alias.html "cpp/language/type alias"); 
  * a [trailing return type](function.html "cpp/language/function"), 
  * a [default argument of a type template parameter](template_parameters.html#Type_template_parameter "cpp/language/template parameters"), or 
  * the type-id of a [`static_cast`](static_cast.html "cpp/language/static cast"), [`dynamic_cast`](dynamic_cast.html "cpp/language/dynamic cast"), [`const_cast`](const_cast.html "cpp/language/const cast"), or [`reinterpret_cast`](reinterpret_cast.html "cpp/language/reinterpret cast"). 


| (since C++20)  
---|---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/dependent_name&action=edit&section=10 "Edit section: The template disambiguator for dependent names")] The template disambiguator for dependent names

Similarly, in a template definition, a dependent name that is not a member of the current instantiation is not considered to be a template name unless the disambiguation keyword template is used or unless it was already established as a template name: 

Run this code
    
    
    template<typename T>
    struct S
    {
        template<typename U>
        void foo() {}
    };
     
    template<typename T>
    void bar()
    {
        S<T> s;
        s.foo<T>();          // error: < parsed as less than operator
        s.template foo<T>(); // OK
    }

The keyword template may only be used in this way after operators :: (scope resolution), -> (member access through pointer), and . (member access), the following are all valid examples: 

  * T::template foo<X>();
  * s.template foo<X>();
  * this->template foo<X>();
  * typename T::template iterator<int>::value_type v;



As is the case with typename, the template prefix is allowed even if the name is not dependent or the use does not appear in the scope of a template. 

Even if the name to the left of `**::**` refers to a namespace, the template disambiguator is allowed: 
    
    
    template<typename>
    struct S {};
     
    ::template S<void> q; // allowed, but unnecessary

Due to the special rules for [unqualified name lookup](unqualified_lookup.html "cpp/language/unqualified lookup") for template names in member access expressions, when a non-dependent template name appears in a member access expression (after -> or after .), the disambiguator is unnecessary if there is a class or alias(since C++11) template with the same name found by ordinary lookup in the context of the expression. However, if the template found by lookup in the context of the expression differs from the one found in the context of the class, the program is ill-formed(until C++11)
    
    
    template<int>
    struct A { int value; };
     
    template<class T>
    void f(T t)
    {
        t.A<0>::value; // Ordinary lookup of A finds a class template.
                       // A<0>::value names member of class A<0>
        // t.A < 0;    // Error: “<” is treated as the start of template argument list
    }

| (until C++23)  
---|---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/dependent_name&action=edit&section=11 "Edit section: Keywords")] Keywords

[`template`](../keyword/template.html "cpp/keyword/template"), [`typename`](../keyword/typename.html "cpp/keyword/typename")

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/dependent_name&action=edit&section=12 "Edit section: Defect reports")] Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[CWG 206](https://cplusplus.github.io/CWG/issues/206.html) | C++98  | it was unspecified at what point semantic constraints are  
applied when a type used in a non-dependent name is  
incomplete at the point at which a template is defined but is  
complete at the point at which an instantiation is performed  | the program is ill-formed  
and no diagnostic is  
required in this case   
[CWG 224](https://cplusplus.github.io/CWG/issues/224.html) | C++98  | the definition of dependent types was based  
on the form of the name rather than lookup  | definition revamped   
[CWG 382](https://cplusplus.github.io/CWG/issues/382.html) | C++98  | the typename disambiguator was only allowed in template scope  | also allowed outside  
of templates   
[CWG 468](https://cplusplus.github.io/CWG/issues/468.html) | C++98  | the template disambiguator was only allowed in template scope  | also allowed outside  
of templates   
[CWG 502](https://cplusplus.github.io/CWG/issues/502.html) | C++98  | it was unspecified whether nested enumerations are dependent  | dependent as nested classes   
[CWG 1047](https://cplusplus.github.io/CWG/issues/1047.html) | C++98  | typeid expressions were never value-dependent  | value-dependent if the  
operand is type-dependent   
[CWG 1160](https://cplusplus.github.io/CWG/issues/1160.html) | C++98  | it was unspecified whether a name refers to the current instantiation  
when a template-id matching a primary template or partial  
specialization appears in the definition of a member of the template  | specified   
[CWG 1413](https://cplusplus.github.io/CWG/issues/1413.html) | C++98  | uninitialized static data member, static member function, and address  
of member of a class template were not listed as value-dependent  | listed   
[CWG 1471](https://cplusplus.github.io/CWG/issues/1471.html) | C++98  | a nested type of a non-dependent base of  
the current instantiation was dependent  | it is not dependent   
[CWG 1850](https://cplusplus.github.io/CWG/issues/1850.html) | C++98  | the list of cases that meaning may change between the  
definition context and the point of instantiation was incomplete  | made complete   
[CWG 1929](https://cplusplus.github.io/CWG/issues/1929.html) | C++98  | it was not clear whether the template disambiguator can  
follow a `::` where the name to its left refers to a namespace  | allowed   
[CWG 2066](https://cplusplus.github.io/CWG/issues/2066.html) | C++98  | this was never value-dependent  | it may be  
value-dependent   
[CWG 2100](https://cplusplus.github.io/CWG/issues/2100.html) | C++98  | address of a static data member of class  
template was not listed as value-dependent  | listed   
[CWG 2109](https://cplusplus.github.io/CWG/issues/2109.html) | C++98  | type-dependent identifier expressions might not be value-dependent  | they are always  
value-dependent   
[CWG 2276](https://cplusplus.github.io/CWG/issues/2276.html) | C++98  | a function type whose exception specification  
is value-dependent was not a dependent type  | it is   
[CWG 2307](https://cplusplus.github.io/CWG/issues/2307.html) | C++98  | a parenthesized constant template parameter used as a  
template argument was equivalent to that template parameter  | not equivalent anymore   
[CWG 2457](https://cplusplus.github.io/CWG/issues/2457.html) | C++11  | a function type with function parameter  
pack was not a dependent type  | it is   
[CWG 2785](https://cplusplus.github.io/CWG/issues/2785.html) | C++20  | requires expressions might be type-dependent  | they are never  
type-dependent   
[CWG 2905](https://cplusplus.github.io/CWG/issues/2905.html) | C++11  | a noexcept expression was only value-dependent  
if its operand is value-dependent  | it is value-dependent  
if its operand involves  
a template parameter   
[CWG 2936](https://cplusplus.github.io/CWG/issues/2936.html) | C++98  | the names of local classes of templated  
functions were not part of the current instantiation  | they are 
