[C++](../../cpp.html "cpp")

[Compiler support](../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../freestanding.html "cpp/freestanding")  
[Language](../language.html "cpp/language")  
[Standard library](../standard_library.html "cpp/standard library")  
[Standard library headers](../headers.html "cpp/header")  
[Named requirements](../iterator/concepts.html "cpp/named req")  
[Feature test macros](../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../utility.html#Language_support "cpp/utility")  
[Concepts library](../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../error.html "cpp/error")  
[Memory management library](../memory.html "cpp/memory")  
[Metaprogramming library](../meta.html "cpp/meta") (C++11)  
[General utilities library](../utility.html "cpp/utility")  
[Containers library](../container.html "cpp/container")  
[Iterators library](../iterator.html "cpp/iterator")  
[Ranges library](../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../algorithm.html "cpp/algorithm")  
[Strings library](../string.html "cpp/string")  
[Text processing library](../text.html "cpp/text")  
[Numerics library](../numeric.html "cpp/numeric")  
[Date and time library](../chrono.html "cpp/chrono")  
[Input/output library](../io.html "cpp/io")  
[Filesystem library](../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../atomic.html "cpp/thread") (C++11)  
[Execution control library](../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../experimental.html "cpp/experimental")  
[Symbols index](../symbol_index.html "cpp/symbol index")  
[External libraries](../links/libs.html "cpp/links/libs")  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/navbar_content&action=edit)

[C++ language](../language.html "cpp/language")

General topics  
---  
| [Preprocessor](../preprocessor.html "cpp/preprocessor")  
---  
[Comments](../comments.html "cpp/comment")  
  
| [Keywords](../keywords.html "cpp/keyword")  
---  
[Escape sequences](escape.html "cpp/language/escape")  
  
[Flow control](statements.html "cpp/language/statements")  
Conditional execution statements  
| [`if`](if.html "cpp/language/if")  
---  
  
| [`switch`](switch.html "cpp/language/switch")  
---  
  
Iteration statements (loops)  
| [`for`](for.html "cpp/language/for")  
---  
[range-`for`](range-for.html "cpp/language/range-for") (C++11)  
  
| [`while`](while.html "cpp/language/while")  
---  
[`do-while`](do.html "cpp/language/do")  
  
Jump statements  
| [`continue`](continue.html "cpp/language/continue") \- [`break`](break.html "cpp/language/break")  
---  
  
| [`goto`](goto.html "cpp/language/goto") \- [`return`](return.html "cpp/language/return")  
---  
  
[Functions](functions.html "cpp/language/functions")  
[Function declaration](function.html "cpp/language/function")  
[Lambda function expression](lambda.html "cpp/language/lambda")  
[`inline` specifier](inline.html "cpp/language/inline")  
[Dynamic exception specifications](except_spec.html "cpp/language/except spec") (until C++17*)  
[`noexcept` specifier](noexcept_spec.html "cpp/language/noexcept spec") (C++11)  
Exceptions  
| [`throw`-expression](throw.html "cpp/language/throw")  
---  
[`try` block](try.html "cpp/language/try")  
  
|   
  
---  
[`catch` handler](catch.html "cpp/language/catch")  
  
Namespaces  
| [Namespace declaration](namespace.html "cpp/language/namespace")` `  
---  
  
| [Namespace aliases](namespace_alias.html "cpp/language/namespace alias")  
---  
  
Types  
| [Fundamental types](types.html "cpp/language/types")  
---  
[Enumeration types](enum.html "cpp/language/enum")  
[Function types](function.html "cpp/language/function")  
  
| [Class/struct types](class.html "cpp/language/class")  
---  
[Union types](union.html "cpp/language/union")  
  
  
  
Specifiers  
| [`const`/`volatile`](cv.html "cpp/language/cv")  
---  
[`decltype`](decltype.html "cpp/language/decltype") (C++11)  
[`auto`](auto.html "cpp/language/auto") (C++11)  
  
| [`constexpr`](constexpr.html "cpp/language/constexpr") (C++11)  
---  
[`consteval`](consteval.html "cpp/language/consteval") (C++20)  
[`constinit`](constinit.html "cpp/language/constinit") (C++20)  
  
[Storage duration specifiers](storage_duration.html "cpp/language/storage duration")  
[Initialization](initialization.html "cpp/language/initialization")  
| [Default-initialization](default_initialization.html "cpp/language/default initialization")  
---  
[Value-initialization](value_initialization.html "cpp/language/value initialization")  
[Zero-initialization](zero_initialization.html "cpp/language/zero initialization")  
[Copy-initialization](copy_initialization.html "cpp/language/copy initialization")  
[Direct-initialization](direct_initialization.html "cpp/language/direct initialization")  
  
| [Aggregate initialization](aggregate_initialization.html "cpp/language/aggregate initialization")  
---  
[List-initialization](list_initialization.html "cpp/language/list initialization") (C++11)` `  
[Constant initialization](constant_initialization.html "cpp/language/constant initialization")  
[Reference initialization](reference_initialization.html "cpp/language/reference initialization")  
  
  
  
[Expressions](expressions.html "cpp/language/expressions")  
---  
| [Value categories](value_category.html "cpp/language/value category")  
---  
[Order of evaluation](eval_order.html "cpp/language/eval order")  
  
| [Operators](operators.html "cpp/language/operators")  
---  
[Operator precedence](operator_precedence.html "cpp/language/operator precedence")  
  
[Alternative representations](operator_alternative.html "cpp/language/operator alternative")  
[Literals](expressions.html#Literals "cpp/language/expressions")  
[Boolean](bool_literal.html "cpp/language/bool literal") \- [Integer](integer_literal.html "cpp/language/integer literal") \- [Floating-point](floating_literal.html "cpp/language/floating literal")  
[Character](character_literal.html "cpp/language/character literal") \- [String](string_literal.html "cpp/language/string literal") \- [`nullptr`](nullptr.html "cpp/language/nullptr") (C++11)  
[User-defined](user_literal.html "cpp/language/user literal") (C++11)  
Utilities  
[Attributes](attributes.html "cpp/language/attributes") (C++11)  
Types  
[`typedef` declaration](typedef.html "cpp/language/typedef")  
[Type alias declaration](type_alias.html "cpp/language/type alias") (C++11)  
Casts  
| [Implicit conversions](implicit_cast.html "cpp/language/implicit conversion")  
---  
[`static_cast`](static_cast.html "cpp/language/static cast")  
[`const_cast`](const_cast.html "cpp/language/const cast")  
  
| [Explicit conversions](explicit_cast.html "cpp/language/explicit cast")  
---  
**`dynamic_cast`**  
[`reinterpret_cast`](reinterpret_cast.html "cpp/language/reinterpret cast")  
  
Memory allocation  
| [`new` expression](new.html "cpp/language/new")  
---  
  
| [`delete` expression](delete.html "cpp/language/delete")  
---  
  
[Classes](classes.html "cpp/language/classes")  
| [Class declaration](class.html "cpp/language/class")  
---  
[Constructors](initializer_list.html "cpp/language/constructor")  
[`this` pointer](this.html "cpp/language/this")  
  
| [Access specifiers](access.html "cpp/language/access")  
---  
[`friend` specifier](friend.html "cpp/language/friend")  
  
  
  
Class-specific function properties  
| [Virtual function](virtual.html "cpp/language/virtual")  
---  
[`override` specifier](override.html "cpp/language/override") (C++11)` `  
[`final` specifier](final.html "cpp/language/final") (C++11)  
  
| [`explicit`](explicit.html "cpp/language/explicit") (C++11)  
---  
[`static`](static.html "cpp/language/static")  
  
  
  
Special member functions  
| [Default constructor](default_constructor.html "cpp/language/default constructor")  
---  
[Copy constructor](copy_constructor.html "cpp/language/copy constructor")  
[Move constructor](move_constructor.html "cpp/language/move constructor") (C++11)  
  
| [Copy assignment](as_operator.html "cpp/language/as operator")  
---  
[Move assignment](move_operator.html "cpp/language/move operator") (C++11)  
[Destructor](destructor.html "cpp/language/destructor")  
  
[Templates](templates.html "cpp/language/templates")  
| [Class template](class_template.html "cpp/language/class template")  
---  
[Function template](function_template.html "cpp/language/function template")  
  
| [Template specialization](template_specialization.html "cpp/language/template specialization")  
---  
[Parameter packs](parameter_pack.html "cpp/language/pack") (C++11)  
  
Miscellaneous  
| [Inline assembly](asm.html "cpp/language/asm")  
---  
  
| [History of C++](history.html "cpp/language/history")  
---  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/navbar_content&action=edit)

[ Expressions](expressions.html "cpp/language/expressions")

General  
---  
| [Value categories](value_category.html "cpp/language/value category")  
---  
[Order of evaluation](eval_order.html "cpp/language/eval order")  
[Constant expressions](constant_expression.html "cpp/language/constant expression")  
[Primary expressions](expressions.html#Primary_expressions "cpp/language/expressions")  
  
| [Lambda expressions](lambda.html "cpp/language/lambda") (C++11)  
---  
[Requires expressions](requires.html "cpp/language/requires") (C++20)  
[Pack indexing expression](pack_indexing.html#Pack_indexing_expression "cpp/language/pack indexing") (C++26)  
[Potentially-evaluated expressions](expressions.html#Potentially-evaluated_expressions "cpp/language/expressions")  
  
Literals  
| [Integer literals](integer_literal.html "cpp/language/integer literal")  
---  
[Floating-point literals](floating_literal.html "cpp/language/floating literal")  
[Boolean literals](bool_literal.html "cpp/language/bool literal")  
[Character literals](character_literal.html "cpp/language/character literal")  
  
| [Escape sequences](escape.html "cpp/language/escape")  
---  
[String literals](string_literal.html "cpp/language/string literal")  
[Null pointer literal](nullptr.html "cpp/language/nullptr") (C++11)  
[User-defined literal](user_literal.html "cpp/language/user literal") (C++11)  
  
Operators  
| [Assignment operators](operator_assignment.html "cpp/language/operator assignment")  
---  
[Increment and decrement](operator_incdec.html "cpp/language/operator incdec")  
[Arithmetic operators](operator_arithmetic.html "cpp/language/operator arithmetic")  
[Logical operators](operator_logical.html "cpp/language/operator logical")  
[Comparison operators](operator_comparison.html "cpp/language/operator comparison")  
[Member access operators](operator_member_access.html "cpp/language/operator member access")  
[Other operators](operator_other.html "cpp/language/operator other")  
[`new`-expression](new.html "cpp/language/new")  
[`delete`-expression](delete.html "cpp/language/delete")  
[`throw`-expression](throw.html "cpp/language/throw")  
  
| [`alignof`](alignof.html "cpp/language/alignof")  
---  
[`sizeof`](sizeof.html "cpp/language/sizeof")  
[`sizeof...`](sizeof....html "cpp/language/sizeof...") (C++11)  
[`typeid`](typeid.html "cpp/language/typeid")  
[`noexcept`](noexcept.html "cpp/language/noexcept") (C++11)  
[Fold expressions](fold.html "cpp/language/fold") (C++17)  
[Alternative representations of operators](operator_alternative.html "cpp/language/operator alternative")  
[Precedence and associativity](operator_precedence.html "cpp/language/operator precedence")  
[Operator overloading](operators.html "cpp/language/operators")  
[Default comparisons](default_comparisons.html "cpp/language/default comparisons") (C++20)  
  
Conversions  
| [Implicit conversions](implicit_cast.html "cpp/language/implicit conversion")  
---  
[Explicit conversions](explicit_cast.html "cpp/language/explicit cast")  
[Usual arithmetic conversions](usual_arithmetic_conversions.html "cpp/language/usual arithmetic conversions")  
[User-defined conversion](cast_operator.html "cpp/language/cast operator")  
  
| [`const_cast`](const_cast.html "cpp/language/const cast")  
---  
[`static_cast`](static_cast.html "cpp/language/static cast")  
**`dynamic_cast`**  
[`reinterpret_cast`](reinterpret_cast.html "cpp/language/reinterpret cast")  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/expressions/navbar_content&action=edit)

Safely converts pointers and references to classes up, down, and sideways along the inheritance hierarchy. 

## Contents

  * [1 Syntax](dynamic_cast.html#Syntax)
  * [2 Explanation](dynamic_cast.html#Explanation)
  * [3 Notes](dynamic_cast.html#Notes)
  * [4 Keywords](dynamic_cast.html#Keywords)
  * [5 Example](dynamic_cast.html#Example)
  * [6 Defect reports](dynamic_cast.html#Defect_reports)
  * [7 References](dynamic_cast.html#References)
  * [8 See also](dynamic_cast.html#See_also)

  
---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/dynamic_cast&action=edit&section=1 "Edit section: Syntax")] Syntax  
  
---  
`**dynamic_cast <**` target-type `**>(**` expression `**)**` |  |   
target-type |  \-  |  pointer to complete class type, reference to complete class type, or pointer to (optionally cv-qualified) void  
---|---|---  
expression |  \-  |  lvalue(until C++11)glvalue(since C++11) of a complete class type if target-type is a reference, prvalue of a pointer to complete class type if target-type is a pointer   
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/dynamic_cast&action=edit&section=2 "Edit section: Explanation")] Explanation

For the convenience of description, “expression or the result is a reference to `T`” means that “it is a glvalue of type `T`”, which follows the convention of [`decltype`](decltype.html "cpp/language/decltype")(since C++11). 

Only the following conversions can be done with dynamic_cast, except when such conversions would [cast away constness](const_cast.html#Casting_away_constness "cpp/language/const cast") (or volatility). 

1) If the type of expression is exactly target-type or a less cv-qualified version of target-type, the result is the value of expression with type target-type. In other words, dynamic_cast can be used to **add constness**. An implicit conversion and static_cast can perform this conversion as well.

2) If target-type is “pointer to (possibly cv-qualified) `Base`” and the type of expression is “pointer to (possibly cv-qualified) `Derived`” such that `Base` is a base class of `Derived`, the result is 

  * a null pointer value if expression is a null pointer value, or 
  * a pointer to the unique `Base` [subobject](objects.html#Subobjects "cpp/language/object") of the `Derived` object pointed to by expression otherwise. In other words, dynamic_cast can be used to **upcast** pointers, from derived to base. An implicit conversion and static_cast can perform this conversion as well.



3) If target-type is “reference to (possibly cv-qualified) `Base`” and the type of expression is “(possibly cv-qualified) `Derived`” such that `Base` is a base class of `Derived`, the result is the unique `Base` subobject of the `Derived` object referred to by expression. In other words, dynamic_cast can be used to **upcast** references, from derived to base. An implicit conversion and static_cast can perform this conversion as well.

4) If expression is a null pointer value of a [polymorphic type](objects.html#Polymorphic_objects "cpp/language/object"), the result is the null pointer value of target-type.

5) Otherwise, expression must be a pointer or reference to an object of [polymorphic type](objects.html#Polymorphic_objects "cpp/language/object") within its [lifetime](lifetime.html "cpp/language/lifetime") or within its period of construction or destruction whose type is [similar](implicit_cast.html#Similar_types "cpp/language/implicit conversion") to the type of expression (otherwise the behavior is undefined) 

a) If expression is a pointer to (possibly cv-qualified) void, the result is a pointer to the [most derived object](objects.html#Subobject "cpp/language/object") pointed to by expression.

b) Otherwise a runtime check is applied to see if the object pointed/referred to by expression can be converted to the type `Target`, pointed or referred to by target-type:

i) If, in the most derived object pointed/referred to by expression, expression points/refers to a public base class subobject of a `Target` object, and if only one object of type `Target` is derived from the subobject pointed/referred to by expression, the result points/refers to that `Target` object. In other words, dynamic_cast can be used to **downcast** pointers/references, from base to derived.

ii) Otherwise, if expression points/refers to a public base class subobject of the most derived object, and the type of the most derived object has an unambiguous and public base class of type `Target`, the result points/refers to the `Target` subobject of the most derived object. In other words, dynamic_cast can be used to **crosscast** (or side-cast) pointers/references, between two types derived from the same base.

iii) Otherwise, the runtime check fails. 

  * If target-type is a pointer type, the result is the null pointer value of target-type. 
  * If target-type is a reference type, an exception of a type that would match a [handler](catch.html "cpp/language/catch") of type [std::bad_cast](../types/bad_cast.html "cpp/types/bad cast") is thrown.



When dynamic_cast is used in a constructor or a destructor (directly or indirectly), and expression refers to the object that's currently under construction/destruction, the object is considered to be the most derived object. If target-type is not a pointer or reference to the constructor's/destructor's own class or one of its bases, the behavior is undefined. 

Similar to other cast expressions, the result is: 

  * an lvalue if target-type is a reference type 
  * an rvalue if target-type is a pointer type 

| (until C++11)  
---|---  
  
  * an lvalue if target-type is an lvalue reference type (expression must be an lvalue) 
  * an xvalue if target-type is an rvalue reference type (expression may be lvalue or rvalue(until C++17)must be a glvalue (prvalues are [materialized](implicit_cast.html#Temporary_materialization "cpp/language/implicit conversion"))(since C++17) of a complete class type) 
  * a prvalue if target-type is a pointer type 

| (since C++11)  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/dynamic_cast&action=edit&section=3 "Edit section: Notes")] Notes

A downcast can also be performed with static_cast, which avoids the cost of the runtime check, but it is only safe if the program can guarantee (through some other logic) that the object pointed to by expression is definitely `Derived`. 

Some forms of dynamic_cast rely on [run-time type identification](https://en.wikipedia.org/wiki/Run-time_type_information "enwiki:Run-time type information") (RTTI), that is, information about each polymorphic class in the compiled program. Compilers typically have options to disable the inclusion of this information. 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/dynamic_cast&action=edit&section=4 "Edit section: Keywords")] Keywords

[`dynamic_cast`](../keyword/dynamic_cast.html "cpp/keyword/dynamic cast")

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/dynamic_cast&action=edit&section=5 "Edit section: Example")] Example

Run this code
    
    
    #include <iostream>
     
    struct V
    {
        virtual void f() {} // must be polymorphic to use runtime-checked dynamic_cast
    };
     
    struct A : virtual V {};
     
    struct B : virtual V
    {
        B(V* v, A* a)
        {
            // casts during construction (see the call in the constructor of D below)
            dynamic_cast<B*>(v); // well-defined: v of type V*, V base of B, results in B*
            dynamic_cast<B*>(a); // undefined behavior: a has type A*, A not a base of B
        }
    };
     
    struct D : A, B
    {
        D() : B(static_cast<A*>(this), this) {}
    };
     
    struct Base
    {
        virtual ~Base() {}
    };
     
    struct Derived : Base
    {
        virtual void name() {}
    };
     
    int main()
    {
        D d; // the most derived object
        A& a = d; // upcast, dynamic_cast may be used, but unnecessary
     
        [[maybe_unused]]
        D& new_d = dynamic_cast<D&>(a); // downcast
        [[maybe_unused]]
        B& new_b = dynamic_cast<B&>(a); // sidecast
     
        Base* b1 = new Base;
        if (Derived* d = dynamic_cast<Derived*>(b1); d != nullptr)
        {
            [std::cout](../io/cout.html) << "downcast from b1 to d successful\n";
            d->name(); // safe to call
        }
     
        Base* b2 = new Derived;
        if (Derived* d = dynamic_cast<Derived*>(b2); d != nullptr)
        {
            [std::cout](../io/cout.html) << "downcast from b2 to d successful\n";
            d->name(); // safe to call
        }
     
        delete b1;
        delete b2;
    }

Output: 
    
    
    downcast from b2 to d successful

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/dynamic_cast&action=edit&section=6 "Edit section: Defect reports")] Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[CWG 1269](https://cplusplus.github.io/CWG/issues/1269.html) | C++11  | the runtime check was not performed for xvalue  
expression ﻿s if target-type is an rvalue reference type  | performed   
[CWG 2861](https://cplusplus.github.io/CWG/issues/2861.html) | C++98  | expression could point/refer to a type-inaccessible object  | the behavior is undefined in this case   
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/dynamic_cast&action=edit&section=7 "Edit section: References")] References

  * C++23 standard (ISO/IEC 14882:2024): 



    

  * 7.6.1.7 Dynamic cast [expr.dynamic.cast] 



  * C++20 standard (ISO/IEC 14882:2020): 



    

  * 7.6.1.6 Dynamic cast [expr.dynamic.cast] 



  * C++17 standard (ISO/IEC 14882:2017): 



    

  * 8.2.7 Dynamic cast [expr.dynamic.cast] 



  * C++14 standard (ISO/IEC 14882:2014): 



    

  * 5.2.7 Dynamic cast [expr.dynamic.cast] 



  * C++11 standard (ISO/IEC 14882:2011): 



    

  * 5.2.7 Dynamic cast [expr.dynamic.cast] 



  * C++98 standard (ISO/IEC 14882:1998): 



    

  * 5.2.7 Dynamic cast [expr.dynamic.cast] 



  * C++03 standard (ISO/IEC 14882:2003): 



    

  * 5.2.7 Dynamic cast [expr.dynamic.cast] 



### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/dynamic_cast&action=edit&section=8 "Edit section: See also")] See also

  * [`const_cast`](const_cast.html "cpp/language/const cast")
  * [`static_cast`](static_cast.html "cpp/language/static cast")
  * [`reinterpret_cast`](reinterpret_cast.html "cpp/language/reinterpret cast")
  * [explicit cast](explicit_cast.html "cpp/language/explicit cast")
  * [implicit conversions](implicit_cast.html "cpp/language/implicit conversion")


