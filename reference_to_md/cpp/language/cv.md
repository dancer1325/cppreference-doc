[C++](../../cpp.html "cpp")

[Compiler support](../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../freestanding.html "cpp/freestanding")  
[Language](../language.html "cpp/language")  
[Standard library](../standard_library.html "cpp/standard library")  
[Standard library headers](../headers.html "cpp/header")  
[Named requirements](../iterator/concepts.html "cpp/named req")  
[Feature test macros](../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../utility.html#Language_support "cpp/utility")  
[Concepts library](../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../error.html "cpp/error")  
[Memory management library](../memory.html "cpp/memory")  
[Metaprogramming library](../meta.html "cpp/meta") (C++11)  
[General utilities library](../utility.html "cpp/utility")  
[Containers library](../container.html "cpp/container")  
[Iterators library](../iterator.html "cpp/iterator")  
[Ranges library](../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../algorithm.html "cpp/algorithm")  
[Strings library](../string.html "cpp/string")  
[Text processing library](../text.html "cpp/text")  
[Numerics library](../numeric.html "cpp/numeric")  
[Date and time library](../chrono.html "cpp/chrono")  
[Input/output library](../io.html "cpp/io")  
[Filesystem library](../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../atomic.html "cpp/thread") (C++11)  
[Execution control library](../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../experimental.html "cpp/experimental")  
[Symbols index](../symbol_index.html "cpp/symbol index")  
[External libraries](../links/libs.html "cpp/links/libs")  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/navbar_content&action=edit)

[C++ language](../language.html "cpp/language")

General topics  
---  
| [Preprocessor](../preprocessor.html "cpp/preprocessor")  
---  
[Comments](../comments.html "cpp/comment")  
  
| [Keywords](../keywords.html "cpp/keyword")  
---  
[Escape sequences](escape.html "cpp/language/escape")  
  
[Flow control](statements.html "cpp/language/statements")  
Conditional execution statements  
| [`if`](if.html "cpp/language/if")  
---  
  
| [`switch`](switch.html "cpp/language/switch")  
---  
  
Iteration statements (loops)  
| [`for`](for.html "cpp/language/for")  
---  
[range-`for`](range-for.html "cpp/language/range-for") (C++11)  
  
| [`while`](while.html "cpp/language/while")  
---  
[`do-while`](do.html "cpp/language/do")  
  
Jump statements  
| [`continue`](continue.html "cpp/language/continue") \- [`break`](break.html "cpp/language/break")  
---  
  
| [`goto`](goto.html "cpp/language/goto") \- [`return`](return.html "cpp/language/return")  
---  
  
[Functions](functions.html "cpp/language/functions")  
[Function declaration](function.html "cpp/language/function")  
[Lambda function expression](lambda.html "cpp/language/lambda")  
[`inline` specifier](inline.html "cpp/language/inline")  
[Dynamic exception specifications](except_spec.html "cpp/language/except spec") (until C++17*)  
[`noexcept` specifier](noexcept_spec.html "cpp/language/noexcept spec") (C++11)  
Exceptions  
| [`throw`-expression](throw.html "cpp/language/throw")  
---  
[`try` block](try.html "cpp/language/try")  
  
|   
  
---  
[`catch` handler](catch.html "cpp/language/catch")  
  
Namespaces  
| [Namespace declaration](namespace.html "cpp/language/namespace")` `  
---  
  
| [Namespace aliases](namespace_alias.html "cpp/language/namespace alias")  
---  
  
Types  
| [Fundamental types](types.html "cpp/language/types")  
---  
[Enumeration types](enum.html "cpp/language/enum")  
[Function types](function.html "cpp/language/function")  
  
| [Class/struct types](class.html "cpp/language/class")  
---  
[Union types](union.html "cpp/language/union")  
  
  
  
Specifiers  
| **`const`/`volatile`**  
---  
[`decltype`](decltype.html "cpp/language/decltype") (C++11)  
[`auto`](auto.html "cpp/language/auto") (C++11)  
  
| [`constexpr`](constexpr.html "cpp/language/constexpr") (C++11)  
---  
[`consteval`](consteval.html "cpp/language/consteval") (C++20)  
[`constinit`](constinit.html "cpp/language/constinit") (C++20)  
  
[Storage duration specifiers](storage_duration.html "cpp/language/storage duration")  
[Initialization](initialization.html "cpp/language/initialization")  
| [Default-initialization](default_initialization.html "cpp/language/default initialization")  
---  
[Value-initialization](value_initialization.html "cpp/language/value initialization")  
[Zero-initialization](zero_initialization.html "cpp/language/zero initialization")  
[Copy-initialization](copy_initialization.html "cpp/language/copy initialization")  
[Direct-initialization](direct_initialization.html "cpp/language/direct initialization")  
  
| [Aggregate initialization](aggregate_initialization.html "cpp/language/aggregate initialization")  
---  
[List-initialization](list_initialization.html "cpp/language/list initialization") (C++11)` `  
[Constant initialization](constant_initialization.html "cpp/language/constant initialization")  
[Reference initialization](reference_initialization.html "cpp/language/reference initialization")  
  
  
  
[Expressions](expressions.html "cpp/language/expressions")  
---  
| [Value categories](value_category.html "cpp/language/value category")  
---  
[Order of evaluation](eval_order.html "cpp/language/eval order")  
  
| [Operators](operators.html "cpp/language/operators")  
---  
[Operator precedence](operator_precedence.html "cpp/language/operator precedence")  
  
[Alternative representations](operator_alternative.html "cpp/language/operator alternative")  
[Literals](expressions.html#Literals "cpp/language/expressions")  
[Boolean](bool_literal.html "cpp/language/bool literal") \- [Integer](integer_literal.html "cpp/language/integer literal") \- [Floating-point](floating_literal.html "cpp/language/floating literal")  
[Character](character_literal.html "cpp/language/character literal") \- [String](string_literal.html "cpp/language/string literal") \- [`nullptr`](nullptr.html "cpp/language/nullptr") (C++11)  
[User-defined](user_literal.html "cpp/language/user literal") (C++11)  
Utilities  
[Attributes](attributes.html "cpp/language/attributes") (C++11)  
Types  
[`typedef` declaration](typedef.html "cpp/language/typedef")  
[Type alias declaration](type_alias.html "cpp/language/type alias") (C++11)  
Casts  
| [Implicit conversions](implicit_cast.html "cpp/language/implicit conversion")  
---  
[`static_cast`](static_cast.html "cpp/language/static cast")  
[`const_cast`](const_cast.html "cpp/language/const cast")  
  
| [Explicit conversions](explicit_cast.html "cpp/language/explicit cast")  
---  
[`dynamic_cast`](dynamic_cast.html "cpp/language/dynamic cast")  
[`reinterpret_cast`](reinterpret_cast.html "cpp/language/reinterpret cast")  
  
Memory allocation  
| [`new` expression](new.html "cpp/language/new")  
---  
  
| [`delete` expression](delete.html "cpp/language/delete")  
---  
  
[Classes](classes.html "cpp/language/classes")  
| [Class declaration](class.html "cpp/language/class")  
---  
[Constructors](initializer_list.html "cpp/language/constructor")  
[`this` pointer](this.html "cpp/language/this")  
  
| [Access specifiers](access.html "cpp/language/access")  
---  
[`friend` specifier](friend.html "cpp/language/friend")  
  
  
  
Class-specific function properties  
| [Virtual function](virtual.html "cpp/language/virtual")  
---  
[`override` specifier](override.html "cpp/language/override") (C++11)` `  
[`final` specifier](final.html "cpp/language/final") (C++11)  
  
| [`explicit`](explicit.html "cpp/language/explicit") (C++11)  
---  
[`static`](static.html "cpp/language/static")  
  
  
  
Special member functions  
| [Default constructor](default_constructor.html "cpp/language/default constructor")  
---  
[Copy constructor](copy_constructor.html "cpp/language/copy constructor")  
[Move constructor](move_constructor.html "cpp/language/move constructor") (C++11)  
  
| [Copy assignment](as_operator.html "cpp/language/as operator")  
---  
[Move assignment](move_operator.html "cpp/language/move operator") (C++11)  
[Destructor](destructor.html "cpp/language/destructor")  
  
[Templates](templates.html "cpp/language/templates")  
| [Class template](class_template.html "cpp/language/class template")  
---  
[Function template](function_template.html "cpp/language/function template")  
  
| [Template specialization](template_specialization.html "cpp/language/template specialization")  
---  
[Parameter packs](parameter_pack.html "cpp/language/pack") (C++11)  
  
Miscellaneous  
| [Inline assembly](asm.html "cpp/language/asm")  
---  
  
| [History of C++](history.html "cpp/language/history")  
---  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/navbar_content&action=edit)

[Declarations](declarations.html "cpp/language/declarations")

| Overview  
---  
[Declaration syntax](declarations.html "cpp/language/declarations")  
[_decl-specifier-seq_](declarations.html#Specifiers "cpp/language/declarations")  
[Declarator](declarations.html#Declarators "cpp/language/declarations")  
[Conflicting declarations](conflicting_declarations.html "cpp/language/conflicting declarations")  
Specifiers  
[typedef](typedef.html "cpp/language/typedef")  
[inline](inline.html "cpp/language/inline")  
[virtual function specifier](virtual.html "cpp/language/virtual")  
[explicit function specifier](explicit.html "cpp/language/explicit")  
[friend](friend.html "cpp/language/friend")  
[constexpr](constexpr.html "cpp/language/constexpr")(C++11)  
[consteval](consteval.html "cpp/language/consteval")(C++20)  
[constinit](constinit.html "cpp/language/constinit")(C++20)  
[Storage class specifiers](storage_duration.html "cpp/language/storage duration")  
[Translation-unit-local](tu_local.html "cpp/language/tu local") (C++20)  
[class/struct](class.html "cpp/language/class")  
[union](union.html "cpp/language/union")  
[enum](enum.html "cpp/language/enum")  
[decltype](decltype.html "cpp/language/decltype")(C++11)  
[auto](auto.html "cpp/language/auto")(C++11)  
[alignas](alignas.html "cpp/language/alignas")(C++11)  
**const volatile**  
[Pack indexing specifier](pack_indexing.html#Pack_indexing_specifier "cpp/language/pack indexing") (C++26)  
[Elaborated type specifier](elaborated_type_specifier.html "cpp/language/elaborated type specifier")  
[Attributes](attributes.html "cpp/language/attributes") (C++11)  
  
| Declarators  
---  
[Reference](reference.html "cpp/language/reference")  
[Pointer](pointer.html "cpp/language/pointer")  
[Array](array.html "cpp/language/array")  
Block declarations  
[Simple-declaration](declarations.html "cpp/language/declarations")  
→[Structured binding declaration](structured_binding.html "cpp/language/structured binding") (C++17)  
[Alias declaration](type_alias.html "cpp/language/type alias") (C++11)  
[Namespace alias definition](namespace_alias.html "cpp/language/namespace alias")  
[using declaration](using_declaration.html "cpp/language/using declaration")  
[`using` directive](namespace.html#Using-directives "cpp/language/namespace")  
[static_assert declaration](static_assert.html "cpp/language/static assert") (C++11)  
[asm declaration](asm.html "cpp/language/asm")  
[Opaque enum declaration](enum.html "cpp/language/enum") (C++11)  
Other declarations  
[Namespace definition](namespace.html "cpp/language/namespace")  
[Function declaration](function.html "cpp/language/function")  
[Class template declaration](class_template.html "cpp/language/class template")  
[Function template declaration](function_template.html "cpp/language/function template")  
[Explicit template instantiation](class_template.html#Explicit_instantiation "cpp/language/class template") (C++11)  
[Explicit template specialization](template_specialization.html "cpp/language/template specialization")  
[Linkage specification](language_linkage.html "cpp/language/language linkage")  
[Attribute declaration](declarations.html "cpp/language/declarations") (C++11)  
[Empty declaration](declarations.html "cpp/language/declarations")  
  
  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/declarations/navbar_content&action=edit)

Appear in any type specifier, including decl-specifier-seq of [declaration grammar](declarations.html "cpp/language/declarations"), to specify constness or volatility of the object being declared or of the type being named. 

  * const \- defines that the type is _constant_. 
  * volatile \- defines that the type is _volatile_. 



## Contents

  * [1 Explanation](cv.html#Explanation)
    * [1.1 const and volatile objects](cv.html#const_and_volatile_objects)
  * [2 mutable specifier](cv.html#mutable_specifier)
  * [3 Conversions](cv.html#Conversions)
  * [4 Notes](cv.html#Notes)
  * [5 Keywords](cv.html#Keywords)
  * [6 Example](cv.html#Example)
  * [7 Defect reports](cv.html#Defect_reports)
  * [8 See also](cv.html#See_also)

  
---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/cv&action=edit&section=1 "Edit section: Explanation")] Explanation

Any (possibly [incomplete](type-id.html#Incomplete_type "cpp/language/type")) type other than [function type](functions.html "cpp/language/functions") or [reference type](reference.html "cpp/language/reference") is a type in a group of the following four distinct but related types: 

  * A _cv-unqualified_ version. 
  * A _const-qualified_ version. 
  * A _volatile-qualified_ version. 
  * A _const-volatile-qualified_ version. 



These four types in the same group have the same [representation](objects.html#Object_representation_and_value_representation "cpp/language/object") and [alignment](objects.html#Alignment "cpp/language/object") requirements. 

[Array types](array.html "cpp/language/array") are considered to have the same cv-qualification as their element types. 

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/cv&action=edit&section=2 "Edit section: const and volatile objects")] const and volatile objects

When an object is first created, the cv-qualifiers used (which could be part of decl-specifier-seq or part of a declarator in a [declaration](declarations.html "cpp/language/declarations"), or part of type-id in a [new-expression](new.html "cpp/language/new")) determine the constness or volatility of the object, as follows: 

  * A _const object_ is 



    

  * an object whose type is const-qualified, or 
  * a non-[mutable](cv.html#mutable) subobject of a const object. 


     Such object cannot be modified: attempt to do so directly is a compile-time error, and attempt to do so indirectly (e.g., by modifying the const object through a reference or pointer to non-const type) results in undefined behavior. 

  * A _volatile object_ is 



    

  * an object whose type is volatile-qualified, 
  * a subobject of a volatile object, or 
  * a [mutable](cv.html#mutable) subobject of a const-volatile object. 


     Every access (read or write operation, member function call, etc.) made through a glvalue expression of volatile-qualified type is treated as a visible side-effect for the [purposes of optimization](as_if.html "cpp/language/as if") (that is, within a single thread of execution, volatile accesses cannot be optimized out or reordered with another visible side effect that is [sequenced-before](eval_order.html "cpp/language/eval order") or sequenced-after the volatile access. This makes volatile objects suitable for communication with a [signal handler](../utility/program/signal.html "cpp/utility/program/signal"), but not with another thread of execution, see [std::memory_order](../atomic/memory_order.html "cpp/atomic/memory order")). Any attempt to access a volatile object through a [glvalue](value_category.html#glvalue "cpp/language/value category") of non-volatile type (e.g. through a reference or pointer to non-volatile type) results in undefined behavior. 

  * A _const volatile object_ is 



    

  * an object whose type is const-volatile-qualified, 
  * a non-[mutable](cv.html#mutable) subobject of a const volatile object, 
  * a const subobject of a volatile object, or 
  * a non-[mutable](cv.html#mutable) volatile subobject of a const object. 


     Behaves as both a const object and as a volatile object. 

Each cv-qualifier (const and volatile) can appear at most once in any cv-qualifier sequence. For example, const const and volatile const volatile are not valid cv-qualifier sequences. 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/cv&action=edit&section=3 "Edit section: mutable specifier")] `mutable` specifier

  * mutable \- permits modification of the class member declared mutable even if the containing object is declared const (i.e., the class member is mutable). 



May appear in the declaration of a non-static [class members](data_members.html "cpp/language/data members") of non-reference non-const type: 
    
    
    class X
    {
        mutable const int* p; // OK
        mutable int* const q; // ill-formed
        mutable int&       r; // ill-formed
    };

mutable is used to specify that the member does not affect the externally visible state of the class (as often used for mutexes, memo caches, lazy evaluation, and access instrumentation). 
    
    
    class ThreadsafeCounter
    {
        mutable [std::mutex](../thread/mutex.html) m; // The "M&M rule": mutable and mutex go together
        int data = 0;
    public:
        int get() const
        {
            [std::lock_guard](../thread/lock_guard.html)<[std::mutex](../thread/mutex.html)> lk(m);
            return data;
        }
     
        void inc()
        {
            [std::lock_guard](../thread/lock_guard.html)<[std::mutex](../thread/mutex.html)> lk(m);
            ++data;
        }
    };

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/cv&action=edit&section=4 "Edit section: Conversions")] Conversions

There is partial ordering of cv-qualifiers by the order of increasing restrictions. The type can be said _more_ or _less_ cv-qualified than: 

  * _unqualified_ < const
  * _unqualified_ < volatile
  * _unqualified_ < const volatile
  * const < const volatile
  * volatile < const volatile



References and pointers to cv-qualified types can be implicitly converted to references and pointers to more cv-qualified types, see [qualification conversions](implicit_cast.html#Qualification_conversions "cpp/language/implicit cast") for details. 

To convert a reference or a pointer to a cv-qualified type to a reference or pointer to a less cv-qualified type, [`const_cast`](const_cast.html "cpp/language/const cast") must be used. 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/cv&action=edit&section=5 "Edit section: Notes")] Notes

The const qualifier used on a declaration of a non-local non-volatile non-[template](variable_template.html "cpp/language/variable template")(since C++14)non-[inline](inline.html "cpp/language/inline")(since C++17) variable that is not declared extern gives it [internal linkage](storage_duration.html#Linkage "cpp/language/storage duration"). This is different from C where const file scope variables have external linkage. 

The C++ language grammar treats mutable as a [storage-class-specifier](storage_duration.html "cpp/language/storage duration"), rather than a type qualifier, but it does not affect storage class or linkage. 

Some uses of volatile are deprecated: 

  * lvalue of volatile type as operand of built-in [increment/decrement](operator_incdec.html "cpp/language/operator incdec") operators; 
  * lvalue of volatile type as left operand of built-in [direct assignment](operator_assignment.html "cpp/language/operator assignment"), unless the direct assignment expression appears in an [unevaluated context](expressions.html#Unevaluated_expressions "cpp/language/expressions") or is a [discarded-value expression](expressions.html#Discarded-value_expressions "cpp/language/expressions"); 
  * volatile object type as function parameter type or return type; 
  * volatile qualifier in [structured binding](structured_binding.html "cpp/language/structured binding") declaration. 

| (since C++20)  
---|---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/cv&action=edit&section=6 "Edit section: Keywords")] Keywords

[`const`](../keyword/const.html "cpp/keyword/const"), [`volatile`](../keyword/volatile.html "cpp/keyword/volatile"), [`mutable`](../keyword/mutable.html "cpp/keyword/mutable")

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/cv&action=edit&section=7 "Edit section: Example")] Example

Run this code
    
    
    #include <cstdlib>
     
    int main()
    {
        int n1 = 0;          // non-const object
        const int n2 = 0;    // const object
        int const n3 = 0;    // const object (same as n2)
        volatile int n4 = 0; // volatile object
     
        const struct
        {
            int n1;
            mutable int n2;
        } x = {0, 0};        // const object with mutable member
     
        n1 = 1;   // OK: modifiable object
    //  n2 = 2;   // error: non-modifiable object
        n4 = 3;   // OK: treated as a side-effect
    //  x.n1 = 4; // error: member of a const object is const
        x.n2 = 4; // OK: mutable member of a const object isn't const
     
        const int& r1 = n1; // reference to const bound to non-const object
    //  r1 = 2; // error: attempt to modify through reference to const
        const_cast<int&>(r1) = 2; // OK: modifies non-const object n1
     
        const int& r2 = n2; // reference to const bound to const object
    //  r2 = 2; // error: attempt to modify through reference to const
    //  const_cast<int&>(r2) = 2; // undefined behavior: attempt to modify const object n2
     
        [](...){}(n3, n4, x, r2); // see also: [[maybe_unused]]
     
        [std::system](../utility/program/system.html)("g++ -O3 -Wa,-adhln ./main.cpp"); // may issue asm on POSIX systems
    }

Possible output: 
    
    
    # typical machine code produced on an x86_64 platform
    # (only the code that contributes to observable side-effects is emitted)
    main:
        movl    $0, -4(%rsp) # volatile int n4 = 0;
        movl    $3, -4(%rsp) # n4 = 3;
        xorl    %eax, %eax   # return 0 (implicit)
        ret

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/cv&action=edit&section=8 "Edit section: Defect reports")] Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[CWG 1428](https://cplusplus.github.io/CWG/issues/1428.html) | C++98  | the definition of 'const object' was based on declaration  | based on object type   
[CWG 1528](https://cplusplus.github.io/CWG/issues/1528.html) | C++98  | there was no requirement on the number of occurrences  
of each cv-qualifier in the same cv-qualifier sequence  | at most once for  
each cv-qualifier   
[CWG 1799](https://cplusplus.github.io/CWG/issues/1799.html) | C++98  | mutable could be applied to data members not declared  
const, but the members' types may still be const-qualified  | cannot apply mutable to data  
members of const-qualified types   
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/cv&action=edit&section=9 "Edit section: See also")] See also

[C documentation](../../c/language/const.html "c/language/const") for const qualifier  
---  
[C documentation](../../c/language/volatile.html "c/language/volatile") for volatile qualifier
