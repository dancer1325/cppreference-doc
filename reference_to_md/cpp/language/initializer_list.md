[C++](../../cpp.html "cpp")

[Compiler support](../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../freestanding.html "cpp/freestanding")  
[Language](../language.html "cpp/language")  
[Standard library](../standard_library.html "cpp/standard library")  
[Standard library headers](../headers.html "cpp/header")  
[Named requirements](../iterator/concepts.html "cpp/named req")  
[Feature test macros](../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../utility.html#Language_support "cpp/utility")  
[Concepts library](../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../error.html "cpp/error")  
[Memory management library](../memory.html "cpp/memory")  
[Metaprogramming library](../meta.html "cpp/meta") (C++11)  
[General utilities library](../utility.html "cpp/utility")  
[Containers library](../container.html "cpp/container")  
[Iterators library](../iterator.html "cpp/iterator")  
[Ranges library](../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../algorithm.html "cpp/algorithm")  
[Strings library](../string.html "cpp/string")  
[Text processing library](../text.html "cpp/text")  
[Numerics library](../numeric.html "cpp/numeric")  
[Date and time library](../chrono.html "cpp/chrono")  
[Input/output library](../io.html "cpp/io")  
[Filesystem library](../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../atomic.html "cpp/thread") (C++11)  
[Execution control library](../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../experimental.html "cpp/experimental")  
[Symbols index](../symbol_index.html "cpp/symbol index")  
[External libraries](../links/libs.html "cpp/links/libs")  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/navbar_content&action=edit)

[C++ language](../language.html "cpp/language")

General topics  
---  
| [Preprocessor](../preprocessor.html "cpp/preprocessor")  
---  
[Comments](../comments.html "cpp/comment")  
  
| [Keywords](../keywords.html "cpp/keyword")  
---  
[Escape sequences](escape.html "cpp/language/escape")  
  
[Flow control](statements.html "cpp/language/statements")  
Conditional execution statements  
| [`if`](if.html "cpp/language/if")  
---  
  
| [`switch`](switch.html "cpp/language/switch")  
---  
  
Iteration statements (loops)  
| [`for`](for.html "cpp/language/for")  
---  
[range-`for`](range-for.html "cpp/language/range-for") (C++11)  
  
| [`while`](while.html "cpp/language/while")  
---  
[`do-while`](do.html "cpp/language/do")  
  
Jump statements  
| [`continue`](continue.html "cpp/language/continue") \- [`break`](break.html "cpp/language/break")  
---  
  
| [`goto`](goto.html "cpp/language/goto") \- [`return`](return.html "cpp/language/return")  
---  
  
[Functions](functions.html "cpp/language/functions")  
[Function declaration](function.html "cpp/language/function")  
[Lambda function expression](lambda.html "cpp/language/lambda")  
[`inline` specifier](inline.html "cpp/language/inline")  
[Dynamic exception specifications](except_spec.html "cpp/language/except spec") (until C++17*)  
[`noexcept` specifier](noexcept_spec.html "cpp/language/noexcept spec") (C++11)  
Exceptions  
| [`throw`-expression](throw.html "cpp/language/throw")  
---  
[`try` block](try.html "cpp/language/try")  
  
|   
  
---  
[`catch` handler](catch.html "cpp/language/catch")  
  
Namespaces  
| [Namespace declaration](namespace.html "cpp/language/namespace")` `  
---  
  
| [Namespace aliases](namespace_alias.html "cpp/language/namespace alias")  
---  
  
Types  
| [Fundamental types](types.html "cpp/language/types")  
---  
[Enumeration types](enum.html "cpp/language/enum")  
[Function types](function.html "cpp/language/function")  
  
| [Class/struct types](class.html "cpp/language/class")  
---  
[Union types](union.html "cpp/language/union")  
  
  
  
Specifiers  
| [`const`/`volatile`](cv.html "cpp/language/cv")  
---  
[`decltype`](decltype.html "cpp/language/decltype") (C++11)  
[`auto`](auto.html "cpp/language/auto") (C++11)  
  
| [`constexpr`](constexpr.html "cpp/language/constexpr") (C++11)  
---  
[`consteval`](consteval.html "cpp/language/consteval") (C++20)  
[`constinit`](constinit.html "cpp/language/constinit") (C++20)  
  
[Storage duration specifiers](storage_duration.html "cpp/language/storage duration")  
[Initialization](initialization.html "cpp/language/initialization")  
| [Default-initialization](default_initialization.html "cpp/language/default initialization")  
---  
[Value-initialization](value_initialization.html "cpp/language/value initialization")  
[Zero-initialization](zero_initialization.html "cpp/language/zero initialization")  
[Copy-initialization](copy_initialization.html "cpp/language/copy initialization")  
[Direct-initialization](direct_initialization.html "cpp/language/direct initialization")  
  
| [Aggregate initialization](aggregate_initialization.html "cpp/language/aggregate initialization")  
---  
[List-initialization](list_initialization.html "cpp/language/list initialization") (C++11)` `  
[Constant initialization](constant_initialization.html "cpp/language/constant initialization")  
[Reference initialization](reference_initialization.html "cpp/language/reference initialization")  
  
  
  
[Expressions](expressions.html "cpp/language/expressions")  
---  
| [Value categories](value_category.html "cpp/language/value category")  
---  
[Order of evaluation](eval_order.html "cpp/language/eval order")  
  
| [Operators](operators.html "cpp/language/operators")  
---  
[Operator precedence](operator_precedence.html "cpp/language/operator precedence")  
  
[Alternative representations](operator_alternative.html "cpp/language/operator alternative")  
[Literals](expressions.html#Literals "cpp/language/expressions")  
[Boolean](bool_literal.html "cpp/language/bool literal") \- [Integer](integer_literal.html "cpp/language/integer literal") \- [Floating-point](floating_literal.html "cpp/language/floating literal")  
[Character](character_literal.html "cpp/language/character literal") \- [String](string_literal.html "cpp/language/string literal") \- [`nullptr`](nullptr.html "cpp/language/nullptr") (C++11)  
[User-defined](user_literal.html "cpp/language/user literal") (C++11)  
Utilities  
[Attributes](attributes.html "cpp/language/attributes") (C++11)  
Types  
[`typedef` declaration](typedef.html "cpp/language/typedef")  
[Type alias declaration](type_alias.html "cpp/language/type alias") (C++11)  
Casts  
| [Implicit conversions](implicit_cast.html "cpp/language/implicit conversion")  
---  
[`static_cast`](static_cast.html "cpp/language/static cast")  
[`const_cast`](const_cast.html "cpp/language/const cast")  
  
| [Explicit conversions](explicit_cast.html "cpp/language/explicit cast")  
---  
[`dynamic_cast`](dynamic_cast.html "cpp/language/dynamic cast")  
[`reinterpret_cast`](reinterpret_cast.html "cpp/language/reinterpret cast")  
  
Memory allocation  
| [`new` expression](new.html "cpp/language/new")  
---  
  
| [`delete` expression](delete.html "cpp/language/delete")  
---  
  
[Classes](classes.html "cpp/language/classes")  
| [Class declaration](class.html "cpp/language/class")  
---  
**Constructors**  
[`this` pointer](this.html "cpp/language/this")  
  
| [Access specifiers](access.html "cpp/language/access")  
---  
[`friend` specifier](friend.html "cpp/language/friend")  
  
  
  
Class-specific function properties  
| [Virtual function](virtual.html "cpp/language/virtual")  
---  
[`override` specifier](override.html "cpp/language/override") (C++11)` `  
[`final` specifier](final.html "cpp/language/final") (C++11)  
  
| [`explicit`](explicit.html "cpp/language/explicit") (C++11)  
---  
[`static`](static.html "cpp/language/static")  
  
  
  
Special member functions  
| [Default constructor](default_constructor.html "cpp/language/default constructor")  
---  
[Copy constructor](copy_constructor.html "cpp/language/copy constructor")  
[Move constructor](move_constructor.html "cpp/language/move constructor") (C++11)  
  
| [Copy assignment](as_operator.html "cpp/language/as operator")  
---  
[Move assignment](move_operator.html "cpp/language/move operator") (C++11)  
[Destructor](destructor.html "cpp/language/destructor")  
  
[Templates](templates.html "cpp/language/templates")  
| [Class template](class_template.html "cpp/language/class template")  
---  
[Function template](function_template.html "cpp/language/function template")  
  
| [Template specialization](template_specialization.html "cpp/language/template specialization")  
---  
[Parameter packs](parameter_pack.html "cpp/language/pack") (C++11)  
  
Miscellaneous  
| [Inline assembly](asm.html "cpp/language/asm")  
---  
  
| [History of C++](history.html "cpp/language/history")  
---  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/navbar_content&action=edit)

[ Classes](classes.html "cpp/language/classes")

General  
---  
[Overview](classes.html "cpp/language/classes")  
[`class`/`struct` types](class.html "cpp/language/class")  
[`union` types](union.html "cpp/language/union")  
[Injected-class-name](injected-class-name.html "cpp/language/injected-class-name")  
[Class property specifiers](class_property_specifiers.html "cpp/language/class property specifiers") (C++26)  
Members  
[Data members](data_members.html "cpp/language/data members")  
[Static members](static.html "cpp/language/static")  
[The `this` pointer](this.html "cpp/language/this")  
[Nested classes](nested_classes.html "cpp/language/nested types")  
[Member templates](member_template.html "cpp/language/member template")  
[Bit-fields](bit_field.html "cpp/language/bit field")  
[`using`-declarations](using_declaration.html "cpp/language/using declaration")  
[Member functions](member_functions.html "cpp/language/member functions")  
[Member access specifiers](access.html "cpp/language/access")  
**Constructors and member initializer lists**  
[Default member initializer](data_members.html#Member_initialization "cpp/language/data members") (C++11)  
[`friend` specifier](friend.html "cpp/language/friend")  
[`explicit` specifier](explicit.html "cpp/language/explicit")  
[Converting constructor](converting_constructor.html "cpp/language/converting constructor")  
Special member functions  
[Default constructor](default_constructor.html "cpp/language/default constructor")  
[Copy constructor](copy_constructor.html "cpp/language/copy constructor")  
[Move constructor](move_constructor.html "cpp/language/move constructor") (C++11)  
[Copy assignment operator](as_operator.html "cpp/language/copy assignment")  
[Move assignment operator](move_operator.html "cpp/language/move assignment") (C++11)  
[Destructor](destructor.html "cpp/language/destructor")  
Inheritance  
[Base and derived classes](derived_class.html "cpp/language/derived class")  
[Empty base optimization (EBO)](ebo.html "cpp/language/ebo")  
[Virtual member functions](virtual.html "cpp/language/virtual")  
[Pure virtual functions and abstract classes](abstract_class.html "cpp/language/abstract class")  
[`override` specifier](override.html "cpp/language/override") (C++11)  
[`final` specifier](final.html "cpp/language/final") (C++11)  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/classes/navbar_content&action=edit)

_Constructors_ are non-static [member functions](member_functions.html "cpp/language/member functions") declared with a special declarator syntax, they are used to initialize objects of their class types. 

A constructor cannot be a [coroutine](coroutines.html "cpp/language/coroutines").  | (since C++20)  
---|---  
A constructor cannot have an [explicit object parameter](member_functions.html#Explicit_object_parameter "cpp/language/member functions").  | (since C++23)  
  
## Contents

  * [1 Syntax](initializer_list.html#Syntax)
  * [2 Member initializer list](initializer_list.html#Member_initializer_list)
  * [3 Explanation](initializer_list.html#Explanation)
    * [3.1 Operations during construction and destruction](initializer_list.html#Operations_during_construction_and_destruction)
    * [3.2 Delegating constructor](initializer_list.html#Delegating_constructor)
    * [3.3 Inheriting constructors](initializer_list.html#Inheriting_constructors)
    * [3.4 Initialization order](initializer_list.html#Initialization_order)
  * [4 Notes](initializer_list.html#Notes)
  * [5 Example](initializer_list.html#Example)
  * [6 Defect reports](initializer_list.html#Defect_reports)
  * [7 References](initializer_list.html#References)
  * [8 See also](initializer_list.html#See_also)

  
---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/constructor&action=edit&section=1 "Edit section: Syntax")] Syntax

Constructors are declared using member [function declarators](function.html "cpp/language/function") of the following form:   
  
---  
class-name `**(**` parameter-list ﻿(optional) `**)**` except ﻿(optional) attr ﻿(optional) |  |   
class-name |  \-  |  an [identifier expression](expressions.html#Primary_expressions "cpp/language/expressions"), possibly followed by a list of [attributes](attributes.html "cpp/language/attributes"), and(since C++11) possibly enclosed by a pair parentheses   
---|---|---  
parameter-list |  \-  |  [parameter list](function.html#Parameter_list "cpp/language/function")  
except |  \-  |  |  [dynamic exception specification](except_spec.html "cpp/language/except spec") | (until C++11)  
---|---  
either [dynamic exception specification](except_spec.html "cpp/language/except spec")  
or [noexcept specification](noexcept_spec.html "cpp/language/noexcept spec") | (since C++11)  
(until C++17)  
[noexcept specification](noexcept_spec.html "cpp/language/noexcept spec") | (since C++17)  
attr |  \-  |  (since C++11) a list of [attributes](attributes.html "cpp/language/attributes")  
  
The only specifiers allowed in the [declaration specifiers](declarations.html#Specifiers "cpp/language/declarations") of a constructor declaration are [`friend`](friend.html "cpp/language/friend"), [`inline`](inline.html "cpp/language/inline"), [`constexpr`](constexpr.html "cpp/language/constexpr")(since C++11), [`consteval`](consteval.html "cpp/language/consteval")(since C++20), and [`explicit`](explicit.html "cpp/language/explicit") (in particular, no return type is allowed). Note that [cv- and ref-qualifiers](member_functions.html "cpp/language/member functions") are not allowed either: const and volatile semantics of an object under construction only kick in after the most-derived constructor completes. 

The identifier expression of class-name must have one of the following forms: 

  * In a [friend declaration](friend.html "cpp/language/friend"), the identifier expression is a [qualified identifier](name.html#Qualified_identifiers "cpp/language/identifiers") that [names a constructor](qualified_lookup.html#Class_members "cpp/language/qualified lookup"). 
  * Otherwise, in a member declaration that belongs to the [member specification](class.html#Member_specification "cpp/language/class") of a class or class template: 



    

  * For classes, the identifier expression is the [injected-class-name](injected-class-name.html "cpp/language/injected-class-name") of the immediately-enclosing class. 
  * For class templates, the identifier expression is a class name that names the [current instantiation](dependent_name.html#Current_instantiation "cpp/language/dependent name")(until C++20)the injected-class-name(since C++20) of the immediately-enclosing class template. 



  * Otherwise, the identifier expression is a qualified identifier whose terminal unqualified identifier is the injected-class-name of its [lookup](lookup.html "cpp/language/lookup") context. 



### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/constructor&action=edit&section=2 "Edit section: Member initializer list")] Member initializer list

The body of a [function definition](function.html "cpp/language/function") of any constructor of class `T`, before the opening brace of the compound statement, may include the _member initializer list ﻿_ , whose syntax is the colon character `**:**`, followed by the comma-separated list of one or more member-initializer ﻿s, each of which has the following syntax:   
  
---  
member initializer |  (1)  |   
class initializer |  (2)  |   
class-pack initializer `**...**` |  (3)  |  (since C++11)  
  
1) [Direct-initializes](direct_initialization.html "cpp/language/direct initialization") the data member named by member with initializer ﻿. member can only name non-static data members.

2) Initializes a class object with initializer ﻿. class can only name the following classes: 

  * Class `T` itself. In this case the constructor is a [delegating constructor](initializer_list.html#Delegating_constructor). 

| (since C++11)  
---|---  
  
  * A direct base class or a [virtual base class](derived_class.html#Virtual_base_classes "cpp/language/derived class") of `T`. In this case the corresponding base class subobject is direct-initialized with initializer ﻿.



3) Initializes multiple base class subobjects using a [pack expansion](parameter_pack.html#Base_specifiers_and_member_initializer_lists "cpp/language/pack").

member |  \-  |  an identifier that names a data member   
---|---|---  
class |  \-  |  a class name   
class-pack |  \-  |  a pack that expands to zero or more classes   
initializer |  \-  |  an [initializer](initialization.html "cpp/language/initialization") that does not begin with `**=**`  
  
Run this code
    
    
    struct S
    {
        int n;
     
        S(int);       // constructor declaration
     
        S() : n(7) {} // constructor definition:
                      // ": n(7)" is the initializer list
                      // ": n(7) {}" is the function body
    };
     
    S::S(int x) : n{x} {} // constructor definition: ": n{x}" is the initializer list
     
    int main()
    {
        S s;      // calls S::S()
        S s2(10); // calls S::S(int)
    }

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/constructor&action=edit&section=3 "Edit section: Explanation")] Explanation

Constructors have no names and cannot be called directly. They are invoked when [initialization](initialization.html "cpp/language/initialization") takes place, and they are selected according to the rules of initialization. The constructors without explicit specifier are [converting constructors](converting_constructor.html "cpp/language/converting constructor"). The constructors with a constexpr specifier make their type a [literal type](constant_expression.html#Literal_type "cpp/language/constant expression"). Constructors that may be called without any argument are [default constructors](default_constructor.html "cpp/language/default constructor"). Constructors that take another object of the same type as the argument are [copy constructors](copy_constructor.html "cpp/language/copy constructor") and [move constructors](move_constructor.html "cpp/language/move constructor"). 

Before the compound statement that forms the function body of the constructor begins executing, initialization of all direct bases, virtual bases, and non-static data members is finished. The member initializer list is the place where non-default initialization of these subobjects can be specified. For bases that cannot be default-initialized and for non-static data members that cannot be initialized by default-initialization or by their [default member initializer](data_members.html#Member_initialization "cpp/language/data members"), if any(since C++11), such as members of reference and const-qualified types, member initializers must be specified. (Note that default member initializers for non-static data members of class template instantiations may be invalid if the member type or initializer is dependent.)(since C++11) No initialization is performed for [anonymous unions](union.html#Anonymous_unions "cpp/language/union") or [variant members](union.html#Union-like_class "cpp/language/union") that do not have a member initializer or default member initializer(since C++11). 

The initializers where class names a virtual base class are ignored during construction of any class that is not the most derived class of the object that is being constructed. 

Names that appear in initializer are evaluated in scope of the constructor: 
    
    
    class X
    {
        int a, b, i, j;
    public:
        const int& r;
        X(int i)
          : r(a) // initializes X::r to refer to X::a
          , b{i} // initializes X::b to the value of the parameter i
          , i(i) // initializes X::i to the value of the parameter i
          , j(this->i) // initializes X::j to the value of X::i
        {}
    };

Exceptions that are thrown from member initializers may be handled by a [function try block](try.html#Function_try_block "cpp/language/try"). 

If a non-static data member has a [default member initializer](data_members.html#Member_initialization "cpp/language/data members") and also appears in a member initializer list, then the member initializer is used and the default member initializer is ignored: 
    
    
    struct S
    {
        int n = 42;   // default member initializer
        S() : n(7) {} // will set n to 7, not 42
    };

| (since C++11)  
---|---  
  
Reference members cannot be bound to temporaries in a member initializer list: 
    
    
    struct A
    {
        A() : v(42) {} // Error
        const int& v;
    };

Note: same applies to [default member initializer](data_members.html#Member_initialization "cpp/language/data members"). 

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/constructor&action=edit&section=4 "Edit section: Operations during construction and destruction")] Operations during construction and destruction

Member functions (including [virtual member functions](virtual.html#During_construction_and_destruction "cpp/language/virtual")) can be called for an object under construction or destruction. Similarly, an object under construction or destruction can be the operand of [`typeid`](typeid.html "cpp/language/typeid") or [`dynamic_cast`](dynamic_cast.html "cpp/language/dynamic cast"). 

However, if these operations are performed during any of the following evaluations, the behavior is undefined: 

  * an evaluation of a [precondition assertion](function.html#Precondition_assertions "cpp/language/function") of a constructor 
  * an evaluation of a [postcondition assertion](function.html#Postcondition_assertions "cpp/language/function") of a [destructor](destructor.html "cpp/language/destructor")

| (since C++26)  
---|---  
  
  * an evaluation of a member initializer list before all the member-initializer ﻿s for base classes have completed 



####  Delegating constructor

If the name of the class itself appears as class-or-identifier in the member initializer list, then the list must consist of that one member initializer only; such a constructor is known as the _delegating constructor_ , and the constructor selected by the only member of the initializer list is the _target constructor_. In this case, the target constructor is selected by overload resolution and executed first, then the control returns to the delegating constructor and its body is executed. Delegating constructors cannot be recursive. 
    
    
    class Foo
    {
    public: 
        Foo(char x, int y) {}
        Foo(int y) : Foo('a', y) {} // Foo(int) delegates to Foo(char, int)
    };

####  Inheriting constructors

See [using declaration](using_declaration.html#Inheriting_constructors "cpp/language/using declaration").  | (since C++11)  
---|---  
  
#### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/constructor&action=edit&section=7 "Edit section: Initialization order")] Initialization order

The order of member initializers in the list is irrelevant, the actual order of initialization is as follows: 

1) If the constructor is for the most-derived class, virtual bases are initialized in the order in which they appear in depth-first left-to-right traversal of the base class declarations (left-to-right refers to the appearance in base-specifier lists).

2) Then, direct bases are initialized in left-to-right order as they appear in this class's base-specifier list.

3) Then, non-static data member are initialized in order of declaration in the class definition.

4) Finally, the body of the constructor is executed.

(Note: if initialization order was controlled by the appearance in the member initializer lists of different constructors, then the [destructor](destructor.html "cpp/language/destructor") wouldn't be able to ensure that the order of destruction is the reverse of the order of construction.) 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/constructor&action=edit&section=8 "Edit section: Notes")] Notes

Feature-test macro | Value | Std | Feature   
---|---|---|---  
[`__cpp_delegating_constructors`](../experimental/feature_test.html#cpp_delegating_constructors "cpp/feature test") | [`200604L`](../compiler_support/11.html#cpp_delegating_constructors_200604L "cpp/compiler support/11") | (C++11) | [Delegating constructors](initializer_list.html#Delegating_constructor)  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/constructor&action=edit&section=9 "Edit section: Example")] Example

Run this code
    
    
    #include <fstream>
    #include <string>
    #include <mutex>
     
    struct Base
    {
        int n;
    };   
     
    struct Class : public Base
    {
        unsigned char x;
        unsigned char y;
        [std::mutex](../thread/mutex.html) m;
        [std::lock_guard](../thread/lock_guard.html)<[std::mutex](../thread/mutex.html)> lg;
        [std::fstream](../io/basic_fstream.html) f;
        [std::string](../string/basic_string.html) s;
     
        Class(int x) : Base{123}, // initialize base class
            x(x),     // x (member) is initialized with x (parameter)
            y{0},     // y initialized to 0
            f{"test.cc", std::ios::app}, // this takes place after m and lg are initialized
            s(__func__), // __func__ is available because init-list is a part of constructor
            lg(m),    // lg uses m, which is already initialized
            m{}       // m is initialized before lg even though it appears last here
        {}            // empty compound statement
     
        Class(double a) : y(a + 1),
            x(y), // x will be initialized before y, its value here is indeterminate
            lg(m)
        {} // base class initializer does not appear in the list, it is
           // default-initialized (not the same as if Base() were used, which is value-init)
     
        Class()
        try // function try block begins before the function body, which includes init list
          : Class(0.0) // delegate constructor
        {
            // ...
        }
        catch (...)
        {
            // exception occurred on initialization
        }
    };
     
    int main()
    {
        Class c;
        Class c1(1);
        Class c2(0.1);
    }

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/constructor&action=edit&section=10 "Edit section: Defect reports")] Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[CWG 194](https://cplusplus.github.io/CWG/issues/194.html) | C++98  | the declarator syntax of constructor only allowed  
at most one function specifier (e.g. a constructor  
cannot be declared inline explicit)  | multiple function  
specifiers allowed   
[CWG 257](https://cplusplus.github.io/CWG/issues/257.html) | C++98  | it was unspecified whether an abstract class should  
provide member initializers for its virtual base classes  | specified as not required  
and such member initializers  
are ignored during execution   
[CWG 263](https://cplusplus.github.io/CWG/issues/263.html) | C++98  | the declarator syntax of constructor  
prohibited constructors from being friends  | allowed constructors  
to be friends   
[CWG 1345](https://cplusplus.github.io/CWG/issues/1345.html) | C++98  | anonymous union members without default  
member initializers were default-initialized  | they are not initialized   
[CWG 1435](https://cplusplus.github.io/CWG/issues/1435.html) | C++98  | the meaning of “class name” in the  
declarator syntax of constructor was unclear  | changed the syntax to a specialized  
function declarator syntax   
[CWG 1696](https://cplusplus.github.io/CWG/issues/1696.html) | C++98  | reference members could be initialized to temporaries  
(whose lifetime would end at the end of constructor)  | such initialization  
is ill-formed   
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/constructor&action=edit&section=11 "Edit section: References")] References

  * C++23 standard (ISO/IEC 14882:2024): 



    

  * 11.4.5 Constructors [class.ctor] 



    

  * 11.9.3 Initializing bases and members [class.base.init] 



  * C++20 standard (ISO/IEC 14882:2020): 



    

  * 11.4.4 Constructors [class.ctor] 



    

  * 11.10.2 Initializing bases and members [class.base.init] 



  * C++17 standard (ISO/IEC 14882:2017): 



    

  * 15.1 Constructors [class.ctor] 



    

  * 15.6.2 Initializing bases and members [class.base.init] 



  * C++14 standard (ISO/IEC 14882:2014): 



    

  * 12.1 Constructors [class.ctor] 



    

  * 12.6.2 Initializing bases and members [class.base.init] 



  * C++11 standard (ISO/IEC 14882:2011): 



    

  * 12.1 Constructors [class.ctor] 



    

  * 12.6.2 Initializing bases and members [class.base.init] 



  * C++98 standard (ISO/IEC 14882:1998): 



    

  * 12.1 Constructors [class.ctor] 



    

  * 12.6.2 Initializing bases and members [class.base.init] 



### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/constructor&action=edit&section=12 "Edit section: See also")] See also

  * [copy elision](copy_elision.html "cpp/language/copy elision")
  * [converting constructor](converting_constructor.html "cpp/language/converting constructor")
  * [copy assignment](as_operator.html "cpp/language/copy assignment")
  * [copy constructor](copy_constructor.html "cpp/language/copy constructor")
  * [default constructor](default_constructor.html "cpp/language/default constructor")
  * [destructor](destructor.html "cpp/language/destructor")
  * [`explicit`](explicit.html "cpp/language/explicit")
  * [initialization](initialization.html "cpp/language/initialization")
    * [aggregate initialization](aggregate_initialization.html "cpp/language/aggregate initialization")
    * [constant initialization](constant_initialization.html "cpp/language/constant initialization")
    * [copy initialization](copy_initialization.html "cpp/language/copy initialization")
    * [default initialization](default_initialization.html "cpp/language/default initialization")
    * [direct initialization](direct_initialization.html "cpp/language/direct initialization")
    * [list initialization](list_initialization.html "cpp/language/list initialization")
    * [reference initialization](reference_initialization.html "cpp/language/reference initialization")
    * [value initialization](value_initialization.html "cpp/language/value initialization")
    * [zero initialization](zero_initialization.html "cpp/language/zero initialization")
  * [move assignment](move_operator.html "cpp/language/move assignment")
  * [move constructor](move_constructor.html "cpp/language/move constructor")
  * [`new`](new.html "cpp/language/new")


  *[Value]: The year/month in which the feature was adopted. The hyperlink under each value opens a compiler support page with entry for given feature.
  *[Std]: Standard in which the feature is introduced; DR means defect report against that revision
