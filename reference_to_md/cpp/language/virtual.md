[C++](../../cpp.html "cpp")

[Compiler support](../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../freestanding.html "cpp/freestanding")  
[Language](../language.html "cpp/language")  
[Standard library](../standard_library.html "cpp/standard library")  
[Standard library headers](../headers.html "cpp/header")  
[Named requirements](../iterator/concepts.html "cpp/named req")  
[Feature test macros](../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../utility.html#Language_support "cpp/utility")  
[Concepts library](../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../error.html "cpp/error")  
[Memory management library](../memory.html "cpp/memory")  
[Metaprogramming library](../meta.html "cpp/meta") (C++11)  
[General utilities library](../utility.html "cpp/utility")  
[Containers library](../container.html "cpp/container")  
[Iterators library](../iterator.html "cpp/iterator")  
[Ranges library](../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../algorithm.html "cpp/algorithm")  
[Strings library](../string.html "cpp/string")  
[Text processing library](../text.html "cpp/text")  
[Numerics library](../numeric.html "cpp/numeric")  
[Date and time library](../chrono.html "cpp/chrono")  
[Input/output library](../io.html "cpp/io")  
[Filesystem library](../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../atomic.html "cpp/thread") (C++11)  
[Execution control library](../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../experimental.html "cpp/experimental")  
[Symbols index](../symbol_index.html "cpp/symbol index")  
[External libraries](../links/libs.html "cpp/links/libs")  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/navbar_content&action=edit)

[C++ language](../language.html "cpp/language")

General topics  
---  
| [Preprocessor](../preprocessor.html "cpp/preprocessor")  
---  
[Comments](../comments.html "cpp/comment")  
  
| [Keywords](../keywords.html "cpp/keyword")  
---  
[Escape sequences](escape.html "cpp/language/escape")  
  
[Flow control](statements.html "cpp/language/statements")  
Conditional execution statements  
| [`if`](if.html "cpp/language/if")  
---  
  
| [`switch`](switch.html "cpp/language/switch")  
---  
  
Iteration statements (loops)  
| [`for`](for.html "cpp/language/for")  
---  
[range-`for`](range-for.html "cpp/language/range-for") (C++11)  
  
| [`while`](while.html "cpp/language/while")  
---  
[`do-while`](do.html "cpp/language/do")  
  
Jump statements  
| [`continue`](continue.html "cpp/language/continue") \- [`break`](break.html "cpp/language/break")  
---  
  
| [`goto`](goto.html "cpp/language/goto") \- [`return`](return.html "cpp/language/return")  
---  
  
[Functions](functions.html "cpp/language/functions")  
[Function declaration](function.html "cpp/language/function")  
[Lambda function expression](lambda.html "cpp/language/lambda")  
[`inline` specifier](inline.html "cpp/language/inline")  
[Dynamic exception specifications](except_spec.html "cpp/language/except spec") (until C++17*)  
[`noexcept` specifier](noexcept_spec.html "cpp/language/noexcept spec") (C++11)  
Exceptions  
| [`throw`-expression](throw.html "cpp/language/throw")  
---  
[`try` block](try.html "cpp/language/try")  
  
|   
  
---  
[`catch` handler](catch.html "cpp/language/catch")  
  
Namespaces  
| [Namespace declaration](namespace.html "cpp/language/namespace")` `  
---  
  
| [Namespace aliases](namespace_alias.html "cpp/language/namespace alias")  
---  
  
Types  
| [Fundamental types](types.html "cpp/language/types")  
---  
[Enumeration types](enum.html "cpp/language/enum")  
[Function types](function.html "cpp/language/function")  
  
| [Class/struct types](class.html "cpp/language/class")  
---  
[Union types](union.html "cpp/language/union")  
  
  
  
Specifiers  
| [`const`/`volatile`](cv.html "cpp/language/cv")  
---  
[`decltype`](decltype.html "cpp/language/decltype") (C++11)  
[`auto`](auto.html "cpp/language/auto") (C++11)  
  
| [`constexpr`](constexpr.html "cpp/language/constexpr") (C++11)  
---  
[`consteval`](consteval.html "cpp/language/consteval") (C++20)  
[`constinit`](constinit.html "cpp/language/constinit") (C++20)  
  
[Storage duration specifiers](storage_duration.html "cpp/language/storage duration")  
[Initialization](initialization.html "cpp/language/initialization")  
| [Default-initialization](default_initialization.html "cpp/language/default initialization")  
---  
[Value-initialization](value_initialization.html "cpp/language/value initialization")  
[Zero-initialization](zero_initialization.html "cpp/language/zero initialization")  
[Copy-initialization](copy_initialization.html "cpp/language/copy initialization")  
[Direct-initialization](direct_initialization.html "cpp/language/direct initialization")  
  
| [Aggregate initialization](aggregate_initialization.html "cpp/language/aggregate initialization")  
---  
[List-initialization](list_initialization.html "cpp/language/list initialization") (C++11)` `  
[Constant initialization](constant_initialization.html "cpp/language/constant initialization")  
[Reference initialization](reference_initialization.html "cpp/language/reference initialization")  
  
  
  
[Expressions](expressions.html "cpp/language/expressions")  
---  
| [Value categories](value_category.html "cpp/language/value category")  
---  
[Order of evaluation](eval_order.html "cpp/language/eval order")  
  
| [Operators](operators.html "cpp/language/operators")  
---  
[Operator precedence](operator_precedence.html "cpp/language/operator precedence")  
  
[Alternative representations](operator_alternative.html "cpp/language/operator alternative")  
[Literals](expressions.html#Literals "cpp/language/expressions")  
[Boolean](bool_literal.html "cpp/language/bool literal") \- [Integer](integer_literal.html "cpp/language/integer literal") \- [Floating-point](floating_literal.html "cpp/language/floating literal")  
[Character](character_literal.html "cpp/language/character literal") \- [String](string_literal.html "cpp/language/string literal") \- [`nullptr`](nullptr.html "cpp/language/nullptr") (C++11)  
[User-defined](user_literal.html "cpp/language/user literal") (C++11)  
Utilities  
[Attributes](attributes.html "cpp/language/attributes") (C++11)  
Types  
[`typedef` declaration](typedef.html "cpp/language/typedef")  
[Type alias declaration](type_alias.html "cpp/language/type alias") (C++11)  
Casts  
| [Implicit conversions](implicit_cast.html "cpp/language/implicit conversion")  
---  
[`static_cast`](static_cast.html "cpp/language/static cast")  
[`const_cast`](const_cast.html "cpp/language/const cast")  
  
| [Explicit conversions](explicit_cast.html "cpp/language/explicit cast")  
---  
[`dynamic_cast`](dynamic_cast.html "cpp/language/dynamic cast")  
[`reinterpret_cast`](reinterpret_cast.html "cpp/language/reinterpret cast")  
  
Memory allocation  
| [`new` expression](new.html "cpp/language/new")  
---  
  
| [`delete` expression](delete.html "cpp/language/delete")  
---  
  
[Classes](classes.html "cpp/language/classes")  
| [Class declaration](class.html "cpp/language/class")  
---  
[Constructors](initializer_list.html "cpp/language/constructor")  
[`this` pointer](this.html "cpp/language/this")  
  
| [Access specifiers](access.html "cpp/language/access")  
---  
[`friend` specifier](friend.html "cpp/language/friend")  
  
  
  
Class-specific function properties  
| **Virtual function**  
---  
[`override` specifier](override.html "cpp/language/override") (C++11)` `  
[`final` specifier](final.html "cpp/language/final") (C++11)  
  
| [`explicit`](explicit.html "cpp/language/explicit") (C++11)  
---  
[`static`](static.html "cpp/language/static")  
  
  
  
Special member functions  
| [Default constructor](default_constructor.html "cpp/language/default constructor")  
---  
[Copy constructor](copy_constructor.html "cpp/language/copy constructor")  
[Move constructor](move_constructor.html "cpp/language/move constructor") (C++11)  
  
| [Copy assignment](as_operator.html "cpp/language/as operator")  
---  
[Move assignment](move_operator.html "cpp/language/move operator") (C++11)  
[Destructor](destructor.html "cpp/language/destructor")  
  
[Templates](templates.html "cpp/language/templates")  
| [Class template](class_template.html "cpp/language/class template")  
---  
[Function template](function_template.html "cpp/language/function template")  
  
| [Template specialization](template_specialization.html "cpp/language/template specialization")  
---  
[Parameter packs](parameter_pack.html "cpp/language/pack") (C++11)  
  
Miscellaneous  
| [Inline assembly](asm.html "cpp/language/asm")  
---  
  
| [History of C++](history.html "cpp/language/history")  
---  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/navbar_content&action=edit)

[ Classes](classes.html "cpp/language/classes")

General  
---  
[Overview](classes.html "cpp/language/classes")  
[`class`/`struct` types](class.html "cpp/language/class")  
[`union` types](union.html "cpp/language/union")  
[Injected-class-name](injected-class-name.html "cpp/language/injected-class-name")  
[Class property specifiers](class_property_specifiers.html "cpp/language/class property specifiers") (C++26)  
Members  
[Data members](data_members.html "cpp/language/data members")  
[Static members](static.html "cpp/language/static")  
[The `this` pointer](this.html "cpp/language/this")  
[Nested classes](nested_classes.html "cpp/language/nested types")  
[Member templates](member_template.html "cpp/language/member template")  
[Bit-fields](bit_field.html "cpp/language/bit field")  
[`using`-declarations](using_declaration.html "cpp/language/using declaration")  
[Member functions](member_functions.html "cpp/language/member functions")  
[Member access specifiers](access.html "cpp/language/access")  
[Constructors and member initializer lists](initializer_list.html "cpp/language/constructor")  
[Default member initializer](data_members.html#Member_initialization "cpp/language/data members") (C++11)  
[`friend` specifier](friend.html "cpp/language/friend")  
[`explicit` specifier](explicit.html "cpp/language/explicit")  
[Converting constructor](converting_constructor.html "cpp/language/converting constructor")  
Special member functions  
[Default constructor](default_constructor.html "cpp/language/default constructor")  
[Copy constructor](copy_constructor.html "cpp/language/copy constructor")  
[Move constructor](move_constructor.html "cpp/language/move constructor") (C++11)  
[Copy assignment operator](as_operator.html "cpp/language/copy assignment")  
[Move assignment operator](move_operator.html "cpp/language/move assignment") (C++11)  
[Destructor](destructor.html "cpp/language/destructor")  
Inheritance  
[Base and derived classes](derived_class.html "cpp/language/derived class")  
[Empty base optimization (EBO)](ebo.html "cpp/language/ebo")  
**Virtual member functions**  
[Pure virtual functions and abstract classes](abstract_class.html "cpp/language/abstract class")  
[`override` specifier](override.html "cpp/language/override") (C++11)  
[`final` specifier](final.html "cpp/language/final") (C++11)  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/classes/navbar_content&action=edit)

Specifies that a non-static [member function](member_functions.html "cpp/language/member functions") is _virtual_ and supports dynamic dispatch. It may only appear in the decl-specifier-seq of the initial declaration of a non-static member function (i.e., when it is declared in the class definition). 

## Contents

  * [1 Explanation](virtual.html#Explanation)
  * [2 In detail](virtual.html#In_detail)
    * [2.1 Covariant return types](virtual.html#Covariant_return_types)
    * [2.2 Virtual destructor](virtual.html#Virtual_destructor)
  * [3 During construction and destruction](virtual.html#During_construction_and_destruction)
  * [4 Keywords](virtual.html#Keywords)
  * [5 Defect reports](virtual.html#Defect_reports)
  * [6 See also](virtual.html#See_also)

  
---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/virtual&action=edit&section=1 "Edit section: Explanation")] Explanation

Virtual functions are member functions whose behavior can be overridden in derived classes. As opposed to non-virtual functions, the overriding behavior is preserved even if there is no compile-time information about the actual type of the class. That is to say, if a derived class is handled using pointer or reference to the base class, a call to an overridden virtual function would invoke the behavior defined in the derived class. Such a function call is known as _virtual function call_ or _virtual call_. Virtual function call is suppressed if the function is selected using [qualified name lookup](lookup.html "cpp/language/lookup") (that is, if the function's name appears to the right of the scope resolution operator `::`). 

Run this code
    
    
    #include <iostream>
     
    struct Base
    {
        virtual void f()
        {
            [std::cout](../io/cout.html) << "base\n";
        }
    };
     
    struct Derived : Base
    {
        void f() override // 'override' is optional
        {
            [std::cout](../io/cout.html) << "derived\n";
        }
    };
     
    int main()
    {
        Base b;
        Derived d;
     
        // virtual function call through reference
        Base& br = b; // the type of br is Base&
        Base& dr = d; // the type of dr is Base& as well
        br.f(); // prints "base"
        dr.f(); // prints "derived"
     
        // virtual function call through pointer
        Base* bp = &b; // the type of bp is Base*
        Base* dp = &d; // the type of dp is Base* as well
        bp->f(); // prints "base"
        dp->f(); // prints "derived"
     
        // non-virtual function call
        br.Base::f(); // prints "base"
        dr.Base::f(); // prints "base"
    }

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/virtual&action=edit&section=2 "Edit section: In detail")] In detail

If some member function `vf` is declared as `virtual` in a class `Base`, and some class `Derived`, which is derived, directly or indirectly, from `Base`, has a declaration for member function with the same 

  * name 
  * parameter type list (but not the return type) 
  * cv-qualifiers 
  * ref-qualifiers 



Then this function in the class `Derived` is also _virtual_ (whether or not the keyword `virtual` is used in its declaration) and _overrides_ Base::vf (whether or not the specifier [`override`](override.html "cpp/language/override") is used in its declaration). 

`Base::vf` does not need to be accessible or visible to be overridden. (`Base::vf` can be declared private, or `Base` can be inherited using private inheritance. Any members with the same name in a base class of `Derived` which inherits `Base` do not matter for override determination, even if they would hide `Base::vf` during name lookup.) 
    
    
    class B
    {
        virtual void do_f(); // private member
    public:
        void f() { do_f(); } // public interface
    };
     
    struct D : public B
    {
        void do_f() override; // overrides B::do_f
    };
     
    int main()
    {
        D d;
        B* bp = &d;
        bp->f(); // internally calls D::do_f();
    }

For every virtual function, there is the _final overrider_ , which is executed when a virtual function call is made. A virtual member function `vf` of a base class `Base` is the final overrider unless the derived class declares or inherits (through multiple inheritance) another function that overrides `vf`. 
    
    
    struct A { virtual void f(); };     // A::f is virtual
    struct B : A { void f(); };         // B::f overrides A::f in B
    struct C : virtual B { void f(); }; // C::f overrides A::f in C
     
    struct D : virtual B {}; // D does not introduce an overrider, B::f is final in D
     
    struct E : C, D          // E does not introduce an overrider, C::f is final in E
    {
        using A::f; // not a function declaration, just makes A::f visible to lookup
    };
     
    int main()
    {
        E e;
        e.f();    // virtual call calls C::f, the final overrider in e
        e.E::f(); // non-virtual call calls A::f, which is visible in E
    }

If a function has more than one final overrider, the program is ill-formed: 
    
    
    struct A
    {
        virtual void f();
    };
     
    struct VB1 : virtual A
    {
        void f(); // overrides A::f
    };
     
    struct VB2 : virtual A
    {
        void f(); // overrides A::f
    };
     
    // struct Error : VB1, VB2
    // {
    //     // Error: A::f has two final overriders in Error
    // };
     
    struct Okay : VB1, VB2
    {
        void f(); // OK: this is the final overrider for A::f
    };
     
    struct VB1a : virtual A {}; // does not declare an overrider
     
    struct Da : VB1a, VB2
    {
        // in Da, the final overrider of A::f is VB2::f
    };

A function with the same name but different parameter list does not override the base function of the same name, but _hides_ it: when [unqualified name lookup](lookup.html "cpp/language/lookup") examines the scope of the derived class, the lookup finds the declaration and does not examine the base class. 
    
    
    struct B
    {
        virtual void f();
    };
     
    struct D : B
    {
        void f(int); // D::f hides B::f (wrong parameter list)
    };
     
    struct D2 : D
    {
        void f(); // D2::f overrides B::f (doesn't matter that it's not visible)
    };
     
    int main()
    {
        B b;
        B& b_as_b = b;
     
        D d;
        B& d_as_b = d;
        D& d_as_d = d;
     
        D2 d2;
        B& d2_as_b = d2;
        D& d2_as_d = d2;
     
        b_as_b.f();  // calls B::f()
        d_as_b.f();  // calls B::f()
        d2_as_b.f(); // calls D2::f()
     
        d_as_d.f();  // Error: lookup in D finds only f(int)
        d2_as_d.f(); // Error: lookup in D finds only f(int)
    }

If a function is declared with the specifier `override`, but does not override a virtual function, the program is ill-formed: 
    
    
    struct B
    {
        virtual void f(int);
    };
     
    struct D : B
    {
        virtual void f(int) override;  // OK, D::f(int) overrides B::f(int)
        virtual void f(long) override; // Error: f(long) does not override B::f(int)
    };

If a function is declared with the specifier `final`, and another function attempts to override it, the program is ill-formed: 
    
    
    struct B
    {
        virtual void f() const final;
    };
     
    struct D : B
    {
        void f() const; // Error: D::f attempts to override final B::f
    };

| (since C++11)  
---|---  
  
Non-member functions and static member functions cannot be virtual. 

Function templates cannot be declared `virtual`. This applies only to functions that are themselves templates - a regular member function of a class template can be declared virtual. 

Virtual functions (whether declared virtual or overriding one) cannot have any associated constraints. 
    
    
    struct A
    {
        virtual void f() requires true; // Error: constrained virtual function
    };

A [`consteval`](consteval.html "cpp/language/consteval") virtual function must not override or be overidden by a non-`consteval` virtual function.  | (since C++20)  
---|---  
  
[Default arguments](default_arguments.html "cpp/language/default arguments") for virtual functions are substituted at the compile time. 

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/virtual&action=edit&section=3 "Edit section: Covariant return types")] Covariant return types

If the function `Derived::f` overrides a function `Base::f`, their return types must either be the same or be _covariant_. Two types are covariant if they satisfy all of the following requirements: 

  * both types are pointers or references (lvalue or rvalue) to classes. Multi-level pointers or references are not allowed. 
  * the referenced/pointed-to class in the return type of `Base::f()` must be an unambiguous and accessible direct or indirect base class of the referenced/pointed-to class of the return type of `Derived::f()`. 
  * the return type of `Derived::f()` must be equally or less [ cv-qualified](cv.html "cpp/language/cv") than the return type of `Base::f()`. 



The class in the return type of `Derived::f` must be either `Derived` itself, or must be a [complete type](incomplete_type.html "cpp/language/incomplete type") at the point of declaration of `Derived::f`. 

When a virtual function call is made, the type returned by the final overrider is [implicitly converted](implicit_cast.html "cpp/language/implicit cast") to the return type of the overridden function that was called: 
    
    
    class B {};
     
    struct Base
    {
        virtual void vf1();
        virtual void vf2();
        virtual void vf3();
        virtual B* vf4();
        virtual B* vf5();
    };
     
    class D : private B
    {
        friend struct Derived; // in Derived, B is an accessible base of D
    };
     
    class A; // forward-declared class is an incomplete type
     
    struct Derived : public Base
    {
        void vf1();    // virtual, overrides Base::vf1()
        void vf2(int); // non-virtual, hides Base::vf2()
    //  char vf3();    // Error: overrides Base::vf3, but has different
                       // and non-covariant return type
        D* vf4();      // overrides Base::vf4() and has covariant return type
    //  A* vf5();      // Error: A is incomplete type
    };
     
    int main()
    {
        Derived d;
        Base& br = d;
        Derived& dr = d;
     
        br.vf1(); // calls Derived::vf1()
        br.vf2(); // calls Base::vf2()
    //  dr.vf2(); // Error: vf2(int) hides vf2()
     
        B* p = br.vf4(); // calls Derived::vf4() and converts the result to B*
        D* q = dr.vf4(); // calls Derived::vf4() and does not convert the result to B*
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/virtual&action=edit&section=4 "Edit section: Virtual destructor")] Virtual destructor

Even though destructors are not inherited, if a base class declares its destructor `virtual`, the derived destructor always overrides it. This makes it possible to delete dynamically allocated objects of polymorphic type through pointers to base. 
    
    
    class Base
    {
    public:
        virtual ~Base() { /* releases Base's resources */ }
    };
     
    class Derived : public Base
    {
        ~Derived() { /* releases Derived's resources */ }
    };
     
    int main()
    {
        Base* b = new Derived;
        delete b; // Makes a virtual function call to Base::~Base()
                  // since it is virtual, it calls Derived::~Derived() which can
                  // release resources of the derived class, and then calls
                  // Base::~Base() following the usual order of destruction
    }

Moreover, if the destructor of the base class is not virtual, deleting a derived class object through a pointer to the base class is _undefined behavior_ regardless of whether there are resources that would be leaked if the derived destructor is not invoked, unless the selected deallocation function is a destroying [operator delete](../memory/new/operator_delete.html "cpp/memory/new/operator delete")(since C++20). 

A useful guideline is that the destructor of any base class must be [public and virtual or protected and non-virtual](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rc-dtor-virtual), whenever delete expressions are involved, e.g. when implicitly used in [std::unique_ptr](../memory/unique_ptr.html "cpp/memory/unique ptr")(since C++11). 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/virtual&action=edit&section=5 "Edit section: During construction and destruction")] During construction and destruction

When a virtual function is called directly or indirectly from a constructor or from a destructor (including during the construction or destruction of the class’s non-static data members, e.g. in a member [initializer list](initializer_list.html "cpp/language/initializer list")), and the object to which the call applies is the object under construction or destruction, the function called is the final overrider in the constructor’s or destructor’s class and not one overriding it in a more-derived class. In other words, during construction or destruction, the more-derived classes do not exist. 

When constructing a complex class with multiple branches, within a constructor that belongs to one branch, polymorphism is restricted to that class and its bases: if it obtains a pointer or reference to a base subobject outside this subhierarchy, and attempts to invoke a virtual function call (e.g. using explicit member access), the behavior is undefined: 
    
    
    struct V
    {
        virtual void f();
        virtual void g();
    };
     
    struct A : virtual V
    {
        virtual void f(); // A::f is the final overrider of V::f in A
    };
     
    struct B : virtual V
    {
        virtual void g(); // B::g is the final overrider of V::g in B
        B(V*, A*);
    };
     
    struct D : A, B
    {
        virtual void f(); // D::f is the final overrider of V::f in D
        virtual void g(); // D::g is the final overrider of V::g in D
     
        // note: A is initialized before B
        D() : B((A*) this, this) {}
    };
     
    // the constructor of B, called from the constructor of D 
    B::B(V* v, A* a)
    {
        f(); // virtual call to V::f (although D has the final overrider, D doesn't exist)
        g(); // virtual call to B::g, which is the final overrider in B 
     
        v->g(); // v's type V is base of B, virtual call calls B::g as before
     
        a->f(); // a’s type A is not a base of B. it belongs to a different branch of the
                // hierarchy. Attempting a virtual call through that branch causes
                // undefined behavior even though A was already fully constructed in this
                // case (it was constructed before B since it appears before B in the list
                // of the bases of D). In practice, the virtual call to A::f will be
                // attempted using B's virtual member function table, since that's what
                // is active during B's construction)
    }

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/virtual&action=edit&section=6 "Edit section: Keywords")] Keywords

[`virtual`](../keyword/virtual.html "cpp/keyword/virtual")

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/virtual&action=edit&section=7 "Edit section: Defect reports")] Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[CWG 258](https://cplusplus.github.io/CWG/issues/258.html) | C++98  | a non-const member function of a derived class might become  
virtual because of a const virtual member function of its base  | virtuality also require cv-  
qualifications to be the same   
[CWG 477](https://cplusplus.github.io/CWG/issues/477.html) | C++98  | a friend declaration could contain the virtual specifier  | not allowed   
[CWG 1516](https://cplusplus.github.io/CWG/issues/1516.html) | C++98  | the definition of the terms "virtual function call"  
and "virtual call" were not provided  | provided   
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/virtual&action=edit&section=8 "Edit section: See also")] See also

[derived classes and modes of inheritance](derived_class.html "cpp/language/derived class")  
---  
[`override` specifier](override.html "cpp/language/override") (C++11) |  explicitly declares that a method overrides another method[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/dsc_override&action=edit)  
[`final` specifier](final.html "cpp/language/final") (C++11) |  declares that a method cannot be overridden or a class be derived from[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/dsc_final&action=edit)
