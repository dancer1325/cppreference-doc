[C++](../../cpp.html "cpp")

[Compiler support](../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../freestanding.html "cpp/freestanding")  
[Language](../language.html "cpp/language")  
[Standard library](../standard_library.html "cpp/standard library")  
[Standard library headers](../headers.html "cpp/header")  
[Named requirements](../iterator/concepts.html "cpp/named req")  
[Feature test macros](../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../utility.html#Language_support "cpp/utility")  
[Concepts library](../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../error.html "cpp/error")  
[Memory management library](../memory.html "cpp/memory")  
[Metaprogramming library](../meta.html "cpp/meta") (C++11)  
[General utilities library](../utility.html "cpp/utility")  
[Containers library](../container.html "cpp/container")  
[Iterators library](../iterator.html "cpp/iterator")  
[Ranges library](../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../algorithm.html "cpp/algorithm")  
[Strings library](../string.html "cpp/string")  
[Text processing library](../text.html "cpp/text")  
[Numerics library](../numeric.html "cpp/numeric")  
[Date and time library](../chrono.html "cpp/chrono")  
[Input/output library](../io.html "cpp/io")  
[Filesystem library](../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../atomic.html "cpp/thread") (C++11)  
[Execution control library](../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../experimental.html "cpp/experimental")  
[Symbols index](../symbol_index.html "cpp/symbol index")  
[External libraries](../links/libs.html "cpp/links/libs")  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/navbar_content&action=edit)

[C++ language](../language.html "cpp/language")

General topics  
---  
| [Preprocessor](../preprocessor.html "cpp/preprocessor")  
---  
[Comments](../comments.html "cpp/comment")  
  
| [Keywords](../keywords.html "cpp/keyword")  
---  
[Escape sequences](escape.html "cpp/language/escape")  
  
[Flow control](statements.html "cpp/language/statements")  
Conditional execution statements  
| [`if`](if.html "cpp/language/if")  
---  
  
| [`switch`](switch.html "cpp/language/switch")  
---  
  
Iteration statements (loops)  
| [`for`](for.html "cpp/language/for")  
---  
[range-`for`](range-for.html "cpp/language/range-for") (C++11)  
  
| [`while`](while.html "cpp/language/while")  
---  
[`do-while`](do.html "cpp/language/do")  
  
Jump statements  
| [`continue`](continue.html "cpp/language/continue") \- [`break`](break.html "cpp/language/break")  
---  
  
| [`goto`](goto.html "cpp/language/goto") \- [`return`](return.html "cpp/language/return")  
---  
  
[Functions](functions.html "cpp/language/functions")  
[Function declaration](function.html "cpp/language/function")  
[Lambda function expression](lambda.html "cpp/language/lambda")  
[`inline` specifier](inline.html "cpp/language/inline")  
[Dynamic exception specifications](except_spec.html "cpp/language/except spec") (until C++17*)  
[`noexcept` specifier](noexcept_spec.html "cpp/language/noexcept spec") (C++11)  
Exceptions  
| [`throw`-expression](throw.html "cpp/language/throw")  
---  
[`try` block](try.html "cpp/language/try")  
  
|   
  
---  
[`catch` handler](catch.html "cpp/language/catch")  
  
Namespaces  
| [Namespace declaration](namespace.html "cpp/language/namespace")` `  
---  
  
| [Namespace aliases](namespace_alias.html "cpp/language/namespace alias")  
---  
  
Types  
| [Fundamental types](types.html "cpp/language/types")  
---  
[Enumeration types](enum.html "cpp/language/enum")  
[Function types](function.html "cpp/language/function")  
  
| [Class/struct types](class.html "cpp/language/class")  
---  
[Union types](union.html "cpp/language/union")  
  
  
  
Specifiers  
| [`const`/`volatile`](cv.html "cpp/language/cv")  
---  
[`decltype`](decltype.html "cpp/language/decltype") (C++11)  
[`auto`](auto.html "cpp/language/auto") (C++11)  
  
| [`constexpr`](constexpr.html "cpp/language/constexpr") (C++11)  
---  
[`consteval`](consteval.html "cpp/language/consteval") (C++20)  
[`constinit`](constinit.html "cpp/language/constinit") (C++20)  
  
[Storage duration specifiers](storage_duration.html "cpp/language/storage duration")  
[Initialization](initialization.html "cpp/language/initialization")  
| [Default-initialization](default_initialization.html "cpp/language/default initialization")  
---  
[Value-initialization](value_initialization.html "cpp/language/value initialization")  
[Zero-initialization](zero_initialization.html "cpp/language/zero initialization")  
[Copy-initialization](copy_initialization.html "cpp/language/copy initialization")  
[Direct-initialization](direct_initialization.html "cpp/language/direct initialization")  
  
| [Aggregate initialization](aggregate_initialization.html "cpp/language/aggregate initialization")  
---  
[List-initialization](list_initialization.html "cpp/language/list initialization") (C++11)` `  
[Constant initialization](constant_initialization.html "cpp/language/constant initialization")  
[Reference initialization](reference_initialization.html "cpp/language/reference initialization")  
  
  
  
[Expressions](expressions.html "cpp/language/expressions")  
---  
| [Value categories](value_category.html "cpp/language/value category")  
---  
[Order of evaluation](eval_order.html "cpp/language/eval order")  
  
| [Operators](operators.html "cpp/language/operators")  
---  
[Operator precedence](operator_precedence.html "cpp/language/operator precedence")  
  
[Alternative representations](operator_alternative.html "cpp/language/operator alternative")  
[Literals](expressions.html#Literals "cpp/language/expressions")  
[Boolean](bool_literal.html "cpp/language/bool literal") \- [Integer](integer_literal.html "cpp/language/integer literal") \- [Floating-point](floating_literal.html "cpp/language/floating literal")  
[Character](character_literal.html "cpp/language/character literal") \- [String](string_literal.html "cpp/language/string literal") \- [`nullptr`](nullptr.html "cpp/language/nullptr") (C++11)  
[User-defined](user_literal.html "cpp/language/user literal") (C++11)  
Utilities  
[Attributes](attributes.html "cpp/language/attributes") (C++11)  
Types  
[`typedef` declaration](typedef.html "cpp/language/typedef")  
[Type alias declaration](type_alias.html "cpp/language/type alias") (C++11)  
Casts  
| [Implicit conversions](implicit_cast.html "cpp/language/implicit conversion")  
---  
[`static_cast`](static_cast.html "cpp/language/static cast")  
[`const_cast`](const_cast.html "cpp/language/const cast")  
  
| [Explicit conversions](explicit_cast.html "cpp/language/explicit cast")  
---  
[`dynamic_cast`](dynamic_cast.html "cpp/language/dynamic cast")  
[`reinterpret_cast`](reinterpret_cast.html "cpp/language/reinterpret cast")  
  
Memory allocation  
| [`new` expression](new.html "cpp/language/new")  
---  
  
| [`delete` expression](delete.html "cpp/language/delete")  
---  
  
[Classes](classes.html "cpp/language/classes")  
| [Class declaration](class.html "cpp/language/class")  
---  
[Constructors](initializer_list.html "cpp/language/constructor")  
[`this` pointer](this.html "cpp/language/this")  
  
| [Access specifiers](access.html "cpp/language/access")  
---  
[`friend` specifier](friend.html "cpp/language/friend")  
  
  
  
Class-specific function properties  
| [Virtual function](virtual.html "cpp/language/virtual")  
---  
[`override` specifier](override.html "cpp/language/override") (C++11)` `  
[`final` specifier](final.html "cpp/language/final") (C++11)  
  
| [`explicit`](explicit.html "cpp/language/explicit") (C++11)  
---  
[`static`](static.html "cpp/language/static")  
  
  
  
Special member functions  
| [Default constructor](default_constructor.html "cpp/language/default constructor")  
---  
[Copy constructor](copy_constructor.html "cpp/language/copy constructor")  
[Move constructor](move_constructor.html "cpp/language/move constructor") (C++11)  
  
| [Copy assignment](as_operator.html "cpp/language/as operator")  
---  
[Move assignment](move_operator.html "cpp/language/move operator") (C++11)  
[Destructor](destructor.html "cpp/language/destructor")  
  
[Templates](templates.html "cpp/language/templates")  
| [Class template](class_template.html "cpp/language/class template")  
---  
[Function template](function_template.html "cpp/language/function template")  
  
| [Template specialization](template_specialization.html "cpp/language/template specialization")  
---  
[Parameter packs](parameter_pack.html "cpp/language/pack") (C++11)  
  
Miscellaneous  
| [Inline assembly](asm.html "cpp/language/asm")  
---  
  
| [History of C++](history.html "cpp/language/history")  
---  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/navbar_content&action=edit)

[ Functions](functions.html "cpp/language/functions")

Declarations  
---  
[Function declaration](function.html "cpp/language/function")  
[Function parameter list](function.html#Parameter_list "cpp/language/function")  
[Function definition](function.html#Function_definition "cpp/language/function")  
[Function contract specifiers](function.html#Function_contract_specifiers "cpp/language/function") (C++26)  
[Default arguments](default_arguments.html "cpp/language/default arguments")  
[Variadic arguments](variadic_arguments.html "cpp/language/variadic arguments")  
[`inline` specifier](inline.html "cpp/language/inline")  
[Lambda expressions](lambda.html "cpp/language/lambda") (C++11)  
**Coroutines** (C++20)  
[Replacement functions](replacement_function.html "cpp/language/replacement function")  
Function calls  
[Argument-Dependent Lookup (ADL)](adl.html "cpp/language/adl")  
[Function-call operator](operator_other.html#Built-in_function_call_operator "cpp/language/operator other")  
[Function objects](../named_req/FunctionObject.html "cpp/named req/FunctionObject")  
Overloading  
[Overload resolution](overload_resolution.html "cpp/language/overload resolution")  
[Operator overloading](operators.html "cpp/language/operators")  
[Address of an overload set](overloaded_address.html "cpp/language/overloaded address")  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/functions/navbar_content&action=edit)

A coroutine is a function that can suspend execution to be resumed later. Coroutines are stackless: they suspend execution by returning to the caller, and the data that is required to resume execution is stored separately from the stack. This allows for sequential code that executes asynchronously (e.g. to handle non-blocking I/O without explicit callbacks), and also supports algorithms on lazy-computed infinite sequences and other uses. 

A function is a coroutine if its definition contains any of the following: 

  * the co_await expression — to suspend execution until resumed 


    
    
    task<> tcp_echo_server()
    {
        char data[1024];
        while (true)
        {
            [std::size_t](../types/size_t.html) n = co_await socket.async_read_some(buffer(data));
            co_await async_write(socket, buffer(data, n));
        }
    }

  * the co_yield expression — to suspend execution returning a value 


    
    
    generator<unsigned int> iota(unsigned int n = 0)
    {
        while (true)
            co_yield n++;
    }

  * the co_return statement — to complete execution returning a value 


    
    
    lazy<int> f()
    {
        co_return 7;
    }

Every coroutine must have a return type that satisfies a number of requirements, noted below. 

## Contents

  * [1 Restrictions](coroutines.html#Restrictions)
  * [2 Execution](coroutines.html#Execution)
  * [3 Dynamic allocation](coroutines.html#Dynamic_allocation)
  * [4 Promise](coroutines.html#Promise)
  * [5 co_await](coroutines.html#co_await)
  * [6 Example](coroutines.html#Example)
  * [7 Example](coroutines.html#Example_2)
  * [8 co_yield](coroutines.html#co_yield)
  * [9 Notes](coroutines.html#Notes)
  * [10 Keywords](coroutines.html#Keywords)
  * [11 Library support](coroutines.html#Library_support)
  * [12 Defect reports](coroutines.html#Defect_reports)
  * [13 See also](coroutines.html#See_also)
  * [14 External links](coroutines.html#External_links)

  
---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/coroutines&action=edit&section=1 "Edit section: Restrictions")] Restrictions

Coroutines cannot use [variadic arguments](variadic_arguments.html "cpp/language/variadic arguments"), plain [return](return.html "cpp/language/return") statements, or [placeholder return types](function.html "cpp/language/function") ([`auto`](auto.html "cpp/language/auto") or [Concept](constraints.html#Concepts "cpp/language/constraints")). 

[Consteval functions](consteval.html "cpp/language/consteval"), [constexpr functions](constexpr.html "cpp/language/constexpr"), [constructors](initializer_list.html "cpp/language/constructor"), [destructors](destructor.html "cpp/language/destructor"), and the [main function](main_function.html "cpp/language/main function") cannot be coroutines. 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/coroutines&action=edit&section=2 "Edit section: Execution")] Execution

Each coroutine is associated with 

  * the _promise object_ , manipulated from inside the coroutine. The coroutine submits its result or exception through this object. Promise objects are in no way related to [std::promise](../thread/promise.html "cpp/thread/promise"). 
  * the _coroutine handle_ , manipulated from outside the coroutine. This is a non-owning handle used to resume execution of the coroutine or to destroy the coroutine frame. 
  * the _coroutine state_ , which is internal, dynamically-allocated storage (unless the allocation is optimized out), object that contains 



    

  * the promise object 
  * the parameters (all copied by value) 
  * some representation of the current suspension point, so that a resume knows where to continue, and a destroy knows what local variables were in scope 
  * local variables and temporaries whose lifetime spans the current suspension point. 



When a coroutine begins execution, it performs the following: 

  * [allocates](coroutines.html#Dynamic_allocation) the coroutine state object using [operator new](../memory/new/operator_new.html "cpp/memory/new/operator new"). 
  * copies all function parameters to the coroutine state: by-value parameters are moved or copied, by-reference parameters remain references (thus, may become dangling, if the coroutine is resumed after the lifetime of referred object ends — see below for examples). 
  * calls the constructor for the promise object. If the promise type has a constructor that takes all coroutine parameters, that constructor is called, with post-copy coroutine arguments. Otherwise the default constructor is called. 
  * calls promise.get_return_object() and keeps the result in a local variable. The result of that call will be returned to the caller when the coroutine first suspends. Any exceptions thrown up to and including this step propagate back to the caller, not placed in the promise. 
  * calls promise.initial_suspend() and `co_await`s its result. Typical `Promise` types either return a [std::suspend_always](../coroutine/suspend_always.html "cpp/coroutine/suspend always"), for lazily-started coroutines, or [std::suspend_never](../coroutine/suspend_never.html "cpp/coroutine/suspend never"), for eagerly-started coroutines. 
  * when co_await promise.initial_suspend() resumes, starts executing the body of the coroutine. 



Some examples of a parameter becoming dangling: 
    
    
    #include <coroutine>
    #include <iostream>
     
    struct promise;
     
    struct coroutine : [std::coroutine_handle](../coroutine/coroutine_handle.html)<promise>
    {
        using promise_type = ::promise;
    };
     
    struct promise
    {
        coroutine get_return_object() { return {coroutine::from_promise(*this)}; }
        [std::suspend_always](../coroutine/suspend_always.html) initial_suspend() noexcept { return {}; }
        [std::suspend_always](../coroutine/suspend_always.html) final_suspend() noexcept { return {}; }
        void return_void() {}
        void unhandled_exception() {}
    };
     
    struct S
    {
        int i;
        coroutine f()
        {
            [std::cout](../io/cout.html) << i;
            co_return;
        }
    };
     
    void bad1()
    {
        coroutine h = S{0}.f();
        // S{0} destroyed
        h.resume(); // resumed coroutine executes std::cout << i, uses S::i after free
        h.destroy();
    }
     
    coroutine bad2()
    {
        S s{0};
        return s.f(); // returned coroutine can't be resumed without committing use after free
    }
     
    void bad3()
    {
        coroutine h = [i = 0]() -> coroutine // a lambda that's also a coroutine
        {
            [std::cout](../io/cout.html) << i;
            co_return;
        }(); // immediately invoked
        // lambda destroyed
        h.resume(); // uses (anonymous lambda type)::i after free
        h.destroy();
    }
     
    void good()
    {
        coroutine h = [](int i) -> coroutine // make i a coroutine parameter
        {
            [std::cout](../io/cout.html) << i;
            co_return;
        }(0);
        // lambda destroyed
        h.resume(); // no problem, i has been copied to the coroutine
                    // frame as a by-value parameter
        h.destroy();
    }

When a coroutine reaches a suspension point 

  * the return object obtained earlier is returned to the caller/resumer, after implicit conversion to the return type of the coroutine, if necessary. 



When a coroutine reaches the co_return statement, it performs the following: 

  * calls promise.return_void() for 



    

  * co_return;
  * co_return expr; where expr has type void



  * or calls promise.return_value(expr) for co_return expr; where expr has non-void type 
  * destroys all variables with automatic storage duration in reverse order they were created. 
  * calls promise.final_suspend() and co_awaits the result. 



Falling off the end of the coroutine is equivalent to co_return;, except that the behavior is undefined if no declarations of `return_void` can be found in the scope of `Promise`. A function with none of the defining keywords in its function body is not a coroutine, regardless of its return type, and falling off the end results in undefined behavior if the return type is not (possibly cv-qualified) void. 
    
    
    // assuming that task is some coroutine task type
    task<void> f()
    {
        // not a coroutine, undefined behavior
    }
     
    task<void> g()
    {
        co_return;  // OK
    }
     
    task<void> h()
    {
        co_await g();
        // OK, implicit co_return;
    }

If the coroutine ends with an uncaught exception, it performs the following: 

  * catches the exception and calls promise.unhandled_exception() from within the catch-block 
  * calls promise.final_suspend() and co_awaits the result (e.g. to resume a continuation or publish a result). It's undefined behavior to resume a coroutine from this point. 



When the coroutine state is destroyed either because it terminated via co_return or uncaught exception, or because it was destroyed via its handle, it does the following: 

  * calls the destructor of the promise object. 
  * calls the destructors of the function parameter copies. 
  * calls [operator delete](../memory/new/operator_delete.html "cpp/memory/new/operator delete") to free the memory used by the coroutine state. 
  * transfers execution back to the caller/resumer. 



### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/coroutines&action=edit&section=3 "Edit section: Dynamic allocation")] Dynamic allocation

Coroutine state is allocated dynamically via non-array [operator new](../memory/new/operator_new.html "cpp/memory/new/operator new"). 

If the `Promise` type defines a class-level replacement, it will be used, otherwise global [operator new](../memory/new/operator_new.html "cpp/memory/new/operator new") will be used. 

If the `Promise` type defines a placement form of [operator new](../memory/new/operator_new.html "cpp/memory/new/operator new") that takes additional parameters, and they match an argument list where the first argument is the size requested (of type [std::size_t](../types/size_t.html "cpp/types/size t")) and the rest are the coroutine function arguments, those arguments will be passed to [operator new](../memory/new/operator_new.html "cpp/memory/new/operator new") (this makes it possible to use [leading-allocator-convention](../memory/uses_allocator.html#Uses-allocator_construction "cpp/memory/uses allocator") for coroutines). 

The call to [operator new](../memory/new/operator_new.html "cpp/memory/new/operator new") can be optimized out (even if custom allocator is used) if 

  * The lifetime of the coroutine state is strictly nested within the lifetime of the caller, and 
  * the size of coroutine frame is known at the call site. 



In that case, coroutine state is embedded in the caller's stack frame (if the caller is an ordinary function) or coroutine state (if the caller is a coroutine). 

If allocation fails, the coroutine throws [std::bad_alloc](../memory/new/bad_alloc.html "cpp/memory/new/bad alloc"), unless the `Promise` type defines the member function Promise::get_return_object_on_allocation_failure(). If that member function is defined, allocation uses the nothrow form of [operator new](../memory/new/operator_new.html "cpp/memory/new/operator new") and on allocation failure, the coroutine immediately returns the object obtained from Promise::get_return_object_on_allocation_failure() to the caller, e.g.: 
    
    
    struct Coroutine::promise_type
    {
        /* ... */
     
        // ensure the use of non-throwing operator-new
        static Coroutine get_return_object_on_allocation_failure()
        {
            [std::cerr](../io/cerr.html) << __func__ << '\n';
            throw [std::bad_alloc](../memory/new/bad_alloc.html)(); // or, return Coroutine(nullptr);
        }
     
        // custom non-throwing overload of new
        void* [operator new](../memory/new/operator_new.html)([std::size_t](../types/size_t.html) n) noexcept
        {
            if (void* mem = [std::malloc](../memory/c/malloc.html)(n))
                return mem;
            return nullptr; // allocation failure
        }
    };

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/coroutines&action=edit&section=4 "Edit section: Promise")] Promise

The `Promise` type is determined by the compiler from the return type of the coroutine using [std::coroutine_traits](../coroutine/coroutine_traits.html "cpp/coroutine/coroutine traits"). 

Formally, let 

  * `R` and `Args...` denote the return type and parameter type list of a coroutine respectively, 
  * `ClassT` denote the class type to which the coroutine belongs if it is defined as a non-static member function, 
  * cv denote the cv-qualification declared in the [function declaration](function.html "cpp/language/function") if it is defined as a non-static member function, 



its `Promise` type is determined by: 

  * [std::coroutine_traits](../coroutine/coroutine_traits.html)<R, Args...>::promise_type, if the coroutine is not defined as an [implicit object member function](member_functions.html "cpp/language/member functions"), 
  * [std::coroutine_traits](../coroutine/coroutine_traits.html)<R,` `cv` `ClassT&, Args...>::promise_type, if the coroutine is defined as an implicit object member function that is not rvalue-reference-qualified, 
  * [std::coroutine_traits](../coroutine/coroutine_traits.html)<R,` `cv` `ClassT&&, Args...>::promise_type, if the coroutine is defined as an implicit object member function that is rvalue-reference-qualified. 



For example: 

If the coroutine is defined as ... | then its `Promise` type is ...   
---|---  
task<void> foo(int x); | [std::coroutine_traits](../coroutine/coroutine_traits.html)<task<void>, int>::promise_type  
task<void> Bar::foo(int x) const; | [std::coroutine_traits](../coroutine/coroutine_traits.html)<task<void>, const Bar&, int>::promise_type  
task<void> Bar::foo(int x) &&; | [std::coroutine_traits](../coroutine/coroutine_traits.html)<task<void>, Bar&&, int>::promise_type  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/coroutines&action=edit&section=5 "Edit section: co await")] co_await

The unary operator co_await suspends a coroutine and returns control to the caller.   
  
---  
`**co_await**` expr |  |   
  
A co_await expression can only appear in a [potentially-evaluated](expressions.html#Potentially-evaluated_expressions "cpp/language/expressions") expression within a regular [function body](function.html#Function_definition "cpp/language/function") (including the function body of a [lambda expression](lambda.html "cpp/language/lambda")), and cannot appear 

  * in a [handler](catch.html "cpp/language/catch"), 
  * in a [declaration](declarations.html "cpp/language/declarations") statement, unless it appears in an initializer of that declaration statement, 
  * in the [simple declaration](declarations.html#Simple_declaration "cpp/language/declarations") of an init-statement (see [`if`](if.html "cpp/language/if"), [`switch`](switch.html "cpp/language/switch"), [`for`](for.html "cpp/language/for") and [[../range-for|range-for]]), unless it appears in an initializer of that init-statement ﻿, 
  * in a [default argument](default_arguments.html "cpp/language/default arguments"), or 
  * in the initializer of a block-scope variable with static or thread [storage duration](storage_duration.html "cpp/language/storage duration"). 

A co_await expression cannot be a [potentially-evaluated](expressions.html#Potentially-evaluated_expressions "cpp/language/expressions") subexpression of the predicate of a [contract assertion](contracts.html "cpp/language/contracts").  | (since C++26)  
---|---  
  
First, expr is converted to an awaitable as follows: 

  * if expr is produced by an initial suspend point, a final suspend point, or a yield expression, the awaitable is expr, as-is. 
  * otherwise, if the current coroutine's `Promise` type has the member function `await_transform`, then the awaitable is promise.await_transform(expr). 
  * otherwise, the awaitable is expr, as-is. 



Then, the awaiter object is obtained, as follows: 

  * if overload resolution for operator co_await gives a single best overload, the awaiter is the result of that call: 



    

  * awaitable.operator co_await() for member overload, 
  * operator co_await(static_cast<Awaitable&&>(awaitable)) for the non-member overload. 



  * otherwise, if overload resolution finds no operator co_await, the awaiter is awaitable, as-is. 
  * otherwise, if overload resolution is ambiguous, the program is ill-formed. 



If the expression above is a [prvalue](value_category.html#prvalue "cpp/language/value category"), the awaiter object is a temporary [materialized](implicit_cast.html#Temporary_materialization "cpp/language/implicit conversion") from it. Otherwise, if the expression above is a [glvalue](value_category.html#glvalue "cpp/language/value category"), the awaiter object is the object to which it refers. 

Then, awaiter.await_ready() is called (this is a short-cut to avoid the cost of suspension if it's known that the result is ready or can be completed synchronously). If its result, contextually-converted to bool is false then 

     The coroutine is suspended (its coroutine state is populated with local variables and current suspension point). 
     awaiter.await_suspend(handle) is called, where handle is the coroutine handle representing the current coroutine. Inside that function, the suspended coroutine state is observable via that handle, and it's this function's responsibility to schedule it to resume on some executor, or to be destroyed (returning false counts as scheduling) 

  * if `await_suspend` returns void, control is immediately returned to the caller/resumer of the current coroutine (this coroutine remains suspended), otherwise 
  * if `await_suspend` returns bool, 



    

  * the value true returns control to the caller/resumer of the current coroutine 
  * the value false resumes the current coroutine. 



  * if `await_suspend` returns a coroutine handle for some other coroutine, that handle is resumed (by a call to handle.resume()) (note this may chain to eventually cause the current coroutine to resume). 
  * if `await_suspend` throws an exception, the exception is caught, the coroutine is resumed, and the exception is immediately re-thrown. 



Finally, awaiter.await_resume() is called (whether the coroutine was suspended or not), and its result is the result of the whole co_await expr expression. 

If the coroutine was suspended in the co_await expression, and is later resumed, the resume point is immediately before the call to awaiter.await_resume(). 

Note that the coroutine is fully suspended before entering awaiter.await_suspend(). Its handle can be shared with another thread and resumed before the await_suspend() function returns. (Note that the default memory safety rules still apply, so if a coroutine handle is shared across threads without a lock, the awaiter should use at least [release semantics](../atomic/memory_order.html#Release_operation "cpp/atomic/memory order") and the resumer should use at least [acquire semantics](../atomic/memory_order.html#Acquire_operation "cpp/atomic/memory order").) For example, the coroutine handle can be put inside a callback, scheduled to run on a threadpool when async I/O operation completes. In that case, since the current coroutine may have been resumed and thus executed the awaiter object's destructor, all concurrently as await_suspend() continues its execution on the current thread, await_suspend() should treat *this as destroyed and not access it after the handle was published to other threads. 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/coroutines&action=edit&section=6 "Edit section: Example")] Example

Run this code
    
    
    #include <coroutine>
    #include <iostream>
    #include <stdexcept>
    #include <thread>
     
    auto switch_to_new_thread([std::jthread](../thread/jthread.html)& out)
    {
        struct awaitable
        {
            [std::jthread](../thread/jthread.html)* p_out;
            bool await_ready() { return false; }
            void await_suspend([std::coroutine_handle](../coroutine/coroutine_handle.html)<> h)
            {
                [std::jthread](../thread/jthread.html)& out = *p_out;
                if (out.joinable())
                    throw [std::runtime_error](../error/runtime_error.html)("Output jthread parameter not empty");
                out = [std::jthread](../thread/jthread.html)([h] { h.resume(); });
                // Potential undefined behavior: accessing potentially destroyed *this
                // std::cout << "New thread ID: " << p_out->get_id() << '\n';
                [std::cout](../io/cout.html) << "New thread ID: " << out.get_id() << '\n'; // this is OK
            }
            void await_resume() {}
        };
        return awaitable{&out};
    }
     
    struct task
    {
        struct promise_type
        {
            task get_return_object() { return {}; }
            [std::suspend_never](../coroutine/suspend_never.html) initial_suspend() { return {}; }
            [std::suspend_never](../coroutine/suspend_never.html) final_suspend() noexcept { return {}; }
            void return_void() {}
            void unhandled_exception() {}
        };
    };
     
    task resuming_on_new_thread([std::jthread](../thread/jthread.html)& out)
    {
        [std::cout](../io/cout.html) << "Coroutine started on thread: " << [std::this_thread::get_id](../thread/get_id.html)() << '\n';
        co_await switch_to_new_thread(out);
        // awaiter destroyed here
        [std::cout](../io/cout.html) << "Coroutine resumed on thread: " << [std::this_thread::get_id](../thread/get_id.html)() << '\n';
    }
     
    int main()
    {
        [std::jthread](../thread/jthread.html) out;
        resuming_on_new_thread(out);
    }

Possible output: 
    
    
    Coroutine started on thread: 139972277602112
    New thread ID: 139972267284224
    Coroutine resumed on thread: 139972267284224

Note: the awaiter object is part of coroutine state (as a temporary whose lifetime crosses a suspension point) and is destroyed before the co_await expression finishes. It can be used to maintain per-operation state as required by some async I/O APIs without resorting to additional dynamic allocations. 

The standard library defines two trivial awaitables: [std::suspend_always](../coroutine/suspend_always.html "cpp/coroutine/suspend always") and [std::suspend_never](../coroutine/suspend_never.html "cpp/coroutine/suspend never"). 

| This section is incomplete  
Reason: examples   
---|---  
  
Demo of promise_type::await_transform and a program provided awaiter  
---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/coroutines&action=edit&section=7 "Edit section: Example")] Example

Run this code
    
    
    #include <cassert>
    #include <coroutine>
    #include <iostream>
     
    struct tunable_coro
    {
        // An awaiter whose "readiness" is determined via constructor's parameter.
        class tunable_awaiter
        {
            bool ready_;
        public:
            explicit(false) tunable_awaiter(bool ready) : ready_{ready} {}
            // Three standard awaiter interface functions:
            bool await_ready() const noexcept { return ready_; }
            static void await_suspend([std::coroutine_handle](../coroutine/coroutine_handle.html)<>) noexcept {}
            static void await_resume() noexcept {}
        };
     
        struct promise_type
        {
            using coro_handle = [std::coroutine_handle](../coroutine/coroutine_handle.html)<promise_type>;
            auto get_return_object() { return coro_handle::from_promise(*this); }
            static auto initial_suspend() { return [std::suspend_always](../coroutine/suspend_always.html)(); }
            static auto final_suspend() noexcept { return [std::suspend_always](../coroutine/suspend_always.html)(); }
            static void return_void() {}
            static void unhandled_exception() { [std::terminate](../error/terminate.html)(); }
            // A user provided transforming function which returns the custom awaiter:
            auto await_transform([std::suspend_always](../coroutine/suspend_always.html)) { return tunable_awaiter(!ready_); }
            void disable_suspension() { ready_ = false; }
        private:
            bool ready_{true};
        };
     
        tunable_coro(promise_type::coro_handle h) : handle_(h) { [assert](../error/assert.html)(h); }
     
        // For simplicity, declare these 4 special functions as deleted:
        tunable_coro(tunable_coro const&) = delete;
        tunable_coro(tunable_coro&&) = delete;
        tunable_coro& operator=(tunable_coro const&) = delete;
        tunable_coro& operator=(tunable_coro&&) = delete;
     
        ~tunable_coro()
        {
            if (handle_)
                handle_.destroy();
        }
     
        void disable_suspension() const
        {
            if (handle_.done())
                return;
            handle_.promise().disable_suspension();
            handle_();
        }
     
        bool operator()()
        {
            if (!handle_.done())
                handle_();
            return !handle_.done();
        }
    private:
        promise_type::coro_handle handle_;
    };
     
    tunable_coro generate(int n)
    {
        for (int i{}; i != n; ++i)
        {
            [std::cout](../io/cout.html) << i << ' ';
            // The awaiter passed to co_await goes to promise_type::await_transform which
            // issues tunable_awaiter that initially causes suspension (returning back to
            // main at each iteration), but after a call to disable_suspension no suspension
            // happens and the loop runs to its end without returning to main().
            co_await [std::suspend_always](../coroutine/suspend_always.html){};
        }
    }
     
    int main()
    {
        auto coro = generate(8);
        coro(); // emits only one first element == 0
        for (int k{}; k < 4; ++k)
        {
            coro(); // emits 1 2 3 4, one per each iteration
            [std::cout](../io/cout.html) << ": ";
        }
        coro.disable_suspension();
        coro(); // emits the tail numbers 5 6 7 all at ones
    }

Output: 
    
    
    0 1 : 2 : 3 : 4 : 5 6 7  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/coroutines&action=edit&section=8 "Edit section: co yield")] co_yield

`co_yield` expression returns a value to the caller and suspends the current coroutine: it is the common building block of resumable generator functions.   
  
---  
`**co_yield**` expr |  |   
`**co_yield**` braced-init-list |  |   
  
It is equivalent to 
    
    
    co_await promise.yield_value(expr)

A typical generator's `yield_value` would store (copy/move or just store the address of, since the argument's lifetime crosses the suspension point inside the `co_await`) its argument into the generator object and return [std::suspend_always](../coroutine/suspend_always.html "cpp/coroutine/suspend always"), transferring control to the caller/resumer. 

Run this code
    
    
    #include <coroutine>
    #include <cstdint>
    #include <exception>
    #include <iostream>
     
    template<typename T>
    struct Generator
    {
        // The class name 'Generator' is our choice and it is not required for coroutine
        // magic. Compiler recognizes coroutine by the presence of 'co_yield' keyword.
        // You can use name 'MyGenerator' (or any other name) instead as long as you include
        // nested struct promise_type with 'MyGenerator get_return_object()' method.
        // (Note: It is necessary to adjust the declarations of constructors and destructors
        //  when renaming.)
     
        struct promise_type;
        using handle_type = [std::coroutine_handle](../coroutine/coroutine_handle.html)<promise_type>;
     
        struct promise_type // required
        {
            T value_;
            [std::exception_ptr](../error/exception_ptr.html) exception_;
     
            Generator get_return_object()
            {
                return Generator(handle_type::from_promise(*this));
            }
            [std::suspend_always](../coroutine/suspend_always.html) initial_suspend() { return {}; }
            [std::suspend_always](../coroutine/suspend_always.html) final_suspend() noexcept { return {}; }
            void unhandled_exception() { exception_ = [std::current_exception](../error/current_exception.html)(); } // saving
                                                                                  // exception
     
            template<[std::convertible_to](../concepts/convertible_to.html)<T> From> // C++20 concept
            [std::suspend_always](../coroutine/suspend_always.html) yield_value(From&& from)
            {
                value_ = [std::forward](../utility/forward.html)<From>(from); // caching the result in promise
                return {};
            }
            void return_void() {}
        };
     
        handle_type h_;
     
        Generator(handle_type h) : h_(h) {}
        ~Generator() { h_.destroy(); }
        explicit operator bool()
        {
            fill(); // The only way to reliably find out whether or not we finished coroutine,
                    // whether or not there is going to be a next value generated (co_yield)
                    // in coroutine via C++ getter (operator () below) is to execute/resume
                    // coroutine until the next co_yield point (or let it fall off end).
                    // Then we store/cache result in promise to allow getter (operator() below
                    // to grab it without executing coroutine).
            return !h_.done();
        }
        T operator()()
        {
            fill();
            full_ = false; // we are going to move out previously cached
                           // result to make promise empty again
            return std::move(h_.promise().value_);
        }
     
    private:
        bool full_ = false;
     
        void fill()
        {
            if (!full_)
            {
                h_();
                if (h_.promise().exception_)
                    [std::rethrow_exception](../error/rethrow_exception.html)(h_.promise().exception_);
                // propagate coroutine exception in called context
     
                full_ = true;
            }
        }
    };
     
    Generator<[std::uint64_t](../types/integer.html)>
    fibonacci_sequence(unsigned n)
    {
        if (n == 0)
            co_return;
     
        if (n > 94)
            throw [std::runtime_error](../error/runtime_error.html)("Too big Fibonacci sequence. Elements would overflow.");
     
        co_yield 0;
     
        if (n == 1)
            co_return;
     
        co_yield 1;
     
        if (n == 2)
            co_return;
     
        [std::uint64_t](../types/integer.html) a = 0;
        [std::uint64_t](../types/integer.html) b = 1;
     
        for (unsigned i = 2; i < n; ++i)
        {
            [std::uint64_t](../types/integer.html) s = a + b;
            co_yield s;
            a = b;
            b = s;
        }
    }
     
    int main()
    {
        try
        {
            auto gen = fibonacci_sequence(10); // max 94 before uint64_t overflows
     
            for (int j = 0; gen; ++j)
                [std::cout](../io/cout.html) << "fib(" << j << ")=" << gen() << '\n';
        }
        catch (const [std::exception](../error/exception.html)& ex)
        {
            [std::cerr](../io/cerr.html) << "Exception: " << ex.what() << '\n';
        }
        catch (...)
        {
            [std::cerr](../io/cerr.html) << "Unknown exception.\n";
        }
    }

Output: 
    
    
    fib(0)=0
    fib(1)=1
    fib(2)=1
    fib(3)=2
    fib(4)=3
    fib(5)=5
    fib(6)=8
    fib(7)=13
    fib(8)=21
    fib(9)=34

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/coroutines&action=edit&section=9 "Edit section: Notes")] Notes

[Feature-test](../utility/feature_test.html "cpp/utility/feature test") macro  | Value | Std | Feature   
---|---|---|---  
[`__cpp_impl_coroutine`](../experimental/feature_test.html#cpp_impl_coroutine "cpp/feature test") | [`201902L`](../compiler_support/20.html#cpp_impl_coroutine_201902L "cpp/compiler support/20") | (C++20) | [Coroutines](coroutines.html#top) (compiler support)   
[`__cpp_lib_coroutine`](../experimental/feature_test.html#cpp_lib_coroutine "cpp/feature test") | [`201902L`](../compiler_support/20.html#cpp_lib_coroutine_201902L "cpp/compiler support/20") | (C++20) | [Coroutines](../coroutine.html "cpp/coroutine") (library support)   
[`__cpp_lib_generator`](../experimental/feature_test.html#cpp_lib_generator "cpp/feature test") | [`202207L`](../compiler_support/23.html#cpp_lib_generator_202207L "cpp/compiler support/23") | (C++23) | std::generator: synchronous coroutine generator for ranges   
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/coroutines&action=edit&section=10 "Edit section: Keywords")] Keywords

[`co_await`](../keyword/co_await.html "cpp/keyword/co await"), [`co_return`](../keyword/co_return.html "cpp/keyword/co return"), [`co_yield`](../keyword/co_yield.html "cpp/keyword/co yield")

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/coroutines&action=edit&section=11 "Edit section: Library support")] Library support

[Coroutine support library](../coroutine.html "cpp/coroutine") defines several types providing compile and run-time support for coroutines. 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/coroutines&action=edit&section=12 "Edit section: Defect reports")] Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[CWG 2556](https://cplusplus.github.io/CWG/issues/2556.html) | C++20  | invalid `return_void` made the behavior of  
falling off the end of the coroutine undefined  | the program is ill-  
formed in this case   
[CWG 2668](https://cplusplus.github.io/CWG/issues/2668.html) | C++20  | co_await could not appear in lambda expressions  | allowed   
[CWG 2754](https://cplusplus.github.io/CWG/issues/2754.html) | C++23  | *this was taken when constructing the promise  
object for explicit object member functions  | *this is not  
taken in this case   
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/coroutines&action=edit&section=13 "Edit section: See also")] See also

[ generator](../coroutine/generator.html "cpp/coroutine/generator")(C++23) |  A [`view`](../ranges/view.html "cpp/ranges/view") that represents synchronous **coroutine** generator   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/ranges/dsc_generator&action=edit)  
---|---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/coroutines&action=edit&section=14 "Edit section: External links")] External links

1\.  | Lewis Baker, 2017-2022 - [Asymmetric Transfer.](https://lewissbaker.github.io/)  
---|---  
2\.  | David Mazières, 2021 - [Tutorial on C++20 coroutines.](https://www.scs.stanford.edu/~dm/blog/c++-coroutines.html)  
3\.  | Chuanqi Xu & Yu Qi & Yao Han, 2021 - [C++20 Principles and Applications of Coroutine. (Chinese)](https://zhuanlan.zhihu.com/p/497224333)  
4\.  | Simon Tatham, 2023 - [Writing custom C++20 coroutine systems.](https://www.chiark.greenend.org.uk/~sgtatham/quasiblog/coroutines-c++20/)
  *[Value]: The year/month in which the feature was adopted. The hyperlink under each value opens a compiler support page with entry for given feature.
  *[Std]: Standard in which the feature is introduced; DR means defect report against that revision
