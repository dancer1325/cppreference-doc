[C++](../../cpp.html "cpp")

[Compiler support](../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../freestanding.html "cpp/freestanding")  
[Language](../language.html "cpp/language")  
[Standard library](../standard_library.html "cpp/standard library")  
[Standard library headers](../headers.html "cpp/header")  
[Named requirements](../iterator/concepts.html "cpp/named req")  
[Feature test macros](../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../utility.html#Language_support "cpp/utility")  
[Concepts library](../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../error.html "cpp/error")  
[Memory management library](../memory.html "cpp/memory")  
[Metaprogramming library](../meta.html "cpp/meta") (C++11)  
[General utilities library](../utility.html "cpp/utility")  
[Containers library](../container.html "cpp/container")  
[Iterators library](../iterator.html "cpp/iterator")  
[Ranges library](../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../algorithm.html "cpp/algorithm")  
[Strings library](../string.html "cpp/string")  
[Text processing library](../text.html "cpp/text")  
[Numerics library](../numeric.html "cpp/numeric")  
[Date and time library](../chrono.html "cpp/chrono")  
[Input/output library](../io.html "cpp/io")  
[Filesystem library](../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../atomic.html "cpp/thread") (C++11)  
[Execution control library](../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../experimental.html "cpp/experimental")  
[Symbols index](../symbol_index.html "cpp/symbol index")  
[External libraries](../links/libs.html "cpp/links/libs")  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/navbar_content&action=edit)

[C++ language](../language.html "cpp/language")

General topics  
---  
| [Preprocessor](../preprocessor.html "cpp/preprocessor")  
---  
[Comments](../comments.html "cpp/comment")  
  
| [Keywords](../keywords.html "cpp/keyword")  
---  
[Escape sequences](escape.html "cpp/language/escape")  
  
[Flow control](statements.html "cpp/language/statements")  
Conditional execution statements  
| [`if`](if.html "cpp/language/if")  
---  
  
| [`switch`](switch.html "cpp/language/switch")  
---  
  
Iteration statements (loops)  
| [`for`](for.html "cpp/language/for")  
---  
[range-`for`](range-for.html "cpp/language/range-for") (C++11)  
  
| [`while`](while.html "cpp/language/while")  
---  
[`do-while`](do.html "cpp/language/do")  
  
Jump statements  
| [`continue`](continue.html "cpp/language/continue") \- [`break`](break.html "cpp/language/break")  
---  
  
| [`goto`](goto.html "cpp/language/goto") \- [`return`](return.html "cpp/language/return")  
---  
  
[Functions](functions.html "cpp/language/functions")  
[Function declaration](function.html "cpp/language/function")  
[Lambda function expression](lambda.html "cpp/language/lambda")  
[`inline` specifier](inline.html "cpp/language/inline")  
[Dynamic exception specifications](except_spec.html "cpp/language/except spec") (until C++17*)  
[`noexcept` specifier](noexcept_spec.html "cpp/language/noexcept spec") (C++11)  
Exceptions  
| [`throw`-expression](throw.html "cpp/language/throw")  
---  
[`try` block](try.html "cpp/language/try")  
  
|   
  
---  
[`catch` handler](catch.html "cpp/language/catch")  
  
Namespaces  
| [Namespace declaration](namespace.html "cpp/language/namespace")` `  
---  
  
| [Namespace aliases](namespace_alias.html "cpp/language/namespace alias")  
---  
  
Types  
| [Fundamental types](types.html "cpp/language/types")  
---  
[Enumeration types](enum.html "cpp/language/enum")  
[Function types](function.html "cpp/language/function")  
  
| [Class/struct types](class.html "cpp/language/class")  
---  
[Union types](union.html "cpp/language/union")  
  
  
  
Specifiers  
| [`const`/`volatile`](cv.html "cpp/language/cv")  
---  
[`decltype`](decltype.html "cpp/language/decltype") (C++11)  
[`auto`](auto.html "cpp/language/auto") (C++11)  
  
| [`constexpr`](constexpr.html "cpp/language/constexpr") (C++11)  
---  
[`consteval`](consteval.html "cpp/language/consteval") (C++20)  
[`constinit`](constinit.html "cpp/language/constinit") (C++20)  
  
[Storage duration specifiers](storage_duration.html "cpp/language/storage duration")  
[Initialization](initialization.html "cpp/language/initialization")  
| [Default-initialization](default_initialization.html "cpp/language/default initialization")  
---  
[Value-initialization](value_initialization.html "cpp/language/value initialization")  
[Zero-initialization](zero_initialization.html "cpp/language/zero initialization")  
[Copy-initialization](copy_initialization.html "cpp/language/copy initialization")  
[Direct-initialization](direct_initialization.html "cpp/language/direct initialization")  
  
| [Aggregate initialization](aggregate_initialization.html "cpp/language/aggregate initialization")  
---  
[List-initialization](list_initialization.html "cpp/language/list initialization") (C++11)` `  
[Constant initialization](constant_initialization.html "cpp/language/constant initialization")  
[Reference initialization](reference_initialization.html "cpp/language/reference initialization")  
  
  
  
[Expressions](expressions.html "cpp/language/expressions")  
---  
| [Value categories](value_category.html "cpp/language/value category")  
---  
[Order of evaluation](eval_order.html "cpp/language/eval order")  
  
| [Operators](operators.html "cpp/language/operators")  
---  
[Operator precedence](operator_precedence.html "cpp/language/operator precedence")  
  
[Alternative representations](operator_alternative.html "cpp/language/operator alternative")  
[Literals](expressions.html#Literals "cpp/language/expressions")  
[Boolean](bool_literal.html "cpp/language/bool literal") \- [Integer](integer_literal.html "cpp/language/integer literal") \- [Floating-point](floating_literal.html "cpp/language/floating literal")  
[Character](character_literal.html "cpp/language/character literal") \- [String](string_literal.html "cpp/language/string literal") \- [`nullptr`](nullptr.html "cpp/language/nullptr") (C++11)  
[User-defined](user_literal.html "cpp/language/user literal") (C++11)  
Utilities  
[Attributes](attributes.html "cpp/language/attributes") (C++11)  
Types  
[`typedef` declaration](typedef.html "cpp/language/typedef")  
[Type alias declaration](type_alias.html "cpp/language/type alias") (C++11)  
Casts  
| [Implicit conversions](implicit_cast.html "cpp/language/implicit conversion")  
---  
[`static_cast`](static_cast.html "cpp/language/static cast")  
[`const_cast`](const_cast.html "cpp/language/const cast")  
  
| [Explicit conversions](explicit_cast.html "cpp/language/explicit cast")  
---  
[`dynamic_cast`](dynamic_cast.html "cpp/language/dynamic cast")  
[`reinterpret_cast`](reinterpret_cast.html "cpp/language/reinterpret cast")  
  
Memory allocation  
| [`new` expression](new.html "cpp/language/new")  
---  
  
| [`delete` expression](delete.html "cpp/language/delete")  
---  
  
[Classes](classes.html "cpp/language/classes")  
| [Class declaration](class.html "cpp/language/class")  
---  
[Constructors](initializer_list.html "cpp/language/constructor")  
[`this` pointer](this.html "cpp/language/this")  
  
| **Access specifiers**  
---  
[`friend` specifier](friend.html "cpp/language/friend")  
  
  
  
Class-specific function properties  
| [Virtual function](virtual.html "cpp/language/virtual")  
---  
[`override` specifier](override.html "cpp/language/override") (C++11)` `  
[`final` specifier](final.html "cpp/language/final") (C++11)  
  
| [`explicit`](explicit.html "cpp/language/explicit") (C++11)  
---  
[`static`](static.html "cpp/language/static")  
  
  
  
Special member functions  
| [Default constructor](default_constructor.html "cpp/language/default constructor")  
---  
[Copy constructor](copy_constructor.html "cpp/language/copy constructor")  
[Move constructor](move_constructor.html "cpp/language/move constructor") (C++11)  
  
| [Copy assignment](as_operator.html "cpp/language/as operator")  
---  
[Move assignment](move_operator.html "cpp/language/move operator") (C++11)  
[Destructor](destructor.html "cpp/language/destructor")  
  
[Templates](templates.html "cpp/language/templates")  
| [Class template](class_template.html "cpp/language/class template")  
---  
[Function template](function_template.html "cpp/language/function template")  
  
| [Template specialization](template_specialization.html "cpp/language/template specialization")  
---  
[Parameter packs](parameter_pack.html "cpp/language/pack") (C++11)  
  
Miscellaneous  
| [Inline assembly](asm.html "cpp/language/asm")  
---  
  
| [History of C++](history.html "cpp/language/history")  
---  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/navbar_content&action=edit)

[ Classes](classes.html "cpp/language/classes")

General  
---  
[Overview](classes.html "cpp/language/classes")  
[`class`/`struct` types](class.html "cpp/language/class")  
[`union` types](union.html "cpp/language/union")  
[Injected-class-name](injected-class-name.html "cpp/language/injected-class-name")  
[Class property specifiers](class_property_specifiers.html "cpp/language/class property specifiers") (C++26)  
Members  
[Data members](data_members.html "cpp/language/data members")  
[Static members](static.html "cpp/language/static")  
[The `this` pointer](this.html "cpp/language/this")  
[Nested classes](nested_classes.html "cpp/language/nested types")  
[Member templates](member_template.html "cpp/language/member template")  
[Bit-fields](bit_field.html "cpp/language/bit field")  
[`using`-declarations](using_declaration.html "cpp/language/using declaration")  
[Member functions](member_functions.html "cpp/language/member functions")  
**Member access specifiers**  
[Constructors and member initializer lists](initializer_list.html "cpp/language/constructor")  
[Default member initializer](data_members.html#Member_initialization "cpp/language/data members") (C++11)  
[`friend` specifier](friend.html "cpp/language/friend")  
[`explicit` specifier](explicit.html "cpp/language/explicit")  
[Converting constructor](converting_constructor.html "cpp/language/converting constructor")  
Special member functions  
[Default constructor](default_constructor.html "cpp/language/default constructor")  
[Copy constructor](copy_constructor.html "cpp/language/copy constructor")  
[Move constructor](move_constructor.html "cpp/language/move constructor") (C++11)  
[Copy assignment operator](as_operator.html "cpp/language/copy assignment")  
[Move assignment operator](move_operator.html "cpp/language/move assignment") (C++11)  
[Destructor](destructor.html "cpp/language/destructor")  
Inheritance  
[Base and derived classes](derived_class.html "cpp/language/derived class")  
[Empty base optimization (EBO)](ebo.html "cpp/language/ebo")  
[Virtual member functions](virtual.html "cpp/language/virtual")  
[Pure virtual functions and abstract classes](abstract_class.html "cpp/language/abstract class")  
[`override` specifier](override.html "cpp/language/override") (C++11)  
[`final` specifier](final.html "cpp/language/final") (C++11)  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/classes/navbar_content&action=edit)

In a member-specification of a [class/struct](class.html "cpp/language/class") or [union](union.html "cpp/language/union"), define the accessibility of subsequent members. 

In a base-specifier of a [derived class](derived_class.html "cpp/language/derived class") declaration, define the accessibility of inherited members of the subsequent base class. 

## Contents

  * [1 Syntax](access.html#Syntax)
  * [2 Explanation](access.html#Explanation)
  * [3 In detail](access.html#In_detail)
  * [4 Public member access](access.html#Public_member_access)
  * [5 Protected member access](access.html#Protected_member_access)
  * [6 Private member access](access.html#Private_member_access)
  * [7 Inheritance](access.html#Inheritance)
  * [8 Keywords](access.html#Keywords)
  * [9 Defect reports](access.html#Defect_reports)

  
---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/access&action=edit&section=1 "Edit section: Syntax")] Syntax  
  
---  
public `**:**` member-declarations |  (1)  |   
protected `**:**` member-declarations |  (2)  |   
private `**:**` member-declarations |  (3)  |   
public base-class |  (4)  |   
protected base-class |  (5)  |   
private base-class |  (6)  |   
  
1) The members declared after the access specifier have public member access.

2) The members declared after the access specifier have protected member access.

3) The members declared after the access specifier have private member access.

4) [Public inheritance](derived_class.html#Public_inheritance "cpp/language/derived class"): the public and protected members of the [base class](derived_class.html "cpp/language/derived class") listed after the access specifier keep their member access in the derived class.

5) [Protected inheritance](derived_class.html#Protected_inheritance "cpp/language/derived class"): the public and protected members of the [base class](derived_class.html "cpp/language/derived class") listed after the access specifier are protected members of the derived class.

6) [Private inheritance](derived_class.html#Private_inheritance "cpp/language/derived class"): the public and protected members of the [base class](derived_class.html "cpp/language/derived class") listed after the access specifier are private members of the derived class.

The private members of the base class are always inaccessible to the derived class regardless of public, protected, or private inheritance. 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/access&action=edit&section=2 "Edit section: Explanation")] Explanation

The name of every [class](class.html "cpp/language/class") member (static, non-static, function, type, etc) has an associated “member access”. When a name of the member is used anywhere a program, its access is checked, and if it does not satisfy the access rules, the program does not compile: 

Run this code
    
    
    #include <iostream>
     
    class Example
    {
    public:             // all declarations after this point are public
        void add(int x) // member “add” has public access
        {
            n += x;     // OK: private Example::n can be accessed from Example::add
        }
    private:            // all declarations after this point are private
        int n = 0;      // member “n” has private access
    };
     
    int main()
    {
        Example e;
        e.add(1); // OK: public Example::add can be accessed from main
    //  e.n = 7;  // error: private Example::n cannot be accessed from main
    }

Access specifiers give the author of the class the ability to decide which class members are accessible to the users of the class (that is, the _interface_) and which members are for internal use of the class (the _implementation_). 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/access&action=edit&section=3 "Edit section: In detail")] In detail

All members of a class (bodies of [member functions](member_functions.html "cpp/language/member functions"), initializers of member objects, and the entire [nested class definitions](nested_classes.html "cpp/language/nested types")) have access to all names the class can access. A local class within a member function has access to all names the member function can access. 

A class defined with the keyword `class` has private access for its members and its base classes by default. A class defined with the keyword `struct` has public access for its members and its base classes by default. A [union](union.html "cpp/language/union") has public access for its members by default. 

To grant access to additional functions or classes to protected or private members, a [friendship declaration](friend.html "cpp/language/friend") may be used. 

Accessibility applies to all names with no regard to their origin, so a name introduced by a [typedef](typedef.html "cpp/language/typedef") or [using declarations](using_declaration.html "cpp/language/using declaration") (except inheriting constructors) is checked, not the name it refers to: 
    
    
    class A : X
    {
        class B {};   // B is private in A
    public:
        typedef B BB; // BB is public
    };
     
    void f()
    {
        A::B y;  // error: A::B is private
        A::BB x; // OK: A::BB is public
    }

Member access does not affect visibility: names of private and privately-inherited members are visible and considered by overload resolution, implicit conversions to inaccessible base classes are still considered, etc. Member access check is the last step after any given language construct is interpreted. The intent of this rule is that replacing any `private` with `public` never alters the behavior of the program. 

Access checking for the names used in [default function arguments](default_arguments.html "cpp/language/default arguments") as well as in the default [template parameters](template_parameters.html#Default_template_arguments "cpp/language/template parameters") is performed at the point of declaration, not at the point of use. 

Access rules for the names of [virtual functions](virtual.html "cpp/language/virtual") are checked at the call point using the type of the expression used to denote the object for which the member function is called. The access of the final overrider is ignored: 
    
    
    struct B
    {
        virtual int f(); // f is public in B
    };
     
    class D : public B
    {
    private:
        int f(); // f is private in D
    };
     
    void f()
    {
        D d;
        B& b = d;
     
        b.f(); // OK: B::f is public, D::f is invoked even though it's private
        d.f(); // error: D::f is private
    }

A name that is private according to unqualified [name lookup](lookup.html "cpp/language/lookup"), may be accessible through qualified name lookup: 
    
    
    class A {};
     
    class B : private A {};
     
    class C : public B
    {
        A* p;   // error: unqualified name lookup finds A as the private base of B
        ::A* q; // OK: qualified name lookup finds the namespace-level declaration
    };

A name that is accessible through multiple paths in the inheritance graph has the access of the path with the most access: 
    
    
    class W
    {
    public:
        void f();
    };
     
    class A : private virtual W {};
     
    class B : public virtual W {};
     
    class C : public A, public B
    {
        void f()
        {
            W::f(); // OK: W is accessible to C through B
        }
    };

Any number of access specifiers may appear within a class, in any order. 

Member access specifiers may affect [class layout](data_members.html#Layout "cpp/language/data members"): the addresses of non-static data members are only guaranteed to increase in order of declaration for the members not separated by an access specifier(until C++11)with the same access(since C++11).  | (until C++23)  
---|---  
For [standard-layout types](../named_req/StandardLayoutType.html "cpp/named req/StandardLayoutType"), all non-static data members must have the same access.  | (since C++11)  
---|---  
  
When a member is redeclared within the same class, it must do so under the same member access: 
    
    
    struct S
    {
        class A;    // S::A is public
    private:
        class A {}; // error: cannot change access
    };

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/access&action=edit&section=4 "Edit section: Public member access")] Public member access

Public members form a part of the public interface of a class (other parts of the public interface are the non-member functions found by [ADL](adl.html "cpp/language/adl")). 

A public member of a class is accessible anywhere: 
    
    
    class S
    {
    public:
        // n, E, A, B, C, U, f are public members
        int n;
        enum E {A, B, C};
        struct U {};
        static void f() {}
    };
     
    int main()
    {
        S::f();     // S::f is accessible in main
     
        S s;
        s.n = S::B; // S::n and S::B are accessible in main
     
        S::U x;     // S::U is accessible in main
    }

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/access&action=edit&section=5 "Edit section: Protected member access")] Protected member access

Protected members form the interface of a class to its derived classes (which is distinct from the public interface of the class). 

A protected member of a class is only accessible 

1) to the members and friends of that class;

2) to the members and friends of any derived class of that class, but only when the class of the object through which the protected member is accessed is that derived class or a derived class of that derived class:
    
    
    struct Base
    {
    protected:
        int i;
    private:
        void g(Base& b, struct Derived& d);
    };
     
    struct Derived : Base
    {
        friend void h(Base& b, Derived& d);
        void f(Base& b, Derived& d) // member function of a derived class
        {
            ++d.i;                  // OK: the type of d is Derived
            ++i;                    // OK: the type of the implied '*this' is Derived
    //      ++b.i;                  // error: can't access a protected member through
                                    // Base (otherwise it would be possible to change
                                    // other derived classes, like a hypothetical
                                    // Derived2, base implementation)
        }
    };
     
    void Base::g(Base& b, Derived& d) // member function of Base
    {
        ++i;                          // OK
        ++b.i;                        // OK
        ++d.i;                        // OK
    }
     
    void h(Base& b, Derived& d) // Friend of Derived
    {
        ++d.i;                  // OK: friend of Derived can access a protected 
                                // member through an object of Derived
    //  ++b.i;                  // error: friend of Derived is not a friend of Base
    }
     
    void x(Base& b, Derived& d) // non-member non-friend
    {
    //  ++b.i;                  // error: no access from non-member
    //  ++d.i;                  // error: no access from non-member
    }

When a pointer to a protected member is formed, it must use a derived class in its declaration: 
    
    
    struct Base
    {
    protected:
        int i;
    };
     
    struct Derived : Base
    {
        void f()
        {
    //      int Base::* ptr = &Base::i;    // error: must name using Derived
            int Base::* ptr = &Derived::i; // OK
        }
    };

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/access&action=edit&section=6 "Edit section: Private member access")] Private member access

Private members form the implementation of a class, as well as the private interface for the other members of the class. 

A private member of a class is only accessible to the members and friends of that class, regardless of whether the members are on the same or different instances: 
    
    
    class S
    {
    private:
        int n; // S::n is private
    public:
        S() : n(10) {}                    // this->n is accessible in S::S
        S(const S& other) : n(other.n) {} // other.n is accessible in S::S
    };

The [explicit cast](explicit_cast.html "cpp/language/explicit cast") (C-style and function-style) allows casting from a derived lvalue to reference to its private base, or from a pointer to derived to a pointer to its private base. 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/access&action=edit&section=7 "Edit section: Inheritance")] Inheritance

See [derived classes](derived_class.html "cpp/language/derived class") for the meaning of public, protected, and private inheritance. 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/access&action=edit&section=8 "Edit section: Keywords")] Keywords

[`public`](../keyword/public.html "cpp/keyword/public"), [`protected`](../keyword/protected.html "cpp/keyword/protected"), [`private`](../keyword/private.html "cpp/keyword/private")

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/access&action=edit&section=9 "Edit section: Defect reports")] Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[CWG 1873](https://cplusplus.github.io/CWG/issues/1873.html) | C++98  | protected members were accessible to friends of derived classes  | made inaccessible 
