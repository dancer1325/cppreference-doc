[C++](../../cpp.html "cpp")

[Compiler support](../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../freestanding.html "cpp/freestanding")  
[Language](../language.html "cpp/language")  
[Standard library](../standard_library.html "cpp/standard library")  
[Standard library headers](../headers.html "cpp/header")  
[Named requirements](../iterator/concepts.html "cpp/named req")  
[Feature test macros](../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../utility.html#Language_support "cpp/utility")  
[Concepts library](../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../error.html "cpp/error")  
[Memory management library](../memory.html "cpp/memory")  
[Metaprogramming library](../meta.html "cpp/meta") (C++11)  
[General utilities library](../utility.html "cpp/utility")  
[Containers library](../container.html "cpp/container")  
[Iterators library](../iterator.html "cpp/iterator")  
[Ranges library](../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../algorithm.html "cpp/algorithm")  
[Strings library](../string.html "cpp/string")  
[Text processing library](../text.html "cpp/text")  
[Numerics library](../numeric.html "cpp/numeric")  
[Date and time library](../chrono.html "cpp/chrono")  
[Input/output library](../io.html "cpp/io")  
[Filesystem library](../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../atomic.html "cpp/thread") (C++11)  
[Execution control library](../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../experimental.html "cpp/experimental")  
[Symbols index](../symbol_index.html "cpp/symbol index")  
[External libraries](../links/libs.html "cpp/links/libs")  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/navbar_content&action=edit)

[C++ language](../language.html "cpp/language")

General topics  
---  
| [Preprocessor](../preprocessor.html "cpp/preprocessor")  
---  
[Comments](../comments.html "cpp/comment")  
  
| [Keywords](../keywords.html "cpp/keyword")  
---  
[Escape sequences](escape.html "cpp/language/escape")  
  
[Flow control](statements.html "cpp/language/statements")  
Conditional execution statements  
| [`if`](if.html "cpp/language/if")  
---  
  
| [`switch`](switch.html "cpp/language/switch")  
---  
  
Iteration statements (loops)  
| [`for`](for.html "cpp/language/for")  
---  
[range-`for`](range-for.html "cpp/language/range-for") (C++11)  
  
| [`while`](while.html "cpp/language/while")  
---  
[`do-while`](do.html "cpp/language/do")  
  
Jump statements  
| [`continue`](continue.html "cpp/language/continue") \- [`break`](break.html "cpp/language/break")  
---  
  
| [`goto`](goto.html "cpp/language/goto") \- [`return`](return.html "cpp/language/return")  
---  
  
[Functions](functions.html "cpp/language/functions")  
[Function declaration](function.html "cpp/language/function")  
[Lambda function expression](lambda.html "cpp/language/lambda")  
[`inline` specifier](inline.html "cpp/language/inline")  
[Dynamic exception specifications](except_spec.html "cpp/language/except spec") (until C++17*)  
[`noexcept` specifier](noexcept_spec.html "cpp/language/noexcept spec") (C++11)  
Exceptions  
| [`throw`-expression](throw.html "cpp/language/throw")  
---  
[`try` block](try.html "cpp/language/try")  
  
|   
  
---  
[`catch` handler](catch.html "cpp/language/catch")  
  
Namespaces  
| [Namespace declaration](namespace.html "cpp/language/namespace")` `  
---  
  
| [Namespace aliases](namespace_alias.html "cpp/language/namespace alias")  
---  
  
Types  
| [Fundamental types](types.html "cpp/language/types")  
---  
[Enumeration types](enum.html "cpp/language/enum")  
[Function types](function.html "cpp/language/function")  
  
| [Class/struct types](class.html "cpp/language/class")  
---  
[Union types](union.html "cpp/language/union")  
  
  
  
Specifiers  
| [`const`/`volatile`](cv.html "cpp/language/cv")  
---  
[`decltype`](decltype.html "cpp/language/decltype") (C++11)  
[`auto`](auto.html "cpp/language/auto") (C++11)  
  
| [`constexpr`](constexpr.html "cpp/language/constexpr") (C++11)  
---  
[`consteval`](consteval.html "cpp/language/consteval") (C++20)  
[`constinit`](constinit.html "cpp/language/constinit") (C++20)  
  
[Storage duration specifiers](storage_duration.html "cpp/language/storage duration")  
[Initialization](initialization.html "cpp/language/initialization")  
| [Default-initialization](default_initialization.html "cpp/language/default initialization")  
---  
[Value-initialization](value_initialization.html "cpp/language/value initialization")  
[Zero-initialization](zero_initialization.html "cpp/language/zero initialization")  
[Copy-initialization](copy_initialization.html "cpp/language/copy initialization")  
[Direct-initialization](direct_initialization.html "cpp/language/direct initialization")  
  
| [Aggregate initialization](aggregate_initialization.html "cpp/language/aggregate initialization")  
---  
[List-initialization](list_initialization.html "cpp/language/list initialization") (C++11)` `  
[Constant initialization](constant_initialization.html "cpp/language/constant initialization")  
[Reference initialization](reference_initialization.html "cpp/language/reference initialization")  
  
  
  
[Expressions](expressions.html "cpp/language/expressions")  
---  
| [Value categories](value_category.html "cpp/language/value category")  
---  
[Order of evaluation](eval_order.html "cpp/language/eval order")  
  
| [Operators](operators.html "cpp/language/operators")  
---  
[Operator precedence](operator_precedence.html "cpp/language/operator precedence")  
  
[Alternative representations](operator_alternative.html "cpp/language/operator alternative")  
[Literals](expressions.html#Literals "cpp/language/expressions")  
[Boolean](bool_literal.html "cpp/language/bool literal") \- [Integer](integer_literal.html "cpp/language/integer literal") \- [Floating-point](floating_literal.html "cpp/language/floating literal")  
[Character](character_literal.html "cpp/language/character literal") \- [String](string_literal.html "cpp/language/string literal") \- [`nullptr`](nullptr.html "cpp/language/nullptr") (C++11)  
[User-defined](user_literal.html "cpp/language/user literal") (C++11)  
Utilities  
[Attributes](attributes.html "cpp/language/attributes") (C++11)  
Types  
[`typedef` declaration](typedef.html "cpp/language/typedef")  
[Type alias declaration](type_alias.html "cpp/language/type alias") (C++11)  
Casts  
| [Implicit conversions](implicit_cast.html "cpp/language/implicit conversion")  
---  
[`static_cast`](static_cast.html "cpp/language/static cast")  
[`const_cast`](const_cast.html "cpp/language/const cast")  
  
| [Explicit conversions](explicit_cast.html "cpp/language/explicit cast")  
---  
[`dynamic_cast`](dynamic_cast.html "cpp/language/dynamic cast")  
**`reinterpret_cast`**  
  
Memory allocation  
| [`new` expression](new.html "cpp/language/new")  
---  
  
| [`delete` expression](delete.html "cpp/language/delete")  
---  
  
[Classes](classes.html "cpp/language/classes")  
| [Class declaration](class.html "cpp/language/class")  
---  
[Constructors](initializer_list.html "cpp/language/constructor")  
[`this` pointer](this.html "cpp/language/this")  
  
| [Access specifiers](access.html "cpp/language/access")  
---  
[`friend` specifier](friend.html "cpp/language/friend")  
  
  
  
Class-specific function properties  
| [Virtual function](virtual.html "cpp/language/virtual")  
---  
[`override` specifier](override.html "cpp/language/override") (C++11)` `  
[`final` specifier](final.html "cpp/language/final") (C++11)  
  
| [`explicit`](explicit.html "cpp/language/explicit") (C++11)  
---  
[`static`](static.html "cpp/language/static")  
  
  
  
Special member functions  
| [Default constructor](default_constructor.html "cpp/language/default constructor")  
---  
[Copy constructor](copy_constructor.html "cpp/language/copy constructor")  
[Move constructor](move_constructor.html "cpp/language/move constructor") (C++11)  
  
| [Copy assignment](as_operator.html "cpp/language/as operator")  
---  
[Move assignment](move_operator.html "cpp/language/move operator") (C++11)  
[Destructor](destructor.html "cpp/language/destructor")  
  
[Templates](templates.html "cpp/language/templates")  
| [Class template](class_template.html "cpp/language/class template")  
---  
[Function template](function_template.html "cpp/language/function template")  
  
| [Template specialization](template_specialization.html "cpp/language/template specialization")  
---  
[Parameter packs](parameter_pack.html "cpp/language/pack") (C++11)  
  
Miscellaneous  
| [Inline assembly](asm.html "cpp/language/asm")  
---  
  
| [History of C++](history.html "cpp/language/history")  
---  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/navbar_content&action=edit)

[ Expressions](expressions.html "cpp/language/expressions")

General  
---  
| [Value categories](value_category.html "cpp/language/value category")  
---  
[Order of evaluation](eval_order.html "cpp/language/eval order")  
[Constant expressions](constant_expression.html "cpp/language/constant expression")  
[Primary expressions](expressions.html#Primary_expressions "cpp/language/expressions")  
  
| [Lambda expressions](lambda.html "cpp/language/lambda") (C++11)  
---  
[Requires expressions](requires.html "cpp/language/requires") (C++20)  
[Pack indexing expression](pack_indexing.html#Pack_indexing_expression "cpp/language/pack indexing") (C++26)  
[Potentially-evaluated expressions](expressions.html#Potentially-evaluated_expressions "cpp/language/expressions")  
  
Literals  
| [Integer literals](integer_literal.html "cpp/language/integer literal")  
---  
[Floating-point literals](floating_literal.html "cpp/language/floating literal")  
[Boolean literals](bool_literal.html "cpp/language/bool literal")  
[Character literals](character_literal.html "cpp/language/character literal")  
  
| [Escape sequences](escape.html "cpp/language/escape")  
---  
[String literals](string_literal.html "cpp/language/string literal")  
[Null pointer literal](nullptr.html "cpp/language/nullptr") (C++11)  
[User-defined literal](user_literal.html "cpp/language/user literal") (C++11)  
  
Operators  
| [Assignment operators](operator_assignment.html "cpp/language/operator assignment")  
---  
[Increment and decrement](operator_incdec.html "cpp/language/operator incdec")  
[Arithmetic operators](operator_arithmetic.html "cpp/language/operator arithmetic")  
[Logical operators](operator_logical.html "cpp/language/operator logical")  
[Comparison operators](operator_comparison.html "cpp/language/operator comparison")  
[Member access operators](operator_member_access.html "cpp/language/operator member access")  
[Other operators](operator_other.html "cpp/language/operator other")  
[`new`-expression](new.html "cpp/language/new")  
[`delete`-expression](delete.html "cpp/language/delete")  
[`throw`-expression](throw.html "cpp/language/throw")  
  
| [`alignof`](alignof.html "cpp/language/alignof")  
---  
[`sizeof`](sizeof.html "cpp/language/sizeof")  
[`sizeof...`](sizeof....html "cpp/language/sizeof...") (C++11)  
[`typeid`](typeid.html "cpp/language/typeid")  
[`noexcept`](noexcept.html "cpp/language/noexcept") (C++11)  
[Fold expressions](fold.html "cpp/language/fold") (C++17)  
[Alternative representations of operators](operator_alternative.html "cpp/language/operator alternative")  
[Precedence and associativity](operator_precedence.html "cpp/language/operator precedence")  
[Operator overloading](operators.html "cpp/language/operators")  
[Default comparisons](default_comparisons.html "cpp/language/default comparisons") (C++20)  
  
Conversions  
| [Implicit conversions](implicit_cast.html "cpp/language/implicit conversion")  
---  
[Explicit conversions](explicit_cast.html "cpp/language/explicit cast")  
[Usual arithmetic conversions](usual_arithmetic_conversions.html "cpp/language/usual arithmetic conversions")  
[User-defined conversion](cast_operator.html "cpp/language/cast operator")  
  
| [`const_cast`](const_cast.html "cpp/language/const cast")  
---  
[`static_cast`](static_cast.html "cpp/language/static cast")  
[`dynamic_cast`](dynamic_cast.html "cpp/language/dynamic cast")  
**`reinterpret_cast`**  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/expressions/navbar_content&action=edit)

Converts between types by reinterpreting the underlying bit pattern. 

## Contents

  * [1 Syntax](reinterpret_cast.html#Syntax)
  * [2 Explanation](reinterpret_cast.html#Explanation)
  * [3 Type aliasing](reinterpret_cast.html#Type_aliasing)
    * [3.1 Type accessibility](reinterpret_cast.html#Type_accessibility)
    * [3.2 Call compatibility](reinterpret_cast.html#Call_compatibility)
  * [4 Notes](reinterpret_cast.html#Notes)
  * [5 Keywords](reinterpret_cast.html#Keywords)
  * [6 Example](reinterpret_cast.html#Example)
  * [7 Defect reports](reinterpret_cast.html#Defect_reports)
  * [8 References](reinterpret_cast.html#References)
  * [9 See also](reinterpret_cast.html#See_also)

  
---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/reinterpret_cast&action=edit&section=1 "Edit section: Syntax")] Syntax  
  
---  
`**reinterpret_cast <**` target-type `**>(**` expression `**)**` |  |   
  
Returns a value of type target-type. 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/reinterpret_cast&action=edit&section=2 "Edit section: Explanation")] Explanation

Unlike static_cast, but like const_cast, the reinterpret_cast expression does not compile to any CPU instructions (except when converting between integers and pointers, or between pointers on obscure architectures where pointer representation depends on its type). It is primarily a compile-time directive which instructs the compiler to treat expression as if it had the type target-type. 

Only the following conversions can be done with reinterpret_cast, except when such conversions would [cast away constness](const_cast.html#Casting_away_constness "cpp/language/const cast") (or volatility). 

1) An expression of integral, enumeration, pointer, or pointer-to-member type can be converted to its own type. The resulting value is the same as the value of expression.

2) A pointer can be converted to any integral type large enough to hold all values of its type (e.g. to [std::uintptr_t](../types/integer.html "cpp/types/integer")).

3) A value of any integral or enumeration type can be converted to a pointer type. A pointer converted to an integer of sufficient size and back to the same pointer type is guaranteed to have its original value, otherwise the resulting pointer cannot be dereferenced safely (the round-trip conversion in the opposite direction is not guaranteed; the same pointer may have multiple integer representations) The null pointer constant [NULL](../types/NULL.html "cpp/types/NULL") or integer zero is not guaranteed to yield the null pointer value of the target type; [`static_cast`](static_cast.html "cpp/language/static cast") or [implicit conversion](implicit_cast.html "cpp/language/implicit cast") should be used for this purpose.

4) Any value of type [std::nullptr_t](../types/nullptr_t.html "cpp/types/nullptr t"), including nullptr can be converted to any integral type as if it were (void*)0, but no value, not even nullptr can be converted to [std::nullptr_t](../types/nullptr_t.html "cpp/types/nullptr t"): static_cast should be used for that purpose. | (since C++11)  
---|---  
  
5) Any object pointer type `T1*` can be converted to another object pointer type `_cv_ T2*`. This is exactly equivalent to static_cast<_cv_ T2*>(static_cast<_cv_ void*>(expression)) (which implies that if `T2`'s alignment requirement is not stricter than `T1`'s, the value of the pointer does not change and conversion of the resulting pointer back to its original type yields the original value). In any case, the resulting pointer may only be dereferenced safely if the dereferenced value is [type-accessible](reinterpret_cast.html#Type_accessibility).

6) An [lvalue](value_category.html#lvalue "cpp/language/value category")(until C++11)[glvalue](value_category.html#glvalue "cpp/language/value category")(since C++11) expression of type `T1` can be converted to reference to another type `T2`. The result is that of *reinterpret_cast<T2*>(p), where p is a pointer of type “pointer to `T1`” to the object or function designated by expression. No temporary is materialized or(since C++17) created, no copy is made, no constructors or conversion functions are called. The resulting reference can only be accessed safely if it is [type-accessible](reinterpret_cast.html#Type_accessibility).

7) Any pointer to function can be converted to a pointer to a different function type. The result is unspecified, but converting such pointer back to pointer to the original function type yields the pointer to the original function. The resulting pointer can only be called safely if it function type is [call-compatible](reinterpret_cast.html#Call_compatibility) with the original function type.

8) On some implementations (in particular, on any POSIX compatible system as required by [`dlsym`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/dlsym.html)), a function pointer can be converted to void* or any other object pointer, or vice versa. If the implementation supports conversion in both directions, conversion to the original type yields the original value, otherwise the resulting pointer cannot be dereferenced or called safely.

9) The null pointer value of any pointer type can be converted to any other pointer type, resulting in the null pointer value of that type. Note that the null pointer constant nullptr or any other value of type [std::nullptr_t](../types/nullptr_t.html "cpp/types/nullptr t") cannot be converted to a pointer with reinterpret_cast: implicit conversion or static_cast should be used for this purpose.

10) A pointer to member function can be converted to pointer to a different member function of a different type. Conversion back to the original type yields the original value, otherwise the resulting pointer cannot be used safely.

11) A pointer to member object of some class `T1` can be converted to a pointer to another member object of another class `T2`. If `T2`'s alignment is not stricter than `T1`'s, conversion back to the original type `T1` yields the original value, otherwise the resulting pointer cannot be used safely.

As with all cast expressions, the result is: 

  * an lvalue if target-type is an lvalue reference type or an rvalue reference to function type(since C++11); 



  * an xvalue if target-type is an rvalue reference to object type; 

| (since C++11)  
---|---  
  
  * a prvalue otherwise. 



### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/reinterpret_cast&action=edit&section=3 "Edit section: Type aliasing")] Type aliasing

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/reinterpret_cast&action=edit&section=4 "Edit section: Type accessibility")] Type accessibility

If a type `T_ref` is [similar](implicit_cast.html#Similar_types "cpp/language/implicit conversion") to any of the following types, an object of [dynamic type](type-id.html#Dynamic_type "cpp/language/type") `T_obj` is _type-accessible_ through a lvalue(until C++11)glvalue(since C++11) of type `T_ref`: 

  * char, unsigned char or std::byte(since C++17): this permits examination of the [object representation](objects.html#Object_representation_and_value_representation "cpp/language/object") of any object as an array of bytes. 
  * `T_obj`
  * the signed or unsigned type corresponding to `T_obj`



If a program attempts to read or modify the stored value of an object through a lvalue(until C++11)glvalue(since C++11) through which it is not type-accessible, the behavior is undefined. 

This rule enables type-based alias analysis, in which a compiler assumes that the value read through a glvalue of one type is not modified by a write to a glvalue of a different type (subject to the exceptions noted above). 

Note that many C++ compilers relax this rule, as a non-standard language extension, to allow wrong-type access through the inactive member of a [union](union.html "cpp/language/union") (such access is not undefined in C). 

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/reinterpret_cast&action=edit&section=5 "Edit section: Call compatibility")] Call compatibility

If any of the following conditions is satisfied, a type `T_call` is _call-compatible_ with a function type `T_func`: 

  * `T_call` is the same type as `T_func`. 



  * `T_func*` can be converted to `T_call*` via a [function pointer conversion](implicit_cast.html#Function_pointer_conversions "cpp/language/implicit conversion"). 

| (since C++17)  
---|---  
  
If a function is called through an expression whose [function type](function.html#Function_type "cpp/language/function") is not call-compatible with the type of the called function’s definition, the behavior is undefined. 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/reinterpret_cast&action=edit&section=6 "Edit section: Notes")] Notes

Assuming that alignment requirements are met, a reinterpret_cast does not change the [value of a pointer](pointer.html#Pointers "cpp/language/pointer") outside of a few limited cases dealing with [_pointer-interconvertible_](static_cast.html#pointer-interconvertible "cpp/language/static cast") objects: 
    
    
    struct S1 { int a; } s1;
    struct S2 { int a; private: int b; } s2; // not standard-layout
    union U { int a; double b; } u = {0};
    int arr[2];
     
    int* p1 = reinterpret_cast<int*>(&s1); // value of p1 is "pointer to s1.a" because
                                           // s1.a and s1 are pointer-interconvertible
     
    int* p2 = reinterpret_cast<int*>(&s2); // value of p2 is unchanged by reinterpret_cast
                                           // and is "pointer to s2". 
     
    int* p3 = reinterpret_cast<int*>(&u);  // value of p3 is "pointer to u.a":
                                           // u.a and u are pointer-interconvertible
     
    double* p4 = reinterpret_cast<double*>(p3); // value of p4 is "pointer to u.b": u.a and
                                                // u.b are pointer-interconvertible because
                                                // both are pointer-interconvertible with u
     
    int* p5 = reinterpret_cast<int*>(&arr); // value of p5 is unchanged by reinterpret_cast
                                            // and is "pointer to arr"

Performing a class member access that designates a non-static data member or a non-static member function on a glvalue that does not actually designate an object of the appropriate type - such as one obtained through a reinterpret_cast \- results in undefined behavior: 
    
    
    struct S { int x; };
    struct T { int x; int f(); };
    struct S1 : S {};    // standard-layout
    struct ST : S, T {}; // not standard-layout
     
    S s = {};
    auto p = reinterpret_cast<T*>(&s); // value of p is "pointer to s"
    auto i = p->x; // class member access expression is undefined behavior;
                   // s is not a T object
    p->x = 1; // undefined behavior
    p->f();   // undefined behavior
     
    S1 s1 = {};
    auto p1 = reinterpret_cast<S*>(&s1); // value of p1 is "pointer to the S subobject of s1"
    auto i = p1->x; // OK
    p1->x = 1;      // OK
     
    ST st = {};
    auto p2 = reinterpret_cast<S*>(&st); // value of p2 is "pointer to st"
    auto i = p2->x; // undefined behavior
    p2->x = 1;      // undefined behavior

Many compilers issue "strict aliasing" warnings in such cases, even though technically such constructs run afoul of something other than the paragraph commonly known as the "strict aliasing rule". 

The purpose of strict aliasing and related rules is to enable type-based alias analysis, which would be decimated if a program can validly create a situation where two pointers to unrelated types (e.g., an int* and a float*) could simultaneously exist and both can be used to load or store the same memory (see [this email on SG12 reflector](https://web.archive.org/web/20201128194944/http://www.open-std.org/pipermail/ub/2016-February/000565.html)). Thus, any technique that is seemingly capable of creating such a situation necessarily invokes undefined behavior. 

When it is needed to interpret the bytes of an object as a value of a different type, [std::memcpy](../string/byte/memcpy.html "cpp/string/byte/memcpy") or [`std::bit_cast`](../numeric/bit_cast.html "cpp/numeric/bit cast")(since C++20) can be used: 
    
    
    double d = 0.1;
    [std::int64_t](../types/integer.html) n;
    static_assert(sizeof n == sizeof d);
    // n = *reinterpret_cast<std::int64_t*>(&d); // Undefined behavior
    [std::memcpy](../string/byte/memcpy.html)(&n, &d, sizeof d);               // OK
    n = [std::bit_cast](../numeric/bit_cast.html)<[std::int64_t](../types/integer.html)>(d);          // also OK

If the implementation provides [std::intptr_t](../types/integer.html "cpp/types/integer") and/or [std::uintptr_t](../types/integer.html "cpp/types/integer"), then a cast from a pointer to an object type or _cv_ void to these types is always well-defined. However, this is not guaranteed for a function pointer.  | (since C++11)  
---|---  
  
In C, aggregate copy and assignment access the aggregate object as a whole. But in C++ such actions are always performed through a member function call, which accesses the individual subobjects rather than the entire object (or, in the case of unions, copies the object representation, i.e., via unsigned char). 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/reinterpret_cast&action=edit&section=7 "Edit section: Keywords")] Keywords

[`reinterpret_cast`](../keyword/reinterpret_cast.html "cpp/keyword/reinterpret cast")

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/reinterpret_cast&action=edit&section=8 "Edit section: Example")] Example

Demonstrates some uses of reinterpret_cast:

Run this code
    
    
    #include <cassert>
    #include <cstdint>
    #include <iostream>
     
    int f() { return 42; }
     
    int main()
    {
        int i = 7;
     
        // pointer to integer and back
        [std::uintptr_t](../types/integer.html) v1 = reinterpret_cast<[std::uintptr_t](../types/integer.html)>(&i); // static_cast is an error
        [std::cout](../io/cout.html) << "The value of &i is " << [std::showbase](../io/manip/showbase.html) << [std::hex](../io/manip/hex.html) << v1 << '\n';
        int* p1 = reinterpret_cast<int*>(v1);
        [assert](../error/assert.html)(p1 == &i);
     
        // pointer to function to another and back
        void(*fp1)() = reinterpret_cast<void(*)()>(f);
        // fp1(); undefined behavior
        int(*fp2)() = reinterpret_cast<int(*)()>(fp1);
        [std::cout](../io/cout.html) << [std::dec](../io/manip/hex.html) << fp2() << '\n'; // safe
     
        // type aliasing through pointer
        char* p2 = reinterpret_cast<char*>(&i);
        [std::cout](../io/cout.html) << (p2[0] == '\x7' ? "This system is little-endian\n"
                                     : "This system is big-endian\n");
     
        // type aliasing through reference
        reinterpret_cast<unsigned int&>(i) = 42;
        [std::cout](../io/cout.html) << i << '\n';
     
        [[maybe_unused]] const int &const_iref = i;
        // int &iref = reinterpret_cast<int&>(
        //     const_iref); // compiler error - can't get rid of const
        // Must use const_cast instead: int &iref = const_cast<int&>(const_iref);
    }

Possible output: 
    
    
    The value of &i is 0x7fff352c3580
    42
    This system is little-endian
    42

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/reinterpret_cast&action=edit&section=9 "Edit section: Defect reports")] Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[CWG 195](https://cplusplus.github.io/CWG/issues/195.html) | C++98  | conversion between function pointers  
and object pointers not allowed  | made conditionally-supported   
[CWG 658](https://cplusplus.github.io/CWG/issues/658.html) | C++98  | the result of pointer conversions was unspecified  
(except for conversions back to the original type)  | specification provided for pointers  
whose pointed-to types satisfy  
the alignment requirements   
[CWG 799](https://cplusplus.github.io/CWG/issues/799.html) | C++98  | it was unclear which identity conversion  
can be done by reinterpret_cast | made clear   
[CWG 1268](https://cplusplus.github.io/CWG/issues/1268.html) | C++11  | reinterpret_cast could only cast  
lvalues to reference types  | xvalues also allowed   
[CWG 2780](https://cplusplus.github.io/CWG/issues/2780.html) | C++98  | reinterpret_cast could not cast  
function lvalues to other reference types  | allowed   
[CWG 2939](https://cplusplus.github.io/CWG/issues/2939.html) | C++17  | reinterpret_cast could cast  
prvalues to rvalue reference types  | not allowed   
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/reinterpret_cast&action=edit&section=10 "Edit section: References")] References

  * C++23 standard (ISO/IEC 14882:2024): 



    

  * 7.6.1.10 Reinterpret cast [expr.reinterpret.cast] 



  * C++20 standard (ISO/IEC 14882:2020): 



    

  * 7.6.1.9 Reinterpret cast [expr.reinterpret.cast] 



  * C++17 standard (ISO/IEC 14882:2017): 



    

  * 8.2.10 Reinterpret cast [expr.reinterpret.cast] 



  * C++14 standard (ISO/IEC 14882:2014): 



    

  * 5.2.10 Reinterpret cast [expr.reinterpret.cast] 



  * C++11 standard (ISO/IEC 14882:2011): 



    

  * 5.2.10 Reinterpret cast [expr.reinterpret.cast] 



  * C++98 standard (ISO/IEC 14882:1998): 



    

  * 5.2.10 Reinterpret cast [expr.reinterpret.cast] 



  * C++03 standard (ISO/IEC 14882:2003): 



    

  * 5.2.10 Reinterpret cast [expr.reinterpret.cast] 



### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/language/reinterpret_cast&action=edit&section=11 "Edit section: See also")] See also

[ `const_cast` conversion ](const_cast.html "cpp/language/const cast") |  adds or removes const[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/dsc_const_cast&action=edit)  
---|---  
[ `static_cast` conversion ](static_cast.html "cpp/language/static cast") |  performs basic conversions[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/dsc_static_cast&action=edit)  
[ `dynamic_cast` conversion ](dynamic_cast.html "cpp/language/dynamic cast") |  performs checked polymorphic conversions[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/dsc_dynamic_cast&action=edit)  
[ explicit casts ](explicit_cast.html "cpp/language/explicit cast") |  permissive conversions between types [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/dsc_explicit_cast&action=edit)  
[ standard conversions ](implicit_cast.html "cpp/language/implicit cast") |  implicit conversions from one type to another[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/dsc_implicit_cast&action=edit)  
[ bit_cast](../numeric/bit_cast.html "cpp/numeric/bit cast")(C++20) |  reinterpret the object representation of one type as that of another   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/numeric/dsc_bit_cast&action=edit)
