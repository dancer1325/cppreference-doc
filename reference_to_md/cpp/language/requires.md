

  
| [`goto`](goto.html "cpp/language/goto") \- [`return`](return.html "cpp/language/return")  
---  
  
[Functions](functions.html "cpp/language/functions")  
[Function declaration](function.html "cpp/language/function")  
[Lambda function expression](lambda.html "cpp/language/lambda")  
[`inline` specifier](inline.html "cpp/language/inline")  
[Dynamic exception specifications](except_spec.html "cpp/language/except spec") (until C++17*)  
[`noexcept` specifier](noexcept_spec.html "cpp/language/noexcept spec") (C++11)  
Exceptions  
| [`throw`-expression](throw.html "cpp/language/throw")  
---  
[`try` block](try.html "cpp/language/try")  
  
|   
  
---  
[`catch` handler](catch.html "cpp/language/catch")  
  
Namespaces  
| [Namespace declaration](namespace.html "cpp/language/namespace")` `  
---  
  
| [Namespace aliases](namespace_alias.html "cpp/language/namespace alias")  
---  
  
Types  
| [Fundamental types](types.html "cpp/language/types")  
---  
[Enumeration types](enum.html "cpp/language/enum")  
[Function types](function.html "cpp/language/function")  
  
| [Class/struct types](class.html "cpp/language/class")  
---  
[Union types](union.html "cpp/language/union")  
  
  
  

  
  
  

---  
  

---  
  


[Declarations](declarations.html "cpp/language/declarations")

| Overview  
---  
[Declaration syntax](declarations.html "cpp/language/declarations")  
[_decl-specifier-seq_](declarations.html#Specifiers "cpp/language/declarations")  
[Declarator](declarations.html#Declarators "cpp/language/declarations")  
[Conflicting declarations](conflicting_declarations.html "cpp/language/conflicting declarations")  
Specifiers  
[typedef](typedef.html "cpp/language/typedef")  
[inline](inline.html "cpp/language/inline")  
[virtual function specifier](virtual.html "cpp/language/virtual")  
[explicit function specifier](explicit.html "cpp/language/explicit")  
[friend](friend.html "cpp/language/friend")  
[constexpr](constexpr.html "cpp/language/constexpr")(C++11)  
[consteval](consteval.html "cpp/language/consteval")(C++20)  
[constinit](constinit.html "cpp/language/constinit")(C++20)  
[Storage class specifiers](storage_duration.html "cpp/language/storage duration")  
[Translation-unit-local](tu_local.html "cpp/language/tu local") (C++20)  
[class/struct](class.html "cpp/language/class")  
[union](union.html "cpp/language/union")  
[enum](enum.html "cpp/language/enum")  
[decltype](decltype.html "cpp/language/decltype")(C++11)  
[auto](auto.html "cpp/language/auto")(C++11)  
[alignas](alignas.html "cpp/language/alignas")(C++11)  
[constvolatile](cv.html "cpp/language/cv")  
[Pack indexing specifier](pack_indexing.html#Pack_indexing_specifier "cpp/language/pack indexing") (C++26)  
[Elaborated type specifier](elaborated_type_specifier.html "cpp/language/elaborated type specifier")  
[Attributes](attributes.html "cpp/language/attributes") (C++11)  
  
| Declarators  
---  
[Reference](reference.html "cpp/language/reference")  
[Pointer](pointer.html "cpp/language/pointer")  
[Array](array.html "cpp/language/array")  
Block declarations  
[Simple-declaration](declarations.html "cpp/language/declarations")  
→[Structured binding declaration](structured_binding.html "cpp/language/structured binding") (C++17)  
[Alias declaration](type_alias.html "cpp/language/type alias") (C++11)  
[Namespace alias definition](namespace_alias.html "cpp/language/namespace alias")  
[using declaration](using_declaration.html "cpp/language/using declaration")  
[`using` directive](namespace.html#Using-directives "cpp/language/namespace")  
[static_assert declaration](static_assert.html "cpp/language/static assert") (C++11)  
[asm declaration](asm.html "cpp/language/asm")  
[Opaque enum declaration](enum.html "cpp/language/enum") (C++11)  
Other declarations  
[Namespace definition](namespace.html "cpp/language/namespace")  
[Function declaration](function.html "cpp/language/function")  
[Class template declaration](class_template.html "cpp/language/class template")  
[Function template declaration](function_template.html "cpp/language/function template")  
[Explicit template instantiation](class_template.html#Explicit_instantiation "cpp/language/class template") (C++11)  
[Explicit template specialization](template_specialization.html "cpp/language/template specialization")  
[Linkage specification](language_linkage.html "cpp/language/language linkage")  
[Attribute declaration](declarations.html "cpp/language/declarations") (C++11)  
[Empty declaration](declarations.html "cpp/language/declarations")  
  
  
  


[ Expressions](expressions.html "cpp/language/expressions")

General  
---  
| [Value categories](value_category.html "cpp/language/value category")  
---  
[Order of evaluation](eval_order.html "cpp/language/eval order")  
[Constant expressions](constant_expression.html "cpp/language/constant expression")  
[Primary expressions](expressions.html#Primary_expressions "cpp/language/expressions")  
  
| [Lambda expressions](lambda.html "cpp/language/lambda") (C++11)  
---  
**Requires expressions** (C++20)  
[Pack indexing expression](pack_indexing.html#Pack_indexing_expression "cpp/language/pack indexing") (C++26)  
[Potentially-evaluated expressions](expressions.html#Potentially-evaluated_expressions "cpp/language/expressions")  
  
Literals  
| [Integer literals](integer_literal.html "cpp/language/integer literal")  
---  
[Floating-point literals](floating_literal.html "cpp/language/floating literal")  
[Boolean literals](bool_literal.html "cpp/language/bool literal")  
[Character literals](character_literal.html "cpp/language/character literal")  
  
| [Escape sequences](escape.html "cpp/language/escape")  
---  
[String literals](string_literal.html "cpp/language/string literal")  
[Null pointer literal](nullptr.html "cpp/language/nullptr") (C++11)  
[User-defined literal](user_literal.html "cpp/language/user literal") (C++11)  
  
Operators  
| [Assignment operators](operator_assignment.html "cpp/language/operator assignment")  
---  
[Increment and decrement](operator_incdec.html "cpp/language/operator incdec")  
[Arithmetic operators](operator_arithmetic.html "cpp/language/operator arithmetic")  
[Logical operators](operator_logical.html "cpp/language/operator logical")  
[Comparison operators](operator_comparison.html "cpp/language/operator comparison")  
[Member access operators](operator_member_access.html "cpp/language/operator member access")  
[Other operators](operator_other.html "cpp/language/operator other")  
[`new`-expression](new.html "cpp/language/new")  
[`delete`-expression](delete.html "cpp/language/delete")  
[`throw`-expression](throw.html "cpp/language/throw")  
  
| [`alignof`](alignof.html "cpp/language/alignof")  
---  
[`sizeof`](sizeof.html "cpp/language/sizeof")  
[`sizeof...`](sizeof....html "cpp/language/sizeof...") (C++11)  
[`typeid`](typeid.html "cpp/language/typeid")  
[`noexcept`](noexcept.html "cpp/language/noexcept") (C++11)  
[Fold expressions](fold.html "cpp/language/fold") (C++17)  
[Alternative representations of operators](operator_alternative.html "cpp/language/operator alternative")  
[Precedence and associativity](operator_precedence.html "cpp/language/operator precedence")  
[Operator overloading](operators.html "cpp/language/operators")  
[Default comparisons](default_comparisons.html "cpp/language/default comparisons") (C++20)  
  
Conversions  
| [Implicit conversions](implicit_cast.html "cpp/language/implicit conversion")  
---  
[Explicit conversions](explicit_cast.html "cpp/language/explicit cast")  
[Usual arithmetic conversions](usual_arithmetic_conversions.html "cpp/language/usual arithmetic conversions")  
[User-defined conversion](cast_operator.html "cpp/language/cast operator")  
  
| [`const_cast`](const_cast.html "cpp/language/const cast")  
---  
[`static_cast`](static_cast.html "cpp/language/static cast")  
[`dynamic_cast`](dynamic_cast.html "cpp/language/dynamic cast")  
[`reinterpret_cast`](reinterpret_cast.html "cpp/language/reinterpret cast")  
  


[ Templates](templates.html "cpp/language/templates")

[Template parameters](template_parameters.html "cpp/language/template parameters")  
---  
[Template arguments](template_arguments.html "cpp/language/template arguments")  
[Class templates](class_template.html "cpp/language/class template")  
[Function templates](function_template.html "cpp/language/function template")  
[Class member templates](member_template.html "cpp/language/member template")  
[Variable templates](variable_template.html "cpp/language/variable template") (C++14)  
[Template argument deduction](template_argument_deduction.html "cpp/language/template argument deduction")  
[Class template argument deduction](ctad.html "cpp/language/class template argument deduction") (C++17)  
[Explicit (full) specialization](template_specialization.html "cpp/language/template specialization")  
[Partial specialization](partial_specialization.html "cpp/language/partial specialization")  
[Dependent names](dependent_name.html "cpp/language/dependent name")  
[Packs](parameter_pack.html "cpp/language/pack") (C++11)  
[sizeof...](sizeof....html "cpp/language/sizeof...") (C++11)  
[Fold expressions](fold.html "cpp/language/fold") (C++17)  
[Pack indexing](pack_indexing.html "cpp/language/pack indexing") (C++26)  
[SFINAE](sfinae.html "cpp/language/sfinae")  
[Constraints and concepts](constraints.html "cpp/language/constraints") (C++20)  
**requires expression** (C++20)  
  


Yields a prvalue expression of type bool that describes the constraints. 

## Contents

  * [1 Syntax](requires.html#Syntax)
  * [2 Explanation](requires.html#Explanation)
  * [3 Local parameters](requires.html#Local_parameters)
  * [4 Simple requirements](requires.html#Simple_requirements)
  * [5 Type requirements](requires.html#Type_requirements)
  * [6 Compound requirements](requires.html#Compound_requirements)
  * [7 Nested requirements](requires.html#Nested_requirements)
  * [8 Note](requires.html#Note)
  * [9 Keywords](requires.html#Keywords)
  * [10 Defect reports](requires.html#Defect_reports)
  * [11 References](requires.html#References)
  * [12 See also](requires.html#See_also)

  
---  
  
### Syntax  
  
---  
`**requires**` `**{**` requirement-seq `**}**` |  (1)  |   
`**requires**` `**(**` parameter-list ﻿(optional) `**)**` `**{**` requirement-seq `**}**` |  (2)  |   
parameter-list |  \-  |  a [parameter list](function.html#Parameter_list "cpp/language/function")  
---|---|---  
requirement-seq |  \-  |  sequence of _requirements_ , each requirement is one of the following: 

  * [simple requirement](requires.html#Simple_requirements)
  * [type requirement](requires.html#Type_requirements)
  * [compound requirement](requires.html#Compound_requirements)
  * [nested requirement](requires.html#Nested_requirements)

  
  
### Explanation

Requirements may refer to the template parameters that are in scope, to the parameters of parameter-list, and to any other declarations that are visible from the enclosing context. 

The substitution of template arguments into a requires expression used in a declaration of a [templated entity](templates.html#Templated_entity "cpp/language/templates") may result in the formation of invalid types or expressions in its requirements, or the violation of semantic constraints of those requirements. In such cases, the requires expression evaluates to false and does not cause the program to be ill-formed. The substitution and semantic constraint checking proceeds in lexical order and stops when a condition that determines the result of the requires expression is encountered. If substitution (if any) and semantic constraint checking succeed, the requires expression evaluates to true. 

If a substitution failure would occur in a requires expression for every possible template argument, the program is ill-formed, no diagnostic required: 
    
    
    template<class T>
    concept C = requires
    {
        new int[-(int)sizeof(T)]; // invalid for every T: ill-formed, no diagnostic required
    };

If a requires expression contains invalid types or expressions in its requirements, and it does not appear within the declaration of a [templated entity](templates.html#Templated_entity "cpp/language/templates"), then the program is ill-formed. 

### Local parameters

A requires expression can introduce local parameters using a [parameter list](function.html#Parameter_list "cpp/language/function"). These parameters have no linkage, storage, or lifetime; they are only used as notation for the purpose of defining requirements. 

The type of each parameter is determined by the same way as [determining the actual type](function.html#Function_type "cpp/language/function") of function parameters: 
    
    
    template<typename T>
    concept C = requires(T p[2])
    {
        (decltype(p))nullptr; // OK, p has type T*
    };

If any of the following conditions is satisfied, the program is ill-formed: 

  * A local parameter has a [default argument](default_arguments.html "cpp/language/default arguments"). 
  * The parameter list terminate with an ellipsis. 


    
    
    template<typename T>
    concept C1 = requires(T t = 0)  // Error: t has a default argument
    {
        t;
    };
     
    template<typename T>
    concept C2 = requires(T t, ...) // Error: terminates with an ellipsis
    {
        t;
    };

### Simple requirements  
  
---  
expression `**;**` |  |   
expression |  \-  |  an expression which does not start with requires  
---|---|---  
  
  
A simple requirement asserts that expression is valid. expression is an [unevaluated operand](expressions.html#Potentially-evaluated_expressions "cpp/language/expressions"). 
    
    
    template<typename T>
    concept Addable = requires (T a, T b)
    {
        a + b; // "the expression “a + b” is a valid expression that will compile"
    };
     
    template<class T, class U = T>
    concept Swappable = requires(T&& t, U&& u)
    {
        swap([std::forward](../utility/forward.html)<T>(t), [std::forward](../utility/forward.html)<U>(u));
        swap([std::forward](../utility/forward.html)<U>(u), [std::forward](../utility/forward.html)<T>(t));
    };

A requirement that starts with the keyword requires is always interpreted as a nested requirement. Thus a simple requirement cannot start with an unparenthesized requires expression. 

### Type requirements  
  
---  
`**typename**` identifier `**;**` |  |   
identifier |  \-  |  a (possibly qualified) [identifier](name.html "cpp/language/identifiers") (including [simple template identifier](templates.html#Template_identifiers "cpp/language/templates"))   
---|---|---  
  
  
A type requirement asserts that the type named by identifier is valid: this can be used to verify that a certain named nested type exists, or that a class/alias template specialization names a type. A type requirement naming a class template specialization does not require the type to be complete. 
    
    
    template<typename T>
    using Ref = T&;
     
    template<typename T>
    concept C = requires
    {
        typename T::inner; // required nested member name
        typename S<T>;     // required class template specialization
        typename Ref<T>;   // required alias template substitution
    };
     
    template<class T, class U>
    using CommonType = [std::common_type_t](../types/common_type.html)<T, U>;
     
    template<class T, class U>
    concept Common = requires (T&& t, U&& u)
    {
        typename CommonType<T, U>; // CommonType<T, U> is valid and names a type
        { CommonType<T, U>{[std::forward](../utility/forward.html)<T>(t)} }; 
        { CommonType<T, U>{[std::forward](../utility/forward.html)<U>(u)} }; 
    };

### Compound requirements  
  
---  
`**{**` expression `**};**` |  (1)  |   
`**{**` expression `**}**` `**noexcept**` `**;**` |  (2)  |   
`**{**` expression `**} - >**` type-constraint `**;**` |  (3)  |   
`**{**` expression `**}**` `**noexcept - >**` type-constraint `**;**` |  (4)  |   
expression |  \-  |  an expression   
---|---|---  
type-constraint |  \-  |  a [constraint](constraints.html#Constraints "cpp/language/constraints")  
  
  
A compound requirement asserts properties of expression ﻿. Substitution and semantic constraint checking proceeds in the following order: 

1) Template arguments (if any) are substituted into expression ﻿.

2) If `**noexcept**` is present, expression must not be [potentially throwing](noexcept.html "cpp/language/noexcept").

3) If type-constraint is present, then:

a) Template arguments are substituted into type-constraint ﻿.

b) decltype((expression ﻿)) must satisfy the constraint imposed by type-constraint ﻿. Otherwise, the enclosing requires expression is false.

expression is an [unevaluated operand](expressions.html#Potentially-evaluated_expressions "cpp/language/expressions"). 
    
    
    template<typename T>
    concept C2 = requires(T x)
    {
        // the expression *x must be valid
        // AND the type T::inner must be valid
        // AND the result of *x must be convertible to T::inner
        {*x} -> [std::convertible_to](../concepts/convertible_to.html)<typename T::inner>;
     
        // the expression x + 1 must be valid
        // AND std::same_as<decltype((x + 1)), int> must be satisfied
        // i.e., (x + 1) must be a prvalue of type int
        {x + 1} -> [std::same_as](../concepts/same_as.html)<int>;
     
        // the expression x * 1 must be valid
        // AND its result must be convertible to T
        {x * 1} -> [std::convertible_to](../concepts/convertible_to.html)<T>;
    };

### Nested requirements  
  
---  
`**requires**` constraint-expression `**;**` |  |   
constraint-expression |  \-  |  an expression representing [constraints](constraints.html "cpp/language/constraints")  
---|---|---  
  
  
A nested requirement can be used to specify additional constraints in terms of local parameters. constraint-expression must be satisfied by the substituted template arguments, if any. Substitution of template arguments into a nested requirement causes substitution into constraint-expression only to the extent needed to determine whether constraint-expression is satisfied. 
    
    
    template<class T>
    concept Semiregular = DefaultConstructible<T> &&
        CopyConstructible<T> && CopyAssignable<T> && Destructible<T> &&
    requires(T a, [std::size_t](../types/size_t.html) n)
    {  
        requires Same<T*, decltype(&a)>; // nested: "Same<...> evaluates to true"
        { a.~T() } noexcept; // compound: "a.~T()" is a valid expression that doesn't throw
        requires Same<T*, decltype(new T)>; // nested: "Same<...> evaluates to true"
        requires Same<T*, decltype(new T[n])>; // nested
        { delete new T }; // compound
        { delete new T[n] }; // compound
    };

### Note

The keyword requires is also used to introduce [requires clauses](constraints.html#Requires_clauses "cpp/language/constraints"). 
    
    
    template<typename T>
    concept Addable = requires (T x) { x + x; }; // requires expression
     
    template<typename T> requires Addable<T> // requires clause, not requires expression
    T add(T a, T b) { return a + b; }
     
    template<typename T>
        requires requires (T x) { x + x; } // ad-hoc constraint, note keyword used twice
    T add(T a, T b) { return a + b; }

### Keywords

[`requires`](../keyword/requires.html "cpp/keyword/requires")

### Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[CWG 2560](https://cplusplus.github.io/CWG/issues/2560.html) | C++20  | it was unclear whether parameter types are adjusted in requires expressions  | also adjusted   
[CWG 2911](https://cplusplus.github.io/CWG/issues/2911.html) | C++20  | all expressions appearing within requires  
expressions were unevaluated operands  | only some  
expressions are   
  
### References

  * C++23 standard (ISO/IEC 14882:2024): 



    

  * 7.5.7 Requires expressions [expr.prim.req] 



  * C++20 standard (ISO/IEC 14882:2020): 



    

  * 7.5.7 Requires expressions [expr.prim.req] 



### See also

[ Constraints and concepts](constraints.html "cpp/language/constraints")(C++20) |  specifies the requirements on template arguments  
---|---
