
  


[Memory management library](../memory.html "cpp/memory")

| [_voidify_](voidify.html "cpp/memory/voidify")(exposition only*)  
---  
[Allocators](../memory.html#Allocators "cpp/memory")  
| [allocator](allocator.html "cpp/memory/allocator")  
---  
[allocator_traits](allocator_traits.html "cpp/memory/allocator traits")(C++11)  
[allocation_result](allocation_result.html "cpp/memory/allocation result")(C++23)  
[scoped_allocator_adaptor](scoped_allocator_adaptor.html "cpp/memory/scoped allocator adaptor")(C++11)  
[pmr::polymorphic_allocator](polymorphic_allocator.html "cpp/memory/polymorphic allocator")(C++17)  
  
| [allocator_arg](allocator_arg.html "cpp/memory/allocator arg")(C++11)  
---  
[uses_allocator](uses_allocator.html "cpp/memory/uses allocator")(C++11)  
[uses_allocator_construction_args](uses_allocator_construction_args.html "cpp/memory/uses allocator construction args")(C++20)  
[make_obj_using_allocator](make_obj_using_allocator.html "cpp/memory/make obj using allocator")(C++20)  
[uninitialized_construct_using_allocator](uninitialized_construct_using_allocator.html "cpp/memory/uninitialized construct using allocator")(C++20)  
  
[Uninitialized memory algorithms](../memory.html#Uninitialized_memory_algorithms "cpp/memory")  
| [uninitialized_copy](uninitialized_copy.html "cpp/memory/uninitialized copy")  
---  
[uninitialized_fill](uninitialized_fill.html "cpp/memory/uninitialized fill")  
[uninitialized_move](uninitialized_move.html "cpp/memory/uninitialized move")(C++17)  
[uninitialized_copy_n](uninitialized_copy_n.html "cpp/memory/uninitialized copy n")(C++11)  
[uninitialized_fill_n](uninitialized_fill_n.html "cpp/memory/uninitialized fill n")  
[uninitialized_move_n](uninitialized_move_n.html "cpp/memory/uninitialized move n")(C++17)  
[construct_at](construct_at.html "cpp/memory/construct at")(C++20)  
  
| [uninitialized_default_construct](uninitialized_default_construct.html "cpp/memory/uninitialized default construct")(C++17)  
---  
[uninitialized_value_construct](uninitialized_value_construct.html "cpp/memory/uninitialized value construct")(C++17)  
[destroy](destroy.html "cpp/memory/destroy")(C++17)  
[uninitialized_default_construct_n](uninitialized_default_construct_n.html "cpp/memory/uninitialized default construct n")(C++17)  
[uninitialized_value_construct_n](uninitialized_value_construct_n.html "cpp/memory/uninitialized value construct n")(C++17)  
[destroy_n](destroy_n.html "cpp/memory/destroy n")(C++17)  
[destroy_at](destroy_at.html "cpp/memory/destroy at")(C++17)  
  
[Constrained uninitialized memory algorithms](../memory.html#Constrained_uninitialized_memory_algorithms "cpp/memory")  
| [ranges::uninitialized_copy](ranges/uninitialized_copy.html "cpp/memory/ranges/uninitialized copy")(C++20)  
---  
[ranges::uninitialized_fill](ranges/uninitialized_fill.html "cpp/memory/ranges/uninitialized fill")(C++20)  
[ranges::uninitialized_move](ranges/uninitialized_move.html "cpp/memory/ranges/uninitialized move")(C++20)  
[ranges::uninitialized_copy_n](ranges/uninitialized_copy_n.html "cpp/memory/ranges/uninitialized copy n")(C++20)` `  
[ranges::uninitialized_fill_n](ranges/uninitialized_fill_n.html "cpp/memory/ranges/uninitialized fill n")(C++20)  
[ranges::uninitialized_move_n](ranges/uninitialized_move_n.html "cpp/memory/ranges/uninitialized move n")(C++20)  
[ranges::construct_at](ranges/construct_at.html "cpp/memory/ranges/construct at")(C++20)  
  
| [ranges::uninitialized_default_construct](ranges/uninitialized_default_construct.html "cpp/memory/ranges/uninitialized default construct")(C++20)  
---  
[ranges::uninitialized_value_construct](ranges/uninitialized_value_construct.html "cpp/memory/ranges/uninitialized value construct")(C++20)  
[ranges::destroy](ranges/destroy.html "cpp/memory/ranges/destroy")(C++20)  
[ranges::uninitialized_default_construct_n](ranges/uninitialized_default_construct_n.html "cpp/memory/ranges/uninitialized default construct n")(C++20)` `  
[ranges::uninitialized_value_construct_n](ranges/uninitialized_value_construct_n.html "cpp/memory/ranges/uninitialized value construct n")(C++20)  
[ranges::destroy_n](ranges/destroy_n.html "cpp/memory/ranges/destroy n")(C++20)  
[ranges::destroy_at](ranges/destroy_at.html "cpp/memory/ranges/destroy at")(C++20)  
  
[Memory resources](../memory.html#Memory_resources "cpp/memory")  
| [pmr::memory_resource](memory_resource.html "cpp/memory/memory resource")(C++17)  
---  
[pmr::get_default_resource](get_default_resource.html "cpp/memory/get default resource")(C++17)  
[pmr::set_default_resource](set_default_resource.html "cpp/memory/set default resource")(C++17)  
[pmr::new_delete_resource](new_delete_resource.html "cpp/memory/new delete resource")(C++17)  
[pmr::pool_options](pool_options.html "cpp/memory/pool options")(C++17)  
  
| [pmr::null_memory_resource](null_memory_resource.html "cpp/memory/null memory resource")(C++17)  
---  
[pmr::synchronized_pool_resource](synchronized_pool_resource.html "cpp/memory/synchronized pool resource")(C++17)  
[pmr::unsynchronized_pool_resource](unsynchronized_pool_resource.html "cpp/memory/unsynchronized pool resource")(C++17)  
[pmr::monotonic_buffer_resource](monotonic_buffer_resource.html "cpp/memory/monotonic buffer resource")(C++17)  
  
  
  
| [Explicit lifetime management](../memory.html#Explicit_lifetime_management "cpp/memory")  
---  
[start_lifetime_as](start_lifetime_as.html "cpp/memory/start lifetime as")(C++23)  
[start_lifetime_as_array](start_lifetime_as.html "cpp/memory/start lifetime as")(C++23)  
  
| [Types for composite class design](../memory.html#Types_for_composite_class_design "cpp/memory")  
---  
[indirect](indirect.html "cpp/memory/indirect")(C++26)  
[polymorphic](polymorphic.html "cpp/memory/polymorphic")(C++26)  
  
[Uninitialized storage](../memory.html#Uninitialized_storage "cpp/memory") (until C++20)  
| [raw_storage_iterator](raw_storage_iterator.html "cpp/memory/raw storage iterator")(until C++20*)  
---  
[get_temporary_buffer](get_temporary_buffer.html "cpp/memory/get temporary buffer")(until C++20*)  
  
| [return_temporary_buffer](return_temporary_buffer.html "cpp/memory/return temporary buffer")(until C++20*)  
---  
  
  
  
[Garbage collector support](../memory.html#Garbage_collector_support "cpp/memory") (until C++23)  
| [declare_reachable](gc/declare_reachable.html "cpp/memory/gc/declare reachable")(C++11)(until C++23)  
---  
[declare_no_pointers](gc/declare_no_pointers.html "cpp/memory/gc/declare no pointers")(C++11)(until C++23)  
[pointer_safety](gc/pointer_safety.html "cpp/memory/gc/pointer safety")(C++11)(until C++23)  
  
| [undeclare_reachable](gc/undeclare_reachable.html "cpp/memory/gc/undeclare reachable")(C++11)(until C++23)  
---  
[undeclare_no_pointers](gc/undeclare_no_pointers.html "cpp/memory/gc/undeclare no pointers")(C++11)(until C++23)  
[get_pointer_safety](gc/get_pointer_safety.html "cpp/memory/gc/get pointer safety")(C++11)(until C++23)  
  
| [Low level memory  
management](new.html#Low_level_memory_management "cpp/memory/new")  
---  
[operator newoperator new[]](new/operator_new.html "cpp/memory/new/operator new")  
[operator deleteoperator delete[]](new/operator_delete.html "cpp/memory/new/operator delete")  
[nothrow_t](new/nothrow_t.html "cpp/memory/new/nothrow t")  
[nothrow](new/nothrow.html "cpp/memory/new/nothrow")  
[new_handler](new/new_handler.html "cpp/memory/new/new handler")  
[set_new_handler](new/set_new_handler.html "cpp/memory/new/set new handler")  
[get_new_handler](new/get_new_handler.html "cpp/memory/new/get new handler")(C++11)  
[bad_alloc](new/bad_alloc.html "cpp/memory/new/bad alloc")  
[bad_array_new_length](new/bad_array_new_length.html "cpp/memory/new/bad array new length")(C++11)  
[align_val_t](new/align_val_t.html "cpp/memory/new/align val t")(C++17)  
[destroying_delete_t](new/destroying_delete_t.html "cpp/memory/new/destroying delete t")(C++20)  
[launder](../utility/launder.html "cpp/utility/launder")(C++17)  
[Smart pointers](../memory.html#Smart_pointers "cpp/memory")  
[unique_ptr](unique_ptr.html "cpp/memory/unique ptr")(C++11)  
**shared_ptr**(C++11)  
[weak_ptr](weak_ptr.html "cpp/memory/weak ptr")(C++11)  
[auto_ptr](auto_ptr.html "cpp/memory/auto ptr")(until C++17*)  
[owner_less](owner_less.html "cpp/memory/owner less")(C++11)  
[owner_less<void>](owner_less_void.html "cpp/memory/owner less void")(C++17)  
[owner_hash](owner_hash.html "cpp/memory/owner hash")(C++26)  
[owner_equal](owner_equal.html "cpp/memory/owner equal")(C++26)  
[enable_shared_from_this](enable_shared_from_this.html "cpp/memory/enable shared from this")(C++11)  
[bad_weak_ptr](bad_weak_ptr.html "cpp/memory/bad weak ptr")(C++11)  
[default_delete](default_delete.html "cpp/memory/default delete")(C++11)  
[out_ptr_t](out_ptr_t.html "cpp/memory/out ptr t")(C++23)  
[inout_ptr_t](inout_ptr_t.html "cpp/memory/inout ptr t")(C++23)  
[Miscellaneous](../memory.html#Miscellaneous "cpp/memory")  
[pointer_traits](pointer_traits.html "cpp/memory/pointer traits")(C++11)  
[to_address](to_address.html "cpp/memory/to address")(C++20)  
[addressof](addressof.html "cpp/memory/addressof")(C++11)  
[align](align.html "cpp/memory/align")(C++11)  
[assume_aligned](assume_aligned.html "cpp/memory/assume aligned")(C++20)  
[is_sufficiently_aligned](is_sufficiently_aligned.html "cpp/memory/is sufficiently aligned")(C++26)  
[C Library](c.html "cpp/memory/c")  
| [malloc](c/malloc.html "cpp/memory/c/malloc")  
---  
[calloc](c/calloc.html "cpp/memory/c/calloc")  
[realloc](c/realloc.html "cpp/memory/c/realloc")  
  
| [free](c/free.html "cpp/memory/c/free")  
---  
[aligned_alloc](c/aligned_alloc.html "cpp/memory/c/aligned alloc")(C++17)  
  
  
  


**`std::shared_ptr`**

Member functions  
---  
[shared_ptr::shared_ptr](shared_ptr/shared_ptr.html "cpp/memory/shared ptr/shared ptr")  
[shared_ptr::~shared_ptr](shared_ptr/~shared_ptr.html "cpp/memory/shared ptr/~shared ptr")  
[shared_ptr::operator=](shared_ptr/operator=.html "cpp/memory/shared ptr/operator=")  
Modifiers  
[shared_ptr::reset](shared_ptr/reset.html "cpp/memory/shared ptr/reset")  
[shared_ptr::swap](shared_ptr/swap.html "cpp/memory/shared ptr/swap")  
Observers  
[shared_ptr::get](shared_ptr/get.html "cpp/memory/shared ptr/get")  
[shared_ptr::operator*shared_ptr::operator->](shared_ptr/operator*.html "cpp/memory/shared ptr/operator*")  
[shared_ptr::operator[]](shared_ptr/operator_at.html "cpp/memory/shared ptr/operator at")(C++17)  
[shared_ptr::use_count](shared_ptr/use_count.html "cpp/memory/shared ptr/use count")  
[shared_ptr::unique](shared_ptr/unique.html "cpp/memory/shared ptr/unique")(until C++20*)  
[shared_ptr::operator bool](shared_ptr/operator_bool.html "cpp/memory/shared ptr/operator bool")  
[shared_ptr::owner_before](shared_ptr/owner_before.html "cpp/memory/shared ptr/owner before")  
[shared_ptr::owner_hash](shared_ptr/owner_hash.html "cpp/memory/shared ptr/owner hash")(C++26)  
[shared_ptr::owner_equal](shared_ptr/owner_equal.html "cpp/memory/shared ptr/owner equal")(C++26)  
Non-member functions  
[swap(std::shared_ptr)](shared_ptr/swap2.html "cpp/memory/shared ptr/swap2")  
[make_sharedmake_shared_for_overwrite](shared_ptr/make_shared.html "cpp/memory/shared ptr/make shared")(C++20)  
[allocate_sharedallocate_shared_for_overwrite](shared_ptr/allocate_shared.html "cpp/memory/shared ptr/allocate shared")(C++20)  
[static_pointer_castdynamic_pointer_castconst_pointer_castreinterpret_pointer_cast](shared_ptr/pointer_cast.html "cpp/memory/shared ptr/pointer cast")(C++17)  
[get_deleter](shared_ptr/get_deleter.html "cpp/memory/shared ptr/get deleter")  
[operator==operator!=operator<operator<=operator>operator>=operator<=>](shared_ptr/operator_cmp.html "cpp/memory/shared ptr/operator cmp")(until C++20)(until C++20)(until C++20)(until C++20)(until C++20)(C++20)  
[operator<<](shared_ptr/operator_ltlt.html "cpp/memory/shared ptr/operator ltlt")  
[atomic_xxx](shared_ptr/atomic.html "cpp/memory/shared ptr/atomic")functions (until C++26*)  
Helper classes  
[atomic<std::shared_ptr>](shared_ptr/atomic2.html "cpp/memory/shared ptr/atomic2")(C++20)  
[hash<std::shared_ptr>](shared_ptr/hash.html "cpp/memory/shared ptr/hash")  
[Deduction guides](shared_ptr/deduction_guides.html "cpp/memory/shared ptr/deduction guides")(C++17)  
  


Defined in header `[<memory>](../header/memory.html "cpp/header/memory")` |  |   
---|---|---  
template< class T > class shared_ptr; |  |  (since C++11)  
| |   
  
`std::shared_ptr` is a smart pointer that retains shared ownership of an object through a pointer. Several `shared_ptr` objects may own the same object. The object is destroyed and its memory deallocated when either of the following happens: 

  * the last remaining `shared_ptr` owning the object is destroyed; 
  * the last remaining `shared_ptr` owning the object is assigned another pointer via [operator=](shared_ptr/operator=.html "cpp/memory/shared ptr/operator=") or [reset()](shared_ptr/reset.html "cpp/memory/shared ptr/reset"). 



The object is destroyed using [delete-expression](../language/delete.html "cpp/language/delete") or a custom deleter that is supplied to `shared_ptr` during construction. 

A `shared_ptr` can share ownership of an object while storing a pointer to another object. This feature can be used to point to member objects while owning the object they belong to. The stored pointer is the one accessed by [get()](shared_ptr/get.html "cpp/memory/shared ptr/get"), the dereference and the comparison operators. The managed pointer is the one passed to the deleter when use count reaches zero. 

A `shared_ptr` may also own no objects, in which case it is called _empty_ (an empty `shared_ptr` may have a non-null stored pointer if the aliasing constructor was used to create it). 

All specializations of `shared_ptr` meet the requirements of [CopyConstructible](../named_req/CopyConstructible.html "cpp/named req/CopyConstructible"), [CopyAssignable](../named_req/CopyAssignable.html "cpp/named req/CopyAssignable"), and [LessThanComparable](../named_req/LessThanComparable.html "cpp/named req/LessThanComparable") and are [contextually convertible](../language/implicit_cast.html "cpp/language/implicit cast") to `bool`. 

All member functions (including copy constructor and copy assignment) can be called by multiple threads on different `shared_ptr` objects without additional synchronization even if these objects are copies and share ownership of the same object. If multiple threads of execution access the same `shared_ptr` object without synchronization and any of those accesses uses a non-const member function of `shared_ptr` then a data race will occur; the [`std::atomic<shared_ptr>`](shared_ptr/atomic2.html "cpp/memory/shared ptr/atomic2") can be used to prevent the data race. 

## Contents

  * [1 Member types](shared_ptr.html#Member_types)
  * [2 Member functions](shared_ptr.html#Member_functions)
    * [2.1 Modifiers](shared_ptr.html#Modifiers)
    * [2.2 Observers](shared_ptr.html#Observers)
  * [3 Non-member functions](shared_ptr.html#Non-member_functions)
  * [4 Helper classes](shared_ptr.html#Helper_classes)
  * [5 Deduction guides (since C++17)](shared_ptr.html#Deduction_guides_.28since_C.2B.2B17.29)
  * [6 Notes](shared_ptr.html#Notes)
  * [7 Implementation notes](shared_ptr.html#Implementation_notes)
  * [8 Example](shared_ptr.html#Example)
  * [9 Example](shared_ptr.html#Example_2)
  * [10 See also](shared_ptr.html#See_also)

  
---  
  
### Member types

Member type  |  Definition   
---|---  
`element_type` |  | T | (until C++17)  
---|---  
[std::remove_extent_t](../types/remove_extent.html)<T> | (since C++17)  
`weak_type` (since C++17) |  [std::weak_ptr](weak_ptr.html)<T>  
  
### Member functions

[ (constructor)](shared_ptr/shared_ptr.html "cpp/memory/shared ptr/shared ptr") |  constructs new `shared_ptr`   
(public member function)   
---|---  
[ (destructor)](shared_ptr/~shared_ptr.html "cpp/memory/shared ptr/~shared ptr") |  destructs the owned object if no more `shared_ptr`s link to it   
(public member function)   
[ operator=](shared_ptr/operator=.html "cpp/memory/shared ptr/operator=") |  assigns the `shared_ptr`   
(public member function)   
  
#####  Modifiers   
  
[ reset](shared_ptr/reset.html "cpp/memory/shared ptr/reset") |  replaces the managed object   
(public member function)   
[ swap](shared_ptr/swap.html "cpp/memory/shared ptr/swap") |  swaps the managed objects   
(public member function)   
  
#####  Observers   
  
[ get](shared_ptr/get.html "cpp/memory/shared ptr/get") |  returns the stored pointer   
(public member function)   
[ operator*operator->](shared_ptr/operator*.html "cpp/memory/shared ptr/operator*") |  dereferences the stored pointer   
(public member function)   
[ operator[]](shared_ptr/operator_at.html "cpp/memory/shared ptr/operator at")(C++17) |  provides indexed access to the stored array   
(public member function)   
[ use_count](shared_ptr/use_count.html "cpp/memory/shared ptr/use count") |  returns the number of `shared_ptr` objects referring to the same managed object   
(public member function)   
[ unique](shared_ptr/unique.html "cpp/memory/shared ptr/unique")(until C++20) |  checks whether the managed object is managed only by the current `shared_ptr` object   
(public member function)   
[ operator bool](shared_ptr/operator_bool.html "cpp/memory/shared ptr/operator bool") |  checks if the stored pointer is not null   
(public member function)   
[ owner_before](shared_ptr/owner_before.html "cpp/memory/shared ptr/owner before") |  provides owner-based ordering of shared pointers   
(public member function)   
[ owner_hash](shared_ptr/owner_hash.html "cpp/memory/shared ptr/owner hash")(C++26) |  provides owner-based hashing of shared pointers   
(public member function)   
[ owner_equal](shared_ptr/owner_equal.html "cpp/memory/shared ptr/owner equal")(C++26) |  provides owner-based equal comparison of shared pointers   
(public member function)   
  
### Non-member functions

[ make_sharedmake_shared_for_overwrite](shared_ptr/make_shared.html "cpp/memory/shared ptr/make shared")(C++20) |  creates a shared pointer that manages a new object   
(function template)   
---|---  
[ allocate_sharedallocate_shared_for_overwrite](shared_ptr/allocate_shared.html "cpp/memory/shared ptr/allocate shared")(C++20) |  creates a shared pointer that manages a new object allocated using an allocator   
(function template)   
[ static_pointer_castdynamic_pointer_castconst_pointer_castreinterpret_pointer_cast](shared_ptr/pointer_cast.html "cpp/memory/shared ptr/pointer cast")(C++17) |  applies [`static_cast`](../language/static_cast.html "cpp/language/static cast"), [`dynamic_cast`](../language/dynamic_cast.html "cpp/language/dynamic cast"), [`const_cast`](../language/const_cast.html "cpp/language/const cast"), or [`reinterpret_cast`](../language/reinterpret_cast.html "cpp/language/reinterpret cast") to the stored pointer   
(function template)   
[ get_deleter](shared_ptr/get_deleter.html "cpp/memory/shared ptr/get deleter") |  returns the deleter of specified type, if owned   
(function template)   
[ operator==operator!=operator<operator<=operator>operator>=operator<=>](shared_ptr/operator_cmp.html "cpp/memory/shared ptr/operator cmp")(removed in C++20)(removed in C++20)(removed in C++20)(removed in C++20)(removed in C++20)(C++20) |  compares with another `shared_ptr` or with nullptr   
(function template)   
[ operator<<(std::shared_ptr)](shared_ptr/operator_ltlt.html "cpp/memory/shared ptr/operator ltlt") |  outputs the value of the stored pointer to an output stream   
(function template)   
[ std::swap(std::shared_ptr)](shared_ptr/swap2.html "cpp/memory/shared ptr/swap2")(C++11) |  specializes the [std::swap](../utility/swap.html "cpp/algorithm/swap") algorithm   
(function template)   
[ std::atomic_is_lock_free(std::shared_ptr)std::atomic_load(std::shared_ptr)std::atomic_load_explicit(std::shared_ptr)std::atomic_store(std::shared_ptr)std::atomic_store_explicit(std::shared_ptr)std::atomic_exchange(std::shared_ptr)std::atomic_exchange_explicit(std::shared_ptr)std::atomic_compare_exchange_weak(std::shared_ptr)std::atomic_compare_exchange_strong(std::shared_ptr)std::atomic_compare_exchange_weak_explicit(std::shared_ptr)std::atomic_compare_exchange_strong_explicit(std::shared_ptr)](shared_ptr/atomic.html "cpp/memory/shared ptr/atomic")(deprecated in C++20)(removed in C++26) |  specializes atomic operations for `std::shared_ptr`   
(function template)   
---|---  
  
### Helper classes

[ std::atomic<std::shared_ptr>](shared_ptr/atomic2.html "cpp/memory/shared ptr/atomic2")(C++20) |  atomic shared pointer   
(class template specialization)   
---|---  
[ std::hash<std::shared_ptr>](shared_ptr/hash.html "cpp/memory/shared ptr/hash")(C++11) |  hash support for **`std::shared_ptr`**   
(class template specialization)   
  
### [Deduction guides](shared_ptr/deduction_guides.html "cpp/memory/shared ptr/deduction guides") (since C++17)

### Notes

Ownership of an object can only be shared through construction or assignment functions that receive another `shared_ptr` object. If a new `shared_ptr` is constructed solely using the raw underlying pointer held by another `shared_ptr`, this new `shared_ptr` will assume no other `shared_ptr` instances hold the object it possesses. This will result in (unless subsequent assignment occurs) the repeated application of the deleter to the same object during destruction. 

`std::shared_ptr` may be used with an [incomplete type](../language/incomplete_type.html "cpp/language/incomplete type") `T`. However, the constructor from a raw pointer (template<class Y> shared_ptr(Y*)) and the template<class Y> void reset(Y*) member function may only be called with a pointer to a complete type (note that [std::unique_ptr](unique_ptr.html "cpp/memory/unique ptr") may be constructed from a raw pointer to an incomplete type). 

The `T` in std::shared_ptr<T> may be a function type: in this case it manages a pointer to function, rather than an object pointer. This is sometimes used to keep a dynamic library or a plugin loaded as long as any of its functions are referenced: 
    
    
    void del(void(*)()) {}
     
    void fun() {}
     
    int main()
    {
        std::shared_ptr<void()> ee(fun, del);
        (*ee)();
    }

### Implementation notes

In a typical implementation, `shared_ptr` holds only two pointers: 

  * the stored pointer (one returned by [get()](shared_ptr/get.html "cpp/memory/shared ptr/get")); 
  * a pointer to _control block_. 



The control block is a dynamically-allocated object that holds: 

  * either a pointer to the managed object or the managed object itself; 
  * the deleter (type-erased); 
  * the allocator (type-erased); 
  * the number of `shared_ptr`s that own the managed object; 
  * the number of `weak_ptr`s that refer to the managed object. 



When `shared_ptr` is created by calling [std::make_shared](shared_ptr/make_shared.html "cpp/memory/shared ptr/make shared") or [std::allocate_shared](shared_ptr/allocate_shared.html "cpp/memory/shared ptr/allocate shared"), the memory for both the control block and the managed object is created with a single allocation. The managed object is constructed in-place in a data member of the control block. When `shared_ptr` is created via one of the `shared_ptr` constructors, the managed object and the control block must be allocated separately. In this case, the control block stores a pointer to the managed object. 

The pointer held by the `shared_ptr` directly is the one returned by [get()](shared_ptr/get.html "cpp/memory/shared ptr/get"), while the pointer/object held by the control block is the one that will be deleted when the number of shared owners reaches zero. These pointers are not necessarily equal. 

The destructor of `shared_ptr` decrements the number of shared owners of the control block. If that counter reaches zero, the control block calls the destructor of the managed object. The control block does not deallocate itself until the [std::weak_ptr](weak_ptr.html "cpp/memory/weak ptr") counter reaches zero as well. 

In existing implementations, the number of weak pointers is incremented ([[1]](https://stackoverflow.com/questions/43297517/stdshared-ptr-internals-weak-count-more-than-expected), [[2]](https://www.reddit.com/r/cpp/comments/3eia29/stdshared_ptrs_secret_constructor/ctfeh1p)) if there is a shared pointer to the same control block. 

To satisfy thread safety requirements, the reference counters are typically incremented using an equivalent of [std::atomic::fetch_add](../atomic/atomic/fetch_add.html "cpp/atomic/atomic/fetch add") with [std::memory_order_relaxed](../atomic/memory_order.html "cpp/atomic/memory order") (decrementing requires stronger ordering to safely destroy the control block). 

### Example

Run this code
    
    
    #include <chrono>
    #include <iostream>
    #include <memory>
    #include <mutex>
    #include <thread>
     
    using namespace std::chrono_literals;
     
    struct Base
    {
        Base() { [std::cout](../io/cout.html) << "Base::Base()\n"; }
     
        // Note: non-virtual destructor is OK here
        ~Base() { [std::cout](../io/cout.html) << "Base::~Base()\n"; }
    };
     
    struct Derived : public Base
    {
        Derived() { [std::cout](../io/cout.html) << "Derived::Derived()\n"; }
     
        ~Derived() { [std::cout](../io/cout.html) << "Derived::~Derived()\n"; }
    };
     
    void print(auto rem, std::shared_ptr<Base> const& sp)
    {
        [std::cout](../io/cout.html) << rem << "\n\tget() = " << sp.get()
                  << ", use_count() = " << sp.use_count() << '\n';
    }
     
    void thr(std::shared_ptr<Base> p)
    {
        [std::this_thread::sleep_for](../thread/sleep_for.html)(987ms);
        std::shared_ptr<Base> lp = p; // thread-safe, even though the
                                      // shared use_count is incremented
        {
            static [std::mutex](../thread/mutex.html) io_mutex;
            [std::lock_guard](../thread/lock_guard.html)<[std::mutex](../thread/mutex.html)> lk(io_mutex);
            print("Local pointer in a thread:", lp);
        }
    }
     
    int main()
    {
        std::shared_ptr<Base> p = [std::make_shared](shared_ptr/make_shared.html)<Derived>();
     
        print("Created a shared Derived (as a pointer to Base)", p);
     
        [std::thread](../thread/thread.html) t1{thr, p}, t2{thr, p}, t3{thr, p};
        p.reset(); // release ownership from main
     
        print("Shared ownership between 3 threads and released ownership from main:", p);
     
        t1.join();
        t2.join();
        t3.join();
     
        [std::cout](../io/cout.html) << "All threads completed, the last one deleted Derived.\n";
    }

Possible output: 
    
    
    Base::Base()
    Derived::Derived()
    Created a shared Derived (as a pointer to Base)
    	get() = 0x118ac30, use_count() = 1
    Shared ownership between 3 threads and released ownership from main:
    	get() = 0, use_count() = 0
    Local pointer in a thread:
    	get() = 0x118ac30, use_count() = 5
    Local pointer in a thread:
    	get() = 0x118ac30, use_count() = 4
    Local pointer in a thread:
    	get() = 0x118ac30, use_count() = 2
    Derived::~Derived()
    Base::~Base()
    All threads completed, the last one deleted Derived.

### Example

Run this code
    
    
    #include <iostream>
    #include <memory>
     
    struct MyObj
    {
        MyObj() { [std::cout](../io/cout.html) << "MyObj constructed\n"; }
     
        ~MyObj() { [std::cout](../io/cout.html) << "MyObj destructed\n"; }
    };
     
    struct Container : [std::enable_shared_from_this](enable_shared_from_this.html)<Container> // note: public inheritance
    {
        std::shared_ptr<MyObj> memberObj;
     
        void CreateMember() { memberObj = [std::make_shared](shared_ptr/make_shared.html)<MyObj>(); }
     
        std::shared_ptr<MyObj> GetAsMyObj()
        {
            // Use an alias shared ptr for member
            return std::shared_ptr<MyObj>(shared_from_this(), memberObj.get());
        }
    };
     
    #define COUT(str) std::cout << '\n' << str << '\n'
     
    #define DEMO(...) std::cout << #__VA_ARGS__ << " = " << __VA_ARGS__ << '\n'
     
    int main()
    {
        COUT("Creating shared container");
        std::shared_ptr<Container> cont = [std::make_shared](shared_ptr/make_shared.html)<Container>();
        DEMO(cont.use_count());
        DEMO(cont->memberObj.use_count());
     
        COUT("Creating member");
        cont->CreateMember();
        DEMO(cont.use_count());
        DEMO(cont->memberObj.use_count());
     
        COUT("Creating another shared container");
        std::shared_ptr<Container> cont2 = cont;
        DEMO(cont.use_count());
        DEMO(cont->memberObj.use_count());
        DEMO(cont2.use_count());
        DEMO(cont2->memberObj.use_count());
     
        COUT("GetAsMyObj");
        std::shared_ptr<MyObj> myobj1 = cont->GetAsMyObj();
        DEMO(myobj1.use_count());
        DEMO(cont.use_count());
        DEMO(cont->memberObj.use_count());
        DEMO(cont2.use_count());
        DEMO(cont2->memberObj.use_count());
     
        COUT("Copying alias obj");
        std::shared_ptr<MyObj> myobj2 = myobj1;
        DEMO(myobj1.use_count());
        DEMO(myobj2.use_count());
        DEMO(cont.use_count());
        DEMO(cont->memberObj.use_count());
        DEMO(cont2.use_count());
        DEMO(cont2->memberObj.use_count());
     
        COUT("Resetting cont2");
        cont2.reset();
        DEMO(myobj1.use_count());
        DEMO(myobj2.use_count());
        DEMO(cont.use_count());
        DEMO(cont->memberObj.use_count());
     
        COUT("Resetting myobj2");
        myobj2.reset();
        DEMO(myobj1.use_count());
        DEMO(cont.use_count());
        DEMO(cont->memberObj.use_count());
     
        COUT("Resetting cont");
        cont.reset();
        DEMO(myobj1.use_count());
        DEMO(cont.use_count());
    }

Output: 
    
    
    Creating shared container
    cont.use_count() = 1
    cont->memberObj.use_count() = 0
     
    Creating member
    MyObj constructed
    cont.use_count() = 1
    cont->memberObj.use_count() = 1
     
    Creating another shared container
    cont.use_count() = 2
    cont->memberObj.use_count() = 1
    cont2.use_count() = 2
    cont2->memberObj.use_count() = 1
     
    GetAsMyObj
    myobj1.use_count() = 3
    cont.use_count() = 3
    cont->memberObj.use_count() = 1
    cont2.use_count() = 3
    cont2->memberObj.use_count() = 1
     
    Copying alias obj
    myobj1.use_count() = 4
    myobj2.use_count() = 4
    cont.use_count() = 4
    cont->memberObj.use_count() = 1
    cont2.use_count() = 4
    cont2->memberObj.use_count() = 1
     
    Resetting cont2
    myobj1.use_count() = 3
    myobj2.use_count() = 3
    cont.use_count() = 3
    cont->memberObj.use_count() = 1
     
    Resetting myobj2
    myobj1.use_count() = 2
    cont.use_count() = 2
    cont->memberObj.use_count() = 1
     
    Resetting cont
    myobj1.use_count() = 1
    cont.use_count() = 0
    MyObj destructed

### See also

[ unique_ptr](unique_ptr.html "cpp/memory/unique ptr")(C++11) |  smart pointer with unique object ownership semantics   
(class template)   
---|---  
[ weak_ptr](weak_ptr.html "cpp/memory/weak ptr")(C++11) |  weak reference to an object managed by **std::shared_ptr**   
(class template) 
