[C++](../../../cpp.html "cpp")

[Compiler support](../../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../../freestanding.html "cpp/freestanding")  
[Language](../../language.html "cpp/language")  
[Standard library](../../standard_library.html "cpp/standard library")  
[Standard library headers](../../headers.html "cpp/header")  
[Named requirements](../../iterator/concepts.html "cpp/named req")  
[Feature test macros](../../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../../utility.html#Language_support "cpp/utility")  
[Concepts library](../../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../../error.html "cpp/error")  
[Memory management library](../../memory.html "cpp/memory")  
[Metaprogramming library](../../meta.html "cpp/meta") (C++11)  
[General utilities library](../../utility.html "cpp/utility")  
[Containers library](../../container.html "cpp/container")  
[Iterators library](../../iterator.html "cpp/iterator")  
[Ranges library](../../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../../algorithm.html "cpp/algorithm")  
[Strings library](../../string.html "cpp/string")  
[Text processing library](../../text.html "cpp/text")  
[Numerics library](../../numeric.html "cpp/numeric")  
[Date and time library](../../chrono.html "cpp/chrono")  
[Input/output library](../../io.html "cpp/io")  
[Filesystem library](../../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../../atomic.html "cpp/thread") (C++11)  
[Execution control library](../../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../../experimental.html "cpp/experimental")  
[Symbols index](../../symbol_index.html "cpp/symbol index")  
[External libraries](../../links/libs.html "cpp/links/libs")  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/navbar_content&action=edit)

[Utilities library](../../utility.html "cpp/utility")

| [Language support](../../utility.html#Language_support "cpp/utility")  
---  
[Type support](../../utility/rtti.html "cpp/types") (basic types, RTTI)  
[Library feature-test macros](../../utility/feature_test.html "cpp/utility/feature test") (C++20)  
[Program utilities](../../utility/program.html "cpp/utility/program")  
[Variadic functions](../../utility/variadic.html "cpp/utility/variadic")  
[initializer_list](../../utility/initializer_list.html "cpp/utility/initializer list")(C++11)  
[is_constant_evaluated](../../types/is_constant_evaluated.html "cpp/types/is constant evaluated")(C++20)  
[is_within_lifetime](../../types/is_within_lifetime.html "cpp/types/is within lifetime")(C++26)  
[source_location](../../utility/source_location.html "cpp/utility/source location")(C++20)  
[Coroutine support](../../coroutine.html "cpp/coroutine") (C++20)  
[Contract support](../../contract.html "cpp/contract") (C++26)  
[Three-way comparison](../../utility.html#Three-way_comparison "cpp/utility")  
[three_way_comparablethree_way_comparable_with](../../utility/compare/three_way_comparable.html "cpp/utility/compare/three way comparable")(C++20)(C++20)  
[strong_ordering](../../utility/compare/strong_ordering.html "cpp/utility/compare/strong ordering")(C++20)  
[weak_ordering](../../utility/compare/weak_ordering.html "cpp/utility/compare/weak ordering")(C++20)  
[partial_ordering](../../utility/compare/partial_ordering.html "cpp/utility/compare/partial ordering")(C++20)  
[common_comparison_category](../../utility/compare/common_comparison_category.html "cpp/utility/compare/common comparison category")(C++20)  
[compare_three_way_result](../../utility/compare/compare_three_way_result.html "cpp/utility/compare/compare three way result")(C++20)  
[compare_three_way](../../utility/compare/compare_three_way.html "cpp/utility/compare/compare three way")(C++20)  
[strong_order](../../utility/compare/strong_order.html "cpp/utility/compare/strong order")(C++20)  
[weak_order](../../utility/compare/weak_order.html "cpp/utility/compare/weak order")(C++20)  
[partial_order](../../utility/compare/partial_order.html "cpp/utility/compare/partial order")(C++20)  
[compare_strong_order_fallback](../../utility/compare/compare_strong_order_fallback.html "cpp/utility/compare/compare strong order fallback")(C++20)  
[compare_weak_order_fallback](../../utility/compare/compare_weak_order_fallback.html "cpp/utility/compare/compare weak order fallback")(C++20)  
[compare_partial_order_fallback](../../utility/compare/compare_partial_order_fallback.html "cpp/utility/compare/compare partial order fallback")(C++20)` `  
|  | [is_eqis_ltis_lteq](../../utility/compare/named_comparison_functions.html "cpp/utility/compare/named comparison functions")(C++20)(C++20)(C++20)` `  
---  
  
| [is_neqis_gtis_gteq](../../utility/compare/named_comparison_functions.html "cpp/utility/compare/named comparison functions")(C++20)(C++20)(C++20)  
---  
  
  
  
  
| General utilities  
---  
| [Function objects](../../functional.html "cpp/utility/functional")  
---  
[Bit manipulation](../../utility/bit.html "cpp/utility/bit") (C++20)  
[C-style bit manipulation](https://en.cppreference.com/mwiki/index.php?title=cpp/utility/stdbit&action=edit&redlink=1 "cpp/utility/stdbit \(page does not exist\)") (C++26)  
[bitset](../../utility/bitset.html "cpp/utility/bitset")  
[hash](../../utility/hash.html "cpp/utility/hash")(C++11)  
  
[Relational operators](../../utility.html#Relational_operators "cpp/utility") (deprecated in C++20)  
|  | [rel_ops::operator!=rel_ops::operator>](../../utility/rel_ops/operator_cmp.html "cpp/utility/rel ops/operator cmp")` `  
---  
  
| [rel_ops::operator<=rel_ops::operator>=](../../utility/rel_ops/operator_cmp.html "cpp/utility/rel ops/operator cmp")  
---  
  
[Integer comparison functions](../../utility.html#Integer_comparison_functions "cpp/utility")  
| [cmp_equalcmp_lesscmp_less_than](../../utility/intcmp.html "cpp/utility/intcmp")(C++20)(C++20)(C++20)` `  
---  
  
| [cmp_not_equalcmp_greatercmp_greater_than](../../utility/intcmp.html "cpp/utility/intcmp")(C++20)(C++20)(C++20)  
---  
  
[in_range](../../utility/in_range.html "cpp/utility/in range")(C++20)  
[Swap](../../utility.html#Swap "cpp/utility") and [type operations](../../utility.html#Type_operations "cpp/utility")  
| [swap](../../utility/swap.html "cpp/algorithm/swap")  
---  
[ranges::swap](../../utility/ranges/swap.html "cpp/utility/ranges/swap")(C++20)  
[exchange](../../utility/exchange.html "cpp/utility/exchange")(C++14)  
[declval](../../utility/declval.html "cpp/utility/declval")(C++11)  
[to_underlying](../../utility/to_underlying.html "cpp/utility/to underlying")(C++23)  
  
| [forward](../../utility/forward.html "cpp/utility/forward")(C++11)  
---  
[forward_like](../../utility/forward_like.html "cpp/utility/forward like")(C++23)  
[move](../../utility/move.html "cpp/utility/move")(C++11)  
[move_if_noexcept](../../utility/move_if_noexcept.html "cpp/utility/move if noexcept")(C++11)  
[as_const](../../utility/as_const.html "cpp/utility/as const")(C++17)  
  
Common vocabulary types  
| [pair](../../utility/pair.html "cpp/utility/pair")  
---  
[tuple](../../utility/tuple.html "cpp/utility/tuple")(C++11)  
[optional](../../utility/optional.html "cpp/utility/optional")(C++17)  
[any](../../utility/any.html "cpp/utility/any")(C++17)  
[variant](../../utility/variant.html "cpp/utility/variant")(C++17)  
  
| [tuple_size](../../utility/tuple_size.html "cpp/utility/tuple size")(C++11)  
---  
[tuple_element](../../utility/tuple_element.html "cpp/utility/tuple element")(C++11)  
[apply](../../utility/apply.html "cpp/utility/apply")(C++17)  
[make_from_tuple](../../utility/make_from_tuple.html "cpp/utility/make from tuple")(C++17)  
[expected](../../utility/expected.html "cpp/utility/expected")(C++23)  
  
  
  
  
  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/navbar_content&action=edit)

[Memory management library](../../memory.html "cpp/memory")

| [_voidify_](../voidify.html "cpp/memory/voidify")(exposition only*)  
---  
[Allocators](../../memory.html#Allocators "cpp/memory")  
| [allocator](../allocator.html "cpp/memory/allocator")  
---  
[allocator_traits](../allocator_traits.html "cpp/memory/allocator traits")(C++11)  
[allocation_result](../allocation_result.html "cpp/memory/allocation result")(C++23)  
[scoped_allocator_adaptor](../scoped_allocator_adaptor.html "cpp/memory/scoped allocator adaptor")(C++11)  
[pmr::polymorphic_allocator](../polymorphic_allocator.html "cpp/memory/polymorphic allocator")(C++17)  
  
| [allocator_arg](../allocator_arg.html "cpp/memory/allocator arg")(C++11)  
---  
[uses_allocator](../uses_allocator.html "cpp/memory/uses allocator")(C++11)  
[uses_allocator_construction_args](../uses_allocator_construction_args.html "cpp/memory/uses allocator construction args")(C++20)  
[make_obj_using_allocator](../make_obj_using_allocator.html "cpp/memory/make obj using allocator")(C++20)  
[uninitialized_construct_using_allocator](../uninitialized_construct_using_allocator.html "cpp/memory/uninitialized construct using allocator")(C++20)  
  
[Uninitialized memory algorithms](../../memory.html#Uninitialized_memory_algorithms "cpp/memory")  
| [uninitialized_copy](../uninitialized_copy.html "cpp/memory/uninitialized copy")  
---  
[uninitialized_fill](../uninitialized_fill.html "cpp/memory/uninitialized fill")  
[uninitialized_move](../uninitialized_move.html "cpp/memory/uninitialized move")(C++17)  
[uninitialized_copy_n](../uninitialized_copy_n.html "cpp/memory/uninitialized copy n")(C++11)  
[uninitialized_fill_n](../uninitialized_fill_n.html "cpp/memory/uninitialized fill n")  
[uninitialized_move_n](../uninitialized_move_n.html "cpp/memory/uninitialized move n")(C++17)  
[construct_at](../construct_at.html "cpp/memory/construct at")(C++20)  
  
| [uninitialized_default_construct](../uninitialized_default_construct.html "cpp/memory/uninitialized default construct")(C++17)  
---  
[uninitialized_value_construct](../uninitialized_value_construct.html "cpp/memory/uninitialized value construct")(C++17)  
[destroy](../destroy.html "cpp/memory/destroy")(C++17)  
[uninitialized_default_construct_n](../uninitialized_default_construct_n.html "cpp/memory/uninitialized default construct n")(C++17)  
[uninitialized_value_construct_n](../uninitialized_value_construct_n.html "cpp/memory/uninitialized value construct n")(C++17)  
[destroy_n](../destroy_n.html "cpp/memory/destroy n")(C++17)  
[destroy_at](../destroy_at.html "cpp/memory/destroy at")(C++17)  
  
[Constrained uninitialized memory algorithms](../../memory.html#Constrained_uninitialized_memory_algorithms "cpp/memory")  
| [ranges::uninitialized_copy](../ranges/uninitialized_copy.html "cpp/memory/ranges/uninitialized copy")(C++20)  
---  
[ranges::uninitialized_fill](../ranges/uninitialized_fill.html "cpp/memory/ranges/uninitialized fill")(C++20)  
[ranges::uninitialized_move](../ranges/uninitialized_move.html "cpp/memory/ranges/uninitialized move")(C++20)  
[ranges::uninitialized_copy_n](../ranges/uninitialized_copy_n.html "cpp/memory/ranges/uninitialized copy n")(C++20)` `  
[ranges::uninitialized_fill_n](../ranges/uninitialized_fill_n.html "cpp/memory/ranges/uninitialized fill n")(C++20)  
[ranges::uninitialized_move_n](../ranges/uninitialized_move_n.html "cpp/memory/ranges/uninitialized move n")(C++20)  
[ranges::construct_at](../ranges/construct_at.html "cpp/memory/ranges/construct at")(C++20)  
  
| [ranges::uninitialized_default_construct](../ranges/uninitialized_default_construct.html "cpp/memory/ranges/uninitialized default construct")(C++20)  
---  
[ranges::uninitialized_value_construct](../ranges/uninitialized_value_construct.html "cpp/memory/ranges/uninitialized value construct")(C++20)  
[ranges::destroy](../ranges/destroy.html "cpp/memory/ranges/destroy")(C++20)  
[ranges::uninitialized_default_construct_n](../ranges/uninitialized_default_construct_n.html "cpp/memory/ranges/uninitialized default construct n")(C++20)` `  
[ranges::uninitialized_value_construct_n](../ranges/uninitialized_value_construct_n.html "cpp/memory/ranges/uninitialized value construct n")(C++20)  
[ranges::destroy_n](../ranges/destroy_n.html "cpp/memory/ranges/destroy n")(C++20)  
[ranges::destroy_at](../ranges/destroy_at.html "cpp/memory/ranges/destroy at")(C++20)  
  
[Memory resources](../../memory.html#Memory_resources "cpp/memory")  
| [pmr::memory_resource](../memory_resource.html "cpp/memory/memory resource")(C++17)  
---  
[pmr::get_default_resource](../get_default_resource.html "cpp/memory/get default resource")(C++17)  
[pmr::set_default_resource](../set_default_resource.html "cpp/memory/set default resource")(C++17)  
[pmr::new_delete_resource](../new_delete_resource.html "cpp/memory/new delete resource")(C++17)  
[pmr::pool_options](../pool_options.html "cpp/memory/pool options")(C++17)  
  
| [pmr::null_memory_resource](../null_memory_resource.html "cpp/memory/null memory resource")(C++17)  
---  
[pmr::synchronized_pool_resource](../synchronized_pool_resource.html "cpp/memory/synchronized pool resource")(C++17)  
[pmr::unsynchronized_pool_resource](../unsynchronized_pool_resource.html "cpp/memory/unsynchronized pool resource")(C++17)  
[pmr::monotonic_buffer_resource](../monotonic_buffer_resource.html "cpp/memory/monotonic buffer resource")(C++17)  
  
  
  
| [Explicit lifetime management](../../memory.html#Explicit_lifetime_management "cpp/memory")  
---  
[start_lifetime_as](../start_lifetime_as.html "cpp/memory/start lifetime as")(C++23)  
[start_lifetime_as_array](../start_lifetime_as.html "cpp/memory/start lifetime as")(C++23)  
  
| [Types for composite class design](../../memory.html#Types_for_composite_class_design "cpp/memory")  
---  
[indirect](../indirect.html "cpp/memory/indirect")(C++26)  
[polymorphic](../polymorphic.html "cpp/memory/polymorphic")(C++26)  
  
[Uninitialized storage](../../memory.html#Uninitialized_storage "cpp/memory") (until C++20)  
| [raw_storage_iterator](../raw_storage_iterator.html "cpp/memory/raw storage iterator")(until C++20*)  
---  
[get_temporary_buffer](../get_temporary_buffer.html "cpp/memory/get temporary buffer")(until C++20*)  
  
| [return_temporary_buffer](../return_temporary_buffer.html "cpp/memory/return temporary buffer")(until C++20*)  
---  
  
  
  
[Garbage collector support](../../memory.html#Garbage_collector_support "cpp/memory") (until C++23)  
| [declare_reachable](../gc/declare_reachable.html "cpp/memory/gc/declare reachable")(C++11)(until C++23)  
---  
[declare_no_pointers](../gc/declare_no_pointers.html "cpp/memory/gc/declare no pointers")(C++11)(until C++23)  
[pointer_safety](../gc/pointer_safety.html "cpp/memory/gc/pointer safety")(C++11)(until C++23)  
  
| [undeclare_reachable](../gc/undeclare_reachable.html "cpp/memory/gc/undeclare reachable")(C++11)(until C++23)  
---  
[undeclare_no_pointers](../gc/undeclare_no_pointers.html "cpp/memory/gc/undeclare no pointers")(C++11)(until C++23)  
[get_pointer_safety](../gc/get_pointer_safety.html "cpp/memory/gc/get pointer safety")(C++11)(until C++23)  
  
| [Low level memory  
management](../new.html#Low_level_memory_management "cpp/memory/new")  
---  
**operator new operator new[]**  
[operator deleteoperator delete[]](operator_delete.html "cpp/memory/new/operator delete")  
[nothrow_t](nothrow_t.html "cpp/memory/new/nothrow t")  
[nothrow](nothrow.html "cpp/memory/new/nothrow")  
[new_handler](new_handler.html "cpp/memory/new/new handler")  
[set_new_handler](set_new_handler.html "cpp/memory/new/set new handler")  
[get_new_handler](get_new_handler.html "cpp/memory/new/get new handler")(C++11)  
[bad_alloc](bad_alloc.html "cpp/memory/new/bad alloc")  
[bad_array_new_length](bad_array_new_length.html "cpp/memory/new/bad array new length")(C++11)  
[align_val_t](align_val_t.html "cpp/memory/new/align val t")(C++17)  
[destroying_delete_t](destroying_delete_t.html "cpp/memory/new/destroying delete t")(C++20)  
[launder](../../utility/launder.html "cpp/utility/launder")(C++17)  
[Smart pointers](../../memory.html#Smart_pointers "cpp/memory")  
[unique_ptr](../unique_ptr.html "cpp/memory/unique ptr")(C++11)  
[shared_ptr](../shared_ptr.html "cpp/memory/shared ptr")(C++11)  
[weak_ptr](../weak_ptr.html "cpp/memory/weak ptr")(C++11)  
[auto_ptr](../auto_ptr.html "cpp/memory/auto ptr")(until C++17*)  
[owner_less](../owner_less.html "cpp/memory/owner less")(C++11)  
[owner_less<void>](../owner_less_void.html "cpp/memory/owner less void")(C++17)  
[owner_hash](../owner_hash.html "cpp/memory/owner hash")(C++26)  
[owner_equal](../owner_equal.html "cpp/memory/owner equal")(C++26)  
[enable_shared_from_this](../enable_shared_from_this.html "cpp/memory/enable shared from this")(C++11)  
[bad_weak_ptr](../bad_weak_ptr.html "cpp/memory/bad weak ptr")(C++11)  
[default_delete](../default_delete.html "cpp/memory/default delete")(C++11)  
[out_ptr_t](../out_ptr_t.html "cpp/memory/out ptr t")(C++23)  
[inout_ptr_t](../inout_ptr_t.html "cpp/memory/inout ptr t")(C++23)  
[Miscellaneous](../../memory.html#Miscellaneous "cpp/memory")  
[pointer_traits](../pointer_traits.html "cpp/memory/pointer traits")(C++11)  
[to_address](../to_address.html "cpp/memory/to address")(C++20)  
[addressof](../addressof.html "cpp/memory/addressof")(C++11)  
[align](../align.html "cpp/memory/align")(C++11)  
[assume_aligned](../assume_aligned.html "cpp/memory/assume aligned")(C++20)  
[is_sufficiently_aligned](../is_sufficiently_aligned.html "cpp/memory/is sufficiently aligned")(C++26)  
[C Library](../c.html "cpp/memory/c")  
| [malloc](../c/malloc.html "cpp/memory/c/malloc")  
---  
[calloc](../c/calloc.html "cpp/memory/c/calloc")  
[realloc](../c/realloc.html "cpp/memory/c/realloc")  
  
| [free](../c/free.html "cpp/memory/c/free")  
---  
[aligned_alloc](../c/aligned_alloc.html "cpp/memory/c/aligned alloc")(C++17)  
  
  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/memory/navbar_content&action=edit)

[Low level memory management](../new.html "cpp/memory/new")

[Functions](../new.html#Functions "cpp/memory/new")  
---  
**operator new operator new[]**  
[operator deleteoperator delete[]](operator_delete.html "cpp/memory/new/operator delete")  
[get_new_handler](get_new_handler.html "cpp/memory/new/get new handler")(C++11)  
[set_new_handler](set_new_handler.html "cpp/memory/new/set new handler")  
[Classes](../new.html#Classes "cpp/memory/new")  
[bad_alloc](bad_alloc.html "cpp/memory/new/bad alloc")  
[bad_array_new_length](bad_array_new_length.html "cpp/memory/new/bad array new length")(C++11)  
[align_val_t](align_val_t.html "cpp/memory/new/align val t")(C++17)  
[Types](../new.html#Types "cpp/memory/new")  
[new_handler](new_handler.html "cpp/memory/new/new handler")  
[Objects](../new.html#Objects "cpp/memory/new")  
[nothrow](nothrow.html "cpp/memory/new/nothrow")  
[destroying_delete](destroying_delete_t.html "cpp/memory/new/destroying delete")(C++20)  
[Object access](../new.html#Object_access "cpp/memory/new")  
[launder](../../utility/launder.html "cpp/utility/launder")(C++17)  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/memory/new/navbar_content&action=edit)

Defined in header `[<new>](../../header/new.html "cpp/header/new")` |  |   
---|---|---  
Replaceable allocation functions |  |   
void* operator new ( [std::size_t](../../types/size_t.html) count ); |  (1) |   
void* operator new[]( [std::size_t](../../types/size_t.html) count ); |  (2) |   
void* operator new ( [std::size_t](../../types/size_t.html) count, [std::align_val_t](align_val_t.html) al ); |  (3) | (since C++17)  
void* operator new[]( [std::size_t](../../types/size_t.html) count, [std::align_val_t](align_val_t.html) al ); |  (4) | (since C++17)  
Replaceable non-throwing allocation functions |  |   
void* operator new ( [std::size_t](../../types/size_t.html) count, const [std::nothrow_t](nothrow_t.html)& tag ); |  (5) | (noexcept since C++11)  
void* operator new[]( [std::size_t](../../types/size_t.html) count, const [std::nothrow_t](nothrow_t.html)& tag ); |  (6) | (noexcept since C++11)  
void* operator new ( [std::size_t](../../types/size_t.html) count, [std::align_val_t](align_val_t.html) al,  
const [std::nothrow_t](nothrow_t.html)& tag ) noexcept; |  (7) | (since C++17)  
void* operator new[]( [std::size_t](../../types/size_t.html) count, [std::align_val_t](align_val_t.html) al,  
const [std::nothrow_t](nothrow_t.html)& tag ) noexcept; |  (8) | (since C++17)  
Non-allocating placement allocation functions |  |   
void* operator new ( [std::size_t](../../types/size_t.html) count, void* ptr ); |  (9) | (noexcept since C++11)   
(constexpr since C++26)  
void* operator new[]( [std::size_t](../../types/size_t.html) count, void* ptr ); |  (10) | (noexcept since C++11)   
(constexpr since C++26)  
User-defined placement allocation functions |  |   
void* operator new ( [std::size_t](../../types/size_t.html) count, /* args... */ ); |  (11) |   
void* operator new[]( [std::size_t](../../types/size_t.html) count, /* args... */ ); |  (12) |   
void* operator new ( [std::size_t](../../types/size_t.html) count,  
[std::align_val_t](align_val_t.html) al, /* args... */ ); |  (13) | (since C++17)  
void* operator new[]( [std::size_t](../../types/size_t.html) count,  
[std::align_val_t](align_val_t.html) al, /* args... */ ); |  (14) | (since C++17)  
Class-specific allocation functions |  |   
void* T::operator new ( [std::size_t](../../types/size_t.html) count ); |  (15) |   
void* T::operator new[]( [std::size_t](../../types/size_t.html) count ); |  (16) |   
void* T::operator new ( [std::size_t](../../types/size_t.html) count, [std::align_val_t](align_val_t.html) al ); |  (17) | (since C++17)  
void* T::operator new[]( [std::size_t](../../types/size_t.html) count, [std::align_val_t](align_val_t.html) al ); |  (18) | (since C++17)  
Class-specific placement allocation functions |  |   
void* T::operator new ( [std::size_t](../../types/size_t.html) count, /* args... */ ); |  (19) |   
void* T::operator new[]( [std::size_t](../../types/size_t.html) count, /* args... */ ); |  (20) |   
void* T::operator new ( [std::size_t](../../types/size_t.html) count,  
[std::align_val_t](align_val_t.html) al, /* args... */ ); |  (21) | (since C++17)  
void* T::operator new[]( [std::size_t](../../types/size_t.html) count,  
[std::align_val_t](align_val_t.html) al, /* args... */ ); |  (22) | (since C++17)  
| |   
  
Attempts to allocate requested number of bytes, and the allocation request can fail (even if the requested number of bytes is zero). These allocation functions are called by [new expressions](../../language/new.html "cpp/language/new") to allocate memory in which new object would then be initialized. They may also be called using regular function call syntax. 

1-8) [Replaceable](../../language/replacement_function.html "cpp/language/replacement function") allocation functions. The standard library provides default implementations for these functions, for the effects of the default implementations, see [below](operator_new.html#Global_replacement).

9,10) Called by the standard [placement new expressions](../../language/new.html#Placement_new "cpp/language/new"). Performs no action and returns ptr unmodified.

If this function is called through placement new and ptr is a null pointer, the behavior is undefined.

11-22) User-defined allocation functions called by new expressions.

Overloads ([1-4](operator_new.html#Version_1)) are implicitly declared in each translation unit even if the [`<new>`](../../header/new.html "cpp/header/new") header is not included. 

See [new expression](../../language/new.html "cpp/language/new") for the criteria of selecting overload. 

## Contents

  * [1 Parameters](operator_new.html#Parameters)
  * [2 Return value](operator_new.html#Return_value)
  * [3 Exceptions](operator_new.html#Exceptions)
  * [4 Global replacements](operator_new.html#Global_replacements)
  * [5 Class-specific overloads](operator_new.html#Class-specific_overloads)
  * [6 Notes](operator_new.html#Notes)
  * [7 Defect reports](operator_new.html#Defect_reports)
  * [8 References](operator_new.html#References)
  * [9 See also](operator_new.html#See_also)

  
---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/memory/new/operator_new&action=edit&section=1 "Edit section: Parameters")] Parameters

count  |  \-  |  number of bytes to allocate   
---|---|---  
ptr  |  \-  |  pointer to a memory area to initialize the object at   
tag  |  \-  |  disambiguation tag used to select non-throwing overloads   
al  |  \-  |  alignment to use, invalid value leads to undefined behavior   
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/memory/new/operator_new&action=edit&section=2 "Edit section: Return value")] Return value

1-4) If the allocation succeeds, a non-null pointer p0 which points to suitably aligned memory of size at least size and is different from any previously returned value p1, unless that value p1 was subsequently passed to a replaceable [deallocation function](operator_delete.html "cpp/memory/new/operator delete"); if the allocation fails, does not return (an exception is thrown, see below).

5-8) Same as ([1-4](operator_new.html#Version_1)), but returns a null pointer if the allocation fails.

9,10) ptr

11-22) Same as ([1-4](operator_new.html#Version_1)) if the function does not return on allocation failure, otherwise same as ([5-8](operator_new.html#Version_5)).

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/memory/new/operator_new&action=edit&section=3 "Edit section: Exceptions")] Exceptions

1-4) Throws an exception of a type that would match a handler of type [std::bad_alloc](bad_alloc.html "cpp/memory/new/bad alloc") on failure to allocate memory.

11-22) Same as ([1-4](operator_new.html#Version_1)) if the function does not return on allocation failure, otherwise same as ([5-8](operator_new.html#Version_5)).

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/memory/new/operator_new&action=edit&section=4 "Edit section: Global replacements")] Global replacements

Overloads ([1-8](operator_new.html#Version_1)) are [replaceable](../../language/replacement_function.html "cpp/language/replacement function"). The effects of the default versions are: 

1) Attempts to allocate the requested storage. Whether the attempt involves a call to [std::malloc](../c/malloc.html "cpp/memory/c/malloc") or [std::aligned_alloc](../c/aligned_alloc.html "cpp/memory/c/aligned alloc") is unspecified. 

  * If the attempt is successful, returns a pointer to the allocated storage. 
  * Otherwise, if currently no [new-handler](set_new_handler.html "cpp/memory/new/set new handler") is installed, throws [std::bad_alloc](bad_alloc.html "cpp/memory/new/bad alloc"). 
  * Otherwise, calls the currently installed new-handler. 
    * If the new-handler returns, starts another allocation attempt. 
    * Otherwise, exits the current invocation.



2) Returns operator new(count).

3) Same as (1).

4) Returns operator new(count, al).

5-8) Calls (1-4) respectively with the same arguments except for tag. 

  * If the call returns normally, returns the result of that call. 
  * Otherwise, returns a null pointer.



On [freestanding implementations](../../freestanding.html "cpp/freestanding"), it is implementation-defined whether the default versions of ([1-8](operator_new.html#Version_1)) satisfy the behaviors required above. Freestanding implementations are recommended that if any of these default versions meet the requirements of a hosted implementation, they all should.  | (since C++26)  
---|---  
  
Global `operator`s new/delete replacement:

Run this code
    
    
    #include <cstdio>
    #include <cstdlib>
    #include <new>
     
    // no inline, required by [replacement.functions]/3
    void* operator new([std::size_t](../../types/size_t.html) sz)
    {
        [std::printf](../../io/c/fprintf.html)("1) new(size_t), size = %zu\n", sz);
        if (sz == 0)
            ++sz; // avoid std::malloc(0) which may return nullptr on success
     
        if (void *ptr = [std::malloc](../c/malloc.html)(sz))
            return ptr;
     
        throw [std::bad_alloc](bad_alloc.html){}; // required by [new.delete.single]/3
    }
     
    // no inline, required by [replacement.functions]/3
    void* operator new[]([std::size_t](../../types/size_t.html) sz)
    {
        [std::printf](../../io/c/fprintf.html)("2) new[](size_t), size = %zu\n", sz);
        if (sz == 0)
            ++sz; // avoid std::malloc(0) which may return nullptr on success
     
        if (void *ptr = [std::malloc](../c/malloc.html)(sz))
            return ptr;
     
        throw [std::bad_alloc](bad_alloc.html){}; // required by [new.delete.single]/3
    }
     
    void [operator delete](operator_delete.html)(void* ptr) noexcept
    {
        [std::puts](../../io/c/puts.html)("3) delete(void*)");
        [std::free](../c/free.html)(ptr);
    }
     
    void [operator delete](operator_delete.html)(void* ptr, [std::size_t](../../types/size_t.html) size) noexcept
    {
        [std::printf](../../io/c/fprintf.html)("4) delete(void*, size_t), size = %zu\n", size);
        [std::free](../c/free.html)(ptr);
    }
     
    void [operator delete](operator_delete.html)[](void* ptr) noexcept
    {
        [std::puts](../../io/c/puts.html)("5) delete[](void* ptr)");
        [std::free](../c/free.html)(ptr);
    }
     
    void [operator delete](operator_delete.html)[](void* ptr, [std::size_t](../../types/size_t.html) size) noexcept
    {
        [std::printf](../../io/c/fprintf.html)("6) delete[](void*, size_t), size = %zu\n", size);
        [std::free](../c/free.html)(ptr);
    }
     
    int main()
    {
        int* p1 = new int;
        delete p1;
     
        int* p2 = new int[10]; // guaranteed to call the replacement in C++11
        delete[] p2;
    }

Possible output: 
    
    
    // Compiled with GCC-5 in C++17 mode to obtain the following:
    1) op new(size_t), size = 4
    4) op delete(void*, size_t), size = 4
    2) op new[](size_t), size = 40
    5) op delete[](void* ptr)

Overloads of `operator new` and `operator new[]` with additional user-defined parameters ("placement forms", versions ([11-14](operator_new.html#Version_11))) may be declared at global scope as usual, and are called by the matching [placement forms](../../language/new.html#Placement_new "cpp/language/new") of new expressions. 

The standard library's non-allocating placement forms of `operator new` ([9,10](operator_new.html#Version_9)) cannot be replaced and can only be customized if the placement new expression did not use the ::new syntax, by providing a class-specific placement new ([19,20](operator_new.html#Version_19)) with matching signature: void* T::operator new([std::size_t](../../types/size_t.html), void*) or void* T::operator new[]([std::size_t](../../types/size_t.html), void*). 

The placement form void* operator new([std::size_t](../../types/size_t.html), [std::size_t](../../types/size_t.html)) is not allowed because the matching signature of the deallocation function, void [operator delete](operator_delete.html)(void*, [std::size_t](../../types/size_t.html)), is a usual (not placement) deallocation function.  | (since C++14)  
---|---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/memory/new/operator_new&action=edit&section=5 "Edit section: Class-specific overloads")] Class-specific overloads

Both single-object and array allocation functions may be defined as public static member functions of a class (versions ([15-18](operator_new.html#Version_15))). If defined, these allocation functions are called by new expressions to allocate memory for single objects and arrays of this class, unless the new expression used the form ::new which bypasses class-scope lookup. The keyword [`static`](../../keywords/static.html "cpp/keyword/static") is optional for these functions: whether used or not, the allocation function is a static member function. 

The new expression looks for appropriate allocation function's name firstly in the class scope, and after that in the global scope. Note, that as per [name lookup rules](../../language/lookup.html "cpp/language/lookup"), any allocation functions declared in class scope hides all global allocation functions for the new expressions that attempt to allocate objects of this class. 

When allocating objects and arrays of objects whose alignment exceeds __STDCPP_DEFAULT_NEW_ALIGNMENT__, overload resolution is performed twice: first, for alignment-aware function signatures, then for alignment-unaware function signatures. This means that if a class with extended alignment has an alignment-unaware class-specific allocation function, it is the function that will be called, not the global alignment-aware allocation function. This is intentional: the class member is expected to know best how to handle that class.  | (since C++17)  
---|---  
When allocating objects and arrays of objects whose alignment does not exceed __STDCPP_DEFAULT_NEW_ALIGNMENT__, overload resolution is performed twice: first, for alignment-unaware function signatures, then for alignment-aware function signatures.  | (since C++20)  
---|---  
  
Run this code
    
    
    #include <cstddef>
    #include <iostream>
     
    // class-specific allocation functions
    struct X
    {
        static void* operator new([std::size_t](../../types/size_t.html) count)
        {
            [std::cout](../../io/cout.html) << "custom new for size " << count << '\n';
            return ::operator new(count);
        }
     
        static void* operator new[]([std::size_t](../../types/size_t.html) count)
        {
            [std::cout](../../io/cout.html) << "custom new[] for size " << count << '\n';
            return ::operator new[](count);
        }
    };
     
    int main()
    {
        X* p1 = new X;
        delete p1;
        X* p2 = new X[10];
        delete[] p2;
    }

Possible output: 
    
    
    custom new for size 1
    custom new[] for size 10

Overloads of `operator new` and `operator new[]` with additional user-defined parameters ("placement forms"), may also be defined as class members ([19-22](operator_new.html#Version_19))). When the placement new expression with the matching signature looks for the corresponding allocation function to call, it begins at class scope before examining the global scope, and if the class-specific placement new is provided, it is called. 

When allocating objects and arrays of objects whose alignment exceeds __STDCPP_DEFAULT_NEW_ALIGNMENT__, overload resolution for placement forms is performed twice just as for regular forms: first, for alignment-aware function signatures, then for alignment-unaware function signatures.  | (since C++17)  
---|---  
When allocating objects and arrays of objects whose alignment does not exceed __STDCPP_DEFAULT_NEW_ALIGNMENT__, overload resolution for placement forms is performed twice just as for regular forms: first, for alignment-unaware function signatures, then for alignment-aware function signatures.  | (since C++20)  
---|---  
  
Run this code
    
    
    #include <cstddef>
    #include <iostream>
    #include <stdexcept>
     
    struct X
    {
        X() { throw [std::runtime_error](../../error/runtime_error.html)(""); }
     
        // custom placement new
        static void* operator new([std::size_t](../../types/size_t.html) count, bool b)
        {
            [std::cout](../../io/cout.html) << "custom placement new called, b = " << b << '\n';
            return ::operator new(count);
        }
     
        // custom placement delete
        static void [operator delete](operator_delete.html)(void* ptr, bool b)
        {
            [std::cout](../../io/cout.html) << "custom placement delete called, b = " << b << '\n';
            ::[operator delete](operator_delete.html)(ptr);
        }
    };
     
    int main()
    {
        try
        {
            [[maybe_unused]] X* p1 = new (true) X;
        }
        catch (const [std::exception](../../error/exception.html)&)
        {}
    }

Output: 
    
    
    custom placement new called, b = 1
    custom placement delete called, b = 1

If class-level `operator new` is a template function, it must have the return type of void*, the first argument [std::size_t](../../types/size_t.html "cpp/types/size t"), and it must have two or more parameters. In other words, only placement forms can be templates. 

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/memory/new/operator_new&action=edit&section=6 "Edit section: Notes")] Notes

Even though the non-allocating placement new ([9,10](operator_new.html#Version_9)) cannot be replaced, a function with the same signature may be defined at class scope as described above. In addition, global overloads that look like placement new but take a non-void pointer type as the second argument are allowed, so the code that wants to ensure that the true placement new is called (e.g. [std::allocator::construct](../allocator/construct.html "cpp/memory/allocator/construct")), must use ::new and also cast the pointer to void*. 

If the behavior of a deallocation function does not satisfy the default constraints, the behavior is undefined. 

The following functions are required to be thread-safe: 

  * The library versions of **`operator new`** and [`operator delete`](operator_delete.html "cpp/memory/new/operator delete")
  * User replacement versions of global **`operator new`** and [`operator delete`](operator_delete.html "cpp/memory/new/operator delete")
  * [std::calloc](../c/calloc.html "cpp/memory/c/calloc"), [std::malloc](../c/malloc.html "cpp/memory/c/malloc"), [std::realloc](../c/realloc.html "cpp/memory/c/realloc"), [std::aligned_alloc](../c/aligned_alloc.html "cpp/memory/c/aligned alloc")(since C++17), [std::free](../c/free.html "cpp/memory/c/free")

Calls to these functions that allocate or deallocate a particular unit of storage occur in a single total order, and each such deallocation call [happens-before](../../atomic/memory_order.html "cpp/atomic/memory order") the next allocation (if any) in this order.  | (since C++11)  
---|---  
  
It is unspecified whether library versions of `operator new` make any calls to [std::malloc](../c/malloc.html "cpp/memory/c/malloc") or [std::aligned_alloc](../c/aligned_alloc.html "cpp/memory/c/aligned alloc")(since C++17). 

For loading a large file, file mapping via OS-specific functions, e.g., [`mmap`](https://pubs.opengroup.org/onlinepubs/9799919799/functions/mmap.html) on POSIX or `CreateFileMapping`([`A`](https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfilemappinga)/[`W`](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-createfilemappingw)) along with [`MapViewOfFile`](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-mapviewoffile) on Windows, is preferable to allocating a buffer for file reading. 

[Feature-test](../../utility/feature_test.html "cpp/utility/feature test") macro  | Value | Std | Feature   
---|---|---|---  
[`__cpp_lib_freestanding_operator_new`](../../experimental/feature_test.html#cpp_lib_freestanding_operator_new "cpp/feature test") | [`202306L`](../../compiler_support/26.html#cpp_lib_freestanding_operator_new_202306L "cpp/compiler support/26") | (C++26) | freestanding support for replaceable operator new[[1]](operator_new.html#cite_note-1)  
[`0`](../../compiler_support/26.html#cpp_lib_freestanding_operator_new_0 "cpp/compiler support/26") | (C++26) | no freestanding support   
[`__cpp_lib_constexpr_new`](../../experimental/feature_test.html#cpp_lib_constexpr_new "cpp/feature test") | [`202406L`](../../compiler_support/26.html#cpp_lib_constexpr_new_202406L "cpp/compiler support/26") | (C++26) | constexpr placement new and new[]  
  
  1. [↑](operator_new.html#cite_ref-1) Formally, this macro expands to 202306L if all the default versions of the replaceable global allocation functions meet the requirements of a hosted implementation.



### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/memory/new/operator_new&action=edit&section=7 "Edit section: Defect reports")] Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[CWG 521](https://cplusplus.github.io/CWG/issues/521.html) | C++98  | any class derived from [std::bad_alloc](bad_alloc.html "cpp/memory/new/bad alloc") could be thrown,  
even if the [std::bad_alloc](bad_alloc.html "cpp/memory/new/bad alloc") base is ambiguous or inaccessible  | the exception thrown should match  
a handler of type [std::bad_alloc](bad_alloc.html "cpp/memory/new/bad alloc")  
[LWG 9](https://cplusplus.github.io/LWG/issue9) | C++98  | multiple calls for allocating zero  
bytes could yield the same pointer  | only allowed if all such previously  
yielded pointers have been  
passed to deallocation functions   
[LWG 206](https://cplusplus.github.io/LWG/issue206) | C++98  | replacing the replaceable allocation functions did  
not affect the default behaviors of the corresponding  
replaceable non-throwing allocation functions  | the default behaviors  
change accordingly   
[LWG 404](https://cplusplus.github.io/LWG/issue404) | C++98  | replacements of the replaceable allocation  
functions could be declared inline | prohibited, no diagnostic required   
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/memory/new/operator_new&action=edit&section=8 "Edit section: References")] References

  * C++23 standard (ISO/IEC 14882:2024): 



    

  * 17.7 Dynamic memory management [support.dynamic] 



  * C++20 standard (ISO/IEC 14882:2020): 



    

  * 17.6 Dynamic memory management [support.dynamic] 



  * C++17 standard (ISO/IEC 14882:2017): 



    

  * 21.6 Dynamic memory management [support.dynamic] 



  * C++14 standard (ISO/IEC 14882:2014): 



    

  * 18.6 Dynamic memory management [support.dynamic] 



  * C++11 standard (ISO/IEC 14882:2011): 



    

  * 18.6 Dynamic memory management [support.dynamic] 



  * C++03 standard (ISO/IEC 14882:2003): 



    

  * 18.4 Dynamic memory management [lib.support.dynamic] 



  * C++98 standard (ISO/IEC 14882:1998): 



    

  * 18.4 Dynamic memory management [lib.support.dynamic] 



### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/memory/new/operator_new&action=edit&section=9 "Edit section: See also")] See also

[ operator new](../../coroutine/generator/promise_type/operator_new.html "cpp/coroutine/generator/promise type/operator new")[static] (C++23) |  allocates memory using `Allocator`   
(public static member function of `std::generator<Ref,V,Allocator>::promise_type`) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/coroutine/generator/promise_type/dsc_operator_new&action=edit)  
---|---  
[ operator deleteoperator delete[]](operator_delete.html "cpp/memory/new/operator delete") |  deallocation functions   
(function) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/memory/new/dsc_operator_delete&action=edit)  
[ get_new_handler](get_new_handler.html "cpp/memory/new/get new handler")(C++11) |  obtains the current new handler   
(function) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/memory/new/dsc_get_new_handler&action=edit)  
[ set_new_handler](set_new_handler.html "cpp/memory/new/set new handler") |  registers a new handler   
(function) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/memory/new/dsc_set_new_handler&action=edit)  
[ get_temporary_buffer](../get_temporary_buffer.html "cpp/memory/get temporary buffer")(deprecated in C++17)(removed in C++20) |  obtains uninitialized storage   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/memory/dsc_get_temporary_buffer&action=edit)  
[ malloc](../c/malloc.html "cpp/memory/c/malloc") |  allocates memory   
(function) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/memory/c/dsc_malloc&action=edit)  
[ aligned_alloc](../c/aligned_alloc.html "cpp/memory/c/aligned alloc")(C++17) |  allocates aligned memory   
(function) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/memory/c/dsc_aligned_alloc&action=edit)
  *[Value]: The year/month in which the feature was adopted. The hyperlink under each value opens a compiler support page with entry for given feature.
  *[Std]: Standard in which the feature is introduced; DR means defect report against that revision
