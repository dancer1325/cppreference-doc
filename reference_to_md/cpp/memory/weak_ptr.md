
  


[Memory management library](../memory.html "cpp/memory")

| [_voidify_](voidify.html "cpp/memory/voidify")(exposition only*)  
---  
[Allocators](../memory.html#Allocators "cpp/memory")  
| [allocator](allocator.html "cpp/memory/allocator")  
---  
[allocator_traits](allocator_traits.html "cpp/memory/allocator traits")(C++11)  
[allocation_result](allocation_result.html "cpp/memory/allocation result")(C++23)  
[scoped_allocator_adaptor](scoped_allocator_adaptor.html "cpp/memory/scoped allocator adaptor")(C++11)  
[pmr::polymorphic_allocator](polymorphic_allocator.html "cpp/memory/polymorphic allocator")(C++17)  
  
| [allocator_arg](allocator_arg.html "cpp/memory/allocator arg")(C++11)  
---  
[uses_allocator](uses_allocator.html "cpp/memory/uses allocator")(C++11)  
[uses_allocator_construction_args](uses_allocator_construction_args.html "cpp/memory/uses allocator construction args")(C++20)  
[make_obj_using_allocator](make_obj_using_allocator.html "cpp/memory/make obj using allocator")(C++20)  
[uninitialized_construct_using_allocator](uninitialized_construct_using_allocator.html "cpp/memory/uninitialized construct using allocator")(C++20)  
  
[Uninitialized memory algorithms](../memory.html#Uninitialized_memory_algorithms "cpp/memory")  
| [uninitialized_copy](uninitialized_copy.html "cpp/memory/uninitialized copy")  
---  
[uninitialized_fill](uninitialized_fill.html "cpp/memory/uninitialized fill")  
[uninitialized_move](uninitialized_move.html "cpp/memory/uninitialized move")(C++17)  
[uninitialized_copy_n](uninitialized_copy_n.html "cpp/memory/uninitialized copy n")(C++11)  
[uninitialized_fill_n](uninitialized_fill_n.html "cpp/memory/uninitialized fill n")  
[uninitialized_move_n](uninitialized_move_n.html "cpp/memory/uninitialized move n")(C++17)  
[construct_at](construct_at.html "cpp/memory/construct at")(C++20)  
  
| [uninitialized_default_construct](uninitialized_default_construct.html "cpp/memory/uninitialized default construct")(C++17)  
---  
[uninitialized_value_construct](uninitialized_value_construct.html "cpp/memory/uninitialized value construct")(C++17)  
[destroy](destroy.html "cpp/memory/destroy")(C++17)  
[uninitialized_default_construct_n](uninitialized_default_construct_n.html "cpp/memory/uninitialized default construct n")(C++17)  
[uninitialized_value_construct_n](uninitialized_value_construct_n.html "cpp/memory/uninitialized value construct n")(C++17)  
[destroy_n](destroy_n.html "cpp/memory/destroy n")(C++17)  
[destroy_at](destroy_at.html "cpp/memory/destroy at")(C++17)  
  
[Constrained uninitialized memory algorithms](../memory.html#Constrained_uninitialized_memory_algorithms "cpp/memory")  
| [ranges::uninitialized_copy](ranges/uninitialized_copy.html "cpp/memory/ranges/uninitialized copy")(C++20)  
---  
[ranges::uninitialized_fill](ranges/uninitialized_fill.html "cpp/memory/ranges/uninitialized fill")(C++20)  
[ranges::uninitialized_move](ranges/uninitialized_move.html "cpp/memory/ranges/uninitialized move")(C++20)  
[ranges::uninitialized_copy_n](ranges/uninitialized_copy_n.html "cpp/memory/ranges/uninitialized copy n")(C++20)` `  
[ranges::uninitialized_fill_n](ranges/uninitialized_fill_n.html "cpp/memory/ranges/uninitialized fill n")(C++20)  
[ranges::uninitialized_move_n](ranges/uninitialized_move_n.html "cpp/memory/ranges/uninitialized move n")(C++20)  
[ranges::construct_at](ranges/construct_at.html "cpp/memory/ranges/construct at")(C++20)  
  
| [ranges::uninitialized_default_construct](ranges/uninitialized_default_construct.html "cpp/memory/ranges/uninitialized default construct")(C++20)  
---  
[ranges::uninitialized_value_construct](ranges/uninitialized_value_construct.html "cpp/memory/ranges/uninitialized value construct")(C++20)  
[ranges::destroy](ranges/destroy.html "cpp/memory/ranges/destroy")(C++20)  
[ranges::uninitialized_default_construct_n](ranges/uninitialized_default_construct_n.html "cpp/memory/ranges/uninitialized default construct n")(C++20)` `  
[ranges::uninitialized_value_construct_n](ranges/uninitialized_value_construct_n.html "cpp/memory/ranges/uninitialized value construct n")(C++20)  
[ranges::destroy_n](ranges/destroy_n.html "cpp/memory/ranges/destroy n")(C++20)  
[ranges::destroy_at](ranges/destroy_at.html "cpp/memory/ranges/destroy at")(C++20)  
  
[Memory resources](../memory.html#Memory_resources "cpp/memory")  
| [pmr::memory_resource](memory_resource.html "cpp/memory/memory resource")(C++17)  
---  
[pmr::get_default_resource](get_default_resource.html "cpp/memory/get default resource")(C++17)  
[pmr::set_default_resource](set_default_resource.html "cpp/memory/set default resource")(C++17)  
[pmr::new_delete_resource](new_delete_resource.html "cpp/memory/new delete resource")(C++17)  
[pmr::pool_options](pool_options.html "cpp/memory/pool options")(C++17)  
  
| [pmr::null_memory_resource](null_memory_resource.html "cpp/memory/null memory resource")(C++17)  
---  
[pmr::synchronized_pool_resource](synchronized_pool_resource.html "cpp/memory/synchronized pool resource")(C++17)  
[pmr::unsynchronized_pool_resource](unsynchronized_pool_resource.html "cpp/memory/unsynchronized pool resource")(C++17)  
[pmr::monotonic_buffer_resource](monotonic_buffer_resource.html "cpp/memory/monotonic buffer resource")(C++17)  
  
  
  
| [Explicit lifetime management](../memory.html#Explicit_lifetime_management "cpp/memory")  
---  
[start_lifetime_as](start_lifetime_as.html "cpp/memory/start lifetime as")(C++23)  
[start_lifetime_as_array](start_lifetime_as.html "cpp/memory/start lifetime as")(C++23)  
  
| [Types for composite class design](../memory.html#Types_for_composite_class_design "cpp/memory")  
---  
[indirect](indirect.html "cpp/memory/indirect")(C++26)  
[polymorphic](polymorphic.html "cpp/memory/polymorphic")(C++26)  
  
[Uninitialized storage](../memory.html#Uninitialized_storage "cpp/memory") (until C++20)  
| [raw_storage_iterator](raw_storage_iterator.html "cpp/memory/raw storage iterator")(until C++20*)  
---  
[get_temporary_buffer](get_temporary_buffer.html "cpp/memory/get temporary buffer")(until C++20*)  
  
| [return_temporary_buffer](return_temporary_buffer.html "cpp/memory/return temporary buffer")(until C++20*)  
---  
  
  
  
[Garbage collector support](../memory.html#Garbage_collector_support "cpp/memory") (until C++23)  
| [declare_reachable](gc/declare_reachable.html "cpp/memory/gc/declare reachable")(C++11)(until C++23)  
---  
[declare_no_pointers](gc/declare_no_pointers.html "cpp/memory/gc/declare no pointers")(C++11)(until C++23)  
[pointer_safety](gc/pointer_safety.html "cpp/memory/gc/pointer safety")(C++11)(until C++23)  
  
| [undeclare_reachable](gc/undeclare_reachable.html "cpp/memory/gc/undeclare reachable")(C++11)(until C++23)  
---  
[undeclare_no_pointers](gc/undeclare_no_pointers.html "cpp/memory/gc/undeclare no pointers")(C++11)(until C++23)  
[get_pointer_safety](gc/get_pointer_safety.html "cpp/memory/gc/get pointer safety")(C++11)(until C++23)  
  
| [Low level memory  
management](new.html#Low_level_memory_management "cpp/memory/new")  
---  
[operator newoperator new[]](new/operator_new.html "cpp/memory/new/operator new")  
[operator deleteoperator delete[]](new/operator_delete.html "cpp/memory/new/operator delete")  
[nothrow_t](new/nothrow_t.html "cpp/memory/new/nothrow t")  
[nothrow](new/nothrow.html "cpp/memory/new/nothrow")  
[new_handler](new/new_handler.html "cpp/memory/new/new handler")  
[set_new_handler](new/set_new_handler.html "cpp/memory/new/set new handler")  
[get_new_handler](new/get_new_handler.html "cpp/memory/new/get new handler")(C++11)  
[bad_alloc](new/bad_alloc.html "cpp/memory/new/bad alloc")  
[bad_array_new_length](new/bad_array_new_length.html "cpp/memory/new/bad array new length")(C++11)  
[align_val_t](new/align_val_t.html "cpp/memory/new/align val t")(C++17)  
[destroying_delete_t](new/destroying_delete_t.html "cpp/memory/new/destroying delete t")(C++20)  
[launder](../utility/launder.html "cpp/utility/launder")(C++17)  
[Smart pointers](../memory.html#Smart_pointers "cpp/memory")  
[unique_ptr](unique_ptr.html "cpp/memory/unique ptr")(C++11)  
[shared_ptr](shared_ptr.html "cpp/memory/shared ptr")(C++11)  
**weak_ptr**(C++11)  
[auto_ptr](auto_ptr.html "cpp/memory/auto ptr")(until C++17*)  
[owner_less](owner_less.html "cpp/memory/owner less")(C++11)  
[owner_less<void>](owner_less_void.html "cpp/memory/owner less void")(C++17)  
[owner_hash](owner_hash.html "cpp/memory/owner hash")(C++26)  
[owner_equal](owner_equal.html "cpp/memory/owner equal")(C++26)  
[enable_shared_from_this](enable_shared_from_this.html "cpp/memory/enable shared from this")(C++11)  
[bad_weak_ptr](bad_weak_ptr.html "cpp/memory/bad weak ptr")(C++11)  
[default_delete](default_delete.html "cpp/memory/default delete")(C++11)  
[out_ptr_t](out_ptr_t.html "cpp/memory/out ptr t")(C++23)  
[inout_ptr_t](inout_ptr_t.html "cpp/memory/inout ptr t")(C++23)  
[Miscellaneous](../memory.html#Miscellaneous "cpp/memory")  
[pointer_traits](pointer_traits.html "cpp/memory/pointer traits")(C++11)  
[to_address](to_address.html "cpp/memory/to address")(C++20)  
[addressof](addressof.html "cpp/memory/addressof")(C++11)  
[align](align.html "cpp/memory/align")(C++11)  
[assume_aligned](assume_aligned.html "cpp/memory/assume aligned")(C++20)  
[is_sufficiently_aligned](is_sufficiently_aligned.html "cpp/memory/is sufficiently aligned")(C++26)  
[C Library](c.html "cpp/memory/c")  
| [malloc](c/malloc.html "cpp/memory/c/malloc")  
---  
[calloc](c/calloc.html "cpp/memory/c/calloc")  
[realloc](c/realloc.html "cpp/memory/c/realloc")  
  
| [free](c/free.html "cpp/memory/c/free")  
---  
[aligned_alloc](c/aligned_alloc.html "cpp/memory/c/aligned alloc")(C++17)  
  
  
  


**`std::weak_ptr`**

Member functions  
---  
[weak_ptr::weak_ptr](weak_ptr/weak_ptr.html "cpp/memory/weak ptr/weak ptr")  
[weak_ptr::~weak_ptr](weak_ptr/~weak_ptr.html "cpp/memory/weak ptr/~weak ptr")  
[weak_ptr::operator=](weak_ptr/operator=.html "cpp/memory/weak ptr/operator=")  
Modifiers  
[weak_ptr::reset](weak_ptr/reset.html "cpp/memory/weak ptr/reset")  
[weak_ptr::swap](weak_ptr/swap.html "cpp/memory/weak ptr/swap")  
Observers  
[weak_ptr::use_count](weak_ptr/use_count.html "cpp/memory/weak ptr/use count")  
[weak_ptr::expired](weak_ptr/expired.html "cpp/memory/weak ptr/expired")  
[weak_ptr::lock](weak_ptr/lock.html "cpp/memory/weak ptr/lock")  
[weak_ptr::owner_before](weak_ptr/owner_before.html "cpp/memory/weak ptr/owner before")  
[weak_ptr::owner_hash](weak_ptr/owner_hash.html "cpp/memory/weak ptr/owner hash")(C++26)  
[weak_ptr::owner_equal](weak_ptr/owner_equal.html "cpp/memory/weak ptr/owner equal")(C++26)  
Non-member functions  
[swap(std::weak_ptr)](weak_ptr/swap2.html "cpp/memory/weak ptr/swap2")  
Helper classes  
[atomic<std::weak_ptr>](weak_ptr/atomic2.html "cpp/memory/weak ptr/atomic2")(C++20)  
[Deduction guides](weak_ptr/deduction_guides.html "cpp/memory/weak ptr/deduction guides")(C++17)  
  


Defined in header `[<memory>](../header/memory.html "cpp/header/memory")` |  |   
---|---|---  
template< class T > class weak_ptr; |  |  (since C++11)  
| |   
  
`std::weak_ptr` is a smart pointer that holds a non-owning ("weak") reference to an object that is managed by [std::shared_ptr](shared_ptr.html "cpp/memory/shared ptr"). It must be converted to [std::shared_ptr](shared_ptr.html "cpp/memory/shared ptr") in order to access the referenced object. 

`std::weak_ptr` models temporary ownership: when an object needs to be accessed only if it exists, and it may be deleted at any time by someone else, `std::weak_ptr` is used to track the object, and it is converted to [std::shared_ptr](shared_ptr.html "cpp/memory/shared ptr") to acquire temporary ownership. If the original [std::shared_ptr](shared_ptr.html "cpp/memory/shared ptr") is destroyed at this time, the object's lifetime is extended until the temporary [std::shared_ptr](shared_ptr.html "cpp/memory/shared ptr") is destroyed as well. 

Another use for `std::weak_ptr` is to break reference cycles formed by objects managed by [std::shared_ptr](shared_ptr.html "cpp/memory/shared ptr"). If such cycle is orphaned (i.e., there are no outside shared pointers into the cycle), the `shared_ptr` reference counts cannot reach zero and the memory is leaked. To prevent this, one of the pointers in the cycle [can be made weak](weak_ptr/~weak_ptr.html#Example "cpp/memory/weak ptr/~weak ptr"). 

## Contents

  * [1 Member types](weak_ptr.html#Member_types)
  * [2 Member functions](weak_ptr.html#Member_functions)
    * [2.1 Modifiers](weak_ptr.html#Modifiers)
    * [2.2 Observers](weak_ptr.html#Observers)
  * [3 Non-member functions](weak_ptr.html#Non-member_functions)
  * [4 Helper classes](weak_ptr.html#Helper_classes)
  * [5 Deduction guides (since C++17)](weak_ptr.html#Deduction_guides_.28since_C.2B.2B17.29)
  * [6 Notes](weak_ptr.html#Notes)
  * [7 Example](weak_ptr.html#Example)
  * [8 Defect reports](weak_ptr.html#Defect_reports)
  * [9 See also](weak_ptr.html#See_also)

  
---  
  
### Member types

Member type  |  Definition   
---|---  
`element_type` |  |  T | (until C++17)  
---|---  
[std::remove_extent_t](../types/remove_extent.html)<T> | (since C++17)  
  
### Member functions

[ (constructor)](weak_ptr/weak_ptr.html "cpp/memory/weak ptr/weak ptr") |  creates a new `weak_ptr`   
(public member function)   
---|---  
[ (destructor)](weak_ptr/~weak_ptr.html "cpp/memory/weak ptr/~weak ptr") |  destroys a `weak_ptr`   
(public member function)   
[ operator=](weak_ptr/operator=.html "cpp/memory/weak ptr/operator=") |  assigns the `weak_ptr`   
(public member function)   
  
#####  Modifiers   
  
[ reset](weak_ptr/reset.html "cpp/memory/weak ptr/reset") |  releases the ownership of the managed object   
(public member function)   
[ swap](weak_ptr/swap.html "cpp/memory/weak ptr/swap") |  swaps the managed objects   
(public member function)   
  
#####  Observers   
  
[ use_count](weak_ptr/use_count.html "cpp/memory/weak ptr/use count") |  returns the number of `shared_ptr` objects that manage the object   
(public member function)   
[ expired](weak_ptr/expired.html "cpp/memory/weak ptr/expired") |  checks whether the referenced object was already deleted   
(public member function)   
[ lock](weak_ptr/lock.html "cpp/memory/weak ptr/lock") |  creates a `shared_ptr` that manages the referenced object   
(public member function)   
[ owner_before](weak_ptr/owner_before.html "cpp/memory/weak ptr/owner before") |  provides owner-based ordering of weak pointers   
(public member function)   
[ owner_hash](weak_ptr/owner_hash.html "cpp/memory/weak ptr/owner hash")(C++26) |  provides owner-based hashing of weak pointers   
(public member function)   
[ owner_equal](weak_ptr/owner_equal.html "cpp/memory/weak ptr/owner equal")(C++26) |  provides owner-based equal comparison of weak pointers   
(public member function)   
  
### Non-member functions

[ std::swap(std::weak_ptr)](weak_ptr/swap2.html "cpp/memory/weak ptr/swap2")(C++11) |  specializes the [std::swap](../utility/swap.html "cpp/algorithm/swap") algorithm   
(function template)   
---|---  
  
### Helper classes

[ std::atomic<std::weak_ptr>](weak_ptr/atomic2.html "cpp/memory/weak ptr/atomic2")(C++20) |  atomic weak pointer   
(class template specialization)   
---|---  
  
### [Deduction guides](weak_ptr/deduction_guides.html "cpp/memory/weak ptr/deduction guides") (since C++17)

### Notes

Like [std::shared_ptr](shared_ptr.html "cpp/memory/shared ptr"), a typical implementation of `weak_ptr` stores two pointers: 

  * a pointer to the control block; and 
  * the stored pointer of the `shared_ptr` it was constructed from. 



A separate stored pointer is necessary to ensure that converting a `shared_ptr` to `weak_ptr` and then back works correctly, even for aliased `shared_ptr`s. It is not possible to access the stored pointer in a `weak_ptr` without locking it into a `shared_ptr`. 

[Feature-test](../utility/feature_test.html "cpp/utility/feature test") macro | Value | Std | Feature   
---|---|---|---  
[`__cpp_lib_smart_ptr_owner_equality`](../experimental/feature_test.html#cpp_lib_smart_ptr_owner_equality "cpp/feature test") | [`202306L`](../compiler_support/26.html#cpp_lib_smart_ptr_owner_equality_202306L "cpp/compiler support/26") | (C++26) | Enabling the use of `std::weak_ptr` as keys in [unordered associative containers](../container.html#Unordered_associative_containers "cpp/container")  
  
### Example

Demonstrates how lock is used to ensure validity of the pointer.

Run this code
    
    
    #include <iostream>
    #include <memory>
     
    std::weak_ptr<int> gw;
     
    void observe()
    {
        [std::cout](../io/cout.html) << "gw.use_count() == " << gw.use_count() << "; ";
        // we have to make a copy of shared pointer before usage:
        if ([std::shared_ptr](shared_ptr.html)<int> spt = gw.lock())
            [std::cout](../io/cout.html) << "*spt == " << *spt << '\n';
        else
            [std::cout](../io/cout.html) << "gw is expired\n";
    }
     
    int main()
    {
        {
            auto sp = [std::make_shared](shared_ptr/make_shared.html)<int>(42);
            gw = sp;
     
            observe();
        }
     
        observe();
    }

Output: 
    
    
    gw.use_count() == 1; *spt == 42
    gw.use_count() == 0; gw is expired

### Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[LWG 3001](https://cplusplus.github.io/LWG/issue3001) | C++17  | `element_type` was not updated for array support  | updated   
  
### See also

[ unique_ptr](unique_ptr.html "cpp/memory/unique ptr")(C++11) |  smart pointer with unique object ownership semantics   
(class template)   
---|---  
[ shared_ptr](shared_ptr.html "cpp/memory/shared ptr")(C++11) |  smart pointer with shared object ownership semantics   
(class template) 
  *[Value]: The year/month in which the feature was adopted. The hyperlink under each value opens a compiler support page with entry for given feature.
  *[Std]: Standard in which the feature is introduced; DR means defect report against that revision
