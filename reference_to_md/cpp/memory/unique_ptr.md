[C++](../../cpp.html "cpp")

[Compiler support](../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../freestanding.html "cpp/freestanding")  
[Language](../language.html "cpp/language")  
[Standard library](../standard_library.html "cpp/standard library")  
[Standard library headers](../headers.html "cpp/header")  
[Named requirements](../iterator/concepts.html "cpp/named req")  
[Feature test macros](../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../utility.html#Language_support "cpp/utility")  
[Concepts library](../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../error.html "cpp/error")  
[Memory management library](../memory.html "cpp/memory")  
[Metaprogramming library](../meta.html "cpp/meta") (C++11)  
[General utilities library](../utility.html "cpp/utility")  
[Containers library](../container.html "cpp/container")  
[Iterators library](../iterator.html "cpp/iterator")  
[Ranges library](../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../algorithm.html "cpp/algorithm")  
[Strings library](../string.html "cpp/string")  
[Text processing library](../text.html "cpp/text")  
[Numerics library](../numeric.html "cpp/numeric")  
[Date and time library](../chrono.html "cpp/chrono")  
[Input/output library](../io.html "cpp/io")  
[Filesystem library](../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../atomic.html "cpp/thread") (C++11)  
[Execution control library](../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../experimental.html "cpp/experimental")  
[Symbols index](../symbol_index.html "cpp/symbol index")  
[External libraries](../links/libs.html "cpp/links/libs")  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/navbar_content&action=edit)

[Memory management library](../memory.html "cpp/memory")

| [_voidify_](voidify.html "cpp/memory/voidify")(exposition only*)  
---  
[Allocators](../memory.html#Allocators "cpp/memory")  
| [allocator](allocator.html "cpp/memory/allocator")  
---  
[allocator_traits](allocator_traits.html "cpp/memory/allocator traits")(C++11)  
[allocation_result](allocation_result.html "cpp/memory/allocation result")(C++23)  
[scoped_allocator_adaptor](scoped_allocator_adaptor.html "cpp/memory/scoped allocator adaptor")(C++11)  
[pmr::polymorphic_allocator](polymorphic_allocator.html "cpp/memory/polymorphic allocator")(C++17)  
  
| [allocator_arg](allocator_arg.html "cpp/memory/allocator arg")(C++11)  
---  
[uses_allocator](uses_allocator.html "cpp/memory/uses allocator")(C++11)  
[uses_allocator_construction_args](uses_allocator_construction_args.html "cpp/memory/uses allocator construction args")(C++20)  
[make_obj_using_allocator](make_obj_using_allocator.html "cpp/memory/make obj using allocator")(C++20)  
[uninitialized_construct_using_allocator](uninitialized_construct_using_allocator.html "cpp/memory/uninitialized construct using allocator")(C++20)  
  
[Uninitialized memory algorithms](../memory.html#Uninitialized_memory_algorithms "cpp/memory")  
| [uninitialized_copy](uninitialized_copy.html "cpp/memory/uninitialized copy")  
---  
[uninitialized_fill](uninitialized_fill.html "cpp/memory/uninitialized fill")  
[uninitialized_move](uninitialized_move.html "cpp/memory/uninitialized move")(C++17)  
[uninitialized_copy_n](uninitialized_copy_n.html "cpp/memory/uninitialized copy n")(C++11)  
[uninitialized_fill_n](uninitialized_fill_n.html "cpp/memory/uninitialized fill n")  
[uninitialized_move_n](uninitialized_move_n.html "cpp/memory/uninitialized move n")(C++17)  
[construct_at](construct_at.html "cpp/memory/construct at")(C++20)  
  
| [uninitialized_default_construct](uninitialized_default_construct.html "cpp/memory/uninitialized default construct")(C++17)  
---  
[uninitialized_value_construct](uninitialized_value_construct.html "cpp/memory/uninitialized value construct")(C++17)  
[destroy](destroy.html "cpp/memory/destroy")(C++17)  
[uninitialized_default_construct_n](uninitialized_default_construct_n.html "cpp/memory/uninitialized default construct n")(C++17)  
[uninitialized_value_construct_n](uninitialized_value_construct_n.html "cpp/memory/uninitialized value construct n")(C++17)  
[destroy_n](destroy_n.html "cpp/memory/destroy n")(C++17)  
[destroy_at](destroy_at.html "cpp/memory/destroy at")(C++17)  
  
[Constrained uninitialized memory algorithms](../memory.html#Constrained_uninitialized_memory_algorithms "cpp/memory")  
| [ranges::uninitialized_copy](ranges/uninitialized_copy.html "cpp/memory/ranges/uninitialized copy")(C++20)  
---  
[ranges::uninitialized_fill](ranges/uninitialized_fill.html "cpp/memory/ranges/uninitialized fill")(C++20)  
[ranges::uninitialized_move](ranges/uninitialized_move.html "cpp/memory/ranges/uninitialized move")(C++20)  
[ranges::uninitialized_copy_n](ranges/uninitialized_copy_n.html "cpp/memory/ranges/uninitialized copy n")(C++20)` `  
[ranges::uninitialized_fill_n](ranges/uninitialized_fill_n.html "cpp/memory/ranges/uninitialized fill n")(C++20)  
[ranges::uninitialized_move_n](ranges/uninitialized_move_n.html "cpp/memory/ranges/uninitialized move n")(C++20)  
[ranges::construct_at](ranges/construct_at.html "cpp/memory/ranges/construct at")(C++20)  
  
| [ranges::uninitialized_default_construct](ranges/uninitialized_default_construct.html "cpp/memory/ranges/uninitialized default construct")(C++20)  
---  
[ranges::uninitialized_value_construct](ranges/uninitialized_value_construct.html "cpp/memory/ranges/uninitialized value construct")(C++20)  
[ranges::destroy](ranges/destroy.html "cpp/memory/ranges/destroy")(C++20)  
[ranges::uninitialized_default_construct_n](ranges/uninitialized_default_construct_n.html "cpp/memory/ranges/uninitialized default construct n")(C++20)` `  
[ranges::uninitialized_value_construct_n](ranges/uninitialized_value_construct_n.html "cpp/memory/ranges/uninitialized value construct n")(C++20)  
[ranges::destroy_n](ranges/destroy_n.html "cpp/memory/ranges/destroy n")(C++20)  
[ranges::destroy_at](ranges/destroy_at.html "cpp/memory/ranges/destroy at")(C++20)  
  
[Memory resources](../memory.html#Memory_resources "cpp/memory")  
| [pmr::memory_resource](memory_resource.html "cpp/memory/memory resource")(C++17)  
---  
[pmr::get_default_resource](get_default_resource.html "cpp/memory/get default resource")(C++17)  
[pmr::set_default_resource](set_default_resource.html "cpp/memory/set default resource")(C++17)  
[pmr::new_delete_resource](new_delete_resource.html "cpp/memory/new delete resource")(C++17)  
[pmr::pool_options](pool_options.html "cpp/memory/pool options")(C++17)  
  
| [pmr::null_memory_resource](null_memory_resource.html "cpp/memory/null memory resource")(C++17)  
---  
[pmr::synchronized_pool_resource](synchronized_pool_resource.html "cpp/memory/synchronized pool resource")(C++17)  
[pmr::unsynchronized_pool_resource](unsynchronized_pool_resource.html "cpp/memory/unsynchronized pool resource")(C++17)  
[pmr::monotonic_buffer_resource](monotonic_buffer_resource.html "cpp/memory/monotonic buffer resource")(C++17)  
  
  
  
| [Explicit lifetime management](../memory.html#Explicit_lifetime_management "cpp/memory")  
---  
[start_lifetime_as](start_lifetime_as.html "cpp/memory/start lifetime as")(C++23)  
[start_lifetime_as_array](start_lifetime_as.html "cpp/memory/start lifetime as")(C++23)  
  
| [Types for composite class design](../memory.html#Types_for_composite_class_design "cpp/memory")  
---  
[indirect](indirect.html "cpp/memory/indirect")(C++26)  
[polymorphic](polymorphic.html "cpp/memory/polymorphic")(C++26)  
  
[Uninitialized storage](../memory.html#Uninitialized_storage "cpp/memory") (until C++20)  
| [raw_storage_iterator](raw_storage_iterator.html "cpp/memory/raw storage iterator")(until C++20*)  
---  
[get_temporary_buffer](get_temporary_buffer.html "cpp/memory/get temporary buffer")(until C++20*)  
  
| [return_temporary_buffer](return_temporary_buffer.html "cpp/memory/return temporary buffer")(until C++20*)  
---  
  
  
  
[Garbage collector support](../memory.html#Garbage_collector_support "cpp/memory") (until C++23)  
| [declare_reachable](gc/declare_reachable.html "cpp/memory/gc/declare reachable")(C++11)(until C++23)  
---  
[declare_no_pointers](gc/declare_no_pointers.html "cpp/memory/gc/declare no pointers")(C++11)(until C++23)  
[pointer_safety](gc/pointer_safety.html "cpp/memory/gc/pointer safety")(C++11)(until C++23)  
  
| [undeclare_reachable](gc/undeclare_reachable.html "cpp/memory/gc/undeclare reachable")(C++11)(until C++23)  
---  
[undeclare_no_pointers](gc/undeclare_no_pointers.html "cpp/memory/gc/undeclare no pointers")(C++11)(until C++23)  
[get_pointer_safety](gc/get_pointer_safety.html "cpp/memory/gc/get pointer safety")(C++11)(until C++23)  
  
| [Low level memory  
management](new.html#Low_level_memory_management "cpp/memory/new")  
---  
[operator newoperator new[]](new/operator_new.html "cpp/memory/new/operator new")  
[operator deleteoperator delete[]](new/operator_delete.html "cpp/memory/new/operator delete")  
[nothrow_t](new/nothrow_t.html "cpp/memory/new/nothrow t")  
[nothrow](new/nothrow.html "cpp/memory/new/nothrow")  
[new_handler](new/new_handler.html "cpp/memory/new/new handler")  
[set_new_handler](new/set_new_handler.html "cpp/memory/new/set new handler")  
[get_new_handler](new/get_new_handler.html "cpp/memory/new/get new handler")(C++11)  
[bad_alloc](new/bad_alloc.html "cpp/memory/new/bad alloc")  
[bad_array_new_length](new/bad_array_new_length.html "cpp/memory/new/bad array new length")(C++11)  
[align_val_t](new/align_val_t.html "cpp/memory/new/align val t")(C++17)  
[destroying_delete_t](new/destroying_delete_t.html "cpp/memory/new/destroying delete t")(C++20)  
[launder](../utility/launder.html "cpp/utility/launder")(C++17)  
[Smart pointers](../memory.html#Smart_pointers "cpp/memory")  
**unique_ptr**(C++11)  
[shared_ptr](shared_ptr.html "cpp/memory/shared ptr")(C++11)  
[weak_ptr](weak_ptr.html "cpp/memory/weak ptr")(C++11)  
[auto_ptr](auto_ptr.html "cpp/memory/auto ptr")(until C++17*)  
[owner_less](owner_less.html "cpp/memory/owner less")(C++11)  
[owner_less<void>](owner_less_void.html "cpp/memory/owner less void")(C++17)  
[owner_hash](owner_hash.html "cpp/memory/owner hash")(C++26)  
[owner_equal](owner_equal.html "cpp/memory/owner equal")(C++26)  
[enable_shared_from_this](enable_shared_from_this.html "cpp/memory/enable shared from this")(C++11)  
[bad_weak_ptr](bad_weak_ptr.html "cpp/memory/bad weak ptr")(C++11)  
[default_delete](default_delete.html "cpp/memory/default delete")(C++11)  
[out_ptr_t](out_ptr_t.html "cpp/memory/out ptr t")(C++23)  
[inout_ptr_t](inout_ptr_t.html "cpp/memory/inout ptr t")(C++23)  
[Miscellaneous](../memory.html#Miscellaneous "cpp/memory")  
[pointer_traits](pointer_traits.html "cpp/memory/pointer traits")(C++11)  
[to_address](to_address.html "cpp/memory/to address")(C++20)  
[addressof](addressof.html "cpp/memory/addressof")(C++11)  
[align](align.html "cpp/memory/align")(C++11)  
[assume_aligned](assume_aligned.html "cpp/memory/assume aligned")(C++20)  
[is_sufficiently_aligned](is_sufficiently_aligned.html "cpp/memory/is sufficiently aligned")(C++26)  
[C Library](c.html "cpp/memory/c")  
| [malloc](c/malloc.html "cpp/memory/c/malloc")  
---  
[calloc](c/calloc.html "cpp/memory/c/calloc")  
[realloc](c/realloc.html "cpp/memory/c/realloc")  
  
| [free](c/free.html "cpp/memory/c/free")  
---  
[aligned_alloc](c/aligned_alloc.html "cpp/memory/c/aligned alloc")(C++17)  
  
  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/memory/navbar_content&action=edit)

**`std::unique_ptr`**

[Member functions](unique_ptr.html#Member_functions "cpp/memory/unique ptr")  
---  
[unique_ptr::unique_ptr](unique_ptr/unique_ptr.html "cpp/memory/unique ptr/unique ptr")  
[unique_ptr::~unique_ptr](unique_ptr/~unique_ptr.html "cpp/memory/unique ptr/~unique ptr")  
[unique_ptr::operator=](unique_ptr/operator=.html "cpp/memory/unique ptr/operator=")  
[Modifiers](unique_ptr.html#Modifiers "cpp/memory/unique ptr")  
[unique_ptr::release](unique_ptr/release.html "cpp/memory/unique ptr/release")  
[unique_ptr::reset](unique_ptr/reset.html "cpp/memory/unique ptr/reset")  
[unique_ptr::swap](unique_ptr/swap.html "cpp/memory/unique ptr/swap")  
[Observers](unique_ptr.html#Observers "cpp/memory/unique ptr")  
[unique_ptr::get](unique_ptr/get.html "cpp/memory/unique ptr/get")  
[unique_ptr::get_deleter](unique_ptr/get_deleter.html "cpp/memory/unique ptr/get deleter")  
[unique_ptr::operator bool](unique_ptr/operator_bool.html "cpp/memory/unique ptr/operator bool")  
[unique_ptr::operator*unique_ptr::operator->](unique_ptr/operator*.html "cpp/memory/unique ptr/operator*")  
[unique_ptr::operator[]](unique_ptr/operator_at.html "cpp/memory/unique ptr/operator at")  
[Non-member functions](unique_ptr.html#Non-member_functions "cpp/memory/unique ptr")  
[make_uniquemake_unique_for_overwrite](unique_ptr/make_unique.html "cpp/memory/unique ptr/make unique")(C++14)(C++20)  
[operator==operator!=operator<operator>operator<=operator>=operator<=>](unique_ptr/operator_cmp.html "cpp/memory/unique ptr/operator cmp")(until C++20)(C++20)  
[operator<<](unique_ptr/operator_ltlt.html "cpp/memory/unique ptr/operator ltlt")(C++20)  
[swap(std::unique_ptr)](unique_ptr/swap2.html "cpp/memory/unique ptr/swap2")  
[Helper classes](unique_ptr.html#Helper_classes "cpp/memory/unique ptr")  
[hash<std::unique_ptr>](unique_ptr/hash.html "cpp/memory/unique ptr/hash")  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/memory/unique_ptr/navbar_content&action=edit)

Defined in header `[<memory>](../header/memory.html "cpp/header/memory")` |  |   
---|---|---  
template<  
class T,  
class Deleter = [std::default_delete](default_delete.html)<T>  
> class unique_ptr; |  (1)  |  (since C++11)  
template <  
class T,  
class Deleter  
> class unique_ptr<T[], Deleter>; |  (2)  |  (since C++11)  
| |   
  
`std::unique_ptr` is a smart pointer that owns (is responsible for) and manages another object via a pointer and subsequently disposes of that object when the `unique_ptr` goes out of scope. 

The object is disposed of, using the associated deleter, when either of the following happens: 

  * the managing `unique_ptr` object is destroyed. 
  * the managing `unique_ptr` object is assigned another pointer via [operator=](unique_ptr/operator=.html "cpp/memory/unique ptr/operator=") or [reset()](unique_ptr/reset.html "cpp/memory/unique ptr/reset"). 



The object is disposed of, using a potentially user-supplied deleter, by calling get_deleter()(ptr). The default deleter (`std::default_delete`) uses the delete operator, which destroys the object and deallocates the memory. 

A `unique_ptr` may alternatively own no object, in which case it is described as _empty_. 

There are two versions of `unique_ptr`: 

  1. Manages a single object (e.g., allocated with new). 
  2. Manages a dynamically-allocated array of objects (e.g., allocated with new[]). 



The class satisfies the requirements of [MoveConstructible](../named_req/MoveConstructible.html "cpp/named req/MoveConstructible") and [MoveAssignable](../named_req/MoveAssignable.html "cpp/named req/MoveAssignable"), but of neither [CopyConstructible](../named_req/CopyConstructible.html "cpp/named req/CopyConstructible") nor [CopyAssignable](../named_req/CopyAssignable.html "cpp/named req/CopyAssignable"). 

If `T*` was not a valid type (e.g., `T` is a reference type), a program that instantiates the definition of std::unique_ptr<T, Deleter> is ill-formed. 

Type requirements   
---  
-`Deleter` must be [FunctionObject](../named_req/FunctionObject.html "cpp/named req/FunctionObject") or lvalue reference to a [FunctionObject](../named_req/FunctionObject.html "cpp/named req/FunctionObject") or lvalue reference to function, callable with an argument of type unique_ptr<T, Deleter>::pointer.   
  
## Contents

  * [1 Notes](unique_ptr.html#Notes)
  * [2 Nested types](unique_ptr.html#Nested_types)
  * [3 Member functions](unique_ptr.html#Member_functions)
    * [3.1 Modifiers](unique_ptr.html#Modifiers)
    * [3.2 Observers](unique_ptr.html#Observers)
    * [3.3 Single-object version, unique_ptr<T>](unique_ptr.html#Single-object_version.2C_unique_ptr.3CT.3E)
    * [3.4 Array version, unique_ptr<T[]>](unique_ptr.html#Array_version.2C_unique_ptr.3CT.5B.5D.3E)
  * [4 Non-member functions](unique_ptr.html#Non-member_functions)
  * [5 Helper classes](unique_ptr.html#Helper_classes)
  * [6 Example](unique_ptr.html#Example)
  * [7 Defect reports](unique_ptr.html#Defect_reports)
  * [8 See also](unique_ptr.html#See_also)

  
---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/memory/unique_ptr&action=edit&section=1 "Edit section: Notes")] Notes

Only non-const `unique_ptr` can transfer the ownership of the managed object to another `unique_ptr`. If an object's lifetime is managed by a const std::unique_ptr, it is limited to the scope in which the pointer was created. 

`unique_ptr` is commonly used to manage the lifetime of objects, including: 

  * providing exception safety to classes and functions that handle objects with dynamic lifetime, by guaranteeing deletion on both normal exit and exit through exception. 


  * passing ownership of uniquely-owned objects with dynamic lifetime into functions. 


  * acquiring ownership of uniquely-owned objects with dynamic lifetime from functions. 


  * as the element type in move-aware containers, such as [std::vector](../container/vector.html "cpp/container/vector"), which hold pointers to dynamically-allocated objects (e.g. if polymorphic behavior is desired). 



`unique_ptr` may be constructed for an [incomplete type](../language/type-id.html#Incomplete_type "cpp/language/type") `T`, such as to facilitate the use as a handle in the [pImpl idiom](../language/pimpl.html "cpp/language/pimpl"). If the default deleter is used, `T` must be complete at the point in code where the deleter is invoked, which happens in the destructor, move assignment operator, and `reset` member function of `unique_ptr`. (In contrast, [std::shared_ptr](shared_ptr.html "cpp/memory/shared ptr") cannot be constructed from a raw pointer to incomplete type, but can be destroyed where `T` is incomplete). Note that if `T` is a class template specialization, use of `unique_ptr` as an operand, e.g. !p requires `T`'s parameters to be complete due to [ADL](../language/adl.html "cpp/language/adl"). 

If `T` is a [derived class](../language/derived_class.html "cpp/language/derived class") of some base `B`, then unique_ptr<T> is [implicitly convertible](unique_ptr/unique_ptr.html "cpp/memory/unique ptr/unique ptr") to unique_ptr<B>. The default deleter of the resulting unique_ptr<B> will use [`operator delete`](new/operator_delete.html "cpp/memory/new/operator delete") for `B`, leading to [undefined behavior](../language/destructor.html#Virtual_destructors "cpp/language/destructor") unless the destructor of `B` is [virtual](../language/virtual.html "cpp/language/virtual"). Note that [std::shared_ptr](shared_ptr.html "cpp/memory/shared ptr") behaves differently: [std::shared_ptr](shared_ptr.html)<B> will use the [`operator delete`](new/operator_delete.html "cpp/memory/new/operator delete") for the type `T` and the owned object will be deleted correctly even if the destructor of `B` is not [virtual](../language/virtual.html "cpp/language/virtual"). 

Unlike [std::shared_ptr](shared_ptr.html "cpp/memory/shared ptr"), `unique_ptr` may manage an object through any custom handle type that satisfies [NullablePointer](../named_req/NullablePointer.html "cpp/named req/NullablePointer"). This allows, for example, managing objects located in shared memory, by supplying a `Deleter` that defines `typedef [boost::offset_ptr](https://www.boost.org/doc/libs/release/doc/html/boost/interprocess/offset_ptr.html) pointer;` or another [fancy pointer](../named_req/Allocator.html#Fancy_pointers "cpp/named req/Allocator"). 

[Feature-test](../utility/feature_test.html "cpp/utility/feature test") macro | Value | Std | Feature   
---|---|---|---  
[`__cpp_lib_constexpr_memory`](../experimental/feature_test.html#cpp_lib_constexpr_memory "cpp/feature test") | [`202202L`](../compiler_support/23.html#cpp_lib_constexpr_memory_202202L "cpp/compiler support/23") | (C++23) | constexpr [`std::unique_ptr`](unique_ptr.html#top)  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/memory/unique_ptr&action=edit&section=2 "Edit section: Nested types")] Nested types

Type  |  Definition   
---|---  
pointer |  [std::remove_reference](../types/remove_reference.html)<Deleter>::type::pointer if that type exists, otherwise `T*`. Must satisfy [NullablePointer](../named_req/NullablePointer.html "cpp/named req/NullablePointer")  
element_type |  `T`, the type of the object managed by this `unique_ptr`  
deleter_type |  `Deleter`, the function object or lvalue reference to function or to function object, to be called from the destructor   
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/memory/unique_ptr&action=edit&section=3 "Edit section: Member functions")] Member functions

[ (constructor)](unique_ptr/unique_ptr.html "cpp/memory/unique ptr/unique ptr") |  constructs a new `unique_ptr`   
(public member function) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/memory/unique_ptr/dsc_constructor&action=edit)  
---|---  
[ (destructor)](unique_ptr/~unique_ptr.html "cpp/memory/unique ptr/~unique ptr") |  destructs the managed object if such is present   
(public member function) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/memory/unique_ptr/dsc_destructor&action=edit)  
[ operator=](unique_ptr/operator=.html "cpp/memory/unique ptr/operator=") |  assigns the `unique_ptr`   
(public member function) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/memory/unique_ptr/dsc_operator%3D&action=edit)  
  
#####  Modifiers   
  
[ release](unique_ptr/release.html "cpp/memory/unique ptr/release") |  returns a pointer to the managed object and releases the ownership   
(public member function) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/memory/unique_ptr/dsc_release&action=edit)  
[ reset](unique_ptr/reset.html "cpp/memory/unique ptr/reset") |  replaces the managed object   
(public member function) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/memory/unique_ptr/dsc_reset&action=edit)  
[ swap](unique_ptr/swap.html "cpp/memory/unique ptr/swap") |  swaps the managed objects   
(public member function) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/memory/unique_ptr/dsc_swap&action=edit)  
  
#####  Observers   
  
[ get](unique_ptr/get.html "cpp/memory/unique ptr/get") |  returns a pointer to the managed object   
(public member function) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/memory/unique_ptr/dsc_get&action=edit)  
[ get_deleter](unique_ptr/get_deleter.html "cpp/memory/unique ptr/get deleter") |  returns the deleter that is used for destruction of the managed object   
(public member function) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/memory/unique_ptr/dsc_get_deleter&action=edit)  
[ operator bool](unique_ptr/operator_bool.html "cpp/memory/unique ptr/operator bool") |  checks if there is an associated managed object   
(public member function) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/memory/unique_ptr/dsc_operator_bool&action=edit)  
  
#####  Single-object version, `unique_ptr<T>`  
  
[ operator*operator->](unique_ptr/operator*.html "cpp/memory/unique ptr/operator*") |  dereferences pointer to the managed object   
(public member function) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/memory/unique_ptr/dsc_operator*&action=edit)  
  
#####  Array version, `unique_ptr<T[]>`  
  
[ operator[]](unique_ptr/operator_at.html "cpp/memory/unique ptr/operator at") |  provides indexed access to the managed array   
(public member function) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/memory/unique_ptr/dsc_operator_at&action=edit)  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/memory/unique_ptr&action=edit&section=4 "Edit section: Non-member functions")] Non-member functions

[ make_uniquemake_unique_for_overwrite](unique_ptr/make_unique.html "cpp/memory/unique ptr/make unique")(C++14)(C++20) |  creates a unique pointer that manages a new object   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/memory/unique_ptr/dsc_make_unique&action=edit)  
---|---  
[ operator==operator!=operator<operator<=operator>operator>=operator<=>](unique_ptr/operator_cmp.html "cpp/memory/unique ptr/operator cmp")(removed in C++20)(C++20) |  compares to another `unique_ptr` or with nullptr   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/memory/unique_ptr/dsc_operator_cmp&action=edit)  
[ operator<<(std::unique_ptr)](unique_ptr/operator_ltlt.html "cpp/memory/unique ptr/operator ltlt")(C++20) |  outputs the value of the managed pointer to an output stream   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/memory/unique_ptr/dsc_operator_ltlt&action=edit)  
[ std::swap(std::unique_ptr)](unique_ptr/swap2.html "cpp/memory/unique ptr/swap2")(C++11) |  specializes the [std::swap](../utility/swap.html "cpp/algorithm/swap") algorithm   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/memory/unique_ptr/dsc_swap2&action=edit)  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/memory/unique_ptr&action=edit&section=5 "Edit section: Helper classes")] Helper classes

[ std::hash<std::unique_ptr>](unique_ptr/hash.html "cpp/memory/unique ptr/hash")(C++11) |  hash support for **`std::unique_ptr`**   
(class template specialization) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/memory/unique_ptr/dsc_hash&action=edit)  
---|---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/memory/unique_ptr&action=edit&section=6 "Edit section: Example")] Example

Run this code
    
    
    #include <cassert>
    #include <cstdio>
    #include <fstream>
    #include <iostream>
    #include <locale>
    #include <memory>
    #include <stdexcept>
     
    // helper class for runtime polymorphism demo below
    struct B
    {
        virtual ~B() = default;
     
        virtual void bar() { [std::cout](../io/cout.html) << "B::bar\n"; }
    };
     
    struct D : B
    {
        D() { [std::cout](../io/cout.html) << "D::D\n"; }
        ~D() { [std::cout](../io/cout.html) << "D::~D\n"; }
     
        void bar() override { [std::cout](../io/cout.html) << "D::bar\n"; }
    };
     
    // a function consuming a unique_ptr can take it by value or by rvalue reference
    std::unique_ptr<D> pass_through(std::unique_ptr<D> p)
    {
        p->bar();
        return p;
    }
     
    // helper function for the custom deleter demo below
    void close_file([std::FILE](../io/c/FILE.html)* fp)
    {
        [std::fclose](../io/c/fclose.html)(fp);
    }
     
    // unique_ptr-based linked list demo
    struct List
    {
        struct Node
        {
            int data;
            std::unique_ptr<Node> next;
        };
     
        std::unique_ptr<Node> head;
     
        ~List()
        {
            // destroy list nodes sequentially in a loop, the default destructor
            // would have invoked its “next”'s destructor recursively, which would
            // cause stack overflow for sufficiently large lists.
            while (head)
            {
                auto next = std::move(head->next);
                head = std::move(next);
            }
        }
     
        void push(int data)
        {
            head = std::unique_ptr<Node>(new Node{data, std::move(head)});
        }
    };
     
    int main()
    {
        [std::cout](../io/cout.html) << "1) Unique ownership semantics demo\n";
        {
            // Create a (uniquely owned) resource
            std::unique_ptr<D> p = [std::make_unique](unique_ptr/make_unique.html)<D>();
     
            // Transfer ownership to “pass_through”,
            // which in turn transfers ownership back through the return value
            std::unique_ptr<D> q = pass_through(std::move(p));
     
            // “p” is now in a moved-from 'empty' state, equal to nullptr
            [assert](../error/assert.html)(!p);
        }
     
        [std::cout](../io/cout.html) << "\n" "2) Runtime polymorphism demo\n";
        {
            // Create a derived resource and point to it via base type
            std::unique_ptr<B> p = [std::make_unique](unique_ptr/make_unique.html)<D>();
     
            // Dynamic dispatch works as expected
            p->bar();
        }
     
        [std::cout](../io/cout.html) << "\n" "3) Custom deleter demo\n";
        [std::ofstream](../io/basic_ofstream.html)("demo.txt") << 'x'; // prepare the file to read
        {
            using unique_file_t = std::unique_ptr<[std::FILE](../io/c/FILE.html), decltype(&close_file)>;
            unique_file_t fp([std::fopen](../io/c/fopen.html)("demo.txt", "r"), &close_file);
            if (fp)
                [std::cout](../io/cout.html) << char([std::fgetc](../io/c/fgetc.html)(fp.get())) << '\n';
        } // “close_file()” called here (if “fp” is not null)
     
        [std::cout](../io/cout.html) << "\n" "4) Custom lambda expression deleter and exception safety demo\n";
        try
        {
            std::unique_ptr<D, void(*)(D*)> p(new D, [](D* ptr)
            {
                [std::cout](../io/cout.html) << "destroying from a custom deleter...\n";
                delete ptr;
            });
     
            throw [std::runtime_error](../error/runtime_error.html)(""); // “p” would leak here if it were a plain pointer
        }
        catch (const [std::exception](../error/exception.html)&)
        {
            [std::cout](../io/cout.html) << "Caught exception\n";
        }
     
        [std::cout](../io/cout.html) << "\n" "5) Array form of unique_ptr demo\n";
        {
            std::unique_ptr<D[]> p(new D[3]);
        } // “D::~D()” is called 3 times
     
        [std::cout](../io/cout.html) << "\n" "6) Linked list demo\n";
        {
            List wall;
            const int enough{1'000'000};
            for (int beer = 0; beer != enough; ++beer)
                wall.push(beer);
     
            [std::cout](../io/cout.html).imbue([std::locale](../locale/locale.html)("en_US.UTF-8"));
            [std::cout](../io/cout.html) << enough << " bottles of beer on the wall...\n";
        } // destroys all the beers
    }

Possible output: 
    
    
    1) Unique ownership semantics demo
    D::D
    D::bar
    D::~D
     
    2) Runtime polymorphism demo
    D::D
    D::bar
    D::~D
     
    3) Custom deleter demo
    x
     
    4) Custom lambda-expression deleter and exception safety demo
    D::D
    destroying from a custom deleter...
    D::~D
    Caught exception
     
    5) Array form of unique_ptr demo
    D::D
    D::D
    D::D
    D::~D
    D::~D
    D::~D
     
    6) Linked list demo
    1,000,000 bottles of beer on the wall...

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/memory/unique_ptr&action=edit&section=7 "Edit section: Defect reports")] Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[LWG 4144](https://cplusplus.github.io/LWG/issue4144) | C++11  | `T*` was not required to form a valid type  | required   
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/memory/unique_ptr&action=edit&section=8 "Edit section: See also")] See also

[ shared_ptr](shared_ptr.html "cpp/memory/shared ptr")(C++11) |  smart pointer with shared object ownership semantics   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/memory/dsc_shared_ptr&action=edit)  
---|---  
[ weak_ptr](weak_ptr.html "cpp/memory/weak ptr")(C++11) |  weak reference to an object managed by [std::shared_ptr](shared_ptr.html "cpp/memory/shared ptr")   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/memory/dsc_weak_ptr&action=edit)  
[ indirect](indirect.html "cpp/memory/indirect")(C++26) |  a wrapper containing dynamically-allocated object with value-like semantics   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/memory/dsc_indirect&action=edit)  
[ any](../utility/any.html "cpp/utility/any")(C++17) |  objects that hold instances of any [CopyConstructible](../named_req/CopyConstructible.html "cpp/named req/CopyConstructible") type   
(class) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/dsc_any&action=edit)
  *[Value]: The year/month in which the feature was adopted. The hyperlink under each value opens a compiler support page with entry for given feature.
  *[Std]: Standard in which the feature is introduced; DR means defect report against that revision
