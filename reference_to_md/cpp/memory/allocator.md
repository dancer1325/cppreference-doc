
  


[Memory management library](../memory.html "cpp/memory")

| [_voidify_](voidify.html "cpp/memory/voidify")(exposition only*)  
---  
[Allocators](../memory.html#Allocators "cpp/memory")  
| **allocator**  
---  
[allocator_traits](allocator_traits.html "cpp/memory/allocator traits")(C++11)  
[allocation_result](allocation_result.html "cpp/memory/allocation result")(C++23)  
[scoped_allocator_adaptor](scoped_allocator_adaptor.html "cpp/memory/scoped allocator adaptor")(C++11)  
[pmr::polymorphic_allocator](polymorphic_allocator.html "cpp/memory/polymorphic allocator")(C++17)  
  
| [allocator_arg](allocator_arg.html "cpp/memory/allocator arg")(C++11)  
---  
[uses_allocator](uses_allocator.html "cpp/memory/uses allocator")(C++11)  
[uses_allocator_construction_args](uses_allocator_construction_args.html "cpp/memory/uses allocator construction args")(C++20)  
[make_obj_using_allocator](make_obj_using_allocator.html "cpp/memory/make obj using allocator")(C++20)  
[uninitialized_construct_using_allocator](uninitialized_construct_using_allocator.html "cpp/memory/uninitialized construct using allocator")(C++20)  
  
[Uninitialized memory algorithms](../memory.html#Uninitialized_memory_algorithms "cpp/memory")  
| [uninitialized_copy](uninitialized_copy.html "cpp/memory/uninitialized copy")  
---  
[uninitialized_fill](uninitialized_fill.html "cpp/memory/uninitialized fill")  
[uninitialized_move](uninitialized_move.html "cpp/memory/uninitialized move")(C++17)  
[uninitialized_copy_n](uninitialized_copy_n.html "cpp/memory/uninitialized copy n")(C++11)  
[uninitialized_fill_n](uninitialized_fill_n.html "cpp/memory/uninitialized fill n")  
[uninitialized_move_n](uninitialized_move_n.html "cpp/memory/uninitialized move n")(C++17)  
[construct_at](construct_at.html "cpp/memory/construct at")(C++20)  
  
| [uninitialized_default_construct](uninitialized_default_construct.html "cpp/memory/uninitialized default construct")(C++17)  
---  
[uninitialized_value_construct](uninitialized_value_construct.html "cpp/memory/uninitialized value construct")(C++17)  
[destroy](destroy.html "cpp/memory/destroy")(C++17)  
[uninitialized_default_construct_n](uninitialized_default_construct_n.html "cpp/memory/uninitialized default construct n")(C++17)  
[uninitialized_value_construct_n](uninitialized_value_construct_n.html "cpp/memory/uninitialized value construct n")(C++17)  
[destroy_n](destroy_n.html "cpp/memory/destroy n")(C++17)  
[destroy_at](destroy_at.html "cpp/memory/destroy at")(C++17)  
  
[Constrained uninitialized memory algorithms](../memory.html#Constrained_uninitialized_memory_algorithms "cpp/memory")  
| [ranges::uninitialized_copy](ranges/uninitialized_copy.html "cpp/memory/ranges/uninitialized copy")(C++20)  
---  
[ranges::uninitialized_fill](ranges/uninitialized_fill.html "cpp/memory/ranges/uninitialized fill")(C++20)  
[ranges::uninitialized_move](ranges/uninitialized_move.html "cpp/memory/ranges/uninitialized move")(C++20)  
[ranges::uninitialized_copy_n](ranges/uninitialized_copy_n.html "cpp/memory/ranges/uninitialized copy n")(C++20)` `  
[ranges::uninitialized_fill_n](ranges/uninitialized_fill_n.html "cpp/memory/ranges/uninitialized fill n")(C++20)  
[ranges::uninitialized_move_n](ranges/uninitialized_move_n.html "cpp/memory/ranges/uninitialized move n")(C++20)  
[ranges::construct_at](ranges/construct_at.html "cpp/memory/ranges/construct at")(C++20)  
  
| [ranges::uninitialized_default_construct](ranges/uninitialized_default_construct.html "cpp/memory/ranges/uninitialized default construct")(C++20)  
---  
[ranges::uninitialized_value_construct](ranges/uninitialized_value_construct.html "cpp/memory/ranges/uninitialized value construct")(C++20)  
[ranges::destroy](ranges/destroy.html "cpp/memory/ranges/destroy")(C++20)  
[ranges::uninitialized_default_construct_n](ranges/uninitialized_default_construct_n.html "cpp/memory/ranges/uninitialized default construct n")(C++20)` `  
[ranges::uninitialized_value_construct_n](ranges/uninitialized_value_construct_n.html "cpp/memory/ranges/uninitialized value construct n")(C++20)  
[ranges::destroy_n](ranges/destroy_n.html "cpp/memory/ranges/destroy n")(C++20)  
[ranges::destroy_at](ranges/destroy_at.html "cpp/memory/ranges/destroy at")(C++20)  
  
[Memory resources](../memory.html#Memory_resources "cpp/memory")  
| [pmr::memory_resource](memory_resource.html "cpp/memory/memory resource")(C++17)  
---  
[pmr::get_default_resource](get_default_resource.html "cpp/memory/get default resource")(C++17)  
[pmr::set_default_resource](set_default_resource.html "cpp/memory/set default resource")(C++17)  
[pmr::new_delete_resource](new_delete_resource.html "cpp/memory/new delete resource")(C++17)  
[pmr::pool_options](pool_options.html "cpp/memory/pool options")(C++17)  
  
| [pmr::null_memory_resource](null_memory_resource.html "cpp/memory/null memory resource")(C++17)  
---  
[pmr::synchronized_pool_resource](synchronized_pool_resource.html "cpp/memory/synchronized pool resource")(C++17)  
[pmr::unsynchronized_pool_resource](unsynchronized_pool_resource.html "cpp/memory/unsynchronized pool resource")(C++17)  
[pmr::monotonic_buffer_resource](monotonic_buffer_resource.html "cpp/memory/monotonic buffer resource")(C++17)  
  
  
  
| [Explicit lifetime management](../memory.html#Explicit_lifetime_management "cpp/memory")  
---  
[start_lifetime_as](start_lifetime_as.html "cpp/memory/start lifetime as")(C++23)  
[start_lifetime_as_array](start_lifetime_as.html "cpp/memory/start lifetime as")(C++23)  
  
| [Types for composite class design](../memory.html#Types_for_composite_class_design "cpp/memory")  
---  
[indirect](indirect.html "cpp/memory/indirect")(C++26)  
[polymorphic](polymorphic.html "cpp/memory/polymorphic")(C++26)  
  
[Uninitialized storage](../memory.html#Uninitialized_storage "cpp/memory") (until C++20)  
| [raw_storage_iterator](raw_storage_iterator.html "cpp/memory/raw storage iterator")(until C++20*)  
---  
[get_temporary_buffer](get_temporary_buffer.html "cpp/memory/get temporary buffer")(until C++20*)  
  
| [return_temporary_buffer](return_temporary_buffer.html "cpp/memory/return temporary buffer")(until C++20*)  
---  
  
  
  
[Garbage collector support](../memory.html#Garbage_collector_support "cpp/memory") (until C++23)  
| [declare_reachable](gc/declare_reachable.html "cpp/memory/gc/declare reachable")(C++11)(until C++23)  
---  
[declare_no_pointers](gc/declare_no_pointers.html "cpp/memory/gc/declare no pointers")(C++11)(until C++23)  
[pointer_safety](gc/pointer_safety.html "cpp/memory/gc/pointer safety")(C++11)(until C++23)  
  
| [undeclare_reachable](gc/undeclare_reachable.html "cpp/memory/gc/undeclare reachable")(C++11)(until C++23)  
---  
[undeclare_no_pointers](gc/undeclare_no_pointers.html "cpp/memory/gc/undeclare no pointers")(C++11)(until C++23)  
[get_pointer_safety](gc/get_pointer_safety.html "cpp/memory/gc/get pointer safety")(C++11)(until C++23)  
  
| [Low level memory  
management](new.html#Low_level_memory_management "cpp/memory/new")  
---  
[operator newoperator new[]](new/operator_new.html "cpp/memory/new/operator new")  
[operator deleteoperator delete[]](new/operator_delete.html "cpp/memory/new/operator delete")  
[nothrow_t](new/nothrow_t.html "cpp/memory/new/nothrow t")  
[nothrow](new/nothrow.html "cpp/memory/new/nothrow")  
[new_handler](new/new_handler.html "cpp/memory/new/new handler")  
[set_new_handler](new/set_new_handler.html "cpp/memory/new/set new handler")  
[get_new_handler](new/get_new_handler.html "cpp/memory/new/get new handler")(C++11)  
[bad_alloc](new/bad_alloc.html "cpp/memory/new/bad alloc")  
[bad_array_new_length](new/bad_array_new_length.html "cpp/memory/new/bad array new length")(C++11)  
[align_val_t](new/align_val_t.html "cpp/memory/new/align val t")(C++17)  
[destroying_delete_t](new/destroying_delete_t.html "cpp/memory/new/destroying delete t")(C++20)  
[launder](../utility/launder.html "cpp/utility/launder")(C++17)  
[Smart pointers](../memory.html#Smart_pointers "cpp/memory")  
[unique_ptr](unique_ptr.html "cpp/memory/unique ptr")(C++11)  
[shared_ptr](shared_ptr.html "cpp/memory/shared ptr")(C++11)  
[weak_ptr](weak_ptr.html "cpp/memory/weak ptr")(C++11)  
[auto_ptr](auto_ptr.html "cpp/memory/auto ptr")(until C++17*)  
[owner_less](owner_less.html "cpp/memory/owner less")(C++11)  
[owner_less<void>](owner_less_void.html "cpp/memory/owner less void")(C++17)  
[owner_hash](owner_hash.html "cpp/memory/owner hash")(C++26)  
[owner_equal](owner_equal.html "cpp/memory/owner equal")(C++26)  
[enable_shared_from_this](enable_shared_from_this.html "cpp/memory/enable shared from this")(C++11)  
[bad_weak_ptr](bad_weak_ptr.html "cpp/memory/bad weak ptr")(C++11)  
[default_delete](default_delete.html "cpp/memory/default delete")(C++11)  
[out_ptr_t](out_ptr_t.html "cpp/memory/out ptr t")(C++23)  
[inout_ptr_t](inout_ptr_t.html "cpp/memory/inout ptr t")(C++23)  
[Miscellaneous](../memory.html#Miscellaneous "cpp/memory")  
[pointer_traits](pointer_traits.html "cpp/memory/pointer traits")(C++11)  
[to_address](to_address.html "cpp/memory/to address")(C++20)  
[addressof](addressof.html "cpp/memory/addressof")(C++11)  
[align](align.html "cpp/memory/align")(C++11)  
[assume_aligned](assume_aligned.html "cpp/memory/assume aligned")(C++20)  
[is_sufficiently_aligned](is_sufficiently_aligned.html "cpp/memory/is sufficiently aligned")(C++26)  
[C Library](c.html "cpp/memory/c")  
| [malloc](c/malloc.html "cpp/memory/c/malloc")  
---  
[calloc](c/calloc.html "cpp/memory/c/calloc")  
[realloc](c/realloc.html "cpp/memory/c/realloc")  
  
| [free](c/free.html "cpp/memory/c/free")  
---  
[aligned_alloc](c/aligned_alloc.html "cpp/memory/c/aligned alloc")(C++17)  
  
  
  


**`std::allocator`**

Member functions  
---  
[allocator::allocator](allocator/allocator.html "cpp/memory/allocator/allocator")  
[allocator::~allocator](allocator/~allocator.html "cpp/memory/allocator/~allocator")  
[allocator::address](allocator/address.html "cpp/memory/allocator/address")(until C++20)  
[allocator::allocate](allocator/allocate.html "cpp/memory/allocator/allocate")  
[allocator::allocate_at_least](allocator/allocate_at_least.html "cpp/memory/allocator/allocate at least")(C++23)  
[allocator::deallocate](allocator/deallocate.html "cpp/memory/allocator/deallocate")  
[allocator::max_size](allocator/max_size.html "cpp/memory/allocator/max size")(until C++20)  
[allocator::construct](allocator/construct.html "cpp/memory/allocator/construct")(until C++20)  
[allocator::destroy](allocator/destroy.html "cpp/memory/allocator/destroy")(until C++20)  
Non-member functions  
[operator==operator!=](allocator/operator_cmp.html "cpp/memory/allocator/operator cmp")(until C++20)  
  


Defined in header `[<memory>](../header/memory.html "cpp/header/memory")` |  |   
---|---|---  
template< class T >  
struct allocator; |  (1)  |   
template<>  
struct allocator<void>; |  (2)  |  (deprecated in C++17)   
(removed in C++20)  
| |   
  
The `std::allocator` class template is the default [Allocator](../named_req/Allocator.html "cpp/named req/Allocator") used by all standard library containers if no user-specified allocator is provided. The default allocator is stateless, that is, all instances of the given allocator are interchangeable, compare equal and can deallocate memory allocated by any other instance of the same allocator type. 

The explicit specialization for void lacks the member typedefs `reference`, `const_reference`, `size_type` and `difference_type`. This specialization declares no member functions.  | (until C++20)  
---|---  
The default allocator satisfies [allocator completeness requirements](../named_req/Allocator.html#Allocator_completeness_requirements "cpp/named req/Allocator").  | (since C++17)  
---|---  
  
## Contents

  * [1 Member types](allocator.html#Member_types)
  * [2 Member functions](allocator.html#Member_functions)
  * [3 Non-member functions](allocator.html#Non-member_functions)
  * [4 Notes](allocator.html#Notes)
  * [5 Example](allocator.html#Example)
  * [6 Defect reports](allocator.html#Defect_reports)
  * [7 See also](allocator.html#See_also)

  
---  
  
### Member types

Type  |  Definition   
---|---  
`value_type` |  `T`  
`pointer` (deprecated in C++17)(removed in C++20) |  `T*`  
`const_pointer` (deprecated in C++17)(removed in C++20) |  const T*  
`reference` (deprecated in C++17)(removed in C++20) |  `T&`  
`const_reference` (deprecated in C++17)(removed in C++20) |  const T&  
`size_type` |  [std::size_t](../types/size_t.html "cpp/types/size t")  
`difference_type` |  [std::ptrdiff_t](../types/ptrdiff_t.html "cpp/types/ptrdiff t")  
`propagate_on_container_move_assignment` (C++11) |  [std::true_type](../types/integral_constant.html "cpp/types/integral constant")  
`rebind` (deprecated in C++17)(removed in C++20) |  template< class U >  
struct rebind  
{  
typedef allocator<U> other;  
};  
`is_always_equal` (C++11)(deprecated in C++23)(removed in C++26) |  [std::true_type](../types/integral_constant.html "cpp/types/integral constant")  
  
### Member functions

[ (constructor)](allocator/allocator.html "cpp/memory/allocator/allocator") |  creates a new allocator instance   
(public member function)   
---|---  
[ (destructor)](allocator/~allocator.html "cpp/memory/allocator/~allocator") |  destructs an allocator instance   
(public member function)   
[ address](allocator/address.html "cpp/memory/allocator/address")(until C++20) |  obtains the address of an object, even if operator& is overloaded   
(public member function)   
[ allocate](allocator/allocate.html "cpp/memory/allocator/allocate") |  allocates uninitialized storage   
(public member function)   
[ allocate_at_least](allocator/allocate_at_least.html "cpp/memory/allocator/allocate at least")(C++23) |  allocates uninitialized storage at least as large as requested size   
(public member function)   
[ deallocate](allocator/deallocate.html "cpp/memory/allocator/deallocate") |  deallocates storage   
(public member function)   
[ max_size](allocator/max_size.html "cpp/memory/allocator/max size")(until C++20) |  returns the largest supported allocation size   
(public member function)   
[ construct](allocator/construct.html "cpp/memory/allocator/construct")(until C++20) |  constructs an object in allocated storage   
(public member function)   
[ destroy](allocator/destroy.html "cpp/memory/allocator/destroy")(until C++20) |  destructs an object in allocated storage   
(public member function)   
  
### Non-member functions

[ operator==operator!=](allocator/operator_cmp.html "cpp/memory/allocator/operator cmp")(removed in C++20) |  compares two allocator instances   
(public member function)   
---|---  
  
### Notes

The member template class `rebind` provides a way to obtain an allocator for a different type. For example, [std::list](../container/list.html)<T, A> allocates nodes of some internal type `Node<T>`, using the allocator `A::rebind<Node<T>>::other`(until C++11)[std::allocator_traits](allocator_traits.html)<A>::rebind_alloc<Node<T>>, which is implemented in terms of `A::rebind<Node<T>>::other` if A is an `std::allocator`(since C++11). 

Member type `is_always_equal` is deprecated via [LWG issue 3170](https://cplusplus.github.io/LWG/issue3170), because it makes custom allocators derived from `std::allocator` treated as always equal by default. [std::allocator_traits](allocator_traits.html)<std::allocator<T>>::is_always_equal is not deprecated and its member constant `value` is true for any `T`. 

### Example

Run this code
    
    
    #include <iostream>
    #include <memory>
    #include <string>
     
    int main()
    {
        // default allocator for ints
        std::allocator<int> alloc1;
     
        // demonstrating the few directly usable members
        static_assert([std::is_same_v](../types/is_same.html)<int, decltype(alloc1)::value_type>);
        int* p1 = alloc1.allocate(1); // space for one int
        alloc1.deallocate(p1, 1);     // and it is gone
     
        // Even those can be used through traits though, so no need
        using traits_t1 = [std::allocator_traits](allocator_traits.html)<decltype(alloc1)>; // The matching trait
        p1 = traits_t1::allocate(alloc1, 1);
        traits_t1::construct(alloc1, p1, 7);  // construct the int
        [std::cout](../io/cout.html) << *p1 << '\n';
        traits_t1::deallocate(alloc1, p1, 1); // deallocate space for one int
     
        // default allocator for strings
        std::allocator<[std::string](../string/basic_string.html)> alloc2;
        // matching traits
        using traits_t2 = [std::allocator_traits](allocator_traits.html)<decltype(alloc2)>;
     
        // Rebinding the allocator using the trait for strings gets the same type
        traits_t2::rebind_alloc<[std::string](../string/basic_string.html)> alloc_ = alloc2;
     
        [std::string](../string/basic_string.html)* p2 = traits_t2::allocate(alloc2, 2); // space for 2 strings
     
        traits_t2::construct(alloc2, p2, "foo");
        traits_t2::construct(alloc2, p2 + 1, "bar");
     
        [std::cout](../io/cout.html) << p2[0] << ' ' << p2[1] << '\n';
     
        traits_t2::destroy(alloc2, p2 + 1);
        traits_t2::destroy(alloc2, p2);
        traits_t2::deallocate(alloc2, p2, 2);
    }

Output: 
    
    
    7
    foo bar

### Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[LWG 2103](https://cplusplus.github.io/LWG/issue2103) | C++11  | redundant comparison between `allocator` might be required  | `propagate_on_container_move_assignment` provided   
[LWG 2108](https://cplusplus.github.io/LWG/issue2108) | C++11  | there was no way to show `allocator` is stateless  | `is_always_equal` provided   
  
### See also

[ allocator_traits](allocator_traits.html "cpp/memory/allocator traits")(C++11) |  provides information about allocator types   
(class template)   
---|---  
[ scoped_allocator_adaptor](scoped_allocator_adaptor.html "cpp/memory/scoped allocator adaptor")(C++11) |  implements multi-level allocator for multi-level containers   
(class template)   
[ uses_allocator](uses_allocator.html "cpp/memory/uses allocator")(C++11) |  checks if the specified type supports uses-allocator construction   
(class template) 
