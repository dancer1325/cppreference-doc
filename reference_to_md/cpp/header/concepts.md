[C++](../../cpp.html "cpp")

[Compiler support](../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../freestanding.html "cpp/freestanding")  
[Language](../language.html "cpp/language")  
[Standard library](../standard_library.html "cpp/standard library")  
[Standard library headers](../headers.html "cpp/header")  
[Named requirements](../iterator/concepts.html "cpp/named req")  
[Feature test macros](../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../utility.html#Language_support "cpp/utility")  
[Concepts library](../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../error.html "cpp/error")  
[Memory management library](../memory.html "cpp/memory")  
[Metaprogramming library](../meta.html "cpp/meta") (C++11)  
[General utilities library](../utility.html "cpp/utility")  
[Containers library](../container.html "cpp/container")  
[Iterators library](../iterator.html "cpp/iterator")  
[Ranges library](../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../algorithm.html "cpp/algorithm")  
[Strings library](../string.html "cpp/string")  
[Text processing library](../text.html "cpp/text")  
[Numerics library](../numeric.html "cpp/numeric")  
[Date and time library](../chrono.html "cpp/chrono")  
[Input/output library](../io.html "cpp/io")  
[Filesystem library](../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../atomic.html "cpp/thread") (C++11)  
[Execution control library](../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../experimental.html "cpp/experimental")  
[Symbols index](../symbol_index.html "cpp/symbol index")  
[External libraries](../links/libs.html "cpp/links/libs")  
  


[Standard library headers](../headers.html "cpp/header")

| [Language support](../headers.html#Language_support_library "cpp/header")  
---  
[`<cfloat>`](cfloat.html "cpp/header/cfloat")  
[`<climits>`](climits.html "cpp/header/climits")  
[`<compare>`](compare.html "cpp/header/compare") (C++20)  
[`<contracts>`](contracts.html "cpp/header/contracts") (C++26)  
[`<coroutine>`](coroutine.html "cpp/header/coroutine") (C++20)  
[`<csetjmp>`](csetjmp.html "cpp/header/csetjmp")  
[`<csignal>`](csignal.html "cpp/header/csignal")  
[`<cstdarg>`](cstdarg.html "cpp/header/cstdarg")  
[`<cstddef>`](cstddef.html "cpp/header/cstddef")  
[`<cstdint>`](cstdint.html "cpp/header/cstdint") (C++11)  
[`<cstdlib>`](cstdlib.html "cpp/header/cstdlib")  
[`<exception>`](exception.html "cpp/header/exception")  
[`<initializer_list>`](initializer_list.html "cpp/header/initializer list") (C++11)` `  
[`<limits>`](limits.html "cpp/header/limits")  
[`<new>`](new.html "cpp/header/new")  
[`<source_location>`](source_location.html "cpp/header/source location") (C++20)  
[`<stdfloat>`](stdfloat.html "cpp/header/stdfloat") (C++23)  
[`<typeinfo>`](typeinfo.html "cpp/header/typeinfo")  
[`<version>`](version.html "cpp/header/version") (C++20)  
[Concepts](../headers.html#Concepts_library "cpp/header")  
**`< concepts>`** (C++20)  
[Diagnostics](../headers.html#Diagnostics_library "cpp/header")  
[`<cassert>`](cassert.html "cpp/header/cassert")  
[`<cerrno>`](cerrno.html "cpp/header/cerrno")  
[`<debugging>`](debugging.html "cpp/header/debugging") (C++26)  
[`<stacktrace>`](stacktrace.html "cpp/header/stacktrace") (C++23)  
[`<stdexcept>`](stdexcept.html "cpp/header/stdexcept")  
[`<system_error>`](system_error.html "cpp/header/system error") (C++11)  
[Memory management](../headers.html#Memory_management_library "cpp/header")  
[`<memory>`](memory.html "cpp/header/memory")  
[`<memory_resource>`](memory_resource.html "cpp/header/memory resource") (C++17)  
[`<scoped_allocator>`](scoped_allocator.html "cpp/header/scoped allocator") (C++11)  
[Metaprogramming](../headers.html#Metaprogramming_library "cpp/header")  
[`<type_traits>`](type_traits.html "cpp/header/type traits") (C++11)  
[`<ratio>`](ratio.html "cpp/header/ratio") (C++11)  
  
  
  
| [General utilities](../headers.html#General_utilities_library "cpp/header")  
---  
[`<any>`](any.html "cpp/header/any") (C++17)  
[`<bitset>`](bitset.html "cpp/header/bitset")  
[`<bit>`](bit.html "cpp/header/bit") (C++20)  
[`<charconv>`](charconv.html "cpp/header/charconv") (C++17)  
[`<expected>`](expected.html "cpp/header/expected") (C++23)  
[`<format>`](format.html "cpp/header/format") (C++20)  
[`<functional>`](functional.html "cpp/header/functional")  
[`<optional>`](optional.html "cpp/header/optional") (C++17)  
[`<stdbit.h>`](stdbit.h.html "cpp/header/stdbit.h") (C++26)  
[`<tuple>`](tuple.html "cpp/header/tuple") (C++11)  
[`<typeindex>`](typeindex.html "cpp/header/typeindex") (C++11)  
[`<utility>`](utility.html "cpp/header/utility")  
[`<variant>`](variant.html "cpp/header/variant") (C++17)  
[Containers](../headers.html#Containers_library "cpp/header")  
[`<array>`](array.html "cpp/header/array") (C++11)  
[`<deque>`](deque.html "cpp/header/deque")  
[`<flat_map>`](flat_map.html "cpp/header/flat map") (C++23)  
[`<flat_set>`](flat_set.html "cpp/header/flat set") (C++23)  
[`<forward_list>`](forward_list.html "cpp/header/forward list") (C++11)  
[`<hive>`](hive.html "cpp/header/hive") (C++26)  
[`<inplace_vector>`](inplace_vector.html "cpp/header/inplace vector") (C++26)` `  
[`<list>`](list.html "cpp/header/list")  
[`<map>`](map.html "cpp/header/map")  
[`<mdspan>`](mdspan.html "cpp/header/mdspan") (C++23)  
[`<queue>`](queue.html "cpp/header/queue")  
[`<set>`](set.html "cpp/header/set")  
[`<span>`](span.html "cpp/header/span") (C++20)  
[`<stack>`](stack.html "cpp/header/stack")  
[`<unordered_map>`](unordered_map.html "cpp/header/unordered map") (C++11)  
[`<unordered_set>`](unordered_set.html "cpp/header/unordered set") (C++11)  
[`<vector>`](vector.html "cpp/header/vector")  
[Iterators](../headers.html#Iterators_library "cpp/header")  
[`<iterator>`](iterator.html "cpp/header/iterator")  
[Ranges](../headers.html#Ranges_library "cpp/header")  
[`<generator>`](generator.html "cpp/header/generator") (C++23)  
[`<ranges>`](ranges.html "cpp/header/ranges") (C++20)  
  
| [Algorithms](../headers.html#Algorithms_library "cpp/header")  
---  
[`<algorithm>`](algorithm.html "cpp/header/algorithm")  
[`<numeric>`](numeric.html "cpp/header/numeric")  
[Strings](../headers.html#Strings_library "cpp/header")  
[`<cctype>`](cctype.html "cpp/header/cctype")  
[`<cstring>`](cstring.html "cpp/header/cstring")  
[`<cuchar>`](cuchar.html "cpp/header/cuchar") (C++11)  
[`<cwchar>`](cwchar.html "cpp/header/cwchar")  
[`<cwctype>`](cwctype.html "cpp/header/cwctype")  
[`<string_view>`](string_view.html "cpp/header/string view") (C++17)  
[`<string>`](string.html "cpp/header/string")  
[Text processing](../headers.html#Text_processing_library "cpp/header")  
[`<clocale>`](clocale.html "cpp/header/clocale")  
[`<codecvt>`](codecvt.html "cpp/header/codecvt") (C++11/17/26*)  
[`<locale>`](locale.html "cpp/header/locale")  
[`<regex>`](regex.html "cpp/header/regex") (C++11)  
[`<text_encoding>`](text_encoding.html "cpp/header/text encoding") (C++26)` `  
[Numerics](../headers.html#Numerics_library "cpp/header")  
[`<cfenv>`](cfenv.html "cpp/header/cfenv") (C++11)  
[`<cmath>`](cmath.html "cpp/header/cmath")  
[`<complex>`](complex.html "cpp/header/complex")  
[`<linalg>`](linalg.html "cpp/header/linalg") (C++26)  
[`<numbers>`](numbers.html "cpp/header/numbers") (C++20)  
[`<random>`](random.html "cpp/header/random") (C++11)  
[`<simd>`](simd.html "cpp/header/simd") (C++26)  
[`<stdckdint.h>`](stdckdint.h.html "cpp/header/stdckdint.h") (C++26)  
[`<valarray>`](valarray.html "cpp/header/valarray")  
[Time](../headers.html#Time_library "cpp/header")  
[`<chrono>`](chrono.html "cpp/header/chrono") (C++11)  
[`<ctime>`](ctime.html "cpp/header/ctime")  
[C compatibility](../headers.html#C_compatibility_headers "cpp/header")  
[`<ccomplex>`](ccomplex.html "cpp/header/ccomplex") (C++11/17/20*)  
[`<ciso646>`](ciso646.html "cpp/header/ciso646") (until C++20)  
[`<cstdalign>`](cstdalign.html "cpp/header/cstdalign") (C++11/17/20*)  
[`<cstdbool>`](cstdbool.html "cpp/header/cstdbool") (C++11/17/20*)  
[`<ctgmath>`](ctgmath.html "cpp/header/ctgmath") (C++11/17/20*)  
  
| [Input/output](../headers.html#Input.2Foutput_library "cpp/header")  
---  
[`<cinttypes>`](cinttypes.html "cpp/header/cinttypes") (C++11)  
[`<cstdio>`](cstdio.html "cpp/header/cstdio")  
[`<filesystem>`](filesystem.html "cpp/header/filesystem") (C++17)  
[`<fstream>`](fstream.html "cpp/header/fstream")  
[`<iomanip>`](iomanip.html "cpp/header/iomanip")  
[`<iosfwd>`](iosfwd.html "cpp/header/iosfwd")  
[`<iostream>`](iostream.html "cpp/header/iostream")  
[`<ios>`](ios.html "cpp/header/ios")  
[`<istream>`](istream.html "cpp/header/istream")  
[`<ostream>`](ostream.html "cpp/header/ostream")  
[`<print>`](print.html "cpp/header/print") (C++23)  
[`<spanstream>`](spanstream.html "cpp/header/spanstream") (C++23)  
[`<sstream>`](sstream.html "cpp/header/sstream")  
[`<streambuf>`](streambuf.html "cpp/header/streambuf")  
[`<strstream>`](strstream.html "cpp/header/strstream") (C++98/26*)  
[`<syncstream>`](syncstream.html "cpp/header/syncstream") (C++20)  
[Concurrency support](../headers.html#Concurrency_support_library "cpp/header")  
[`<atomic>`](atomic.html "cpp/header/atomic") (C++11)  
[`<barrier>`](barrier.html "cpp/header/barrier") (C++20)  
[`<condition_variable>`](condition_variable.html "cpp/header/condition variable") (C++11)  
[`<future>`](future.html "cpp/header/future") (C++11)  
[`<hazard_pointer>`](hazard_pointer.html "cpp/header/hazard pointer") (C++26)  
[`<latch>`](latch.html "cpp/header/latch") (C++20)  
[`<mutex>`](mutex.html "cpp/header/mutex") (C++11)  
[`<rcu>`](rcu.html "cpp/header/rcu") (C++26)  
[`<semaphore>`](semaphore.html "cpp/header/semaphore") (C++20)  
[`<shared_mutex>`](shared_mutex.html "cpp/header/shared mutex") (C++14)  
[`<stdatomic.h>`](stdatomic.h.html "cpp/header/stdatomic.h") (C++23)  
[`<stop_token>`](stop_token.html "cpp/header/stop token") (C++20)  
[`<thread>`](thread.html "cpp/header/thread") (C++11)  
[Execution support](../headers.html#Multi-purpose_headers "cpp/header")  
[`<execution>`](execution.html "cpp/header/execution") (C++17)  
  
  
  
  
  
  
  
  
  


This header is part of the [concepts](../concepts.html "cpp/concepts") library. 

| 

## Contents

  * [1 Concepts](concepts.html#Concepts)
    * [1.1 Core language concepts](concepts.html#Core_language_concepts)
    * [1.2 Comparison concepts](concepts.html#Comparison_concepts)
    * [1.3 Object concepts](concepts.html#Object_concepts)
    * [1.4 Callable concepts](concepts.html#Callable_concepts)
  * [2 Customization point objects](concepts.html#Customization_point_objects)
  * [3 Synopsis](concepts.html#Synopsis)
    * [3.1 Helper concept _boolean-testable_](concepts.html#Helper_concept_boolean-testable)
    * [3.2 Concept same_as](concepts.html#Concept_same_as)
    * [3.3 Concept derived_from](concepts.html#Concept_derived_from)
    * [3.4 Concept convertible_to](concepts.html#Concept_convertible_to)
    * [3.5 Concept common_reference_with](concepts.html#Concept_common_reference_with)
    * [3.6 Concept common_with](concepts.html#Concept_common_with)
    * [3.7 Concept integral](concepts.html#Concept_integral)
    * [3.8 Concept signed_integral](concepts.html#Concept_signed_integral)
    * [3.9 Concept unsigned_integral](concepts.html#Concept_unsigned_integral)
    * [3.10 Concept floating_point](concepts.html#Concept_floating_point)
    * [3.11 Concept assignable_from](concepts.html#Concept_assignable_from)
    * [3.12 Concept swappable](concepts.html#Concept_swappable)
    * [3.13 Concept swappable_with](concepts.html#Concept_swappable_with)
    * [3.14 Concept destructible](concepts.html#Concept_destructible)
    * [3.15 Concept constructible_from](concepts.html#Concept_constructible_from)
    * [3.16 Concept default_initializable](concepts.html#Concept_default_initializable)
    * [3.17 Concept move_constructible](concepts.html#Concept_move_constructible)
    * [3.18 Concept copy_constructible](concepts.html#Concept_copy_constructible)
    * [3.19 Concept equality_comparable](concepts.html#Concept_equality_comparable)
    * [3.20 Concept equality_comparable_with](concepts.html#Concept_equality_comparable_with)
    * [3.21 Helper concept _partially-ordered-with_](concepts.html#Helper_concept_partially-ordered-with)
    * [3.22 Concept totally_ordered](concepts.html#Concept_totally_ordered)
    * [3.23 Concept totally_ordered_with](concepts.html#Concept_totally_ordered_with)
    * [3.24 Concept movable](concepts.html#Concept_movable)
    * [3.25 Concept copyable](concepts.html#Concept_copyable)
    * [3.26 Concept semiregular](concepts.html#Concept_semiregular)
    * [3.27 Concept regular](concepts.html#Concept_regular)
    * [3.28 Concept invocable](concepts.html#Concept_invocable)
    * [3.29 Concept regular_invocable](concepts.html#Concept_regular_invocable)
    * [3.30 Concept predicate](concepts.html#Concept_predicate)
    * [3.31 Concept relation](concepts.html#Concept_relation)
    * [3.32 Concept equivalence_relation](concepts.html#Concept_equivalence_relation)
    * [3.33 Concept strict_weak_order](concepts.html#Concept_strict_weak_order)

  
---  
  
###  Concepts   
  
#####  Core language concepts   
  
[ same_as](../concepts/same_as.html "cpp/concepts/same as")(C++20) |  specifies that a type is the same as another type   
(concept)   
[ derived_from](../concepts/derived_from.html "cpp/concepts/derived from")(C++20) |  specifies that a type is derived from another type   
(concept)   
[ convertible_to](../concepts/convertible_to.html "cpp/concepts/convertible to")(C++20) |  specifies that a type is implicitly convertible to another type   
(concept)   
[ common_reference_with](../concepts/common_reference_with.html "cpp/concepts/common reference with")(C++20) |  specifies that two types share a common reference type   
(concept)   
[ common_with](../concepts/common_with.html "cpp/concepts/common with")(C++20) |  specifies that two types share a common type   
(concept)   
[ integral](../concepts/integral.html "cpp/concepts/integral")(C++20) |  specifies that a type is an integral type   
(concept)   
[ signed_integral](../concepts/signed_integral.html "cpp/concepts/signed integral")(C++20) |  specifies that a type is an integral type that is signed   
(concept)   
[ unsigned_integral](../concepts/unsigned_integral.html "cpp/concepts/unsigned integral")(C++20) |  specifies that a type is an integral type that is unsigned   
(concept)   
[ floating_point](../concepts/floating_point.html "cpp/concepts/floating point")(C++20) |  specifies that a type is a floating-point type   
(concept)   
[ assignable_from](../concepts/assignable_from.html "cpp/concepts/assignable from")(C++20) |  specifies that a type is assignable from another type   
(concept)   
[ swappableswappable_with](../concepts/swappable.html "cpp/concepts/swappable")(C++20) |  specifies that a type can be swapped or that two types can be swapped with each other   
(concept)   
[ destructible](../concepts/destructible.html "cpp/concepts/destructible")(C++20) |  specifies that an object of the type can be destroyed   
(concept)   
[ constructible_from](../concepts/constructible_from.html "cpp/concepts/constructible from")(C++20) |  specifies that a variable of the type can be constructed from or bound to a set of argument types   
(concept)   
[ default_initializable](../concepts/default_initializable.html "cpp/concepts/default initializable")(C++20) |  specifies that an object of a type can be default constructed   
(concept)   
[ move_constructible](../concepts/move_constructible.html "cpp/concepts/move constructible")(C++20) |  specifies that an object of a type can be move constructed   
(concept)   
[ copy_constructible](../concepts/copy_constructible.html "cpp/concepts/copy constructible")(C++20) |  specifies that an object of a type can be copy constructed and move constructed   
(concept)   
  
#####  Comparison concepts   
  
[ equality_comparableequality_comparable_with](../concepts/equality_comparable.html "cpp/concepts/equality comparable")(C++20) |  specifies that operator == is an equivalence relation   
(concept)   
[ totally_orderedtotally_ordered_with](../concepts/totally_ordered.html "cpp/concepts/totally ordered")(C++20) |  specifies that the comparison operators on the type yield a total order   
(concept)   
  
#####  Object concepts   
  
[ movable](../concepts/movable.html "cpp/concepts/movable")(C++20) |  specifies that an object of a type can be moved and swapped   
(concept)   
[ copyable](../concepts/copyable.html "cpp/concepts/copyable")(C++20) |  specifies that an object of a type can be copied, moved, and swapped   
(concept)   
[ semiregular](../concepts/semiregular.html "cpp/concepts/semiregular")(C++20) |  specifies that an object of a type can be copied, moved, swapped, and default constructed   
(concept)   
[ regular](../concepts/regular.html "cpp/concepts/regular")(C++20) |  specifies that a type is regular, that is, it is both [`semiregular`](../concepts/semiregular.html "cpp/concepts/semiregular") and [`equality_comparable`](../concepts/equality_comparable.html "cpp/concepts/equality comparable")   
(concept)   
  
#####  Callable concepts   
  
[ invocableregular_invocable](../concepts/invocable.html "cpp/concepts/invocable")(C++20) |  specifies that a callable type can be invoked with a given set of argument types   
(concept)   
[ predicate](../concepts/predicate.html "cpp/concepts/predicate")(C++20) |  specifies that a callable type is a Boolean predicate   
(concept)   
[ relation](../concepts/relation.html "cpp/concepts/relation")(C++20) |  specifies that a callable type is a binary relation   
(concept)   
[ equivalence_relation](../concepts/equivalence_relation.html "cpp/concepts/equivalence relation")(C++20) |  specifies that a [`relation`](../concepts/relation.html "cpp/concepts/relation") imposes an equivalence relation   
(concept)   
[ strict_weak_order](../concepts/strict_weak_order.html "cpp/concepts/strict weak order")(C++20) |  specifies that a [`relation`](../concepts/relation.html "cpp/concepts/relation") imposes a strict weak ordering   
(concept)   
  
###  Customization point objects  
  
[ ranges::swap](../utility/ranges/swap.html "cpp/utility/ranges/swap")(C++20) |  swaps the values of two objects  
(customization point object)  
  
### Synopsis
    
    
    // all freestanding
    namespace std {
      // language-related concepts
      // concept same_as
      template<class T, class U>
      concept same_as = /* see description */;
     
      // concept derived_from
      template<class Derived, class Base>
      concept derived_from = /* see description */;
     
      // concept convertible_to
      template<class From, class To>
      concept convertible_to = /* see description */;
     
      // concept common_reference_with
      template<class T, class U>
      concept common_reference_with = /* see description */;
     
      // concept common_with
      template<class T, class U>
      concept common_with = /* see description */;
     
      // arithmetic concepts
      template<class T>
      concept integral = /* see description */;
      template<class T>
      concept signed_integral = /* see description */;
      template<class T>
      concept unsigned_integral = /* see description */;
      template<class T>
      concept floating_point = /* see description */;
     
      // concept assignable_from
      template<class LHS, class RHS>
      concept assignable_from = /* see description */;
     
      // concept swappable
      namespace ranges {
        inline namespace /* unspecified */ {
          inline constexpr /* unspecified */ swap = /* unspecified */;
        }
      }
      template<class T>
      concept swappable = /* see description */;
      template<class T, class U>
      concept swappable_with = /* see description */;
     
      // concept destructible
      template<class T>
      concept destructible = /* see description */;
     
      // concept constructible_from
      template<class T, class... Args>
      concept constructible_from = /* see description */;
     
      // concept default_initializable
      template<class T>
      concept default_initializable = /* see description */;
     
      // concept move_constructible
      template<class T>
      concept move_constructible = /* see description */;
     
      // concept copy_constructible
      template<class T>
      concept copy_constructible = /* see description */;
     
      // comparison concepts
      // concept equality_comparable
      template<class T>
      concept equality_comparable = /* see description */;
      template<class T, class U>
      concept equality_comparable_with = /* see description */;
     
      // concept totally_ordered
      template<class T>
      concept totally_ordered = /* see description */;
      template<class T, class U>
      concept totally_ordered_with = /* see description */;
     
      // object concepts
      template<class T>
      concept movable = /* see description */;
      template<class T>
      concept copyable = /* see description */;
      template<class T>
      concept semiregular = /* see description */;
      template<class T>
      concept regular = /* see description */;
     
      // callable concepts
      // concept invocable
      template<class F, class... Args>
      concept invocable = /* see description */;
     
      // concept regular_invocable
      template<class F, class... Args>
      concept regular_invocable = /* see description */;
     
      // concept predicate
      template<class F, class... Args>
      concept predicate = /* see description */;
     
      // concept relation
      template<class R, class T, class U>
      concept relation = /* see description */;
     
      // concept equivalence_relation
      template<class R, class T, class U>
      concept equivalence_relation = /* see description */;
     
      // concept strict_weak_order
      template<class R, class T, class U>
      concept strict_weak_order = /* see description */;
    }

#### Helper concept [`_boolean-testable_`](../concepts/boolean-testable.html "cpp/concepts/boolean-testable")
    
    
    template<class T>
    concept /*boolean-testable-impl*/ = convertible_to<T, bool>; // exposition only;
     
    template<class T>
    concept [boolean-testable](../concepts/boolean-testable.html) = // exposition only
      /*boolean-testable-impl*/<T> && requires(T&& t) {
        {
          ![std::forward](../utility/forward.html)<T>(t)
        } -> /*boolean-testable-impl*/;
      };

#### Concept [`same_as`](../concepts/same_as.html "cpp/concepts/same as")
    
    
    template<class T, class U>
    concept /*same-as-impl*/ = is_same_v<T, U>; // exposition only
     
    template<class T, class U>
    concept same_as = /*same-as-impl*/<T, U> && /*same-as-impl*/<U, T>;

#### Concept [`derived_from`](../concepts/derived_from.html "cpp/concepts/derived from")
    
    
    template<class Derived, class Base>
    concept derived_from = is_base_of_v<Base, Derived> &&
                           is_convertible_v<const volatile Derived*, const volatile Base*>;

#### Concept [`convertible_to`](../concepts/convertible_to.html "cpp/concepts/convertible to")
    
    
    template<class From, class To>
    concept convertible_to =
      is_convertible_v<From, To> && requires { static_cast<To>(declval<From>()); };

#### Concept [`common_reference_with`](../concepts/common_reference_with.html "cpp/concepts/common reference with")
    
    
    template<class T, class U>
    concept common_reference_with =
      same_as<common_reference_t<T, U>, common_reference_t<U, T>> &&
      convertible_to<T, common_reference_t<T, U>> &&
      convertible_to<U, common_reference_t<T, U>>;

#### Concept [`common_with`](../concepts/common_with.html "cpp/concepts/common with")
    
    
    template<class T, class U>
    concept common_with =
      same_as<common_type_t<T, U>, common_type_t<U, T>> &&
      requires {
        static_cast<common_type_t<T, U>>(declval<T>());
        static_cast<common_type_t<T, U>>(declval<U>());
      } &&
      common_reference_with<add_lvalue_reference_t<const T>,
                            add_lvalue_reference_t<const U>> &&
      common_reference_with<
        add_lvalue_reference_t<common_type_t<T, U>>,
        common_reference_t<add_lvalue_reference_t<const T>, add_lvalue_reference_t<const U>>>;

#### Concept [`integral`](../concepts/integral.html "cpp/concepts/integral")
    
    
    template<class T>
    concept integral = is_integral_v<T>;

#### Concept [`signed_integral`](../concepts/signed_integral.html "cpp/concepts/signed integral")
    
    
    template<class T>
    concept signed_integral = integral<T> && is_signed_v<T>;

#### Concept [`unsigned_integral`](../concepts/unsigned_integral.html "cpp/concepts/unsigned integral")
    
    
    template<class T>
    concept unsigned_integral = integral<T> && !signed_integral<T>;

#### Concept [`floating_point`](../concepts/floating_point.html "cpp/concepts/floating point")
    
    
    template<class T>
    concept floating_point = is_floating_point_v<T>;

#### Concept [`assignable_from`](../concepts/assignable_from.html "cpp/concepts/assignable from")
    
    
    template<class LHS, class RHS>
    concept assignable_from =
      is_lvalue_reference_v<LHS> &&
      common_reference_with<const remove_reference_t<LHS>&, const remove_reference_t<RHS>&> &&
      requires(LHS lhs, RHS&& rhs) {
        {
          lhs = [std::forward](../utility/forward.html)<RHS>(rhs)
        } -> same_as<LHS>;
      };

#### Concept [`swappable`](../concepts/swappable.html "cpp/concepts/swappable")
    
    
    template<class T>
    concept swappable = requires(T& a, T& b) { [ranges::swap](http://en.cppreference.com/w/cpp/ranges-utility-placeholder/swap)(a, b); };

#### Concept [`swappable_with`](../concepts/swappable.html "cpp/concepts/swappable")
    
    
    template<class T, class U>
    concept swappable_with = common_reference_with<T, U> && requires(T&& t, U&& u) {
      [ranges::swap](http://en.cppreference.com/w/cpp/ranges-utility-placeholder/swap)([std::forward](../utility/forward.html)<T>(t), [std::forward](../utility/forward.html)<T>(t));
      [ranges::swap](http://en.cppreference.com/w/cpp/ranges-utility-placeholder/swap)([std::forward](../utility/forward.html)<U>(u), [std::forward](../utility/forward.html)<U>(u));
      [ranges::swap](http://en.cppreference.com/w/cpp/ranges-utility-placeholder/swap)([std::forward](../utility/forward.html)<T>(t), [std::forward](../utility/forward.html)<U>(u));
      [ranges::swap](http://en.cppreference.com/w/cpp/ranges-utility-placeholder/swap)([std::forward](../utility/forward.html)<U>(u), [std::forward](../utility/forward.html)<T>(t));
    };

#### Concept [`destructible`](../concepts/destructible.html "cpp/concepts/destructible")
    
    
    template<class T>
    concept destructible = is_nothrow_destructible_v<T>;

#### Concept [`constructible_from`](../concepts/constructible_from.html "cpp/concepts/constructible from")
    
    
    template<class T, class... Args>
    concept constructible_from = destructible<T> && is_constructible_v<T, Args...>;

#### Concept [`default_initializable`](../concepts/default_initializable.html "cpp/concepts/default initializable")
    
    
    template<class T>
    constexpr bool /*is-default-initializable*/ = /* see description */; // exposition only
     
    template<class T>
    concept default_initializable =
      constructible_from<T> && requires { T{}; } && /*is-default-initializable*/<T>;

#### Concept [`move_constructible`](../concepts/move_constructible.html "cpp/concepts/move constructible")
    
    
    template<class T>
    concept move_constructible = constructible_from<T, T> && convertible_to<T, T>;

#### Concept [`copy_constructible`](../concepts/copy_constructible.html "cpp/concepts/copy constructible")
    
    
    template<class T>
    concept copy_constructible =
      move_constructible<T> && constructible_from<T, T&> && convertible_to<T&, T> &&
      constructible_from<T, const T&> && convertible_to<const T&, T> &&
      constructible_from<T, const T> && convertible_to<const T, T>;

#### Concept [`equality_comparable`](../concepts/equality_comparable.html "cpp/concepts/equality comparable")
    
    
    template<class T, class U>
    concept /*weakly-equality-comparable-with*/ = // exposition only
      requires(const remove_reference_t<T>& t, const remove_reference_t<U>& u) {
        { t == u } -> [boolean-testable](../concepts/boolean-testable.html);
        { t != u } -> [boolean-testable](../concepts/boolean-testable.html);
        { u == t } -> [boolean-testable](../concepts/boolean-testable.html);
        { u != t } -> [boolean-testable](../concepts/boolean-testable.html);
      };
     
    template<class T>
    concept equality_comparable = /*weakly-equality-comparable-with*/<T, T>;

#### Concept [`equality_comparable_with`](../concepts/equality_comparable.html "cpp/concepts/equality comparable")
    
    
    template<class T, class U, class C = common_reference_t<const T&, const U&>>
    concept /*comparison-common-type-with-impl*/ = // exposition only
      same_as<common_reference_t<const T&, const U&>,
              common_reference_t<const U&, const T&>> &&
      requires {
        requires convertible_to<const T&, const C&> || convertible_to<T, const C&>;
        requires convertible_to<const U&, const C&> || convertible_to<U, const C&>;
      };
     
    template<class T, class U>
    concept /*comparison-common-type-with*/ = // exposition only
      /*comparison-common-type-with-impl*/<remove_cvref_t<T>, remove_cvref_t<U>>;
     
    template<class T, class U>
    concept equality_comparable_with =
      equality_comparable<T> && equality_comparable<U> &&
      /*comparison-common-type-with*/<T, U> &&
      equality_comparable<
        common_reference_t<const remove_reference_t<T>&, const remove_reference_t<U>&>> &&
      /*weakly-equality-comparable-with*/<T, U>;

#### Helper concept [`_partially-ordered-with_`](../concepts/totally_ordered.html "cpp/concepts/totally ordered")

Defined in header [`<compare>`](compare.html#Concept_three_way_comparable "cpp/header/compare")
    
    
    template<class T, class U>
    concept /*partially-ordered-with*/ = // exposition only
      requires(const remove_reference_t<T>& t, const remove_reference_t<U>& u) {
        { t <  u } -> [boolean-testable](../concepts/boolean-testable.html);
        { t >  u } -> [boolean-testable](../concepts/boolean-testable.html);
        { t <= u } -> [boolean-testable](../concepts/boolean-testable.html);
        { t >= u } -> [boolean-testable](../concepts/boolean-testable.html);
        { u <  t } -> [boolean-testable](../concepts/boolean-testable.html);
        { u >  t } -> [boolean-testable](../concepts/boolean-testable.html);
        { u <= t } -> [boolean-testable](../concepts/boolean-testable.html);
        { u >= t } -> [boolean-testable](../concepts/boolean-testable.html);
      };

#### Concept [`totally_ordered`](../concepts/totally_ordered.html "cpp/concepts/totally ordered")
    
    
    template<class T>
    concept totally_ordered = equality_comparable<T> && /*partially-ordered-with*/<T, T>;

#### Concept [`totally_ordered_with`](../concepts/totally_ordered.html "cpp/concepts/totally ordered")
    
    
    template<class T, class U>
    concept totally_ordered_with =
      totally_ordered<T> && totally_ordered<U> && equality_comparable_with<T, U> &&
      totally_ordered<
        common_reference_t<const remove_reference_t<T>&, const remove_reference_t<U>&>> &&
      /*partially-ordered-with*/<T, U>;

#### Concept [`movable`](../concepts/movable.html "cpp/concepts/movable")
    
    
    template<class T>
    concept movable =
      is_object_v<T> && move_constructible<T> && assignable_from<T&, T> && swappable<T>;

#### Concept [`copyable`](../concepts/copyable.html "cpp/concepts/copyable")
    
    
    template<class T>
    concept copyable = copy_constructible<T> && movable<T> && assignable_from<T&, T&> &&
                       assignable_from<T&, const T&> && assignable_from<T&, const T>;

#### Concept [`semiregular`](../concepts/semiregular.html "cpp/concepts/semiregular")
    
    
    template<class T>
    concept semiregular = copyable<T> && default_initializable<T>;

#### Concept [`regular`](../concepts/regular.html "cpp/concepts/regular")
    
    
    template<class T>
    concept regular = semiregular<T> && equality_comparable<T>;

#### Concept [`invocable`](../concepts/invocable.html "cpp/concepts/invocable")
    
    
    template<class F, class... Args>
    concept invocable = requires(F&& f, Args&&... args) {
      invoke([std::forward](../utility/forward.html)<F>(f),
             [std::forward](../utility/forward.html)<Args>(args)...); // not required to be equality-preserving
    };

#### Concept [`regular_invocable`](../concepts/invocable.html "cpp/concepts/invocable")
    
    
    template<class F, class... Args>
      concept regular_invocable = invocable<F, Args...>;

#### Concept [`predicate`](../concepts/predicate.html "cpp/concepts/predicate")
    
    
    template<class F, class... Args>
    concept predicate =
      regular_invocable<F, Args...> && [boolean-testable](../concepts/boolean-testable.html)<invoke_result_t<F, Args...>>;

#### Concept [`relation`](../concepts/relation.html "cpp/concepts/relation")
    
    
    template<class R, class T, class U>
    concept relation =
      predicate<R, T, T> && predicate<R, U, U> && predicate<R, T, U> && predicate<R, U, T>;

#### Concept [`equivalence_relation`](../concepts/equivalence_relation.html "cpp/concepts/equivalence relation")
    
    
    template<class R, class T, class U>
    concept equivalence_relation = relation<R, T, U>;

#### Concept [`strict_weak_order`](../concepts/strict_weak_order.html "cpp/concepts/strict weak order")
    
    
    template<class R, class T, class U>
    concept strict_weak_order = relation<R, T, U>;
