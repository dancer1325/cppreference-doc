
  


[Standard library headers](../headers.html "cpp/header")

| [Language support](../headers.html#Language_support_library "cpp/header")  
---  
[`<cfloat>`](cfloat.html "cpp/header/cfloat")  
[`<climits>`](climits.html "cpp/header/climits")  
[`<compare>`](compare.html "cpp/header/compare") (C++20)  
[`<contracts>`](contracts.html "cpp/header/contracts") (C++26)  
[`<coroutine>`](coroutine.html "cpp/header/coroutine") (C++20)  
[`<csetjmp>`](csetjmp.html "cpp/header/csetjmp")  
[`<csignal>`](csignal.html "cpp/header/csignal")  
[`<cstdarg>`](cstdarg.html "cpp/header/cstdarg")  
[`<cstddef>`](cstddef.html "cpp/header/cstddef")  
[`<cstdint>`](cstdint.html "cpp/header/cstdint") (C++11)  
[`<cstdlib>`](cstdlib.html "cpp/header/cstdlib")  
[`<exception>`](exception.html "cpp/header/exception")  
[`<initializer_list>`](initializer_list.html "cpp/header/initializer list") (C++11)` `  
[`<limits>`](limits.html "cpp/header/limits")  
[`<new>`](new.html "cpp/header/new")  
[`<source_location>`](source_location.html "cpp/header/source location") (C++20)  
[`<stdfloat>`](stdfloat.html "cpp/header/stdfloat") (C++23)  
[`<typeinfo>`](typeinfo.html "cpp/header/typeinfo")  
[`<version>`](version.html "cpp/header/version") (C++20)  
[Concepts](../headers.html#Concepts_library "cpp/header")  
[`<concepts>`](concepts.html "cpp/header/concepts") (C++20)  
[Diagnostics](../headers.html#Diagnostics_library "cpp/header")  
[`<cassert>`](cassert.html "cpp/header/cassert")  
[`<cerrno>`](cerrno.html "cpp/header/cerrno")  
[`<debugging>`](debugging.html "cpp/header/debugging") (C++26)  
[`<stacktrace>`](stacktrace.html "cpp/header/stacktrace") (C++23)  
[`<stdexcept>`](stdexcept.html "cpp/header/stdexcept")  
[`<system_error>`](system_error.html "cpp/header/system error") (C++11)  
[Memory management](../headers.html#Memory_management_library "cpp/header")  
[`<memory>`](memory.html "cpp/header/memory")  
[`<memory_resource>`](memory_resource.html "cpp/header/memory resource") (C++17)  
[`<scoped_allocator>`](scoped_allocator.html "cpp/header/scoped allocator") (C++11)  
[Metaprogramming](../headers.html#Metaprogramming_library "cpp/header")  
[`<type_traits>`](type_traits.html "cpp/header/type traits") (C++11)  
[`<ratio>`](ratio.html "cpp/header/ratio") (C++11)  
  
  
  
| [General utilities](../headers.html#General_utilities_library "cpp/header")  
---  
[`<any>`](any.html "cpp/header/any") (C++17)  
[`<bitset>`](bitset.html "cpp/header/bitset")  
[`<bit>`](bit.html "cpp/header/bit") (C++20)  
[`<charconv>`](charconv.html "cpp/header/charconv") (C++17)  
[`<expected>`](expected.html "cpp/header/expected") (C++23)  
[`<format>`](format.html "cpp/header/format") (C++20)  
[`<functional>`](functional.html "cpp/header/functional")  
[`<optional>`](optional.html "cpp/header/optional") (C++17)  
[`<stdbit.h>`](stdbit.h.html "cpp/header/stdbit.h") (C++26)  
[`<tuple>`](tuple.html "cpp/header/tuple") (C++11)  
[`<typeindex>`](typeindex.html "cpp/header/typeindex") (C++11)  
[`<utility>`](utility.html "cpp/header/utility")  
[`<variant>`](variant.html "cpp/header/variant") (C++17)  
[Containers](../headers.html#Containers_library "cpp/header")  
[`<array>`](array.html "cpp/header/array") (C++11)  
[`<deque>`](deque.html "cpp/header/deque")  
[`<flat_map>`](flat_map.html "cpp/header/flat map") (C++23)  
[`<flat_set>`](flat_set.html "cpp/header/flat set") (C++23)  
[`<forward_list>`](forward_list.html "cpp/header/forward list") (C++11)  
[`<hive>`](hive.html "cpp/header/hive") (C++26)  
[`<inplace_vector>`](inplace_vector.html "cpp/header/inplace vector") (C++26)` `  
[`<list>`](list.html "cpp/header/list")  
[`<map>`](map.html "cpp/header/map")  
[`<mdspan>`](mdspan.html "cpp/header/mdspan") (C++23)  
[`<queue>`](queue.html "cpp/header/queue")  
[`<set>`](set.html "cpp/header/set")  
[`<span>`](span.html "cpp/header/span") (C++20)  
[`<stack>`](stack.html "cpp/header/stack")  
[`<unordered_map>`](unordered_map.html "cpp/header/unordered map") (C++11)  
[`<unordered_set>`](unordered_set.html "cpp/header/unordered set") (C++11)  
[`<vector>`](vector.html "cpp/header/vector")  
[Iterators](../headers.html#Iterators_library "cpp/header")  
**`< iterator>`**  
[Ranges](../headers.html#Ranges_library "cpp/header")  
[`<generator>`](generator.html "cpp/header/generator") (C++23)  
[`<ranges>`](ranges.html "cpp/header/ranges") (C++20)  
  
| [Algorithms](../headers.html#Algorithms_library "cpp/header")  
---  
[`<algorithm>`](algorithm.html "cpp/header/algorithm")  
[`<numeric>`](numeric.html "cpp/header/numeric")  
[Strings](../headers.html#Strings_library "cpp/header")  
[`<cctype>`](cctype.html "cpp/header/cctype")  
[`<cstring>`](cstring.html "cpp/header/cstring")  
[`<cuchar>`](cuchar.html "cpp/header/cuchar") (C++11)  
[`<cwchar>`](cwchar.html "cpp/header/cwchar")  
[`<cwctype>`](cwctype.html "cpp/header/cwctype")  
[`<string_view>`](string_view.html "cpp/header/string view") (C++17)  
[`<string>`](string.html "cpp/header/string")  
[Text processing](../headers.html#Text_processing_library "cpp/header")  
[`<clocale>`](clocale.html "cpp/header/clocale")  
[`<codecvt>`](codecvt.html "cpp/header/codecvt") (C++11/17/26*)  
[`<locale>`](locale.html "cpp/header/locale")  
[`<regex>`](regex.html "cpp/header/regex") (C++11)  
[`<text_encoding>`](text_encoding.html "cpp/header/text encoding") (C++26)` `  
[Numerics](../headers.html#Numerics_library "cpp/header")  
[`<cfenv>`](cfenv.html "cpp/header/cfenv") (C++11)  
[`<cmath>`](cmath.html "cpp/header/cmath")  
[`<complex>`](complex.html "cpp/header/complex")  
[`<linalg>`](linalg.html "cpp/header/linalg") (C++26)  
[`<numbers>`](numbers.html "cpp/header/numbers") (C++20)  
[`<random>`](random.html "cpp/header/random") (C++11)  
[`<simd>`](simd.html "cpp/header/simd") (C++26)  
[`<stdckdint.h>`](stdckdint.h.html "cpp/header/stdckdint.h") (C++26)  
[`<valarray>`](valarray.html "cpp/header/valarray")  
[Time](../headers.html#Time_library "cpp/header")  
[`<chrono>`](chrono.html "cpp/header/chrono") (C++11)  
[`<ctime>`](ctime.html "cpp/header/ctime")  
[C compatibility](../headers.html#C_compatibility_headers "cpp/header")  
[`<ccomplex>`](ccomplex.html "cpp/header/ccomplex") (C++11/17/20*)  
[`<ciso646>`](ciso646.html "cpp/header/ciso646") (until C++20)  
[`<cstdalign>`](cstdalign.html "cpp/header/cstdalign") (C++11/17/20*)  
[`<cstdbool>`](cstdbool.html "cpp/header/cstdbool") (C++11/17/20*)  
[`<ctgmath>`](ctgmath.html "cpp/header/ctgmath") (C++11/17/20*)  
  
| [Input/output](../headers.html#Input.2Foutput_library "cpp/header")  
---  
[`<cinttypes>`](cinttypes.html "cpp/header/cinttypes") (C++11)  
[`<cstdio>`](cstdio.html "cpp/header/cstdio")  
[`<filesystem>`](filesystem.html "cpp/header/filesystem") (C++17)  
[`<fstream>`](fstream.html "cpp/header/fstream")  
[`<iomanip>`](iomanip.html "cpp/header/iomanip")  
[`<iosfwd>`](iosfwd.html "cpp/header/iosfwd")  
[`<iostream>`](iostream.html "cpp/header/iostream")  
[`<ios>`](ios.html "cpp/header/ios")  
[`<istream>`](istream.html "cpp/header/istream")  
[`<ostream>`](ostream.html "cpp/header/ostream")  
[`<print>`](print.html "cpp/header/print") (C++23)  
[`<spanstream>`](spanstream.html "cpp/header/spanstream") (C++23)  
[`<sstream>`](sstream.html "cpp/header/sstream")  
[`<streambuf>`](streambuf.html "cpp/header/streambuf")  
[`<strstream>`](strstream.html "cpp/header/strstream") (C++98/26*)  
[`<syncstream>`](syncstream.html "cpp/header/syncstream") (C++20)  
[Concurrency support](../headers.html#Concurrency_support_library "cpp/header")  
[`<atomic>`](atomic.html "cpp/header/atomic") (C++11)  
[`<barrier>`](barrier.html "cpp/header/barrier") (C++20)  
[`<condition_variable>`](condition_variable.html "cpp/header/condition variable") (C++11)  
[`<future>`](future.html "cpp/header/future") (C++11)  
[`<hazard_pointer>`](hazard_pointer.html "cpp/header/hazard pointer") (C++26)  
[`<latch>`](latch.html "cpp/header/latch") (C++20)  
[`<mutex>`](mutex.html "cpp/header/mutex") (C++11)  
[`<rcu>`](rcu.html "cpp/header/rcu") (C++26)  
[`<semaphore>`](semaphore.html "cpp/header/semaphore") (C++20)  
[`<shared_mutex>`](shared_mutex.html "cpp/header/shared mutex") (C++14)  
[`<stdatomic.h>`](stdatomic.h.html "cpp/header/stdatomic.h") (C++23)  
[`<stop_token>`](stop_token.html "cpp/header/stop token") (C++20)  
[`<thread>`](thread.html "cpp/header/thread") (C++11)  
[Execution support](../headers.html#Multi-purpose_headers "cpp/header")  
[`<execution>`](execution.html "cpp/header/execution") (C++17)  
  
  
  
  
  
  
  
  
  


This header is part of the [iterator](../iterator.html "cpp/iterator") library. 

This header is a partial [freestanding](../freestanding.html "cpp/freestanding") header. Everything inside this header is freestanding beside stream iterators.  | (since C++23)  
---|---  
| 

## Contents

  * [1 Concepts](iterator.html#Concepts)
    * [1.1 Iterator concepts](iterator.html#Iterator_concepts)
    * [1.2 Indirect callable concepts](iterator.html#Indirect_callable_concepts)
    * [1.3 Common algorithm requirements](iterator.html#Common_algorithm_requirements)
  * [2 Classes](iterator.html#Classes)
    * [2.1 Algorithm utilities](iterator.html#Algorithm_utilities)
    * [2.2 Associated types](iterator.html#Associated_types)
    * [2.3 Primitives](iterator.html#Primitives)
    * [2.4 Adaptors](iterator.html#Adaptors)
    * [2.5 Stream Iterators](iterator.html#Stream_Iterators)
  * [3 Customization point objects](iterator.html#Customization_point_objects)
  * [4 Constants](iterator.html#Constants)
  * [5 Functions](iterator.html#Functions)
    * [5.1 Adaptors](iterator.html#Adaptors_2)
    * [5.2 Non-member operators](iterator.html#Non-member_operators)
    * [5.3 Operations](iterator.html#Operations)
    * [5.4 Range access](iterator.html#Range_access)
  * [6 Synopsis](iterator.html#Synopsis)
    * [6.1 Concept indirectly_readable](iterator.html#Concept_indirectly_readable)
    * [6.2 Concept indirectly_writable](iterator.html#Concept_indirectly_writable)
    * [6.3 Concept weakly_incrementable](iterator.html#Concept_weakly_incrementable)
    * [6.4 Concept incrementable](iterator.html#Concept_incrementable)
    * [6.5 Concept input_or_output_iterator](iterator.html#Concept_input_or_output_iterator)
    * [6.6 Concept sentinel_for](iterator.html#Concept_sentinel_for)
    * [6.7 Concept sized_sentinel_for](iterator.html#Concept_sized_sentinel_for)
    * [6.8 Concept input_iterator](iterator.html#Concept_input_iterator)
    * [6.9 Concept output_iterator](iterator.html#Concept_output_iterator)
    * [6.10 Concept forward_iterator](iterator.html#Concept_forward_iterator)
    * [6.11 Concept bidirectional_iterator](iterator.html#Concept_bidirectional_iterator)
    * [6.12 Concept random_access_iterator](iterator.html#Concept_random_access_iterator)
    * [6.13 Concept contiguous_iterator](iterator.html#Concept_contiguous_iterator)
    * [6.14 Concept indirectly_unary_invocable](iterator.html#Concept_indirectly_unary_invocable)
    * [6.15 Concept indirectly_regular_unary_invocable](iterator.html#Concept_indirectly_regular_unary_invocable)
    * [6.16 Concept indirect_unary_predicate](iterator.html#Concept_indirect_unary_predicate)
    * [6.17 Concept indirect_binary_predicate](iterator.html#Concept_indirect_binary_predicate)
    * [6.18 Concept indirect_equivalence_relation](iterator.html#Concept_indirect_equivalence_relation)
    * [6.19 Concept indirect_strict_weak_order](iterator.html#Concept_indirect_strict_weak_order)
    * [6.20 Concept indirectly_movable](iterator.html#Concept_indirectly_movable)
    * [6.21 Concept indirectly_movable_storable](iterator.html#Concept_indirectly_movable_storable)
    * [6.22 Concept indirectly_copyable](iterator.html#Concept_indirectly_copyable)
    * [6.23 Concept indirectly_copyable_storable](iterator.html#Concept_indirectly_copyable_storable)
    * [6.24 Concept indirectly_swappable](iterator.html#Concept_indirectly_swappable)
    * [6.25 Concept indirectly_comparable](iterator.html#Concept_indirectly_comparable)
    * [6.26 Concept permutable](iterator.html#Concept_permutable)
    * [6.27 Concept mergeable](iterator.html#Concept_mergeable)
    * [6.28 Concept sortable](iterator.html#Concept_sortable)
    * [6.29 Class template std::incrementable_traits](iterator.html#Class_template_std::incrementable_traits)
    * [6.30 Class template std::indirectly_readable_traits](iterator.html#Class_template_std::indirectly_readable_traits)
    * [6.31 Class template std::projected](iterator.html#Class_template_std::projected)
    * [6.32 Class template std::iterator_traits](iterator.html#Class_template_std::iterator_traits)
    * [6.33 Iterator tags](iterator.html#Iterator_tags)
    * [6.34 Class template std::reverse_iterator](iterator.html#Class_template_std::reverse_iterator)
    * [6.35 Class template std::back_insert_iterator](iterator.html#Class_template_std::back_insert_iterator)
    * [6.36 Class template std::front_insert_iterator](iterator.html#Class_template_std::front_insert_iterator)
    * [6.37 Class template std::insert_iterator](iterator.html#Class_template_std::insert_iterator)
    * [6.38 Class template std::move_iterator](iterator.html#Class_template_std::move_iterator)
    * [6.39 Class template std::move_sentinel](iterator.html#Class_template_std::move_sentinel)
    * [6.40 Class template std::common_iterator](iterator.html#Class_template_std::common_iterator)
    * [6.41 Class std::default_sentinel_t](iterator.html#Class_std::default_sentinel_t)
    * [6.42 Class template std::counted_iterator](iterator.html#Class_template_std::counted_iterator)
    * [6.43 Class std::unreachable_sentinel_t](iterator.html#Class_std::unreachable_sentinel_t)
    * [6.44 Class template std::istream_iterator](iterator.html#Class_template_std::istream_iterator)
    * [6.45 Class template std::ostream_iterator](iterator.html#Class_template_std::ostream_iterator)
    * [6.46 Class template std::istreambuf_iterator](iterator.html#Class_template_std::istreambuf_iterator)
    * [6.47 Class template std::ostreambuf_iterator](iterator.html#Class_template_std::ostreambuf_iterator)
    * [6.48 Class template std::iterator](iterator.html#Class_template_std::iterator)
  * [7 Defect reports](iterator.html#Defect_reports)

  
---  
  
###  Concepts  
  
#####  Iterator concepts   
  
[ indirectly_readable](../iterator/indirectly_readable.html "cpp/iterator/indirectly readable")(C++20) |  specifies that a type is indirectly readable by applying operator `*`   
(concept)   
[ indirectly_writable](../iterator/indirectly_writable.html "cpp/iterator/indirectly writable")(C++20) |  specifies that a value can be written to an iterator's referenced object   
(concept)   
[ weakly_incrementable](../iterator/weakly_incrementable.html "cpp/iterator/weakly incrementable")(C++20) |  specifies that a [`semiregular`](../concepts/semiregular.html "cpp/concepts/semiregular") type can be incremented with pre- and post-increment operators   
(concept)   
[ incrementable](../iterator/incrementable.html "cpp/iterator/incrementable")(C++20) |  specifies that the increment operation on a [`weakly_incrementable`](../iterator/weakly_incrementable.html "cpp/iterator/weakly incrementable") type is [equality-preserving](../concepts.html#Equality_preservation "cpp/concepts") and that the type is [`equality_comparable`](../concepts/equality_comparable.html "cpp/concepts/equality comparable")   
(concept)   
[ input_or_output_iterator](../iterator/input_or_output_iterator.html "cpp/iterator/input or output iterator")(C++20) |  specifies that objects of a type can be incremented and dereferenced   
(concept)   
[ sentinel_for](../iterator/sentinel_for.html "cpp/iterator/sentinel for")(C++20) |  specifies a type is a sentinel for an [`input_or_output_iterator`](../iterator/input_or_output_iterator.html "cpp/iterator/input or output iterator") type   
(concept)   
[ sized_sentinel_for](../iterator/sized_sentinel_for.html "cpp/iterator/sized sentinel for")(C++20) |  specifies that the - operator can be applied to an iterator and a sentinel to calculate their difference in constant time   
(concept)   
[ input_iterator](../iterator/input_iterator.html "cpp/iterator/input iterator")(C++20) |  specifies that a type is an input iterator, that is, its referenced values can be read and it can be both pre- and post-incremented   
(concept)   
[ output_iterator](../iterator/output_iterator.html "cpp/iterator/output iterator")(C++20) |  specifies that a type is an output iterator for a given value type, that is, values of that type can be written to it and it can be both pre- and post-incremented   
(concept)   
[ forward_iterator](../iterator/forward_iterator.html "cpp/iterator/forward iterator")(C++20) |  specifies that an [`input_iterator`](../iterator/input_iterator.html "cpp/iterator/input iterator") is a forward iterator, supporting equality comparison and multi-pass   
(concept)   
[ bidirectional_iterator](../iterator/bidirectional_iterator.html "cpp/iterator/bidirectional iterator")(C++20) |  specifies that a [`forward_iterator`](../iterator/forward_iterator.html "cpp/iterator/forward iterator") is a bidirectional iterator, supporting movement backwards   
(concept)   
[ random_access_iterator](../iterator/random_access_iterator.html "cpp/iterator/random access iterator")(C++20) |  specifies that a [`bidirectional_iterator`](../iterator/bidirectional_iterator.html "cpp/iterator/bidirectional iterator") is a random-access iterator, supporting advancement in constant time and subscripting   
(concept)   
[ contiguous_iterator](../iterator/contiguous_iterator.html "cpp/iterator/contiguous iterator")(C++20) |  specifies that a [`random_access_iterator`](../iterator/random_access_iterator.html "cpp/iterator/random access iterator") is a contiguous iterator, referring to elements that are contiguous in memory   
(concept)   
  
#####  Indirect callable concepts   
  
[ indirectly_unary_invocableindirectly_regular_unary_invocable](../iterator/indirectly_unary_invocable.html "cpp/iterator/indirectly unary invocable")(C++20)(C++20) |  specifies that a callable type can be invoked with the result of dereferencing an [`indirectly_readable`](../iterator/indirectly_readable.html "cpp/iterator/indirectly readable") type   
(concept)   
[ indirect_unary_predicate](../iterator/indirect_unary_predicate.html "cpp/iterator/indirect unary predicate")(C++20) |  specifies that a callable type, when invoked with the result of dereferencing an [`indirectly_readable`](../iterator/indirectly_readable.html "cpp/iterator/indirectly readable") type, satisfies [`predicate`](../concepts/predicate.html "cpp/concepts/predicate")   
(concept)   
[ indirect_binary_predicate](../iterator/indirect_binary_predicate.html "cpp/iterator/indirect binary predicate")(C++20) |  specifies that a callable type, when invoked with the result of dereferencing two [`indirectly_readable`](../iterator/indirectly_readable.html "cpp/iterator/indirectly readable") types, satisfies [`predicate`](../concepts/predicate.html "cpp/concepts/predicate")   
(concept)   
[ indirect_equivalence_relation](../iterator/indirect_equivalence_relation.html "cpp/iterator/indirect equivalence relation")(C++20) |  specifies that a callable type, when invoked with the result of dereferencing two [`indirectly_readable`](../iterator/indirectly_readable.html "cpp/iterator/indirectly readable") types, satisfies [`equivalence_relation`](../concepts/equivalence_relation.html "cpp/concepts/equivalence relation")   
(concept)   
[ indirect_strict_weak_order](../iterator/indirect_strict_weak_order.html "cpp/iterator/indirect strict weak order")(C++20) |  specifies that a callable type, when invoked with the result of dereferencing two [`indirectly_readable`](../iterator/indirectly_readable.html "cpp/iterator/indirectly readable") types, satisfies [`strict_weak_order`](../concepts/strict_weak_order.html "cpp/concepts/strict weak order")   
(concept)   
  
#####  Common algorithm requirements   
  
[ indirectly_movable](../iterator/indirectly_movable.html "cpp/iterator/indirectly movable")(C++20) |  specifies that values may be moved from an [`indirectly_readable`](../iterator/indirectly_readable.html "cpp/iterator/indirectly readable") type to an [`indirectly_writable`](../iterator/indirectly_writable.html "cpp/iterator/indirectly writable") type   
(concept)   
[ indirectly_movable_storable](../iterator/indirectly_movable_storable.html "cpp/iterator/indirectly movable storable")(C++20) |  specifies that values may be moved from an [`indirectly_readable`](../iterator/indirectly_readable.html "cpp/iterator/indirectly readable") type to an [`indirectly_writable`](../iterator/indirectly_writable.html "cpp/iterator/indirectly writable") type and that the move may be performed via an intermediate object   
(concept)   
[ indirectly_copyable](../iterator/indirectly_copyable.html "cpp/iterator/indirectly copyable")(C++20) |  specifies that values may be copied from an [`indirectly_readable`](../iterator/indirectly_readable.html "cpp/iterator/indirectly readable") type to an [`indirectly_writable`](../iterator/indirectly_writable.html "cpp/iterator/indirectly writable") type   
(concept)   
[ indirectly_copyable_storable](../iterator/indirectly_copyable_storable.html "cpp/iterator/indirectly copyable storable")(C++20) |  specifies that values may be copied from an [`indirectly_readable`](../iterator/indirectly_readable.html "cpp/iterator/indirectly readable") type to an [`indirectly_writable`](../iterator/indirectly_writable.html "cpp/iterator/indirectly writable") type and that the copy may be performed via an intermediate object   
(concept)   
[ indirectly_swappable](../iterator/indirectly_swappable.html "cpp/iterator/indirectly swappable")(C++20) |  specifies that the values referenced by two [`indirectly_readable`](../iterator/indirectly_readable.html "cpp/iterator/indirectly readable") types can be swapped   
(concept)   
[ indirectly_comparable](../iterator/indirectly_comparable.html "cpp/iterator/indirectly comparable")(C++20) |  specifies that the values referenced by two [`indirectly_readable`](../iterator/indirectly_readable.html "cpp/iterator/indirectly readable") types can be compared   
(concept)   
[ permutable](../iterator/permutable.html "cpp/iterator/permutable")(C++20) |  specifies the common requirements of algorithms that reorder elements in place   
(concept)   
[ mergeable](../iterator/mergeable.html "cpp/iterator/mergeable")(C++20) |  specifies the requirements of algorithms that merge sorted sequences into an output sequence by copying elements   
(concept)   
[ sortable](../iterator/sortable.html "cpp/iterator/sortable")(C++20) |  specifies the common requirements of algorithms that permute sequences into ordered sequences   
(concept)   
  
###  Classes  
  
#####  Algorithm utilities   
  
[ indirect_result_t](../iterator/indirect_result_t.html "cpp/iterator/indirect result t")(C++20) |  computes the result of invoking a callable object on the result of dereferencing some set of [`indirectly_readable`](../iterator/indirectly_readable.html "cpp/iterator/indirectly readable") types  
(alias template)  
[ projected](../iterator/projected.html "cpp/iterator/projected")(C++20) |  helper template for specifying the constraints on algorithms that accept projections  
(alias template)  
[ projected_value_t](../iterator/projected_value_t.html "cpp/iterator/projected value t")(C++26) |  computes the value type of an [`indirectly_readable`](../iterator/indirectly_readable.html "cpp/iterator/indirectly readable") type by projection  
(alias template)  
  
#####  Associated types   
  
[ incrementable_traits](../iterator/incrementable_traits.html "cpp/iterator/incrementable traits")(C++20) |  computes the difference type of a [`weakly_incrementable`](../iterator/weakly_incrementable.html "cpp/iterator/weakly incrementable") type   
(class template)   
[ indirectly_readable_traits](../iterator/readable_traits.html "cpp/iterator/indirectly readable traits")(C++20) |  computes the value type of an [`indirectly_readable`](../iterator/indirectly_readable.html "cpp/iterator/indirectly readable") type   
(class template)   
[ iter_value_titer_reference_titer_const_reference_titer_difference_titer_rvalue_reference_titer_common_reference_t](../iterator/iter_t.html "cpp/iterator/iter t")(C++20)(C++20)(C++23)(C++20)(C++20)(C++20) |  computes the associated types of an iterator  
(alias template)  
  
#####  Primitives   
  
[ iterator_traits](../iterator/iterator_traits.html "cpp/iterator/iterator traits") |  provides uniform interface to the properties of an iterator   
(class template)   
[ input_iterator_tagoutput_iterator_tagforward_iterator_tagbidirectional_iterator_tagrandom_access_iterator_tagcontiguous_iterator_tag](../iterator/iterator_tags.html "cpp/iterator/iterator tags")(C++20) |  empty class types used to indicate iterator categories   
(class)   
[ iterator](../iterator/iterator.html "cpp/iterator/iterator")(deprecated in C++17) |  base class to ease the definition of required types for simple iterators   
(class template)   
  
#####  Adaptors   
  
[ reverse_iterator](../iterator/reverse_iterator.html "cpp/iterator/reverse iterator") |  iterator adaptor for reverse-order traversal   
(class template)   
[ move_iterator](../iterator/move_iterator.html "cpp/iterator/move iterator")(C++11) |  iterator adaptor which dereferences to an rvalue   
(class template)   
[ move_sentinel](../iterator/move_sentinel.html "cpp/iterator/move sentinel")(C++20) |  sentinel adaptor for [std::move_iterator](../iterator/move_iterator.html "cpp/iterator/move iterator")   
(class template)   
[ basic_const_iterator](../iterator/basic_const_iterator.html "cpp/iterator/basic const iterator")(C++23) |  iterator adaptor that converts an iterator into a constant iterator   
(class template)   
[ const_iterator](../iterator/const_iterator.html#Helper_alias_templates "cpp/iterator/const iterator")(C++23) |  computes a constant iterator type for a given type  
(alias template)  
[ const_sentinel](../iterator/const_sentinel.html#Helper_alias_templates "cpp/iterator/const sentinel")(C++23) |  computes a sentinel type to be used with constant iterators  
(alias template)  
[ common_iterator](../iterator/common_iterator.html "cpp/iterator/common iterator")(C++20) |  adapts an iterator type and its sentinel into a common iterator type   
(class template)   
[ default_sentinel_t](../iterator/default_sentinel.html "cpp/iterator/default sentinel t")(C++20) |  default sentinel for use with iterators that know the bound of their range   
(class)   
[ counted_iterator](../iterator/counted_iterator.html "cpp/iterator/counted iterator")(C++20) |  iterator adaptor that tracks the distance to the end of the range   
(class template)   
[ unreachable_sentinel_t](../iterator/unreachable_sentinel_t.html "cpp/iterator/unreachable sentinel t")(C++20) |  sentinel that always compares unequal to any [`weakly_incrementable`](../iterator/weakly_incrementable.html "cpp/iterator/weakly incrementable") type   
(class)   
[ back_insert_iterator](../iterator/back_insert_iterator.html "cpp/iterator/back insert iterator") |  iterator adaptor for insertion at the end of a container   
(class template)   
[ front_insert_iterator](../iterator/front_insert_iterator.html "cpp/iterator/front insert iterator") |  iterator adaptor for insertion at the front of a container   
(class template)   
[ insert_iterator](../iterator/insert_iterator.html "cpp/iterator/insert iterator") |  iterator adaptor for insertion into a container   
(class template)   
  
#####  Stream Iterators   
  
[ istream_iterator](../iterator/istream_iterator.html "cpp/iterator/istream iterator") |  input iterator that reads from [std::basic_istream](../io/basic_istream.html "cpp/io/basic istream")   
(class template)   
[ ostream_iterator](../iterator/ostream_iterator.html "cpp/iterator/ostream iterator") |  output iterator that writes to [std::basic_ostream](../io/basic_ostream.html "cpp/io/basic ostream")   
(class template)   
[ istreambuf_iterator](../iterator/istreambuf_iterator.html "cpp/iterator/istreambuf iterator") |  input iterator that reads from [std::basic_streambuf](../io/basic_streambuf.html "cpp/io/basic streambuf")   
(class template)   
[ ostreambuf_iterator](../iterator/ostreambuf_iterator.html "cpp/iterator/ostreambuf iterator") |  output iterator that writes to [std::basic_streambuf](../io/basic_streambuf.html "cpp/io/basic streambuf")   
(class template)   
  
###  Customization point objects  
  
Defined in namespace `std::ranges`  
[ iter_move](../iterator/ranges/iter_move.html "cpp/iterator/ranges/iter move")(C++20) |  casts the result of dereferencing an object to its associated rvalue reference type  
(customization point object)  
[ iter_swap](../iterator/ranges/iter_swap.html "cpp/iterator/ranges/iter swap")(C++20) |  swaps the values referenced by two dereferenceable objects  
(customization point object)  
  
###  Constants  
  
[ unreachable_sentinel](../iterator/unreachable_sentinel_t.html "cpp/iterator/unreachable sentinel t")(C++20) |  an object of type `unreachable_sentinel_t` that always compares unequal to any [`weakly_incrementable`](../iterator/weakly_incrementable.html "cpp/iterator/weakly incrementable") type   
(constant)   
[ default_sentinel](../iterator/default_sentinel.html "cpp/iterator/default sentinel t")(C++20) |  an object of type `default_sentinel_t` used with iterators that know the bound of their range   
(constant)   
  
###  Functions  
  
#####  Adaptors   
  
[ make_reverse_iterator](../iterator/make_reverse_iterator.html "cpp/iterator/make reverse iterator")(C++14) |  creates a [std::reverse_iterator](../iterator/reverse_iterator.html "cpp/iterator/reverse iterator") of type inferred from the argument   
(function template)   
[ make_move_iterator](../iterator/make_move_iterator.html "cpp/iterator/make move iterator")(C++11) |  creates a [std::move_iterator](../iterator/move_iterator.html "cpp/iterator/move iterator") of type inferred from the argument   
(function template)   
[ make_const_iterator](../iterator/make_const_iterator.html#Helper_function_templates "cpp/iterator/make const iterator")(C++23) |  creates a std::const_iterator of type inferred from the argument   
(function template)   
[ make_const_sentinel](../iterator/make_const_sentinel.html#Helper_function_templates "cpp/iterator/make const sentinel")(C++23) |  creates a std::const_sentinel of type inferred from the argument   
(function template)   
[ front_inserter](../iterator/front_inserter.html "cpp/iterator/front inserter") |  creates a [std::front_insert_iterator](../iterator/front_insert_iterator.html "cpp/iterator/front insert iterator") of type inferred from the argument   
(function template)   
[ back_inserter](../iterator/back_inserter.html "cpp/iterator/back inserter") |  creates a [std::back_insert_iterator](../iterator/back_insert_iterator.html "cpp/iterator/back insert iterator") of type inferred from the argument   
(function template)   
[ inserter](../iterator/inserter.html "cpp/iterator/inserter") |  creates a [std::insert_iterator](../iterator/insert_iterator.html "cpp/iterator/insert iterator") of type inferred from the argument   
(function template)   
  
#####  Non-member operators   
  
[ operator==operator!=operator<operator<=operator>operator>=operator<=>](../iterator/move_iterator/operator_cmp.html "cpp/iterator/move iterator/operator cmp")(C++11)(C++11)(removed in C++20)(C++11)(C++11)(C++11)(C++11)(C++20) |  compares the underlying iterators   
(function template)   
[ operator+](../iterator/move_iterator/operator+.html "cpp/iterator/move iterator/operator+")(C++11) |  advances the iterator   
(function template)   
[ operator-](../iterator/move_iterator/operator-.html "cpp/iterator/move iterator/operator-")(C++11) |  computes the distance between two iterator adaptors   
(function template)   
[ operator==operator!=operator<operator<=operator>operator>=operator<=>](../iterator/reverse_iterator/operator_cmp.html "cpp/iterator/reverse iterator/operator cmp")(C++20) |  compares the underlying iterators   
(function template)   
[ operator+](../iterator/reverse_iterator/operator+.html "cpp/iterator/reverse iterator/operator+") |  advances the iterator   
(function template)   
[ operator-](../iterator/reverse_iterator/operator-.html "cpp/iterator/reverse iterator/operator-") |  computes the distance between two iterator adaptors   
(function template)   
[ operator==operator<=>](../iterator/counted_iterator/operator_cmp.html "cpp/iterator/counted iterator/operator cmp")(C++20) |  compares the distances to the end   
(function template)   
[ operator+](../iterator/counted_iterator/operator+.html "cpp/iterator/counted iterator/operator+")(C++20) |  advances the iterator   
(function template)   
[ operator-](../iterator/counted_iterator/operator-.html "cpp/iterator/counted iterator/operator-")(C++20) |  computes the distance between two iterator adaptors   
(function template)   
[ operator==operator!=](../iterator/istream_iterator/operator_cmp.html "cpp/iterator/istream iterator/operator cmp")(removed in C++20) |  compares two `istream_iterator`s   
(function template)   
[ operator==operator!=](../iterator/istreambuf_iterator/operator_cmp.html "cpp/iterator/istreambuf iterator/operator cmp")(removed in C++20) |  compares two `istreambuf_iterator`s   
(function template)   
  
#####  Operations   
  
[ advance](../iterator/advance.html "cpp/iterator/advance") |  advances an iterator by given distance   
(function template)   
[ distance](../iterator/distance.html "cpp/iterator/distance") |  returns the distance between two iterators   
(function template)   
[ next](../iterator/next.html "cpp/iterator/next")(C++11) |  increment an iterator   
(function template)   
[ prev](../iterator/prev.html "cpp/iterator/prev")(C++11) |  decrement an iterator   
(function template)   
[ ranges::advance](../iterator/ranges/advance.html "cpp/iterator/ranges/advance")(C++20) |  advances an iterator by given distance or to a given bound  
(algorithm function object)  
[ ranges::distance](../iterator/ranges/distance.html "cpp/iterator/ranges/distance")(C++20) |  returns the distance between an iterator and a sentinel, or between the beginning and end of a range  
(algorithm function object)  
[ ranges::next](../iterator/ranges/next.html "cpp/iterator/ranges/next")(C++20) |  increment an iterator by a given distance or to a bound  
(algorithm function object)  
[ ranges::prev](../iterator/ranges/prev.html "cpp/iterator/ranges/prev")(C++20) |  decrement an iterator by a given distance or to a bound  
(algorithm function object)  
  
#####  Range access   
  
[ begincbegin](../iterator/begin.html "cpp/iterator/begin")(C++11)(C++14) |  returns an iterator to the beginning of a container or array   
(function template)   
[ endcend](../iterator/end.html "cpp/iterator/end")(C++11)(C++14) |  returns an iterator to the end of a container or array   
(function template)   
[ rbegincrbegin](../iterator/rbegin.html "cpp/iterator/rbegin")(C++14) |  returns a reverse iterator to the beginning of a container or array   
(function template)   
[ rendcrend](../iterator/rend.html "cpp/iterator/rend")(C++14) |  returns a reverse end iterator for a container or array   
(function template)   
[ sizessize](../iterator/size.html "cpp/iterator/size")(C++17)(C++20) |  returns the size of a container or array   
(function template)   
[ empty](../iterator/empty.html "cpp/iterator/empty")(C++17) |  checks whether the container is empty   
(function template)   
[ data](../iterator/data.html "cpp/iterator/data")(C++17) |  obtains the pointer to the underlying array   
(function template)   
  
### Synopsis
    
    
    #include <compare>
    #include <concepts>
     
    namespace std {
      template<class T> using /* with-reference */ = T&;  // exposition only
      template<class T> concept /* can-reference */       // exposition only
        = requires { typename /* with-reference */<T>; };
      template<class T> concept /* dereferenceable */     // exposition only
        = requires(T& t) {
          { *t } -> /* can-reference */;  // not required to be equality-preserving
        };
     
      // associated types
      // incrementable traits
      template<class> struct incrementable_traits;
      template<class T>
        using iter_difference_t = /* see description */;
     
      // indirectly readable traits
      template<class> struct indirectly_readable_traits;
      template<class T>
        using iter_value_t = /* see description */;
     
      // iterator traits
      template<class I> struct iterator_traits;
      template<class T> requires is_object_v<T> struct iterator_traits<T*>;
     
      template</* dereferenceable */ T>
        using iter_reference_t = decltype(*declval<T&>());
     
      namespace ranges {
        // customization point objects
        inline namespace /* unspecified */ {
          // ranges::iter_move
          inline constexpr /* unspecified */ iter_move = /* unspecified */;
     
          // ranges::iter_swap
          inline constexpr /* unspecified */ iter_swap = /* unspecified */;
        }
      }
     
      template</* dereferenceable */ T>
        requires requires(T& t) {
          { [ranges::iter_move](../iterator/ranges/iter_move.html)(t) } -> /* can-reference */;
        }
      using iter_rvalue_reference_t
        = decltype([ranges::iter_move](../iterator/ranges/iter_move.html)(declval<T&>()));
     
      // iterator concepts
      // concept indirectly_readable
      template<class In>
        concept indirectly_readable = /* see description */;
     
      template<indirectly_readable T>
        using iter_common_reference_t =
          common_reference_t<iter_reference_t<T>, iter_value_t<T>&>;
     
      // concept indirectly_writable
      template<class Out, class T>
        concept indirectly_writable = /* see description */;
     
      // concept weakly_incrementable
      template<class I>
        concept weakly_incrementable = /* see description */;
     
      // concept incrementable
      template<class I>
        concept incrementable = /* see description */;
     
      // concept input_or_output_iterator
      template<class I>
        concept input_or_output_iterator = /* see description */;
     
      // concept sentinel_for
      template<class S, class I>
        concept sentinel_for = /* see description */;
     
      // concept sized_sentinel_for
      template<class S, class I>
        inline constexpr bool disable_sized_sentinel_for = false;
     
      template<class S, class I>
        concept sized_sentinel_for = /* see description */;
     
      // concept input_iterator
      template<class I>
        concept input_iterator = /* see description */;
     
      // concept output_iterator
      template<class I, class T>
        concept output_iterator = /* see description */;
     
      // concept forward_iterator
      template<class I>
        concept forward_iterator = /* see description */;
     
      // concept bidirectional_iterator
      template<class I>
        concept bidirectional_iterator = /* see description */;
     
      // concept random_access_iterator
      template<class I>
        concept random_access_iterator = /* see description */;
     
      // concept contiguous_iterator
      template<class I>
        concept contiguous_iterator = /* see description */;
     
      // indirect callable requirements
      // indirect callables
      template<class F, class I>
        concept indirectly_unary_invocable = /* see description */;
     
      template<class F, class I>
        concept indirectly_regular_unary_invocable = /* see description */;
     
      template<class F, class I>
        concept indirect_unary_predicate = /* see description */;
     
      template<class F, class I1, class I2>
        concept indirect_binary_predicate = /* see description */;
     
      template<class F, class I1, class I2 = I1>
        concept indirect_equivalence_relation = /* see description */;
     
      template<class F, class I1, class I2 = I1>
        concept indirect_strict_weak_order = /* see description */;
     
      template<class F, class... Is>
        requires (indirectly_readable<Is> && ...) && invocable<F, iter_reference_t<Is>...>
          using indirect_result_t = invoke_result_t<F, iter_reference_t<Is>...>;
     
      // projected
      template<indirectly_readable I, indirectly_regular_unary_invocable<I> Proj>
        using [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected) = /* see description */;
     
      template<indirectly_­readable I, indirectly_­regular_­unary_­invocable<I> Proj>
        using projected_value_t = remove_cvref_t<invoke_result_t<Proj&, iter_value_t<I>&>>;
     
      // common algorithm requirements
      // concept indirectly_movable
      template<class In, class Out>
        concept indirectly_movable = /* see description */;
     
      template<class In, class Out>
        concept indirectly_movable_storable = /* see description */;
     
      // concept indirectly_copyable
      template<class In, class Out>
        concept indirectly_copyable = /* see description */;
     
      template<class In, class Out>
        concept indirectly_copyable_storable = /* see description */;
     
      // concept indirectly_swappable
      template<class I1, class I2 = I1>
        concept indirectly_swappable = /* see description */;
     
      // concept indirectly_comparable
      template<class I1, class I2, class R, class P1 = identity, class P2 = identity>
        concept indirectly_comparable = /* see description */;
     
      // concept permutable
      template<class I>
        concept permutable = /* see description */;
     
      // concept mergeable
      template<class I1, class I2, class Out,
          class R = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less), class P1 = identity, class P2 = identity>
        concept mergeable = /* see description */;
     
      // concept sortable
      template<class I, class R = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less), class P = identity>
        concept sortable = /* see description */;
     
      // primitives
      // iterator tags
      struct input_iterator_tag { };
      struct output_iterator_tag { };
      struct forward_iterator_tag: public input_iterator_tag { };
      struct bidirectional_iterator_tag: public forward_iterator_tag { };
      struct random_access_iterator_tag: public bidirectional_iterator_tag { };
      struct contiguous_iterator_tag: public random_access_iterator_tag { };
     
      // iterator operations
      template<class InputIt, class Distance>
        constexpr void advance(InputIt& i, Distance n);
      template<class InputIt>
        constexpr typename iterator_traits<InputIt>::difference_type
          distance(InputIt first, InputIt last);
      template<class InputIt>
        constexpr InputIt
          next(InputIt x, typename iterator_traits<InputIt>::difference_type n = 1);
      template<class BidirIt>
        constexpr BidirIt
          prev(BidirIt x, typename iterator_traits<BidirIt>::difference_type n = 1);
     
      // range iterator operations
      namespace ranges {
        // ranges::advance
        template<input_or_output_iterator I>
          constexpr void advance(I& i, iter_difference_t<I> n);
        template<input_or_output_iterator I, sentinel_for<I> S>
          constexpr void advance(I& i, S bound);
        template<input_or_output_iterator I, sentinel_for<I> S>
          constexpr iter_difference_t<I> advance(I& i, iter_difference_t<I> n, S bound);
     
        // ranges::distance
        template<class I, sentinel_for<I> S>
          requires (!sized_sentinel_for<S, I>)
          constexpr iter_difference_t<I> distance(I first, S last);
        template<class I, sized_sentinel_for<decay_t<I>> S>
          constexpr iter_difference_t<decay_t<I>> distance(I&& first, S last);
        template<range R>
          constexpr range_difference_t<R> distance(R&& r);
     
        // ranges::next
        template<input_or_output_iterator I>
          constexpr I next(I x);
        template<input_or_output_iterator I>
          constexpr I next(I x, iter_difference_t<I> n);
        template<input_or_output_iterator I, sentinel_for<I> S>
          constexpr I next(I x, S bound);
        template<input_or_output_iterator I, sentinel_for<I> S>
          constexpr I next(I x, iter_difference_t<I> n, S bound);
     
        // ranges::prev
        template<bidirectional_iterator I>
          constexpr I prev(I x);
        template<bidirectional_iterator I>
          constexpr I prev(I x, iter_difference_t<I> n);
        template<bidirectional_iterator I>
          constexpr I prev(I x, iter_difference_t<I> n, I bound);
      }
     
      // predefined iterators and sentinels
      // reverse iterators
      template<class It> class reverse_iterator;
     
      template<class It1, class It2>
        constexpr bool operator==(const reverse_iterator<It1>& x,
                                  const reverse_iterator<It2>& y);
      template<class It1, class It2>
        constexpr bool operator!=(const reverse_iterator<It1>& x,
                                  const reverse_iterator<It2>& y);
      template<class It1, class It2>
        constexpr bool operator<(const reverse_iterator<It1>& x,
                                 const reverse_iterator<It2>& y);
      template<class It1, class It2>
        constexpr bool operator>(const reverse_iterator<It1>& x,
                                 const reverse_iterator<It2>& y);
      template<class It1, class It2>
        constexpr bool operator<=(const reverse_iterator<It1>& x,
                                  const reverse_iterator<It2>& y);
      template<class It1, class It2>
        constexpr bool operator>=(const reverse_iterator<It1>& x,
                                  const reverse_iterator<It2>& y);
      template<class It1, three_way_comparable_with<It1> It2>
        constexpr compare_three_way_result_t<It1, It2>
          operator<=>(const reverse_iterator<It1>& x, const reverse_iterator<It2>& y);
     
      template<class It1, class It2>
        constexpr auto operator-(const reverse_iterator<It1>& x,
                                 const reverse_iterator<It2>& y)
          -> decltype(y.base() - x.base());
      template<class It>
        constexpr reverse_iterator<It> operator+(iter_difference_t<It> n,
                                                 const reverse_iterator<It>& x);
     
      template<class It>
        constexpr reverse_iterator<It> make_reverse_iterator(It i);
     
      template<class It1, class It2>
          requires (!sized_sentinel_for<It1, It2>)
        inline constexpr bool disable_sized_sentinel_for<reverse_iterator<It1>,
                                                         reverse_iterator<It2>> = true;
     
      // insert iterators
      template<class Container> class back_insert_iterator;
      template<class Container>
        constexpr back_insert_iterator<Container> back_inserter(Container& x);
     
      template<class Container> class front_insert_iterator;
      template<class Container>
        constexpr front_insert_iterator<Container> front_inserter(Container& x);
     
      template<class Container> class insert_iterator;
      template<class Container>
        constexpr insert_iterator<Container>
          inserter(Container& x, [ranges::iterator_t](../ranges/iterator_t.html)<Container> i);
     
      // move iterators and sentinels
      template<class It> class move_iterator;
     
      template<class It1, class It2>
        constexpr bool operator==(const move_iterator<It1>& x, const move_iterator<It2>& y);
      template<class It1, class It2>
        constexpr bool operator<(const move_iterator<It1>& x, const move_iterator<It2>& y);
      template<class It1, class It2>
        constexpr bool operator>(const move_iterator<It1>& x, const move_iterator<It2>& y);
      template<class It1, class It2>
        constexpr bool operator<=(const move_iterator<It1>& x, const move_iterator<It2>& y);
      template<class It1, class It2>
        constexpr bool operator>=(const move_iterator<It1>& x, const move_iterator<It2>& y);
      template<class It1, three_way_comparable_with<It1> It2>
        constexpr compare_three_way_result_t<It1, It2>
          operator<=>(const move_iterator<It1>& x, const move_iterator<It2>& y);
     
      template<class It1, class It2>
        constexpr auto operator-(const move_iterator<It1>& x, const move_iterator<It2>& y)
          -> decltype(x.base() - y.base());
      template<class It>
        constexpr move_iterator<It>
          operator+(iter_difference_t<It> n, const move_iterator<It>& x);
     
      template<class It>
        constexpr move_iterator<It> make_move_iterator(It i);
     
      template<semiregular S> class move_sentinel;
     
      // common iterators
      template<input_or_output_iterator I, sentinel_for<I> S>
        requires (!same_as<I, S> && copyable<I>)
          class common_iterator;
     
      template<class I, class S>
        struct incrementable_traits<common_iterator<I, S>>;
     
      template<input_iterator I, class S>
        struct iterator_traits<common_iterator<I, S>>;
     
      // default sentinel
      struct default_sentinel_t;
      inline constexpr default_sentinel_t default_sentinel{};
     
      // counted iterators
      template<input_or_output_iterator I> class counted_iterator;
     
      template<input_iterator I>
        requires /* see description */
        struct iterator_traits<counted_iterator<I>>;
     
      // unreachable sentinel
      struct unreachable_sentinel_t;
      inline constexpr unreachable_sentinel_t unreachable_sentinel{};
     
      // stream iterators
      template<class T, class CharT = char, class Traits = char_traits<CharT>,
               class Distance = ptrdiff_t>
      class istream_iterator;
      template<class T, class CharT, class Traits, class Distance>
        bool operator==(const istream_iterator<T, CharT, Traits, Distance>& x,
                        const istream_iterator<T, CharT, Traits, Distance>& y);
     
      template<class T, class CharT = char, class traits = char_traits<CharT>>
          class ostream_iterator;
     
      template<class CharT, class Traits = char_traits<CharT>>
        class istreambuf_iterator;
      template<class CharT, class Traits>
        bool operator==(const istreambuf_iterator<CharT, Traits>& a,
                        const istreambuf_iterator<CharT, Traits>& b);
     
      template<class CharT, class Traits = char_traits<CharT>>
        class ostreambuf_iterator;
     
      // range access
      template<class C> constexpr auto begin(C& c) -> decltype(c.begin());
      template<class C> constexpr auto begin(const C& c) -> decltype(c.begin());
      template<class C> constexpr auto end(C& c) -> decltype(c.end());
      template<class C> constexpr auto end(const C& c) -> decltype(c.end());
      template<class T, size_t N> constexpr T* begin(T (&a)[N]) noexcept;
      template<class T, size_t N> constexpr T* end(T (&a)[N]) noexcept;
      template<class C> constexpr auto cbegin(const C& c) noexcept(noexcept([std::begin](../iterator/begin.html)(c)))
        -> decltype([std::begin](../iterator/begin.html)(c));
      template<class C> constexpr auto cend(const C& c) noexcept(noexcept([std::end](../iterator/end.html)(c)))
        -> decltype([std::end](../iterator/end.html)(c));
      template<class C> constexpr auto rbegin(C& c) -> decltype(c.rbegin());
      template<class C> constexpr auto rbegin(const C& c) -> decltype(c.rbegin());
      template<class C> constexpr auto rend(C& c) -> decltype(c.rend());
      template<class C> constexpr auto rend(const C& c) -> decltype(c.rend());
      template<class T, size_t N> constexpr reverse_iterator<T*> rbegin(T (&a)[N]);
      template<class T, size_t N> constexpr reverse_iterator<T*> rend(T (&a)[N]);
      template<class E> constexpr reverse_iterator<const E*> rbegin(initializer_list<E> il);
      template<class E> constexpr reverse_iterator<const E*> rend(initializer_list<E> il);
      template<class C> constexpr auto crbegin(const C& c) -> decltype([std::rbegin](../iterator/rbegin.html)(c));
      template<class C> constexpr auto crend(const C& c) -> decltype([std::rend](../iterator/rend.html)(c));
     
      template<class C> constexpr auto size(const C& c) -> decltype(c.size());
      template<class T, size_t N> constexpr size_t size(const T (&a)[N]) noexcept;
      template<class C> constexpr auto ssize(const C& c)
        -> common_type_t<ptrdiff_t, make_signed_t<decltype(c.size())>>;
      template<class T, ptrdiff_t N> constexpr ptrdiff_t ssize(const T (&a)[N]) noexcept;
      template<class C> constexpr auto empty(const C& c) -> decltype(c.empty());
      template<class T, size_t N> constexpr bool empty(const T (&a)[N]) noexcept;
      template<class E> constexpr bool empty(initializer_list<E> il) noexcept;
      template<class C> constexpr auto data(C& c) -> decltype(c.data());
      template<class C> constexpr auto data(const C& c) -> decltype(c.data());
      template<class T, size_t N> constexpr T* data(T (&a)[N]) noexcept;
      template<class E> constexpr const E* data(initializer_list<E> il) noexcept;
    }

#### Concept [`indirectly_readable`](../iterator/indirectly_readable.html "cpp/iterator/indirectly readable")
    
    
    namespace std {
      template<class In>
        concept /*indirectlyReadableImpl*/ = // exposition only
          requires(const In in) {
            typename iter_value_t<In>;
            typename iter_reference_t<In>;
            typename iter_rvalue_reference_t<In>;
            { *in } -> same_as<iter_reference_t<In>>
            { iter_move(in) } -> same_as<iter_rvalue_reference_t<In>>
          } &&
          common_reference_with<iter_reference_t<In>&&, iter_value_t<In>&> &&
          common_reference_with<iter_reference_t<In>&&, iter_rvalue_reference_t<In>&&> &&
          common_reference_with<iter_rvalue_reference_t<In>&&, const iter_value_t<In>&>;
     
      template<class In>
        concept indirectly_readable =
          /*indirectlyReadableImpl*/<remove_cvref_t<In>>
    }

#### Concept [`indirectly_writable`](../iterator/indirectly_writable.html "cpp/iterator/indirectly writable")
    
    
    namespace std {
      template<class Out, class T>
        concept indirectly_writable =
          requires(Out&& o, T&& t) {
            *o = [std::forward](../utility/forward.html)<T>(t); // not required to be equality-preserving
            *[std::forward](../utility/forward.html)<Out>(o) = [std::forward](../utility/forward.html)<T>(t);
            // not required to be equality-preserving
            const_cast<const iter_reference_t<Out>&&>(*o) =
            [std::forward](../utility/forward.html)<T>(t); // not required to be equality-preserving
            const_cast<const iter_reference_t<Out>&&>(*[std::forward](../utility/forward.html)<Out>(o)) =
            [std::forward](../utility/forward.html)<T>(t); // not required to be equality-preserving
          };
    }

#### Concept [`weakly_incrementable`](../iterator/weakly_incrementable.html "cpp/iterator/weakly incrementable")
    
    
    namespace std {
      template<class T>
        inline constexpr bool /*is_integer_like*/ = /* see description */; // exposition only
     
      template<class T>
        inline constexpr bool /*is_signed_integer_like*/ =  // exposition only
          /* see description */;
     
      template<class I>
        concept weakly_incrementable =
          default_initializable<I> && movable<I> &&
          requires(I i) {
            typename iter_difference_t<I>;
            requires /*is_signed_integer_like*/<iter_difference_t<I>>;
            { ++i } -> same_as<I&>;   // not required to be equality-preserving
            i++;                      // not required to be equality-preserving
          };
    }

#### Concept [`incrementable`](../iterator/incrementable.html "cpp/iterator/incrementable")
    
    
    namespace std {
      template<class I>
        concept incrementable =
          regular<I> &&
          weakly_incrementable<I> &&
          requires(I i) {
            { i++ } -> same_as<I>;
          };
    }

#### Concept [`input_or_output_iterator`](../iterator/input_or_output_iterator.html "cpp/iterator/input or output iterator")
    
    
    namespace std {
      template<class I>
        concept input_or_output_iterator =
          requires(I i) {
            { *i } -> can-reference;
          } &&
          weakly_incrementable<I>;
    }

#### Concept [`sentinel_for`](../iterator/sentinel_for.html "cpp/iterator/sentinel for")
    
    
    namespace std {
      template<class S, class I>
        concept sentinel_for =
          semiregular<S> &&
          input_or_output_iterator<I> &&
          /*WeaklyEqualityComparableWith*/<S, I>;
    }

#### Concept [`sized_sentinel_for`](../iterator/sized_sentinel_for.html "cpp/iterator/sized sentinel for")
    
    
    namespace std {
      template<class S, class I>
        concept sized_sentinel_for =
          sentinel_for<S, I> &&
          !disable_sized_sentinel<remove_cv_t<S>, remove_cv_t<I>> &&
          requires(const I& i, const S& s) {
            { s - i } -> same_as<iter_difference_t<I>>;
            { i - s } -> same_as<iter_difference_t<I>>;
          };
    }

#### Concept [`input_iterator`](../iterator/input_iterator.html "cpp/iterator/input iterator")
    
    
    namespace std {
      template<class I>
        concept input_iterator =
          input_or_output_iterator<I> &&
          indirectly_readable<I> &&
          requires { typename /* ITER_CONCEPT */(I); } &&
          derived_from</* ITER_CONCEPT */(I), input_iterator_tag>;
    }

#### Concept [`output_iterator`](../iterator/output_iterator.html "cpp/iterator/output iterator")
    
    
    namespace std {
      template<class I, class T>
        concept output_iterator =
          input_or_output_iterator<I> &&
          indirectly_writable<I, T> &&
          requires(I i, T&& t) {
            *i++ = [std::forward](../utility/forward.html)<T>(t); // not required to be equality-preserving
          };
    }

#### Concept [`forward_iterator`](../iterator/forward_iterator.html "cpp/iterator/forward iterator")
    
    
    namespace std {
      template<class I>
        concept forward_iterator =
          input_iterator<I> &&
          derived_from</* ITER_CONCEPT */(I), forward_iterator_tag> &&
          incrementable<I> &&
          sentinel_for<I, I>;
    }

#### Concept [`bidirectional_iterator`](../iterator/bidirectional_iterator.html "cpp/iterator/bidirectional iterator")
    
    
    namespace std {
      template<class I>
        concept bidirectional_iterator =
          forward_iterator<I> &&
          derived_from</* ITER_CONCEPT */(I), bidirectional_iterator_tag> &&
          requires(I i) {
            { --i } -> same_as<I&>;
            { i-- } -> same_as<I>;
          };
    }

#### Concept [`random_access_iterator`](../iterator/random_access_iterator.html "cpp/iterator/random access iterator")
    
    
    namespace std {
      template<class I>
        concept random_access_iterator =
          bidirectional_iterator<I> &&
          derived_from</* ITER_CONCEPT */(I), random_access_iterator_tag> &&
          totally_ordered<I> &&
          sized_sentinel_for<I, I> &&
          requires(I i, const I j, const iter_difference_t<I> n) {
            { i += n } -> same_as<I&>;
            { j +  n } -> same_as<I>;
            { n +  j } -> same_as<I>;
            { i -= n } -> same_as<I&>;
            { j -  n } -> same_as<I>;
            {  j[n]  } -> same_as<iter_reference_t<I>>;
          };
    }

#### Concept [`contiguous_iterator`](../iterator/contiguous_iterator.html "cpp/iterator/contiguous iterator")
    
    
    namespace std {
      template<class I>
        concept contiguous_iterator =
          random_access_iterator<I> &&
          derived_from</* ITER_CONCEPT */(I), contiguous_iterator_tag> &&
          is_lvalue_reference_v<iter_reference_t<I>> &&
          same_as<iter_value_t<I>, remove_cvref_t<iter_reference_t<I>>> &&
          requires(const I& i) {
            { to_address(i) } -> same_as<add_pointer_t<iter_reference_t<I>>>;
          };
    }

#### Concept [`indirectly_unary_invocable`](../iterator/indirectly_unary_invocable.html "cpp/iterator/indirectly unary invocable")
    
    
    namespace std {
      template<class F, class I>
        concept indirectly_unary_invocable =
          indirectly_readable<I> &&
          copy_constructible<F> &&
          invocable<F&, iter_value_t<I>&> &&
          invocable<F&, iter_reference_t<I>> &&
          common_reference_with<
            invoke_result_t<F&, iter_value_t<I>&>,
            invoke_result_t<F&, iter_reference_t<I>>>;
    }

#### Concept [`indirectly_regular_unary_invocable`](../iterator/indirectly_unary_invocable.html "cpp/iterator/indirectly unary invocable")
    
    
    namespace std {
      template<class F, class I>
        concept indirectly_regular_unary_invocable =
          indirectly_readable<I> &&
          copy_constructible<F> &&
          regular_invocable<F&, iter_value_t<I>&> &&
          regular_invocable<F&, iter_reference_t<I>> &&
          common_reference_with<
            invoke_result_t<F&, iter_value_t<I>&>,
            invoke_result_t<F&, iter_reference_t<I>>>;
    }

#### Concept [`indirect_unary_predicate`](../iterator/indirect_unary_predicate.html "cpp/iterator/indirect unary predicate")
    
    
    namespace std {
      template<class F, class I>
        concept indirect_unary_predicate =
          indirectly_readable<I> &&
          copy_constructible<F> &&
          predicate<F&, iter_value_t<I>&> &&
          predicate<F&, iter_reference_t<I>>;
    }

#### Concept [`indirect_binary_predicate`](../iterator/indirect_binary_predicate.html "cpp/iterator/indirect binary predicate")
    
    
    namespace std {
      template<class F, class I1, class I2 = I1>
        concept indirect_binary_predicate =
          indirectly_readable<I1> && indirectly_readable<I2> &&
          copy_constructible<F> &&
          predicate<F&, iter_value_t<I1>&, iter_value_t<I2>&> &&
          predicate<F&, iter_value_t<I1>&, iter_reference_t<I2>> &&
          predicate<F&, iter_reference_t<I1>, iter_value_t<I2>&> &&
          predicate<F&, iter_reference_t<I1>, iter_reference_t<I2>>;
    }

#### Concept [`indirect_equivalence_relation`](../iterator/indirect_equivalence_relation.html "cpp/iterator/indirect equivalence relation")
    
    
    namespace std {
      template<class F, class I1, class I2 = I1>
        concept indirect_equivalence_relation =
          indirectly_readable<I1> && indirectly_readable<I2> &&
          copy_constructible<F> &&
          equivalence_relation<F&, iter_value_t<I1>&, iter_value_t<I2>&> &&
          equivalence_relation<F&, iter_value_t<I1>&, iter_reference_t<I2>> &&
          equivalence_relation<F&, iter_reference_t<I1>, iter_value_t<I2>&> &&
          equivalence_relation<F&, iter_reference_t<I1>, iter_reference_t<I2>>;
    }

#### Concept [`indirect_strict_weak_order`](../iterator/indirect_strict_weak_order.html "cpp/iterator/indirect strict weak order")
    
    
    namespace std {
      template<class F, class I1, class I2 = I1>
        concept indirect_strict_weak_order =
          indirectly_readable<I1> && indirectly_readable<I2> &&
          copy_constructible<F> &&
          strict_weak_order<F&, iter_value_t<I1>&, iter_value_t<I2>&> &&
          strict_weak_order<F&, iter_value_t<I1>&, iter_reference_t<I2>> &&
          strict_weak_order<F&, iter_reference_t<I1>, iter_value_t<I2>&> &&
          strict_weak_order<F&, iter_reference_t<I1>, iter_reference_t<I2>>;
    }

#### Concept [`indirectly_movable`](../iterator/indirectly_movable.html "cpp/iterator/indirectly movable")
    
    
    namespace std {
      template<class In, class Out>
        concept indirectly_movable =
          indirectly_readable<In> &&
          indirectly_writable<Out, iter_rvalue_reference_t<In>>;
    }

#### Concept [`indirectly_movable_storable`](../iterator/indirectly_movable_storable.html "cpp/iterator/indirectly movable storable")
    
    
    namespace std {
      template<class In, class Out>
        concept indirectly_movable_storable =
          indirectly_movable<In, Out> &&
          indirectly_writable<Out, iter_value_t<In>> &&
          movable<iter_value_t<In>> &&
          constructible_from<iter_value_t<In>, iter_rvalue_reference_t<In>> &&
          assignable_from<iter_value_t<In>&, iter_rvalue_reference_t<In>>;
    }

#### Concept [`indirectly_copyable`](../iterator/indirectly_copyable.html "cpp/iterator/indirectly copyable")
    
    
    namespace std {
      template<class In, class Out>
        concept indirectly_copyable =
          indirectly_readable<In> &&
          indirectly_writable<Out, iter_reference_t<In>>;
    }

#### Concept [`indirectly_copyable_storable`](../iterator/indirectly_copyable_storable.html "cpp/iterator/indirectly copyable storable")
    
    
    namespace std {
      template<class In, class Out>
        concept indirectly_copyable_storable =
          indirectly_copyable<In, Out> &&
          indirectly_writable<Out, iter_value_t<In>&> &&
          indirectly_writable<Out, const iter_value_t<In>&> &&
          indirectly_writable<Out, iter_value_t<In>&&> &&
          indirectly_writable<Out, const iter_value_t<In>&&> &&
          copyable<iter_value_t<In>> &&
          constructible_from<iter_value_t<In>, iter_reference_t<In>> &&
          assignable_from<iter_value_t<In>&, iter_reference_t<In>>;
    }

#### Concept [`indirectly_swappable`](../iterator/indirectly_swappable.html "cpp/iterator/indirectly swappable")
    
    
    namespace std {
      template<class I1, class I2 = I1>
        concept indirectly_swappable =
          indirectly_readable<I1> && indirectly_readable<I2> &&
          requires(const I1 i1, const I2 i2) {
            [ranges::iter_swap](../iterator/ranges/iter_swap.html)(i1, i1);
            [ranges::iter_swap](../iterator/ranges/iter_swap.html)(i2, i2);
            [ranges::iter_swap](../iterator/ranges/iter_swap.html)(i1, i2);
            [ranges::iter_swap](../iterator/ranges/iter_swap.html)(i2, i1);
          };
    }

#### Concept [`indirectly_comparable`](../iterator/indirectly_comparable.html "cpp/iterator/indirectly comparable")
    
    
    namespace std {
      template<class I1, class I2, class R, class P1 = identity, class P2 = identity>
        concept indirectly_comparable =
          indirect_predicate<R, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I1, P1>, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I2, P2>>;
    }

#### Concept [`permutable`](../iterator/permutable.html "cpp/iterator/permutable")
    
    
    namespace std {
      template<class I>
        concept permutable =
          forward_iterator<I> &&
          indirectly_movable_storable<I, I> &&
          indirectly_swappable<I, I>;
    }

#### Concept [`mergeable`](../iterator/mergeable.html "cpp/iterator/mergeable")
    
    
    namespace std {
      template<class I1, class I2, class Out, class R = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less),
               class P1 = identity, class P2 = identity>
        concept mergeable =
          input_iterator<I1> &&
          input_iterator<I2> &&
          weakly_incrementable<Out> &&
          indirectly_copyable<I1, Out> &&
          indirectly_copyable<I2, Out> &&
          indirect_strict_weak_order<R, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I1, P1>, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I2, P2>>;
    }

#### Concept [`sortable`](../iterator/sortable.html "cpp/iterator/sortable")
    
    
    namespace std {
      template<class I, class R = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less), class P = identity>
        concept sortable =
          permutable<I> &&
          indirect_strict_weak_order<R, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, P>>;
    }

#### Class template [std::incrementable_traits](../iterator/incrementable_traits.html "cpp/iterator/incrementable traits")
    
    
    namespace std {
      template<class> struct incrementable_traits { };
     
      template<class T>
        requires is_object_v<T>
      struct incrementable_traits<T*> {
        using difference_type = ptrdiff_t;
      };
     
      template<class I>
      struct incrementable_traits<const I>
        : incrementable_traits<I> { };
     
      template<class T>
        requires requires { typename T::difference_type; }
      struct incrementable_traits<T> {
        using difference_type = typename T::difference_type;
      };
     
      template<class T>
        requires (!requires { typename T::difference_type; } &&
                  requires(const T& a, const T& b) { { a - b } -> integral; })
      struct incrementable_traits<T> {
        using difference_type = make_signed_t<decltype(declval<T>() - declval<T>())>;
      };
     
      template<class T>
        using iter_difference_t = /* see description */;
    }

#### Class template [std::indirectly_readable_traits](../iterator/readable_traits.html "cpp/iterator/indirectly readable traits")
    
    
    namespace std {
      template<class> struct /*cond_value_type*/ { };   // exposition only
      template<class T>
        requires is_object_v<T>
      struct /*cond_value_type*/ {
        using value_type = remove_cv_t<T>;
      };
     
      template<class> struct indirectly_readable_traits { };
     
      template<class T>
      struct indirectly_readable_traits<T*>
        : /*cond_value_type*/<T> { };
     
      template<class I>
        requires is_array_v<I>
      struct indirectly_readable_traits<I> {
        using value_type = remove_cv_t<remove_extent_t<I>>;
      };
     
      template<class I>
      struct indirectly_readable_traits<const I>
        : indirectly_readable_traits<I> { };
     
      template<class T>
        requires requires { typename T::value_type; }
      struct indirectly_readable_traits<T>
        : /*cond_value_type*/<typename T::value_type> { };
     
      template<class T>
        requires requires { typename T::element_type; }
      struct indirectly_readable_traits<T>
        : /*cond_value_type*/<typename T::element_type> { };
    }

#### Class template [std::projected](../iterator/projected.html "cpp/iterator/projected")
    
    
    namespace std {
      template<class I, class Proj>
      struct /*projected-impl*/ {                        // exposition only
        struct /*type*/ {                                // exposition only
          using value_type = remove_cvref_t<indirect_result_t<Proj&, I>>;
          using difference_type = iter_difference_t<I>;  // present only if I
                                                         // models weakly_incrementable
          indirect_result_t<Proj&, I> operator*() const; // not defined
        };
      };
     
      template<indirectly_readable I, indirectly_regular_unary_invocable<I> Proj>
      using [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected) = /*projected-impl*/<I, Proj>::/*type*/;
    }

#### Class template [std::iterator_traits](../iterator/iterator_traits.html "cpp/iterator/iterator traits")
    
    
    namespace std {
      template<class I>
      struct iterator_traits {
        using iterator_category = /* see description */;
        using value_type        = /* see description */;
        using difference_type   = /* see description */;
        using pointer           = /* see description */;
        using reference         = /* see description */;
      };
     
      template<class T>
        requires is_object_v<T>
      struct iterator_traits<T*> {
        using iterator_concept  = contiguous_iterator_tag;
        using iterator_category = random_access_iterator_tag;
        using value_type        = remove_cv_t<T>;
        using difference_type   = ptrdiff_t;
        using pointer           = T*;
        using reference         = T&;
      };
    }

#### Iterator tags
    
    
    namespace std {
      struct input_iterator_tag { };
      struct output_iterator_tag { };
      struct forward_iterator_tag: public input_iterator_tag { };
      struct bidirectional_iterator_tag: public forward_iterator_tag { };
      struct random_access_iterator_tag: public bidirectional_iterator_tag { };
      struct contiguous_iterator_tag: public random_access_iterator_tag { };
    }

#### Class template [std::reverse_iterator](../iterator/reverse_iterator.html "cpp/iterator/reverse iterator")
    
    
    namespace std {
      template<class Iter>
      class reverse_iterator {
      public:
        using iterator_type     = Iter;
        using iterator_concept  = /* see description */;
        using iterator_category = /* see description */;
        using value_type        = iter_value_t<Iter>;
        using difference_type   = iter_difference_t<Iter>;
        using pointer           = typename iterator_traits<Iter>::pointer;
        using reference         = iter_reference_t<Iter>;
     
        constexpr reverse_iterator();
        constexpr explicit reverse_iterator(Iter x);
        template<class U> constexpr reverse_iterator(const reverse_iterator<U>& u);
        template<class U> constexpr reverse_iterator& operator=(const reverse_iterator<U>& u);
     
        constexpr Iter base() const;
        constexpr reference operator*() const;
        constexpr pointer   operator->() const requires /* see description */;
     
        constexpr reverse_iterator& operator++();
        constexpr reverse_iterator  operator++(int);
        constexpr reverse_iterator& operator--();
        constexpr reverse_iterator  operator--(int);
     
        constexpr reverse_iterator  operator+ (difference_type n) const;
        constexpr reverse_iterator& operator+=(difference_type n);
        constexpr reverse_iterator  operator- (difference_type n) const;
        constexpr reverse_iterator& operator-=(difference_type n);
        constexpr /* unspecified */ operator[](difference_type n) const;
     
        friend constexpr iter_rvalue_reference_t<Iter>
          iter_move(const reverse_iterator& i) noexcept(/* see description */);
        template<indirectly_swappable<Iter> Iter2>
          friend constexpr void
            iter_swap(const reverse_iterator& x,
                      const reverse_iterator<Iter2>& y) noexcept(/* see description */);
     
      protected:
        Iter current;
      };
    }

#### Class template [std::back_insert_iterator](../iterator/back_insert_iterator.html "cpp/iterator/back insert iterator")
    
    
    namespace std {
      template<class Container>
      class back_insert_iterator {
      protected:
        Container* container = nullptr;
     
      public:
        using iterator_category = output_iterator_tag;
        using value_type        = void;
        using difference_type   = ptrdiff_t;
        using pointer           = void;
        using reference         = void;
        using container_type    = Container;
     
        constexpr back_insert_iterator() noexcept = default;
        constexpr explicit back_insert_iterator(Container& x);
        constexpr back_insert_iterator& operator=(const typename Container::value_type& value);
        constexpr back_insert_iterator& operator=(typename Container::value_type&& value);
     
        constexpr back_insert_iterator& operator*();
        constexpr back_insert_iterator& operator++();
        constexpr back_insert_iterator  operator++(int);
      };
    }

#### Class template [std::front_insert_iterator](../iterator/front_insert_iterator.html "cpp/iterator/front insert iterator")
    
    
    namespace std {
      template<class Container>
      class front_insert_iterator {
      protected:
        Container* container = nullptr;
     
      public:
        using iterator_category = output_iterator_tag;
        using value_type        = void;
        using difference_type   = ptrdiff_t;
        using pointer           = void;
        using reference         = void;
        using container_type    = Container;
     
        constexpr front_insert_iterator(Container& x) noexcept = default;
        constexpr explicit front_insert_iterator(Container& x);
        constexpr front_insert_iterator&
          operator=(const typename Container::value_type& value);
        constexpr front_insert_iterator& operator=(typename Container::value_type&& value);
     
        constexpr front_insert_iterator& operator*();
        constexpr front_insert_iterator& operator++();
        constexpr front_insert_iterator  operator++(int);
      };
    }

#### Class template [std::insert_iterator](../iterator/insert_iterator.html "cpp/iterator/insert iterator")
    
    
    namespace std {
      template<class Container>
      class insert_iterator {
      protected:
        Container* container = nullptr;
        [ranges::iterator_t](../ranges/iterator_t.html)<Container> iter = [ranges::iterator_t](../ranges/iterator_t.html)<Container>();
     
      public:
        using iterator_category = output_iterator_tag;
        using value_type        = void;
        using difference_type   = ptrdiff_t;
        using pointer           = void;
        using reference         = void;
        using container_type    = Container;
     
        insert_iterator() = default;
        constexpr insert_iterator(Container& x, [ranges::iterator_t](../ranges/iterator_t.html)<Container> i);
        constexpr insert_iterator& operator=(const typename Container::value_type& value);
        constexpr insert_iterator& operator=(typename Container::value_type&& value);
     
        constexpr insert_iterator& operator*();
        constexpr insert_iterator& operator++();
        constexpr insert_iterator& operator++(int);
      };
    }

#### Class template [std::move_iterator](../iterator/move_iterator.html "cpp/iterator/move iterator")
    
    
    namespace std {
      template<class Iter>
      class move_iterator {
      public:
        using iterator_type     = Iter;
        using iterator_concept  = /* see description */;
        using iterator_category = /* see description */;
        using value_type        = iter_value_t<Iter>;
        using difference_type   = iter_difference_t<Iter>;
        using pointer           = Iter;
        using reference         = iter_rvalue_reference_t<Iter>;
     
        constexpr move_iterator();
        constexpr explicit move_iterator(Iter i);
        template<class U> constexpr move_iterator(const move_iterator<U>& u);
        template<class U> constexpr move_iterator& operator=(const move_iterator<U>& u);
     
        constexpr iterator_type base() const &;
        constexpr iterator_type base() &&;
        constexpr reference operator*() const;
        constexpr pointer operator->() const;
     
        constexpr move_iterator& operator++();
        constexpr auto operator++(int);
        constexpr move_iterator& operator--();
        constexpr move_iterator operator--(int);
     
        constexpr move_iterator operator+(difference_type n) const;
        constexpr move_iterator& operator+=(difference_type n);
        constexpr move_iterator operator-(difference_type n) const;
        constexpr move_iterator& operator-=(difference_type n);
        constexpr reference operator[](difference_type n) const;
     
        template<sentinel_for<Iter> S>
          friend constexpr bool
            operator==(const move_iterator& x, const move_sentinel<S>& y);
        template<sized_sentinel_for<Iter> S>
          friend constexpr iter_difference_t<Iter>
            operator-(const move_sentinel<S>& x, const move_iterator& y);
        template<sized_sentinel_for<Iter> S>
          friend constexpr iter_difference_t<Iter>
            operator-(const move_iterator& x, const move_sentinel<S>& y);
        friend constexpr iter_rvalue_reference_t<Iter>
          iter_move(const move_iterator& i)
            noexcept(noexcept([ranges::iter_move](../iterator/ranges/iter_move.html)(i.current)));
        template<indirectly_swappable<Iter> Iter2>
          friend constexpr void
            iter_swap(const move_iterator& x, const move_iterator<Iter2>& y)
              noexcept(noexcept([ranges::iter_swap](../iterator/ranges/iter_swap.html)(x.current, y.current)));
     
      private:
        Iter current;     // exposition only
      };
    }

#### Class template [std::move_sentinel](../iterator/move_sentinel.html "cpp/iterator/move sentinel")
    
    
    namespace std {
      template<semiregular S>
      class move_sentinel {
      public:
        constexpr move_sentinel();
        constexpr explicit move_sentinel(S s);
        template<class S2>
          requires convertible_to<const S2&, S>
            constexpr move_sentinel(const move_sentinel<S2>& s);
        template<class S2>
          requires assignable_from<S&, const S2&>
            constexpr move_sentinel& operator=(const move_sentinel<S2>& s);
     
        constexpr S base() const;
      private:
        S last;     // exposition only
      };
    }

#### Class template [std::common_iterator](../iterator/common_iterator.html "cpp/iterator/common iterator")
    
    
    namespace std {
      template<input_or_output_iterator I, sentinel_for<I> S>
        requires (!same_as<I, S> && copyable<I>)
      class common_iterator {
      public:
        constexpr common_iterator() = default;
        constexpr common_iterator(I i);
        constexpr common_iterator(S s);
        template<class I2, class S2>
          requires convertible_to<const I2&, I> && convertible_to<const S2&, S>
            constexpr common_iterator(const common_iterator<I2, S2>& x);
     
        template<class I2, class S2>
          requires convertible_to<const I2&, I> && convertible_to<const S2&, S> &&
                   assignable_from<I&, const I2&> && assignable_from<S&, const S2&>
            common_iterator& operator=(const common_iterator<I2, S2>& x);
     
        decltype(auto) operator*();
        decltype(auto) operator*() const
          requires dereferenceable<const I>;
        decltype(auto) operator->() const
          requires /* see description */;
     
        common_iterator& operator++();
        decltype(auto) operator++(int);
     
        template<class I2, sentinel_for<I> S2>
          requires sentinel_for<S, I2>
        friend bool operator==(
          const common_iterator& x, const common_iterator<I2, S2>& y);
        template<class I2, sentinel_for<I> S2>
          requires sentinel_for<S, I2> && equality_comparable_with<I, I2>
        friend bool operator==(
          const common_iterator& x, const common_iterator<I2, S2>& y);
     
        template<sized_sentinel_for<I> I2, sized_sentinel_for<I> S2>
          requires sized_sentinel_for<S, I2>
        friend iter_difference_t<I2> operator-(
          const common_iterator& x, const common_iterator<I2, S2>& y);
     
        friend constexpr decltype(auto) iter_move(const common_iterator& i)
          noexcept(noexcept([ranges::iter_move](../iterator/ranges/iter_move.html)(declval<const I&>())))
            requires input_iterator<I>;
        template<indirectly_swappable<I> I2, class S2>
          friend void iter_swap(const common_iterator& x, const common_iterator<I2, S2>& y)
            noexcept(noexcept([ranges::iter_swap](../iterator/ranges/iter_swap.html)(declval<const I&>(), declval<const I2&>())));
     
      private:
        variant<I, S> v_;   // exposition only
      };
     
      template<class I, class S>
      struct incrementable_traits<common_iterator<I, S>> {
        using difference_type = iter_difference_t<I>;
      };
     
      template<input_iterator I, class S>
      struct iterator_traits<common_iterator<I, S>> {
        using iterator_concept = /* see description */;
        using iterator_category = /* see description */;
        using value_type = iter_value_t<I>;
        using difference_type = iter_difference_t<I>;
        using pointer = /* see description */;
        using reference = iter_reference_t<I>;
      };
    }

#### Class [std::default_sentinel_t](../iterator/default_sentinel.html "cpp/iterator/default sentinel t")
    
    
    namespace std {
      struct default_sentinel_t { };
    }

#### Class template [std::counted_iterator](../iterator/counted_iterator.html "cpp/iterator/counted iterator")
    
    
    namespace std {
      template<input_or_output_iterator I>
      class counted_iterator {
      public:
        using iterator_type = I;
     
        constexpr counted_iterator() = default;
        constexpr counted_iterator(I x, iter_difference_t<I> n);
        template<class I2>
          requires convertible_to<const I2&, I>
            constexpr counted_iterator(const counted_iterator<I2>& x);
     
        template<class I2>
          requires assignable_from<I&, const I2&>
            constexpr counted_iterator& operator=(const counted_iterator<I2>& x);
     
        constexpr I base() const & requires copy_constructible<I>;
        constexpr I base() &&;
        constexpr iter_difference_t<I> count() const noexcept;
        constexpr decltype(auto) operator*();
        constexpr decltype(auto) operator*() const
          requires dereferenceable<const I>;
        constexpr auto operator->() const noexcept
          requires contiguous_iterator<I>;
     
        constexpr counted_iterator& operator++();
        decltype(auto) operator++(int);
        constexpr counted_iterator operator++(int)
          requires forward_iterator<I>;
        constexpr counted_iterator& operator--()
          requires bidirectional_iterator<I>;
        constexpr counted_iterator operator--(int)
          requires bidirectional_iterator<I>;
     
        constexpr counted_iterator operator+(iter_difference_t<I> n) const
          requires random_access_iterator<I>;
        friend constexpr counted_iterator operator+(
          iter_difference_t<I> n, const counted_iterator& x)
            requires random_access_iterator<I>;
        constexpr counted_iterator& operator+=(iter_difference_t<I> n)
          requires random_access_iterator<I>;
     
        constexpr counted_iterator operator-(iter_difference_t<I> n) const
          requires random_access_iterator<I>;
        template<common_with<I> I2>
          friend constexpr iter_difference_t<I2> operator-(
            const counted_iterator& x, const counted_iterator<I2>& y);
        friend constexpr iter_difference_t<I> operator-(
          const counted_iterator& x, default_sentinel_t);
        friend constexpr iter_difference_t<I> operator-(
          default_sentinel_t, const counted_iterator& y);
        constexpr counted_iterator& operator-=(iter_difference_t<I> n)
          requires random_access_iterator<I>;
     
        constexpr decltype(auto) operator[](iter_difference_t<I> n) const
          requires random_access_iterator<I>;
     
        template<common_with<I> I2>
          friend constexpr bool operator==(
            const counted_iterator& x, const counted_iterator<I2>& y);
        friend constexpr bool operator==(
          const counted_iterator& x, default_sentinel_t);
     
        template<common_with<I> I2>
          friend constexpr strong_ordering operator<=>(
            const counted_iterator& x, const counted_iterator<I2>& y);
     
        friend constexpr decltype(auto) iter_move(const counted_iterator& i)
          noexcept(noexcept([ranges::iter_move](../iterator/ranges/iter_move.html)(i.current)))
            requires input_iterator<I>;
        template<indirectly_swappable<I> I2>
          friend constexpr void iter_swap(const counted_iterator& x,
                                          const counted_iterator<I2>& y)
            noexcept(noexcept([ranges::iter_swap](../iterator/ranges/iter_swap.html)(x.current, y.current)));
     
      private:
        I current = I();                    // exposition only
        iter_difference_t<I> length = 0;    // exposition only
      };
     
      template<input_iterator I>
      struct iterator_traits<counted_iterator<I>> : iterator_traits<I> {
        using pointer = void;
      };
    }

#### Class [std::unreachable_sentinel_t](../iterator/unreachable_sentinel_t.html "cpp/iterator/unreachable sentinel t")
    
    
    namespace std {
      struct unreachable_sentinel_t {
        template<weakly_incrementable I>
          friend constexpr bool operator==(unreachable_sentinel_t, const I&) noexcept
          { return false; }
      };
    }

#### Class template [std::istream_iterator](../iterator/istream_iterator.html "cpp/iterator/istream iterator")
    
    
    namespace std {
      template<class T, class CharT = char, class Traits = char_traits<CharT>,
               class Distance = ptrdiff_t>
      class istream_iterator {
      public:
        using iterator_category = input_iterator_tag;
        using value_type        = T;
        using difference_type   = Distance;
        using pointer           = const T*;
        using reference         = const T&;
        using char_type         = CharT;
        using traits_type       = Traits;
        using istream_type      = basic_istream<CharT, Traits>;
     
        constexpr istream_iterator();
        constexpr istream_iterator(default_sentinel_t);
        istream_iterator(istream_type& s);
        istream_iterator(const istream_iterator& x) = default;
        ~istream_iterator() = default;
        istream_iterator& operator=(const istream_iterator&) = default;
     
        const T& operator*() const;
        const T* operator->() const;
        istream_iterator& operator++();
        istream_iterator  operator++(int);
     
        friend bool operator==(const istream_iterator& i, default_sentinel_t);
     
      private:
        basic_istream<CharT, Traits>* in_stream; // exposition only
        T value;                                 // exposition only
      };
    }

#### Class template [std::ostream_iterator](../iterator/ostream_iterator.html "cpp/iterator/ostream iterator")
    
    
    namespace std {
      template<class T, class CharT = char, classTraits = char_traits<CharT>>
      class ostream_iterator {
      public:
        using iterator_category = output_iterator_tag;
        using value_type        = void;
        using difference_type   = ptrdiff_t;
        using pointer           = void;
        using reference         = void;
        using char_type         = CharT;
        using traits_type       = Traits;
        using ostream_type      = basic_ostream<CharT, Traits>;
     
        constexpr ostreambuf_iterator() noexcept = default;
        ostream_iterator(ostream_type& s);
        ostream_iterator(ostream_type& s, const CharT* delimiter);
        ostream_iterator(const ostream_iterator& x);
        ~ostream_iterator();
        ostream_iterator& operator=(const ostream_iterator&) = default;
        ostream_iterator& operator=(const T& value);
     
        ostream_iterator& operator*();
        ostream_iterator& operator++();
        ostream_iterator& operator++(int);
     
      private:
        basic_ostream<CharT, Traits>* out_stream = nullptr;          // exposition only
        const CharT* delim = nullptr;                                // exposition only
      };
    }

#### Class template [std::istreambuf_iterator](../iterator/istreambuf_iterator.html "cpp/iterator/istreambuf iterator")
    
    
    namespace std {
      template<class CharT, class Traits = char_traits<CharT>>
      class istreambuf_iterator {
      public:
        using iterator_category = input_iterator_tag;
        using value_type        = CharT;
        using difference_type   = typename Traits::off_type;
        using pointer           = /* unspecified */;
        using reference         = CharT;
        using char_type         = CharT;
        using traits_type       = Traits;
        using int_type          = typename Traits::int_type;
        using streambuf_type    = basic_streambuf<CharT, Traits>;
        using istream_type      = basic_istream<CharT, Traits>;
     
        class proxy;                          // exposition only
     
        constexpr istreambuf_iterator() noexcept;
        constexpr istreambuf_iterator(default_sentinel_t) noexcept;
        istreambuf_iterator(const istreambuf_iterator&) noexcept = default;
        ~istreambuf_iterator() = default;
        istreambuf_iterator(istream_type& s) noexcept;
        istreambuf_iterator(streambuf_type* s) noexcept;
        istreambuf_iterator(const proxy& p) noexcept;
        istreambuf_iterator& operator=(const istreambuf_iterator&) noexcept = default;
        CharT operator*() const;
        istreambuf_iterator& operator++();
        proxy operator++(int);
        bool equal(const istreambuf_iterator& b) const;
     
        friend bool operator==(const istreambuf_iterator& i, default_sentinel_t s);
     
      private:
        streambuf_type* sbuf_;                // exposition only
      };
     
      template<class CharT, class Traits>
      class istreambuf_iterator<CharT, Traits>::proxy { // exposition only
        CharT keep_;
        basic_streambuf<CharT, Traits>* sbuf_;
        proxy(CharT c, basic_streambuf<CharT, Traits>* sbuf)
          : keep_(c), sbuf_(sbuf) { }
      public:
        CharT operator*() { return keep_; }
      };
    }

#### Class template [std::ostreambuf_iterator](../iterator/ostreambuf_iterator.html "cpp/iterator/ostreambuf iterator")
    
    
    namespace std {
      template<class CharT, class Traits = char_traits<CharT>>
      class ostreambuf_iterator {
      public:
        using iterator_category = output_iterator_tag;
        using value_type        = void;
        using difference_type   = ptrdiff_t;
        using pointer           = void;
        using reference         = void;
        using char_type         = CharT;
        using traits_type       = Traits;
        using streambuf_type    = basic_streambuf<CharT, Traits>;
        using ostream_type      = basic_ostream<CharT, Traits>;
     
        constexpr ostreambuf_iterator() noexcept = default;
        ostreambuf_iterator(ostream_type& s) noexcept;
        ostreambuf_iterator(streambuf_type* s) noexcept;
        ostreambuf_iterator& operator=(CharT c);
     
        ostreambuf_iterator& operator*();
        ostreambuf_iterator& operator++();
        ostreambuf_iterator& operator++(int);
        bool failed() const noexcept;
     
      private:
        streambuf_type* sbuf_ = nullptr;    // exposition only
      };
    }

#### Class template [std::iterator](../iterator/iterator.html "cpp/iterator/iterator")
    
    
    namespace std {
      template<class Category, class T, class Distance = ptrdiff_t,
               class Pointer = T*, class Reference = T&>
      struct iterator {
        typedef Category  iterator_category;
        typedef T         value_type;
        typedef Distance  difference_type;
        typedef Pointer   pointer;
        typedef Reference reference;
      };
    }

### Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[LWG 349](https://cplusplus.github.io/LWG/issue349) | C++98  | the exposition-only member `delim` of  
[std::ostream_iterator](../iterator/ostream_iterator.html "cpp/iterator/ostream iterator") had type const char* | corrected to const CharT*
