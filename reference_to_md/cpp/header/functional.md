[C++](../../cpp.html "cpp")

[Compiler support](../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../freestanding.html "cpp/freestanding")  
[Language](../language.html "cpp/language")  
[Standard library](../standard_library.html "cpp/standard library")  
[Standard library headers](../headers.html "cpp/header")  
[Named requirements](../iterator/concepts.html "cpp/named req")  
[Feature test macros](../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../utility.html#Language_support "cpp/utility")  
[Concepts library](../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../error.html "cpp/error")  
[Memory management library](../memory.html "cpp/memory")  
[Metaprogramming library](../meta.html "cpp/meta") (C++11)  
[General utilities library](../utility.html "cpp/utility")  
[Containers library](../container.html "cpp/container")  
[Iterators library](../iterator.html "cpp/iterator")  
[Ranges library](../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../algorithm.html "cpp/algorithm")  
[Strings library](../string.html "cpp/string")  
[Text processing library](../text.html "cpp/text")  
[Numerics library](../numeric.html "cpp/numeric")  
[Date and time library](../chrono.html "cpp/chrono")  
[Input/output library](../io.html "cpp/io")  
[Filesystem library](../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../atomic.html "cpp/thread") (C++11)  
[Execution control library](../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../experimental.html "cpp/experimental")  
[Symbols index](../symbol_index.html "cpp/symbol index")  
[External libraries](../links/libs.html "cpp/links/libs")  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/navbar_content&action=edit)

[Standard library headers](../headers.html "cpp/header")

| [Language support](../headers.html#Language_support_library "cpp/header")  
---  
[`<cfloat>`](cfloat.html "cpp/header/cfloat")  
[`<climits>`](climits.html "cpp/header/climits")  
[`<compare>`](compare.html "cpp/header/compare") (C++20)  
[`<contracts>`](contracts.html "cpp/header/contracts") (C++26)  
[`<coroutine>`](coroutine.html "cpp/header/coroutine") (C++20)  
[`<csetjmp>`](csetjmp.html "cpp/header/csetjmp")  
[`<csignal>`](csignal.html "cpp/header/csignal")  
[`<cstdarg>`](cstdarg.html "cpp/header/cstdarg")  
[`<cstddef>`](cstddef.html "cpp/header/cstddef")  
[`<cstdint>`](cstdint.html "cpp/header/cstdint") (C++11)  
[`<cstdlib>`](cstdlib.html "cpp/header/cstdlib")  
[`<exception>`](exception.html "cpp/header/exception")  
[`<initializer_list>`](initializer_list.html "cpp/header/initializer list") (C++11)` `  
[`<limits>`](limits.html "cpp/header/limits")  
[`<new>`](new.html "cpp/header/new")  
[`<source_location>`](source_location.html "cpp/header/source location") (C++20)  
[`<stdfloat>`](stdfloat.html "cpp/header/stdfloat") (C++23)  
[`<typeinfo>`](typeinfo.html "cpp/header/typeinfo")  
[`<version>`](version.html "cpp/header/version") (C++20)  
[Concepts](../headers.html#Concepts_library "cpp/header")  
[`<concepts>`](concepts.html "cpp/header/concepts") (C++20)  
[Diagnostics](../headers.html#Diagnostics_library "cpp/header")  
[`<cassert>`](cassert.html "cpp/header/cassert")  
[`<cerrno>`](cerrno.html "cpp/header/cerrno")  
[`<debugging>`](debugging.html "cpp/header/debugging") (C++26)  
[`<stacktrace>`](stacktrace.html "cpp/header/stacktrace") (C++23)  
[`<stdexcept>`](stdexcept.html "cpp/header/stdexcept")  
[`<system_error>`](system_error.html "cpp/header/system error") (C++11)  
[Memory management](../headers.html#Memory_management_library "cpp/header")  
[`<memory>`](memory.html "cpp/header/memory")  
[`<memory_resource>`](memory_resource.html "cpp/header/memory resource") (C++17)  
[`<scoped_allocator>`](scoped_allocator.html "cpp/header/scoped allocator") (C++11)  
[Metaprogramming](../headers.html#Metaprogramming_library "cpp/header")  
[`<type_traits>`](type_traits.html "cpp/header/type traits") (C++11)  
[`<ratio>`](ratio.html "cpp/header/ratio") (C++11)  
  
  
  
| [General utilities](../headers.html#General_utilities_library "cpp/header")  
---  
[`<any>`](any.html "cpp/header/any") (C++17)  
[`<bitset>`](bitset.html "cpp/header/bitset")  
[`<bit>`](bit.html "cpp/header/bit") (C++20)  
[`<charconv>`](charconv.html "cpp/header/charconv") (C++17)  
[`<expected>`](expected.html "cpp/header/expected") (C++23)  
[`<format>`](format.html "cpp/header/format") (C++20)  
**`< functional>`**  
[`<optional>`](optional.html "cpp/header/optional") (C++17)  
[`<stdbit.h>`](stdbit.h.html "cpp/header/stdbit.h") (C++26)  
[`<tuple>`](tuple.html "cpp/header/tuple") (C++11)  
[`<typeindex>`](typeindex.html "cpp/header/typeindex") (C++11)  
[`<utility>`](utility.html "cpp/header/utility")  
[`<variant>`](variant.html "cpp/header/variant") (C++17)  
[Containers](../headers.html#Containers_library "cpp/header")  
[`<array>`](array.html "cpp/header/array") (C++11)  
[`<deque>`](deque.html "cpp/header/deque")  
[`<flat_map>`](flat_map.html "cpp/header/flat map") (C++23)  
[`<flat_set>`](flat_set.html "cpp/header/flat set") (C++23)  
[`<forward_list>`](forward_list.html "cpp/header/forward list") (C++11)  
[`<hive>`](hive.html "cpp/header/hive") (C++26)  
[`<inplace_vector>`](inplace_vector.html "cpp/header/inplace vector") (C++26)` `  
[`<list>`](list.html "cpp/header/list")  
[`<map>`](map.html "cpp/header/map")  
[`<mdspan>`](mdspan.html "cpp/header/mdspan") (C++23)  
[`<queue>`](queue.html "cpp/header/queue")  
[`<set>`](set.html "cpp/header/set")  
[`<span>`](span.html "cpp/header/span") (C++20)  
[`<stack>`](stack.html "cpp/header/stack")  
[`<unordered_map>`](unordered_map.html "cpp/header/unordered map") (C++11)  
[`<unordered_set>`](unordered_set.html "cpp/header/unordered set") (C++11)  
[`<vector>`](vector.html "cpp/header/vector")  
[Iterators](../headers.html#Iterators_library "cpp/header")  
[`<iterator>`](iterator.html "cpp/header/iterator")  
[Ranges](../headers.html#Ranges_library "cpp/header")  
[`<generator>`](generator.html "cpp/header/generator") (C++23)  
[`<ranges>`](ranges.html "cpp/header/ranges") (C++20)  
  
| [Algorithms](../headers.html#Algorithms_library "cpp/header")  
---  
[`<algorithm>`](algorithm.html "cpp/header/algorithm")  
[`<numeric>`](numeric.html "cpp/header/numeric")  
[Strings](../headers.html#Strings_library "cpp/header")  
[`<cctype>`](cctype.html "cpp/header/cctype")  
[`<cstring>`](cstring.html "cpp/header/cstring")  
[`<cuchar>`](cuchar.html "cpp/header/cuchar") (C++11)  
[`<cwchar>`](cwchar.html "cpp/header/cwchar")  
[`<cwctype>`](cwctype.html "cpp/header/cwctype")  
[`<string_view>`](string_view.html "cpp/header/string view") (C++17)  
[`<string>`](string.html "cpp/header/string")  
[Text processing](../headers.html#Text_processing_library "cpp/header")  
[`<clocale>`](clocale.html "cpp/header/clocale")  
[`<codecvt>`](codecvt.html "cpp/header/codecvt") (C++11/17/26*)  
[`<locale>`](locale.html "cpp/header/locale")  
[`<regex>`](regex.html "cpp/header/regex") (C++11)  
[`<text_encoding>`](text_encoding.html "cpp/header/text encoding") (C++26)` `  
[Numerics](../headers.html#Numerics_library "cpp/header")  
[`<cfenv>`](cfenv.html "cpp/header/cfenv") (C++11)  
[`<cmath>`](cmath.html "cpp/header/cmath")  
[`<complex>`](complex.html "cpp/header/complex")  
[`<linalg>`](linalg.html "cpp/header/linalg") (C++26)  
[`<numbers>`](numbers.html "cpp/header/numbers") (C++20)  
[`<random>`](random.html "cpp/header/random") (C++11)  
[`<simd>`](simd.html "cpp/header/simd") (C++26)  
[`<stdckdint.h>`](stdckdint.h.html "cpp/header/stdckdint.h") (C++26)  
[`<valarray>`](valarray.html "cpp/header/valarray")  
[Time](../headers.html#Time_library "cpp/header")  
[`<chrono>`](chrono.html "cpp/header/chrono") (C++11)  
[`<ctime>`](ctime.html "cpp/header/ctime")  
[C compatibility](../headers.html#C_compatibility_headers "cpp/header")  
[`<ccomplex>`](ccomplex.html "cpp/header/ccomplex") (C++11/17/20*)  
[`<ciso646>`](ciso646.html "cpp/header/ciso646") (until C++20)  
[`<cstdalign>`](cstdalign.html "cpp/header/cstdalign") (C++11/17/20*)  
[`<cstdbool>`](cstdbool.html "cpp/header/cstdbool") (C++11/17/20*)  
[`<ctgmath>`](ctgmath.html "cpp/header/ctgmath") (C++11/17/20*)  
  
| [Input/output](../headers.html#Input.2Foutput_library "cpp/header")  
---  
[`<cinttypes>`](cinttypes.html "cpp/header/cinttypes") (C++11)  
[`<cstdio>`](cstdio.html "cpp/header/cstdio")  
[`<filesystem>`](filesystem.html "cpp/header/filesystem") (C++17)  
[`<fstream>`](fstream.html "cpp/header/fstream")  
[`<iomanip>`](iomanip.html "cpp/header/iomanip")  
[`<iosfwd>`](iosfwd.html "cpp/header/iosfwd")  
[`<iostream>`](iostream.html "cpp/header/iostream")  
[`<ios>`](ios.html "cpp/header/ios")  
[`<istream>`](istream.html "cpp/header/istream")  
[`<ostream>`](ostream.html "cpp/header/ostream")  
[`<print>`](print.html "cpp/header/print") (C++23)  
[`<spanstream>`](spanstream.html "cpp/header/spanstream") (C++23)  
[`<sstream>`](sstream.html "cpp/header/sstream")  
[`<streambuf>`](streambuf.html "cpp/header/streambuf")  
[`<strstream>`](strstream.html "cpp/header/strstream") (C++98/26*)  
[`<syncstream>`](syncstream.html "cpp/header/syncstream") (C++20)  
[Concurrency support](../headers.html#Concurrency_support_library "cpp/header")  
[`<atomic>`](atomic.html "cpp/header/atomic") (C++11)  
[`<barrier>`](barrier.html "cpp/header/barrier") (C++20)  
[`<condition_variable>`](condition_variable.html "cpp/header/condition variable") (C++11)  
[`<future>`](future.html "cpp/header/future") (C++11)  
[`<hazard_pointer>`](hazard_pointer.html "cpp/header/hazard pointer") (C++26)  
[`<latch>`](latch.html "cpp/header/latch") (C++20)  
[`<mutex>`](mutex.html "cpp/header/mutex") (C++11)  
[`<rcu>`](rcu.html "cpp/header/rcu") (C++26)  
[`<semaphore>`](semaphore.html "cpp/header/semaphore") (C++20)  
[`<shared_mutex>`](shared_mutex.html "cpp/header/shared mutex") (C++14)  
[`<stdatomic.h>`](stdatomic.h.html "cpp/header/stdatomic.h") (C++23)  
[`<stop_token>`](stop_token.html "cpp/header/stop token") (C++20)  
[`<thread>`](thread.html "cpp/header/thread") (C++11)  
[Execution support](../headers.html#Multi-purpose_headers "cpp/header")  
[`<execution>`](execution.html "cpp/header/execution") (C++17)  
  
  
  
  
  
  
  
  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/navbar_content&action=edit)

This header is part of the [function objects](../functional.html "cpp/utility/functional") library and provides the standard [hash function](../utility/hash.html "cpp/utility/hash"). 

| 

## Contents

  * [1 Namespaces](functional.html#Namespaces)
  * [2 Classes](functional.html#Classes)
    * [2.1 Wrappers](functional.html#Wrappers)
    * [2.2 Helper classes](functional.html#Helper_classes)
    * [2.3 Arithmetic operations](functional.html#Arithmetic_operations)
    * [2.4 Comparisons](functional.html#Comparisons)
    * [2.5 Concept-constrained comparisons](functional.html#Concept-constrained_comparisons)
    * [2.6 Logical operations](functional.html#Logical_operations)
    * [2.7 Bitwise operations](functional.html#Bitwise_operations)
    * [2.8 Negators](functional.html#Negators)
    * [2.9 Identities](functional.html#Identities)
    * [2.10 Searchers](functional.html#Searchers)
    * [2.11 Hashing](functional.html#Hashing)
  * [3 Constants](functional.html#Constants)
  * [4 Functions](functional.html#Functions)
  * [5 Deprecated in C++11 and removed in C++17](functional.html#Deprecated_in_C.2B.2B11_and_removed_in_C.2B.2B17)
    * [5.1 Base](functional.html#Base)
    * [5.2 Binders](functional.html#Binders)
    * [5.3 Function adaptors](functional.html#Function_adaptors)
  * [6 Deprecated in C++17 and removed in C++20](functional.html#Deprecated_in_C.2B.2B17_and_removed_in_C.2B.2B20)
    * [6.1 Negators](functional.html#Negators_2)
  * [7 Synopsis](functional.html#Synopsis)
    * [7.1 Class template std::reference_wrapper](functional.html#Class_template_std::reference_wrapper)
    * [7.2 Class template std::unwrap_reference](functional.html#Class_template_std::unwrap_reference)
    * [7.3 Class template std::unwrap_ref_decay](functional.html#Class_template_std::unwrap_ref_decay)
    * [7.4 Class template std::plus](functional.html#Class_template_std::plus)
    * [7.5 Class template std::minus](functional.html#Class_template_std::minus)
    * [7.6 Class template std::multiplies](functional.html#Class_template_std::multiplies)
    * [7.7 Class template std::divides](functional.html#Class_template_std::divides)
    * [7.8 Class template std::modulus](functional.html#Class_template_std::modulus)
    * [7.9 Class template std::negate](functional.html#Class_template_std::negate)
    * [7.10 Class template std::equal_to](functional.html#Class_template_std::equal_to)
    * [7.11 Class template std::not_equal_to](functional.html#Class_template_std::not_equal_to)
    * [7.12 Class template std::greater](functional.html#Class_template_std::greater)
    * [7.13 Class template std::less](functional.html#Class_template_std::less)
    * [7.14 Class template std::greater_equal](functional.html#Class_template_std::greater_equal)
    * [7.15 Class template std::less_equal](functional.html#Class_template_std::less_equal)
    * [7.16 Class std::compare_three_way](functional.html#Class_std::compare_three_way)
    * [7.17 Class std::ranges::equal_to](functional.html#Class_std::ranges::equal_to)
    * [7.18 Class std::ranges::not_equal_to](functional.html#Class_std::ranges::not_equal_to)
    * [7.19 Class std::ranges::greater](functional.html#Class_std::ranges::greater)
    * [7.20 Class std::ranges::less](functional.html#Class_std::ranges::less)
    * [7.21 Class std::ranges::greater_equal](functional.html#Class_std::ranges::greater_equal)
    * [7.22 Class std::ranges::less_equal](functional.html#Class_std::ranges::less_equal)
    * [7.23 Class template std::logical_and](functional.html#Class_template_std::logical_and)
    * [7.24 Class template std::logical_or](functional.html#Class_template_std::logical_or)
    * [7.25 Class template std::logical_not](functional.html#Class_template_std::logical_not)
    * [7.26 Class template std::bit_and](functional.html#Class_template_std::bit_and)
    * [7.27 Class template std::bit_or](functional.html#Class_template_std::bit_or)
    * [7.28 Class template std::bit_xor](functional.html#Class_template_std::bit_xor)
    * [7.29 Class template std::bit_not](functional.html#Class_template_std::bit_not)
    * [7.30 Class template std::identity](functional.html#Class_template_std::identity)
    * [7.31 Class template std::is_bind_expression](functional.html#Class_template_std::is_bind_expression)
    * [7.32 Class template std::is_placeholder](functional.html#Class_template_std::is_placeholder)
    * [7.33 Class std::bad_function_call](functional.html#Class_std::bad_function_call)
    * [7.34 Class template std::function](functional.html#Class_template_std::function)
    * [7.35 Class template std::move_only_function](functional.html#Class_template_std::move_only_function)
    * [7.36 Class template std::copyable_function](functional.html#Class_template_std::copyable_function)
    * [7.37 Class template std::function_ref](functional.html#Class_template_std::function_ref)
    * [7.38 Class template std::default_searcher](functional.html#Class_template_std::default_searcher)
    * [7.39 Class template std::boyer_moore_searcher](functional.html#Class_template_std::boyer_moore_searcher)
    * [7.40 Class template std::boyer_moore_horspool_searcher](functional.html#Class_template_std::boyer_moore_horspool_searcher)
  * [8 See also](functional.html#See_also)

  
---  
  
###  Namespaces  
  
[`placeholders`](../utility/functional/placeholders.html "cpp/utility/functional/placeholders") (C++11) |  Provides placeholders for the unbound arguments in a [std::bind](../utility/functional/bind.html "cpp/utility/functional/bind") expression   
  
###  Classes  
  
#####  Wrappers   
  
[ function](../utility/functional/function.html "cpp/utility/functional/function")(C++11) |  copyable wrapper of any copy constructible callable object   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_function&action=edit)  
[ move_only_function](../utility/functional/move_only_function.html "cpp/utility/functional/move only function")(C++23) |  move-only wrapper of any callable object that supports qualifiers in a given call signature   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_move_only_function&action=edit)  
[ copyable_function](../utility/functional/copyable_function.html "cpp/utility/functional/copyable function")(C++26) |  copyable wrapper of any copy constructible callable object that supports qualifiers in a given call signature   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_copyable_function&action=edit)  
[ function_ref](../utility/functional/function_ref.html "cpp/utility/functional/function ref")(C++26) |  non-owning wrapper of any callable object   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_function_ref&action=edit)  
[ mem_fn](../utility/functional/mem_fn.html "cpp/utility/functional/mem fn")(C++11) |  creates a function object out of a pointer to a member   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_mem_fn&action=edit)  
[ reference_wrapper](../utility/functional/reference_wrapper.html "cpp/utility/functional/reference wrapper")(C++11) |  [CopyConstructible](../named_req/CopyConstructible.html "cpp/named req/CopyConstructible") and [CopyAssignable](../named_req/CopyAssignable.html "cpp/named req/CopyAssignable") reference wrapper   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_reference_wrapper&action=edit)  
[ unwrap_referenceunwrap_ref_decay](../utility/functional/unwrap_reference.html "cpp/utility/functional/unwrap reference")(C++20)(C++20) |  get the reference type wrapped in [std::reference_wrapper](../utility/functional/reference_wrapper.html "cpp/utility/functional/reference wrapper")   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_unwrap_reference&action=edit)  
  
#####  Helper classes   
  
[ bad_function_call](../utility/functional/bad_function_call.html "cpp/utility/functional/bad function call")(C++11) |  the exception thrown when invoking an empty [std::function](../utility/functional/function.html "cpp/utility/functional/function")   
(class) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_bad_function_call&action=edit)  
[ is_bind_expression](../utility/functional/is_bind_expression.html "cpp/utility/functional/is bind expression")(C++11) |  indicates that an object is `std::bind` expression or can be used as one   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_is_bind_expression&action=edit)  
[ is_placeholder](../utility/functional/is_placeholder.html "cpp/utility/functional/is placeholder")(C++11) |  indicates that an object is a standard placeholder or can be used as one   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_is_placeholder&action=edit)  
  
#####  Arithmetic operations   
  
[ plus](../utility/functional/plus.html "cpp/utility/functional/plus") |  function object implementing x + y   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_plus&action=edit)  
[ minus](../utility/functional/minus.html "cpp/utility/functional/minus") |  function object implementing x - y   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_minus&action=edit)  
[ multiplies](../utility/functional/multiplies.html "cpp/utility/functional/multiplies") |  function object implementing x * y   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_multiplies&action=edit)  
[ divides](../utility/functional/divides.html "cpp/utility/functional/divides") |  function object implementing x / y   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_divides&action=edit)  
[ modulus](../utility/functional/modulus.html "cpp/utility/functional/modulus") |  function object implementing x % y   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_modulus&action=edit)  
[ negate](../utility/functional/negate.html "cpp/utility/functional/negate") |  function object implementing -x   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_negate&action=edit)  
  
#####  Comparisons   
  
[ equal_to](../utility/functional/equal_to.html "cpp/utility/functional/equal to") |  function object implementing x == y   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_equal_to&action=edit)  
[ not_equal_to](../utility/functional/not_equal_to.html "cpp/utility/functional/not equal to") |  function object implementing x != y   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_not_equal_to&action=edit)  
[ greater](../utility/functional/greater.html "cpp/utility/functional/greater") |  function object implementing x > y   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_greater&action=edit)  
[ less](../utility/functional/less.html "cpp/utility/functional/less") |  function object implementing x < y   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_less&action=edit)  
[ greater_equal](../utility/functional/greater_equal.html "cpp/utility/functional/greater equal") |  function object implementing x >= y   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_greater_equal&action=edit)  
[ less_equal](../utility/functional/less_equal.html "cpp/utility/functional/less equal") |  function object implementing x <= y   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_less_equal&action=edit)  
  
#####  Concept-constrained comparisons   
  
[ ranges::equal_to](../utility/functional/ranges/equal_to.html "cpp/utility/functional/ranges/equal to")(C++20) |  constrained function object implementing x == y   
(class) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/ranges/dsc_equal_to&action=edit)  
[ ranges::not_equal_to](../utility/functional/ranges/not_equal_to.html "cpp/utility/functional/ranges/not equal to")(C++20) |  constrained function object implementing x != y   
(class) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/ranges/dsc_not_equal_to&action=edit)  
[ ranges::greater](../utility/functional/ranges/greater.html "cpp/utility/functional/ranges/greater")(C++20) |  constrained function object implementing x > y   
(class) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/ranges/dsc_greater&action=edit)  
[ ranges::less](../utility/functional/ranges/less.html "cpp/utility/functional/ranges/less")(C++20) |  constrained function object implementing x < y   
(class) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/ranges/dsc_less&action=edit)  
[ ranges::greater_equal](../utility/functional/ranges/greater_equal.html "cpp/utility/functional/ranges/greater equal")(C++20) |  constrained function object implementing x >= y   
(class) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/ranges/dsc_greater_equal&action=edit)  
[ ranges::less_equal](../utility/functional/ranges/less_equal.html "cpp/utility/functional/ranges/less equal")(C++20) |  constrained function object implementing x <= y   
(class) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/ranges/dsc_less_equal&action=edit)  
[ compare_three_way](../utility/compare/compare_three_way.html "cpp/utility/compare/compare three way")(C++20) |  constrained function object implementing x <=> y   
(class) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/compare/dsc_compare_three_way&action=edit)  
  
#####  Logical operations   
  
[ logical_and](../utility/functional/logical_and.html "cpp/utility/functional/logical and") |  function object implementing x && y   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_logical_and&action=edit)  
[ logical_or](../utility/functional/logical_or.html "cpp/utility/functional/logical or") |  function object implementing x || y   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_logical_or&action=edit)  
[ logical_not](../utility/functional/logical_not.html "cpp/utility/functional/logical not") |  function object implementing !x   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_logical_not&action=edit)  
  
#####  Bitwise operations   
  
[ bit_and](../utility/functional/bit_and.html "cpp/utility/functional/bit and") |  function object implementing x & y   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_bit_and&action=edit)  
[ bit_or](../utility/functional/bit_or.html "cpp/utility/functional/bit or") |  function object implementing x | y   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_bit_or&action=edit)  
[ bit_xor](../utility/functional/bit_xor.html "cpp/utility/functional/bit xor") |  function object implementing x ^ y   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_bit_xor&action=edit)  
[ bit_not](../utility/functional/bit_not.html "cpp/utility/functional/bit not")(C++14) |  function object implementing ~x   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_bit_not&action=edit)  
  
#####  Negators   
  
[ not_fn](../utility/functional/not_fn.html "cpp/utility/functional/not fn")(C++17) |  creates a function object that returns the complement of the result of the function object it holds   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_not_fn&action=edit)  
  
#####  Identities   
  
[ identity](../utility/functional/identity.html "cpp/utility/functional/identity")(C++20) |  function object that returns its argument unchanged   
(class) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_identity&action=edit)  
  
#####  Searchers   
  
[ default_searcher](../utility/functional/default_searcher.html "cpp/utility/functional/default searcher")(C++17) |  standard C++ library search algorithm implementation   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_default_searcher&action=edit)  
[ boyer_moore_searcher](../utility/functional/boyer_moore_searcher.html "cpp/utility/functional/boyer moore searcher")(C++17) |  Boyer-Moore search algorithm implementation   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_boyer_moore_searcher&action=edit)  
[ boyer_moore_horspool_searcher](../utility/functional/boyer_moore_horspool_searcher.html "cpp/utility/functional/boyer moore horspool searcher")(C++17) |  Boyer-Moore-Horspool search algorithm implementation   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_boyer_moore_horspool_searcher&action=edit)  
  
#####  Hashing   
  
[ hash](../utility/hash.html "cpp/utility/hash")(C++11) |  hash function object   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/dsc_hash&action=edit)  
[ std::hash<_Arithmetic_ >std::hash<_Enumeration_ >std::hash<std::nullptr_t>std::hash<T*>](../utility/hash.html "cpp/utility/hash")(C++11) |  [std::hash](../utility/hash.html "cpp/utility/hash") specializations for fundamental, enumeration, and pointer types   
(class template specialization)  
  
###  Constants  
  
Defined in namespace `std::placeholders`  
[ _1, _2, _3, _4, ...](../utility/functional/placeholders.html "cpp/utility/functional/placeholders")(C++11) |  placeholders for the unbound arguments in a `std::bind` expression   
(constant) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_placeholders&action=edit)  
  
###  Functions  
  
[ bind_frontbind_back](../utility/functional/bind_front.html "cpp/utility/functional/bind front")(C++20)(C++23) |  bind a variable number of arguments, in order, to a function object   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_bind_front&action=edit)  
[ bind](../utility/functional/bind.html "cpp/utility/functional/bind")(C++11) |  binds one or more arguments to a function object   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_bind&action=edit)  
[ refcref](../utility/functional/ref.html "cpp/utility/functional/ref")(C++11)(C++11) |  creates a [std::reference_wrapper](../utility/functional/reference_wrapper.html "cpp/utility/functional/reference wrapper") with a type deduced from its argument   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_ref&action=edit)  
[ invokeinvoke_r](../utility/functional/invoke.html "cpp/utility/functional/invoke")(C++17)(C++23) |  invokes any [Callable](../named_req/Callable.html "cpp/named req/Callable") object with given arguments and possibility to specify return type(since C++23)   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_invoke&action=edit)  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/header/functional&action=edit&section=1 "Edit section: Deprecated in C++11 and removed in C++17")] Deprecated in C++11 and removed in C++17

#####  Base   
  
---  
[ unary_function](../utility/functional/unary_function.html "cpp/utility/functional/unary function")(deprecated in C++11)(removed in C++17) |  adaptor-compatible unary function base class   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_unary_function&action=edit)  
[ binary_function](../utility/functional/binary_function.html "cpp/utility/functional/binary function")(deprecated in C++11)(removed in C++17) |  adaptor-compatible binary function base class   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_binary_function&action=edit)  
  
#####  Binders   
  
[ binder1stbinder2nd](../utility/functional/binder12.html "cpp/utility/functional/binder12")(deprecated in C++11)(removed in C++17) |  function object holding a binary function and one of its arguments   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_binder12&action=edit)  
[ bind1stbind2nd](../utility/functional/bind12.html "cpp/utility/functional/bind12")(deprecated in C++11)(removed in C++17) |  binds one argument to a binary function   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_bind12&action=edit)  
  
#####  Function adaptors   
  
[ pointer_to_unary_function](../utility/functional/pointer_to_unary_function.html "cpp/utility/functional/pointer to unary function")(deprecated in C++11)(removed in C++17) |  adaptor-compatible wrapper for a pointer to unary function   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_pointer_to_unary_function&action=edit)  
[ pointer_to_binary_function](../utility/functional/pointer_to_binary_function.html "cpp/utility/functional/pointer to binary function")(deprecated in C++11)(removed in C++17) |  adaptor-compatible wrapper for a pointer to binary function   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_pointer_to_binary_function&action=edit)  
[ ptr_fun](../utility/functional/ptr_fun.html "cpp/utility/functional/ptr fun")(deprecated in C++11)(removed in C++17) |  creates an adaptor-compatible function object wrapper from a pointer to function   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_ptr_fun&action=edit)  
[ mem_fun_tmem_fun1_tconst_mem_fun_tconst_mem_fun1_t](../utility/functional/mem_fun_t.html "cpp/utility/functional/mem fun t")(deprecated in C++11)(removed in C++17) |  wrapper for a pointer to nullary or unary member function, callable with a pointer to object   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_mem_fun_t&action=edit)  
[ mem_fun](../utility/functional/mem_fun.html "cpp/utility/functional/mem fun")(deprecated in C++11)(removed in C++17) |  creates a wrapper from a pointer to member function, callable with a pointer to object   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_mem_fun&action=edit)  
[ mem_fun_ref_tmem_fun1_ref_tconst_mem_fun_ref_tconst_mem_fun1_ref_t](../utility/functional/mem_fun_ref_t.html "cpp/utility/functional/mem fun ref t")(deprecated in C++11)(removed in C++17) |  wrapper for a pointer to nullary or unary member function, callable with a reference to object   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_mem_fun_ref_t&action=edit)  
[ mem_fun_ref](../utility/functional/mem_fun_ref.html "cpp/utility/functional/mem fun ref")(deprecated in C++11)(removed in C++17) |  creates a wrapper from a pointer to member function, callable with a reference to object   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_mem_fun_ref&action=edit)  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/header/functional&action=edit&section=2 "Edit section: Deprecated in C++17 and removed in C++20")] Deprecated in C++17 and removed in C++20

#####  Negators   
  
---  
[ unary_negate](../utility/functional/unary_negate.html "cpp/utility/functional/unary negate")(deprecated in C++17)(removed in C++20) |  wrapper function object returning the complement of the unary predicate it holds   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_unary_negate&action=edit)  
[ binary_negate](../utility/functional/binary_negate.html "cpp/utility/functional/binary negate")(deprecated in C++17)(removed in C++20) |  wrapper function object returning the complement of the binary predicate it holds   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_binary_negate&action=edit)  
[ not1](../utility/functional/not1.html "cpp/utility/functional/not1")(deprecated in C++17)(removed in C++20) |  constructs custom [std::unary_negate](../utility/functional/unary_negate.html "cpp/utility/functional/unary negate") object   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_not1&action=edit)  
[ not2](../utility/functional/not2.html "cpp/utility/functional/not2")(deprecated in C++17)(removed in C++20) |  constructs custom [std::binary_negate](../utility/functional/binary_negate.html "cpp/utility/functional/binary negate") object   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/dsc_not2&action=edit)  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/header/functional&action=edit&section=3 "Edit section: Synopsis")] Synopsis
    
    
    namespace std {
      // invoke
      template<class F, class... Args>
        constexpr invoke_result_t<F, Args...> invoke(F&& f, Args&&... args)
          noexcept(is_nothrow_invocable_v<F, Args...>);
      template<class R, class F, class... Args>
        constexpr R invoke_r(F&& f, Args&&... args)
          noexcept(is_nothrow_invocable_r_v<R, F, Args...>);
     
      // reference_wrapper
      template<class T> class reference_wrapper;
     
      template<class T> constexpr reference_wrapper<T> ref(T&) noexcept;
      template<class T> constexpr reference_wrapper<const T> cref(const T&) noexcept;
      template<class T> void ref(const T&&) = delete;
      template<class T> void cref(const T&&) = delete;
     
      template<class T>
        constexpr reference_wrapper<T> ref(reference_wrapper<T>) noexcept;
      template<class T>
        constexpr reference_wrapper<const T> cref(reference_wrapper<T>) noexcept;
     
      template<class T> struct unwrap_reference;
      template<class T> using unwrap_reference_t = typename unwrap_reference<T>::type;
      template<class T> struct unwrap_ref_decay;
      template<class T> using unwrap_ref_decay_t = typename unwrap_ref_decay<T>::type;
     
      // common_reference related specializations
      template<class R, class T, template<class> class RQual, template<class> class TQual>
        requires /* see below */
      struct basic_common_reference<R, T, RQual, TQual>;
     
      template<class T, class R, template<class> class TQual, template<class> class RQual>
        requires /* see below */
      struct basic_common_reference<T, R, TQual, RQual>;
     
      // arithmetic operations
      template<class T = void> struct plus;
      template<class T = void> struct minus;
      template<class T = void> struct multiplies;
      template<class T = void> struct divides;
      template<class T = void> struct modulus;
      template<class T = void> struct negate;
      template<> struct plus<void>;
      template<> struct minus<void>;
      template<> struct multiplies<void>;
      template<> struct divides<void>;
      template<> struct modulus<void>;
      template<> struct negate<void>;
     
      // comparisons
      template<class T = void> struct equal_to;
      template<class T = void> struct not_equal_to;
      template<class T = void> struct greater;
      template<class T = void> struct less;
      template<class T = void> struct greater_equal;
      template<class T = void> struct less_equal;
      template<> struct equal_to<void>;
      template<> struct not_equal_to<void>;
      template<> struct greater<void>;
      template<> struct less<void>;
      template<> struct greater_equal<void>;
      template<> struct less_equal<void>;
     
      // logical operations
      template<class T = void> struct logical_and;
      template<class T = void> struct logical_or;
      template<class T = void> struct logical_not;
      template<> struct logical_and<void>;
      template<> struct logical_or<void>;
      template<> struct logical_not<void>;
     
      // bitwise operations
      template<class T = void> struct bit_and;
      template<class T = void> struct bit_or;
      template<class T = void> struct bit_xor;
      template<class T = void> struct bit_not;
      template<> struct bit_and<void>;
      template<> struct bit_or<void>;
      template<> struct bit_xor<void>;
      template<> struct bit_not<void>;
     
      // identity
      struct identity;
     
      // function template not_fn
      template<class F> constexpr /* unspecified */ not_fn(F&& f);
     
      // function templates bind_front and bind_back
      template<class F, class... Args> constexpr /* unspecified */ bind_front(F&&, Args&&...);
      template<class F, class... Args> constexpr /* unspecified */ bind_back(F&&, Args&&...);
     
      // bind
      template<class T> struct is_bind_expression;
      template<class T>
        inline constexpr bool is_bind_expression_v = is_bind_expression<T>::value;
     
      template<class T> struct is_placeholder;
      template<class T>
        inline constexpr int is_placeholder_v = is_placeholder<T>::value;
     
      template<class F, class... BoundArgs>
        constexpr /* unspecified */ bind(F&&, BoundArgs&&...);
      template<class R, class F, class... BoundArgs>
        constexpr /* unspecified */ bind(F&&, BoundArgs&&...);
     
      namespace placeholders {
        // M is the implementation-defined number of placeholders
        /* see description */ _1;
        /* see description */ _2;
                   .
                   .
                   .
        /* see description */ _M;
      }
     
      // member function adaptors
      template<class R, class T>
        constexpr /* unspecified */ mem_fn(R T::*) noexcept;
     
      // polymorphic function wrappers
      class bad_function_call;
     
      template<class> class function; // not defined
      template<class R, class... ArgTypes> class function<R(ArgTypes...)>;
     
      template<class R, class... ArgTypes>
        void swap(function<R(ArgTypes...)>&, function<R(ArgTypes...)>&) noexcept;
     
      template<class R, class... ArgTypes>
        bool operator==(const function<R(ArgTypes...)>&, nullptr_t) noexcept;
     
      // move-only wrapper
      template<class...> class move_only_function; // not defined
     
      template<class R, class... ArgTypes>
        class move_only_function<R(ArgTypes...) /*cv ref*/ noexcept(/*noex*/)>;
     
      // copyable wrapper
      template<class...> class copyable_function; // not defined
     
      template<class R, class... ArgTypes>
        class copyable_function<R(ArgTypes...) /*cv ref*/ noexcept(/*noex*/)>;
     
      // non-owning wrapper
      template<class...> class function_ref; // not defined
     
      template<class R, class... ArgTypes>
        class function_ref<R(ArgTypes...) /*cv*/ noexcept(/*noex*/)>;
     
      // searchers
      template<class ForwardIter, class BinaryPredicate = equal_to<>>
        class default_searcher;
     
      template<class RandomAccessIter,
               class Hash = hash<typename iterator_traits<RandomAccessIter>::value_type>,
               class BinaryPredicate = equal_to<>>
        class boyer_moore_searcher;
     
      template<class RandomAccessIter,
               class Hash = hash<typename iterator_traits<RandomAccessIter>::value_type>,
               class BinaryPredicate = equal_to<>>
        class boyer_moore_horspool_searcher;
     
      // hash function primary template
      template<class T>
        struct hash;
     
      // concept-constrained comparisons
      struct compare_three_way;
      namespace ranges {
        struct equal_to;
        struct not_equal_to;
        struct greater;
        struct less;
        struct greater_equal;
        struct less_equal;
      }
     
      // exposition only
      template<class Fn, class... Args>
        concept /*callable*/ =
          requires (Fn&& fn, Args&&... args) {
            [std::forward](../utility/forward.html)<Fn>(fn)([std::forward](../utility/forward.html)<Args>(args)...);
          };
     
      // exposition only
      template<class Fn, class... Args>
        concept /*nothrow-callable*/ =
          /*callable*/<Fn, Args...> &&
          requires (Fn&& fn, Args&&... args) {
            { [std::forward](../utility/forward.html)<Fn>(fn)([std::forward](../utility/forward.html)<Args>(args)...) } noexcept;
          };
     
      // exposition only
      template<class Fn, class... Args>
        using /*call-result-t*/ = decltype([std::declval](../utility/declval.html)<Fn>()([std::declval](../utility/declval.html)<Args>()...));
     
      // exposition only
      template<const auto& T>
        using /*decayed-typeof*/ = decltype(auto(T));
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/functional&action=edit&section=T-1 "Template:cpp/synopsis/functional")] Class template [std::reference_wrapper](../utility/functional/reference_wrapper.html "cpp/utility/functional/reference wrapper")
    
    
    namespace std {
      template<class T> class reference_wrapper {
      public:
        // types
        using type = T;
     
        // construct/copy/destroy
        template<class U>
          constexpr reference_wrapper(U&&) noexcept(/* see below */);
        constexpr reference_wrapper(const reference_wrapper& x) noexcept;
     
        // assignment
        constexpr reference_wrapper& operator=(const reference_wrapper& x) noexcept;
     
        // access
        constexpr operator T& () const noexcept;
        constexpr T& get() const noexcept;
     
        // invocation
        template<class... ArgTypes>
          constexpr invoke_result_t<T&, ArgTypes...> operator()(ArgTypes&&...) const
            noexcept(is_nothrow_invocable_v<T&, ArgTypes...>);
     
        // comparison
        friend constexpr bool operator==(reference_wrapper, reference_wrapper);
        friend constexpr bool operator==(reference_wrapper, const T&);
        friend constexpr bool operator==(reference_wrapper, reference_wrapper<const T>);
     
        friend constexpr auto operator<=>(reference_wrapper, reference_wrapper);
        friend constexpr auto operator<=>(reference_wrapper, const T&);
        friend constexpr auto operator<=>(reference_wrapper, reference_wrapper<const T>);
      };
      // deduction guides
      template<class T>
        reference_wrapper(T&) -> reference_wrapper<T>;
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/functional&action=edit&section=T-2 "Template:cpp/synopsis/functional")] Class template [std::unwrap_reference](../utility/functional/unwrap_reference.html "cpp/utility/functional/unwrap reference")
    
    
    namespace std {
      template<class T>
        struct unwrap_reference;
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/functional&action=edit&section=T-3 "Template:cpp/synopsis/functional")] Class template [std::unwrap_ref_decay](../utility/functional/unwrap_reference.html "cpp/utility/functional/unwrap reference")
    
    
    namespace std {
      template<class T>
        struct unwrap_ref_decay;
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/functional&action=edit&section=T-4 "Template:cpp/synopsis/functional")] Class template [std::plus](../utility/functional/plus.html "cpp/utility/functional/plus")
    
    
    namespace std {
      template<class T = void> struct plus {
        constexpr T operator()(const T& x, const T& y) const;
      };
     
      template<> struct plus<void> {
        template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
          -> decltype([std::forward](../utility/forward.html)<T>(t) + [std::forward](../utility/forward.html)<U>(u));
     
        using is_transparent = /* unspecified */;
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/functional&action=edit&section=T-5 "Template:cpp/synopsis/functional")] Class template [std::minus](../utility/functional/minus.html "cpp/utility/functional/minus")
    
    
    namespace std {
      template<class T = void> struct minus {
        constexpr T operator()(const T& x, const T& y) const;
      };
     
      template<> struct minus<void> {
        template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
          -> decltype([std::forward](../utility/forward.html)<T>(t) - [std::forward](../utility/forward.html)<U>(u));
     
        using is_transparent = /* unspecified */;
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/functional&action=edit&section=T-6 "Template:cpp/synopsis/functional")] Class template [std::multiplies](../utility/functional/multiplies.html "cpp/utility/functional/multiplies")
    
    
    namespace std {
      template<class T = void> struct multiplies {
        constexpr T operator()(const T& x, const T& y) const;
      };
     
      template<> struct multiplies<void> {
        template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
          -> decltype([std::forward](../utility/forward.html)<T>(t) * [std::forward](../utility/forward.html)<U>(u));
     
        using is_transparent = /* unspecified */;
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/functional&action=edit&section=T-7 "Template:cpp/synopsis/functional")] Class template [std::divides](../utility/functional/divides.html "cpp/utility/functional/divides")
    
    
    namespace std {
      template<class T = void> struct divides {
        constexpr T operator()(const T& x, const T& y) const;
      };
     
      template<> struct divides<void> {
        template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
          -> decltype([std::forward](../utility/forward.html)<T>(t) / [std::forward](../utility/forward.html)<U>(u));
     
        using is_transparent = /* unspecified */;
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/functional&action=edit&section=T-8 "Template:cpp/synopsis/functional")] Class template [std::modulus](../utility/functional/modulus.html "cpp/utility/functional/modulus")
    
    
    namespace std {
      template<class T = void> struct modulus {
        constexpr T operator()(const T& x, const T& y) const;
      };
     
      template<> struct modulus<void> {
        template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
          -> decltype([std::forward](../utility/forward.html)<T>(t) % [std::forward](../utility/forward.html)<U>(u));
     
        using is_transparent = /* unspecified */;
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/functional&action=edit&section=T-9 "Template:cpp/synopsis/functional")] Class template [std::negate](../utility/functional/negate.html "cpp/utility/functional/negate")
    
    
    namespace std {
      template<class T = void> struct negate {
        constexpr T operator()(const T& x) const;
      };
     
      template<> struct negate<void> {
        template<class T> constexpr auto operator()(T&& t) const
          -> decltype(-[std::forward](../utility/forward.html)<T>(t));
     
        using is_transparent = /* unspecified */;
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/functional&action=edit&section=T-10 "Template:cpp/synopsis/functional")] Class template [std::equal_to](../utility/functional/equal_to.html "cpp/utility/functional/equal to")
    
    
    namespace std {
      template<class T = void> struct equal_to {
        constexpr bool operator()(const T& x, const T& y) const;
      };
     
      template<> struct equal_to<void> {
        template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
          -> decltype([std::forward](../utility/forward.html)<T>(t) == [std::forward](../utility/forward.html)<U>(u));
     
        using is_transparent = /* unspecified */;
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/functional&action=edit&section=T-11 "Template:cpp/synopsis/functional")] Class template [std::not_equal_to](../utility/functional/not_equal_to.html "cpp/utility/functional/not equal to")
    
    
    namespace std {
      template<class T = void> struct not_equal_to {
        constexpr bool operator()(const T& x, const T& y) const;
      };
     
      template<> struct not_equal_to<void> {
        template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
          -> decltype([std::forward](../utility/forward.html)<T>(t) != [std::forward](../utility/forward.html)<U>(u));
     
        using is_transparent = /* unspecified */;
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/functional&action=edit&section=T-12 "Template:cpp/synopsis/functional")] Class template [std::greater](../utility/functional/greater.html "cpp/utility/functional/greater")
    
    
    namespace std {
      template<class T = void> struct greater {
        constexpr bool operator()(const T& x, const T& y) const;
      };
     
      template<> struct greater<void> {
        template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
          -> decltype([std::forward](../utility/forward.html)<T>(t) > [std::forward](../utility/forward.html)<U>(u));
     
        using is_transparent = /* unspecified */;
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/functional&action=edit&section=T-13 "Template:cpp/synopsis/functional")] Class template [std::less](../utility/functional/less.html "cpp/utility/functional/less")
    
    
    namespace std {
      template<class T = void> struct less {
        constexpr bool operator()(const T& x, const T& y) const;
      };
     
      template<> struct less<void> {
        template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
          -> decltype([std::forward](../utility/forward.html)<T>(t) < [std::forward](../utility/forward.html)<U>(u));
     
        using is_transparent = /* unspecified */;
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/functional&action=edit&section=T-14 "Template:cpp/synopsis/functional")] Class template [std::greater_equal](../utility/functional/greater_equal.html "cpp/utility/functional/greater equal")
    
    
    namespace std {
      template<class T = void> struct greater_equal {
        constexpr bool operator()(const T& x, const T& y) const;
      };
     
      template<> struct greater_equal<void> {
        template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
          -> decltype([std::forward](../utility/forward.html)<T>(t) >= [std::forward](../utility/forward.html)<U>(u));
     
        using is_transparent = /* unspecified */;
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/functional&action=edit&section=T-15 "Template:cpp/synopsis/functional")] Class template [std::less_equal](../utility/functional/less_equal.html "cpp/utility/functional/less equal")
    
    
    namespace std {
      template<class T = void> struct less_equal {
        constexpr bool operator()(const T& x, const T& y) const;
      };
     
      template<> struct less_equal<void> {
        template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
          -> decltype([std::forward](../utility/forward.html)<T>(t) <= [std::forward](../utility/forward.html)<U>(u));
     
        using is_transparent = /* unspecified */;
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/functional&action=edit&section=T-16 "Template:cpp/synopsis/functional")] Class [std::compare_three_way](../utility/compare/compare_three_way.html "cpp/utility/compare/compare three way")
    
    
    namespace std {
      struct compare_three_way {
        template<class T, class U>
        constexpr auto operator()(T&& t, U&& u) const;
     
        using is_transparent = /* unspecified */;
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/functional&action=edit&section=T-17 "Template:cpp/synopsis/functional")] Class std::ranges::equal_to
    
    
    namespace std::ranges {
      struct equal_to {
        template<class T, class U>
        constexpr bool operator()(T&& t, U&& u) const;
     
        using is_transparent = /* unspecified */;
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/functional&action=edit&section=T-18 "Template:cpp/synopsis/functional")] Class std::ranges::not_equal_to
    
    
    namespace std::ranges {
      struct not_equal_to {
        template<class T, class U>
        constexpr bool operator()(T&& t, U&& u) const;
     
        using is_transparent = /* unspecified */;
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/functional&action=edit&section=T-19 "Template:cpp/synopsis/functional")] Class std::ranges::greater
    
    
    namespace std::ranges {
      struct greater {
        template<class T, class U>
        constexpr bool operator()(T&& t, U&& u) const;
     
        using is_transparent = /* unspecified */;
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/functional&action=edit&section=T-20 "Template:cpp/synopsis/functional")] Class std::ranges::less
    
    
    namespace std::ranges {
      struct less {
        template<class T, class U>
        constexpr bool operator()(T&& t, U&& u) const;
     
        using is_transparent = /* unspecified */;
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/functional&action=edit&section=T-21 "Template:cpp/synopsis/functional")] Class std::ranges::greater_equal
    
    
    namespace std::ranges {
      struct greater_equal {
        template<class T, class U>
        constexpr bool operator()(T&& t, U&& u) const;
     
        using is_transparent = /* unspecified */;
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/functional&action=edit&section=T-22 "Template:cpp/synopsis/functional")] Class std::ranges::less_equal
    
    
    namespace std::ranges {
      struct less_equal {
        template<class T, class U>
        constexpr bool operator()(T&& t, U&& u) const;
     
        using is_transparent = /* unspecified */;
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/functional&action=edit&section=T-23 "Template:cpp/synopsis/functional")] Class template [std::logical_and](../utility/functional/logical_and.html "cpp/utility/functional/logical and")
    
    
    namespace std {
      template<class T = void> struct logical_and {
        constexpr bool operator()(const T& x, const T& y) const;
      };
     
      template<> struct logical_and<void> {
        template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
          -> decltype([std::forward](../utility/forward.html)<T>(t) && [std::forward](../utility/forward.html)<U>(u));
     
        using is_transparent = /* unspecified */;
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/functional&action=edit&section=T-24 "Template:cpp/synopsis/functional")] Class template [std::logical_or](../utility/functional/logical_or.html "cpp/utility/functional/logical or")
    
    
    namespace std {
      template<class T = void> struct logical_or {
        constexpr bool operator()(const T& x, const T& y) const;
      };
     
      template<> struct logical_or<void> {
        template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
          -> decltype([std::forward](../utility/forward.html)<T>(t) || [std::forward](../utility/forward.html)<U>(u));
     
        using is_transparent = /* unspecified */;
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/functional&action=edit&section=T-25 "Template:cpp/synopsis/functional")] Class template [std::logical_not](../utility/functional/logical_not.html "cpp/utility/functional/logical not")
    
    
    namespace std {
      template<class T = void> struct logical_not {
        constexpr bool operator()(const T& x) const;
      };
     
      template<> struct logical_not<void> {
        template<class T> constexpr auto operator()(T&& t) const
          -> decltype(![std::forward](../utility/forward.html)<T>(t));
     
        using is_transparent = /* unspecified */;
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/functional&action=edit&section=T-26 "Template:cpp/synopsis/functional")] Class template [std::bit_and](../utility/functional/bit_and.html "cpp/utility/functional/bit and")
    
    
    namespace std {
      template<class T = void> struct bit_and {
        constexpr T operator()(const T& x, const T& y) const;
      };
     
      template<> struct bit_and<void> {
        template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
          -> decltype([std::forward](../utility/forward.html)<T>(t) & [std::forward](../utility/forward.html)<U>(u));
     
        using is_transparent = /* unspecified */;
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/functional&action=edit&section=T-27 "Template:cpp/synopsis/functional")] Class template [std::bit_or](../utility/functional/bit_or.html "cpp/utility/functional/bit or")
    
    
    namespace std {
      template<class T = void> struct bit_or {
        constexpr T operator()(const T& x, const T& y) const;
      };
     
      template<> struct bit_or<void> {
        template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
          -> decltype([std::forward](../utility/forward.html)<T>(t) | [std::forward](../utility/forward.html)<U>(u));
     
        using is_transparent = /* unspecified */;
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/functional&action=edit&section=T-28 "Template:cpp/synopsis/functional")] Class template std::bit_xor
    
    
    namespace std {
      template<class T = void> struct bit_xor {
        constexpr T operator()(const T& x, const T& y) const;
      };
     
      template<> struct bit_xor<void> {
        template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
          -> decltype([std::forward](../utility/forward.html)<T>(t) ^ [std::forward](../utility/forward.html)<U>(u));
     
        using is_transparent = /* unspecified */;
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/functional&action=edit&section=T-29 "Template:cpp/synopsis/functional")] Class template [std::bit_not](../utility/functional/bit_not.html "cpp/utility/functional/bit not")
    
    
    namespace std {
      template<class T = void> struct bit_not {
        constexpr T operator()(const T& x) const;
      };
     
      template<> struct bit_not<void> {
        template<class T> constexpr auto operator()(T&& t) const
          -> decltype(~[std::forward](../utility/forward.html)<T>(t));
     
        using is_transparent = /* unspecified */;
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/functional&action=edit&section=T-30 "Template:cpp/synopsis/functional")] Class template std::identity
    
    
    namespace std {
      struct identity {
        template<class T>
          constexpr T&& operator()(T&& t) const noexcept;
     
        using is_transparent = /* unspecified */;
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/functional&action=edit&section=T-31 "Template:cpp/synopsis/functional")] Class template [std::is_bind_expression](../utility/functional/is_bind_expression.html "cpp/utility/functional/is bind expression")
    
    
    namespace std {
      template<class T> struct is_bind_expression;
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/functional&action=edit&section=T-32 "Template:cpp/synopsis/functional")] Class template [std::is_placeholder](../utility/functional/is_placeholder.html "cpp/utility/functional/is placeholder")
    
    
    namespace std {
      template<class T> struct is_placeholder;
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/functional&action=edit&section=T-33 "Template:cpp/synopsis/functional")] Class [std::bad_function_call](../utility/functional/bad_function_call.html "cpp/utility/functional/bad function call")
    
    
    namespace std {
      class bad_function_call : public exception {
      public:
        // see [exception] for the specification of the special member functions
        const char* what() const noexcept override;
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/functional&action=edit&section=T-34 "Template:cpp/synopsis/functional")] Class template [std::function](../utility/functional/function.html "cpp/utility/functional/function")
    
    
    namespace std {
      template<class> class function; // not defined
     
      template<class R, class... ArgTypes>
      class function<R(ArgTypes...)> {
      public:
        using result_type = R;
     
        // construct/copy/destroy
        function() noexcept;
        function(nullptr_t) noexcept;
        function(const function&);
        function(function&&) noexcept;
        template<class F> function(F);
     
        function& operator=(const function&);
        function& operator=(function&&);
        function& operator=(nullptr_t) noexcept;
        template<class F> function& operator=(F&&);
        template<class F> function& operator=(reference_wrapper<F>) noexcept;
     
        ~function();
     
        // function modifiers
        void swap(function&) noexcept;
     
        // function capacity
        explicit operator bool() const noexcept;
     
        // function invocation
        R operator()(ArgTypes...) const;
     
        // function target access
        const type_info& target_type() const noexcept;
        template<class T>       T* target() noexcept;
        template<class T> const T* target() const noexcept;
      };
     
      template<class R, class... ArgTypes>
        function(R(*)(ArgTypes...)) -> function<R(ArgTypes...)>;
     
      template<class F> function(F) -> function</* see description */>;
     
      // null pointer comparison functions
      template<class R, class... ArgTypes>
        bool operator==(const function<R(ArgTypes...)>&, nullptr_t) noexcept;
     
      // specialized algorithms
      template<class R, class... ArgTypes>
        void swap(function<R(ArgTypes...)>&, function<R(ArgTypes...)>&) noexcept;
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/functional&action=edit&section=T-35 "Template:cpp/synopsis/functional")] Class template std::move_only_function
    
    
    namespace std {
      template<class... S> class move_only_function; // not defined
     
      template<class R, class... ArgTypes>
      class move_only_function<R(ArgTypes...) /*cv-ref*/ noexcept(/*noex*/)> {
      public:
        using result_type = R;
     
        // construct/move/destroy
        move_only_function() noexcept;
        move_only_function(nullptr_t) noexcept;
        move_only_function(move_only_function&&) noexcept;
        template<class F> move_only_function(F&&);
     
        template<class T, class... Args>
          explicit move_only_function(in_place_type_t<T>, Args&&...);
        template<class T, class U, class... Args>
          explicit move_only_function(in_place_type_t<T>, initializer_list<U>, Args&&...);
     
        move_only_function& operator=(move_only_function&&);
        move_only_function& operator=(nullptr_t) noexcept;
        template<class F> move_only_function& operator=(F&&);
     
        ~move_only_function();
     
        // invocation
        explicit operator bool() const noexcept;
     
        R operator()(ArgTypes...) /*cv-ref*/ noexcept(/*noex*/);
     
        // utility
        void swap(move_only_function&) noexcept;
     
        friend void swap(move_only_function&, move_only_function&) noexcept;
     
        friend bool operator==(const move_only_function&, nullptr_t) noexcept;
     
      private:
        // exposition-only
        template<class VT>
          static constexpr bool /*is-callable-from*/ = /* see description */; 
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/functional&action=edit&section=T-36 "Template:cpp/synopsis/functional")] Class template std::copyable_function
    
    
    namespace std {
      template<class... S> class copyable_function; // not defined
     
      template<class R, class... ArgTypes>
      class copyable_function<R(ArgTypes...) /*cv-ref*/ noexcept(/*noex*/)> {
      public:
        using result_type = R;
     
        // construct/move/destroy
        copyable_function() noexcept;
        copyable_function(nullptr_t) noexcept;
        copyable_function(const copyable_function&);
        copyable_function(copyable_function&&) noexcept;
        template<class F> copyable_function(F&&);
     
        template<class T, class... Args>
          explicit copyable_function(in_place_type_t<T>, Args&&...);
        template<class T, class U, class... Args>
          explicit copyable_function(in_place_type_t<T>, initializer_list<U>, Args&&...);
     
        copyable_function& operator=(const copyable_function&);
        copyable_function& operator=(copyable_function&&);
        copyable_function& operator=(nullptr_t) noexcept;
        template<class F> copyable_function& operator=(F&&);
     
        ~copyable_function();
     
        // invocation
        explicit operator bool() const noexcept;
     
        R operator()(ArgTypes...) /*cv-ref*/ noexcept(/*noex*/);
     
        // utility
        void swap(copyable_function&) noexcept;
     
        friend void swap(copyable_function&, copyable_function&) noexcept;
     
        friend bool operator==(const copyable_function&, nullptr_t) noexcept;
     
      private:
        // exposition-only
        template<class VT>
          static constexpr bool /*is-callable-from*/ = /* see description */; 
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/functional&action=edit&section=T-37 "Template:cpp/synopsis/functional")] Class template std::function_ref
    
    
    namespace std {
      template<class... S> class function_ref; // not defined
     
      template<class R, class... ArgTypes>
      class function_ref<R(ArgTypes...) /*cv*/ noexcept(/*noex*/)> {
      public:
        // constructors and assignment operators
        template<class F> function_ref(F*) noexcept;
        template<class F> constexpr function_ref(F&&) noexcept;
        template<auto f> constexpr function_ref(nontype_t<f>) noexcept;
        template<auto f, class U>
          constexpr function_ref(nontype_t<f>, U&&) noexcept;
        template<auto f, class T>
          constexpr function_ref(nontype_t<f>, /*cv*/ T*) noexcept;
     
        constexpr function_ref(const function_ref&) noexcept = default;
        constexpr function_ref& operator=(const function_ref&) noexcept = default;
        template<class T> function_ref& operator=(T) = delete;
     
        // invocation
        R operator()(ArgTypes...) /*cv*/ noexcept(/*noex*/);
     
      private:
        // exposition-only
        template<class... T>
          static constexpr bool /*is-invocable-using*/ = /* see description */;
     
        R (*thunk-ptr)(BoundEntityType, ArgTypes&&...) noexcept(/*noex*/); // exposition-only
        BoundEntityType bound-entity; // exposition-only
      };
      // deduction guides
      template<class F>
        function_ref(F*) -> function_ref<F>;
      template<auto f>
        function_ref(nontype_t<f>) -> function_ref</* see description */>;
      template<auto f, class T>
        function_ref(nontype_t<f>, T&&) -> function_ref</* see description */>;
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/functional&action=edit&section=T-38 "Template:cpp/synopsis/functional")] Class template [std::default_searcher](../utility/functional/default_searcher.html "cpp/utility/functional/default searcher")
    
    
    namespace std {
      template<class ForwardIter1, class BinaryPredicate = equal_to<>>
        class default_searcher {
        public:
          constexpr default_searcher(ForwardIter1 pat_first, ForwardIter1 pat_last,
                                     BinaryPredicate pred = BinaryPredicate());
     
          template<class ForwardIter2>
            constexpr pair<ForwardIter2, ForwardIter2>
              operator()(ForwardIter2 first, ForwardIter2 last) const;
     
        private:
          ForwardIter1 pat_first_;            // exposition only
          ForwardIter1 pat_last_;             // exposition only
          BinaryPredicate pred_;              // exposition only
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/functional&action=edit&section=T-39 "Template:cpp/synopsis/functional")] Class template [std::boyer_moore_searcher](../utility/functional/boyer_moore_searcher.html "cpp/utility/functional/boyer moore searcher")
    
    
    namespace std {
      template<class RandomAccessIter1,
               class Hash = hash<typename iterator_traits<RandomAccessIter1>::value_type>,
               class BinaryPredicate = equal_to<>>
        class boyer_moore_searcher {
        public:
          boyer_moore_searcher(RandomAccessIter1 pat_first,
                               RandomAccessIter1 pat_last,
                               Hash hf = Hash(),
                               BinaryPredicate pred = BinaryPredicate());
     
          template<class RandomAccessIter2>
            pair<RandomAccessIter2, RandomAccessIter2>
              operator()(RandomAccessIter2 first, RandomAccessIter2 last) const;
     
        private:
          RandomAccessIter1 pat_first_;       // exposition only
          RandomAccessIter1 pat_last_;        // exposition only
          Hash hash_;                         // exposition only
          BinaryPredicate pred_;              // exposition only
        };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/functional&action=edit&section=T-40 "Template:cpp/synopsis/functional")] Class template [std::boyer_moore_horspool_searcher](../utility/functional/boyer_moore_horspool_searcher.html "cpp/utility/functional/boyer moore horspool searcher")
    
    
    namespace std {
      template<class RandomAccessIter1,
               class Hash = hash<typename iterator_traits<RandomAccessIter1>::value_type>,
               class BinaryPredicate = equal_to<>>
        class boyer_moore_horspool_searcher {
        public:
          boyer_moore_horspool_searcher(RandomAccessIter1 pat_first,
                                        RandomAccessIter1 pat_last,
                                        Hash hf = Hash(),
                                        BinaryPredicate pred = BinaryPredicate());
     
          template<class RandomAccessIter2>
            pair<RandomAccessIter2, RandomAccessIter2>
              operator()(RandomAccessIter2 first, RandomAccessIter2 last) const;
     
        private:
          RandomAccessIter1 pat_first_;       // exposition only
          RandomAccessIter1 pat_last_;        // exposition only
          Hash hash_;                         // exposition only
          BinaryPredicate pred_;              // exposition only
      };
    }

### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/header/functional&action=edit&section=4 "Edit section: See also")] See also

[std::hash](../utility/hash.html "cpp/utility/hash") [specializations for library types](../utility/hash.html#Specializations_for_library_types "cpp/utility/hash")  
---
