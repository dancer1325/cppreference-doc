[C++](../../cpp.html "cpp")

[Compiler support](../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../freestanding.html "cpp/freestanding")  
[Language](../language.html "cpp/language")  
[Standard library](../standard_library.html "cpp/standard library")  
[Standard library headers](../headers.html "cpp/header")  
[Named requirements](../iterator/concepts.html "cpp/named req")  
[Feature test macros](../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../utility.html#Language_support "cpp/utility")  
[Concepts library](../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../error.html "cpp/error")  
[Memory management library](../memory.html "cpp/memory")  
[Metaprogramming library](../meta.html "cpp/meta") (C++11)  
[General utilities library](../utility.html "cpp/utility")  
[Containers library](../container.html "cpp/container")  
[Iterators library](../iterator.html "cpp/iterator")  
[Ranges library](../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../algorithm.html "cpp/algorithm")  
[Strings library](../string.html "cpp/string")  
[Text processing library](../text.html "cpp/text")  
[Numerics library](../numeric.html "cpp/numeric")  
[Date and time library](../chrono.html "cpp/chrono")  
[Input/output library](../io.html "cpp/io")  
[Filesystem library](../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../atomic.html "cpp/thread") (C++11)  
[Execution control library](../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../experimental.html "cpp/experimental")  
[Symbols index](../symbol_index.html "cpp/symbol index")  
[External libraries](../links/libs.html "cpp/links/libs")  
  


[Standard library headers](../headers.html "cpp/header")

| [Language support](../headers.html#Language_support_library "cpp/header")  
---  
[`<cfloat>`](cfloat.html "cpp/header/cfloat")  
[`<climits>`](climits.html "cpp/header/climits")  
[`<compare>`](compare.html "cpp/header/compare") (C++20)  
[`<contracts>`](contracts.html "cpp/header/contracts") (C++26)  
[`<coroutine>`](coroutine.html "cpp/header/coroutine") (C++20)  
[`<csetjmp>`](csetjmp.html "cpp/header/csetjmp")  
[`<csignal>`](csignal.html "cpp/header/csignal")  
[`<cstdarg>`](cstdarg.html "cpp/header/cstdarg")  
[`<cstddef>`](cstddef.html "cpp/header/cstddef")  
[`<cstdint>`](cstdint.html "cpp/header/cstdint") (C++11)  
[`<cstdlib>`](cstdlib.html "cpp/header/cstdlib")  
[`<exception>`](exception.html "cpp/header/exception")  
[`<initializer_list>`](initializer_list.html "cpp/header/initializer list") (C++11)` `  
[`<limits>`](limits.html "cpp/header/limits")  
[`<new>`](new.html "cpp/header/new")  
[`<source_location>`](source_location.html "cpp/header/source location") (C++20)  
[`<stdfloat>`](stdfloat.html "cpp/header/stdfloat") (C++23)  
[`<typeinfo>`](typeinfo.html "cpp/header/typeinfo")  
[`<version>`](version.html "cpp/header/version") (C++20)  
[Concepts](../headers.html#Concepts_library "cpp/header")  
[`<concepts>`](concepts.html "cpp/header/concepts") (C++20)  
[Diagnostics](../headers.html#Diagnostics_library "cpp/header")  
[`<cassert>`](cassert.html "cpp/header/cassert")  
[`<cerrno>`](cerrno.html "cpp/header/cerrno")  
[`<debugging>`](debugging.html "cpp/header/debugging") (C++26)  
[`<stacktrace>`](stacktrace.html "cpp/header/stacktrace") (C++23)  
[`<stdexcept>`](stdexcept.html "cpp/header/stdexcept")  
[`<system_error>`](system_error.html "cpp/header/system error") (C++11)  
[Memory management](../headers.html#Memory_management_library "cpp/header")  
[`<memory>`](memory.html "cpp/header/memory")  
[`<memory_resource>`](memory_resource.html "cpp/header/memory resource") (C++17)  
[`<scoped_allocator>`](scoped_allocator.html "cpp/header/scoped allocator") (C++11)  
[Metaprogramming](../headers.html#Metaprogramming_library "cpp/header")  
[`<type_traits>`](type_traits.html "cpp/header/type traits") (C++11)  
[`<ratio>`](ratio.html "cpp/header/ratio") (C++11)  
  
  
  
| [General utilities](../headers.html#General_utilities_library "cpp/header")  
---  
[`<any>`](any.html "cpp/header/any") (C++17)  
[`<bitset>`](bitset.html "cpp/header/bitset")  
[`<bit>`](bit.html "cpp/header/bit") (C++20)  
[`<charconv>`](charconv.html "cpp/header/charconv") (C++17)  
[`<expected>`](expected.html "cpp/header/expected") (C++23)  
[`<format>`](format.html "cpp/header/format") (C++20)  
[`<functional>`](functional.html "cpp/header/functional")  
[`<optional>`](optional.html "cpp/header/optional") (C++17)  
[`<stdbit.h>`](stdbit.h.html "cpp/header/stdbit.h") (C++26)  
[`<tuple>`](tuple.html "cpp/header/tuple") (C++11)  
[`<typeindex>`](typeindex.html "cpp/header/typeindex") (C++11)  
[`<utility>`](utility.html "cpp/header/utility")  
[`<variant>`](variant.html "cpp/header/variant") (C++17)  
[Containers](../headers.html#Containers_library "cpp/header")  
[`<array>`](array.html "cpp/header/array") (C++11)  
[`<deque>`](deque.html "cpp/header/deque")  
[`<flat_map>`](flat_map.html "cpp/header/flat map") (C++23)  
[`<flat_set>`](flat_set.html "cpp/header/flat set") (C++23)  
[`<forward_list>`](forward_list.html "cpp/header/forward list") (C++11)  
[`<hive>`](hive.html "cpp/header/hive") (C++26)  
[`<inplace_vector>`](inplace_vector.html "cpp/header/inplace vector") (C++26)` `  
[`<list>`](list.html "cpp/header/list")  
[`<map>`](map.html "cpp/header/map")  
[`<mdspan>`](mdspan.html "cpp/header/mdspan") (C++23)  
[`<queue>`](queue.html "cpp/header/queue")  
[`<set>`](set.html "cpp/header/set")  
[`<span>`](span.html "cpp/header/span") (C++20)  
[`<stack>`](stack.html "cpp/header/stack")  
[`<unordered_map>`](unordered_map.html "cpp/header/unordered map") (C++11)  
[`<unordered_set>`](unordered_set.html "cpp/header/unordered set") (C++11)  
[`<vector>`](vector.html "cpp/header/vector")  
[Iterators](../headers.html#Iterators_library "cpp/header")  
[`<iterator>`](iterator.html "cpp/header/iterator")  
[Ranges](../headers.html#Ranges_library "cpp/header")  
[`<generator>`](generator.html "cpp/header/generator") (C++23)  
[`<ranges>`](ranges.html "cpp/header/ranges") (C++20)  
  
| [Algorithms](../headers.html#Algorithms_library "cpp/header")  
---  
**`< algorithm>`**  
[`<numeric>`](numeric.html "cpp/header/numeric")  
[Strings](../headers.html#Strings_library "cpp/header")  
[`<cctype>`](cctype.html "cpp/header/cctype")  
[`<cstring>`](cstring.html "cpp/header/cstring")  
[`<cuchar>`](cuchar.html "cpp/header/cuchar") (C++11)  
[`<cwchar>`](cwchar.html "cpp/header/cwchar")  
[`<cwctype>`](cwctype.html "cpp/header/cwctype")  
[`<string_view>`](string_view.html "cpp/header/string view") (C++17)  
[`<string>`](string.html "cpp/header/string")  
[Text processing](../headers.html#Text_processing_library "cpp/header")  
[`<clocale>`](clocale.html "cpp/header/clocale")  
[`<codecvt>`](codecvt.html "cpp/header/codecvt") (C++11/17/26*)  
[`<locale>`](locale.html "cpp/header/locale")  
[`<regex>`](regex.html "cpp/header/regex") (C++11)  
[`<text_encoding>`](text_encoding.html "cpp/header/text encoding") (C++26)` `  
[Numerics](../headers.html#Numerics_library "cpp/header")  
[`<cfenv>`](cfenv.html "cpp/header/cfenv") (C++11)  
[`<cmath>`](cmath.html "cpp/header/cmath")  
[`<complex>`](complex.html "cpp/header/complex")  
[`<linalg>`](linalg.html "cpp/header/linalg") (C++26)  
[`<numbers>`](numbers.html "cpp/header/numbers") (C++20)  
[`<random>`](random.html "cpp/header/random") (C++11)  
[`<simd>`](simd.html "cpp/header/simd") (C++26)  
[`<stdckdint.h>`](stdckdint.h.html "cpp/header/stdckdint.h") (C++26)  
[`<valarray>`](valarray.html "cpp/header/valarray")  
[Time](../headers.html#Time_library "cpp/header")  
[`<chrono>`](chrono.html "cpp/header/chrono") (C++11)  
[`<ctime>`](ctime.html "cpp/header/ctime")  
[C compatibility](../headers.html#C_compatibility_headers "cpp/header")  
[`<ccomplex>`](ccomplex.html "cpp/header/ccomplex") (C++11/17/20*)  
[`<ciso646>`](ciso646.html "cpp/header/ciso646") (until C++20)  
[`<cstdalign>`](cstdalign.html "cpp/header/cstdalign") (C++11/17/20*)  
[`<cstdbool>`](cstdbool.html "cpp/header/cstdbool") (C++11/17/20*)  
[`<ctgmath>`](ctgmath.html "cpp/header/ctgmath") (C++11/17/20*)  
  
| [Input/output](../headers.html#Input.2Foutput_library "cpp/header")  
---  
[`<cinttypes>`](cinttypes.html "cpp/header/cinttypes") (C++11)  
[`<cstdio>`](cstdio.html "cpp/header/cstdio")  
[`<filesystem>`](filesystem.html "cpp/header/filesystem") (C++17)  
[`<fstream>`](fstream.html "cpp/header/fstream")  
[`<iomanip>`](iomanip.html "cpp/header/iomanip")  
[`<iosfwd>`](iosfwd.html "cpp/header/iosfwd")  
[`<iostream>`](iostream.html "cpp/header/iostream")  
[`<ios>`](ios.html "cpp/header/ios")  
[`<istream>`](istream.html "cpp/header/istream")  
[`<ostream>`](ostream.html "cpp/header/ostream")  
[`<print>`](print.html "cpp/header/print") (C++23)  
[`<spanstream>`](spanstream.html "cpp/header/spanstream") (C++23)  
[`<sstream>`](sstream.html "cpp/header/sstream")  
[`<streambuf>`](streambuf.html "cpp/header/streambuf")  
[`<strstream>`](strstream.html "cpp/header/strstream") (C++98/26*)  
[`<syncstream>`](syncstream.html "cpp/header/syncstream") (C++20)  
[Concurrency support](../headers.html#Concurrency_support_library "cpp/header")  
[`<atomic>`](atomic.html "cpp/header/atomic") (C++11)  
[`<barrier>`](barrier.html "cpp/header/barrier") (C++20)  
[`<condition_variable>`](condition_variable.html "cpp/header/condition variable") (C++11)  
[`<future>`](future.html "cpp/header/future") (C++11)  
[`<hazard_pointer>`](hazard_pointer.html "cpp/header/hazard pointer") (C++26)  
[`<latch>`](latch.html "cpp/header/latch") (C++20)  
[`<mutex>`](mutex.html "cpp/header/mutex") (C++11)  
[`<rcu>`](rcu.html "cpp/header/rcu") (C++26)  
[`<semaphore>`](semaphore.html "cpp/header/semaphore") (C++20)  
[`<shared_mutex>`](shared_mutex.html "cpp/header/shared mutex") (C++14)  
[`<stdatomic.h>`](stdatomic.h.html "cpp/header/stdatomic.h") (C++23)  
[`<stop_token>`](stop_token.html "cpp/header/stop token") (C++20)  
[`<thread>`](thread.html "cpp/header/thread") (C++11)  
[Execution support](../headers.html#Multi-purpose_headers "cpp/header")  
[`<execution>`](execution.html "cpp/header/execution") (C++17)  
  
  
  
  
  
  
  
  
  


This header is part of the [algorithm](../algorithm.html "cpp/algorithm") library. 

| 

## Contents

  * [1 Includes](algorithm.html#Includes)
  * [2 Classes](algorithm.html#Classes)
    * [2.1 Return types (C++20)](algorithm.html#Return_types_.28C.2B.2B20.29)
  * [3 Functions](algorithm.html#Functions)
    * [3.1 Non-modifying sequence operations](algorithm.html#Non-modifying_sequence_operations)
    * [3.2 Modifying sequence operations](algorithm.html#Modifying_sequence_operations)
    * [3.3 Partitioning operations](algorithm.html#Partitioning_operations)
    * [3.4 Sorting operations](algorithm.html#Sorting_operations)
    * [3.5 Binary search operations (on sorted ranges)](algorithm.html#Binary_search_operations_.28on_sorted_ranges.29)
    * [3.6 Other operations on sorted ranges](algorithm.html#Other_operations_on_sorted_ranges)
    * [3.7 Set operations (on sorted ranges)](algorithm.html#Set_operations_.28on_sorted_ranges.29)
    * [3.8 Heap operations](algorithm.html#Heap_operations)
    * [3.9 Minimum/maximum operations](algorithm.html#Minimum.2Fmaximum_operations)
    * [3.10 Comparison operations](algorithm.html#Comparison_operations)
    * [3.11 Permutation operations](algorithm.html#Permutation_operations)
  * [4 Function-like entities (C++20)](algorithm.html#Function-like_entities_.28C.2B.2B20.29)
    * [4.1 Non-modifying sequence operations](algorithm.html#Non-modifying_sequence_operations_2)
    * [4.2 Fold operations](algorithm.html#Fold_operations)
    * [4.3 Modifying sequence operations](algorithm.html#Modifying_sequence_operations_2)
    * [4.4 Partitioning operations](algorithm.html#Partitioning_operations_2)
    * [4.5 Sorting operations](algorithm.html#Sorting_operations_2)
    * [4.6 Binary search operations (on sorted ranges)](algorithm.html#Binary_search_operations_.28on_sorted_ranges.29_2)
    * [4.7 Other operations on sorted ranges](algorithm.html#Other_operations_on_sorted_ranges_2)
    * [4.8 Set operations (on sorted ranges)](algorithm.html#Set_operations_.28on_sorted_ranges.29_2)
    * [4.9 Heap operations](algorithm.html#Heap_operations_2)
    * [4.10 Minimum/maximum operations](algorithm.html#Minimum.2Fmaximum_operations_2)
    * [4.11 Comparison operations](algorithm.html#Comparison_operations_2)
    * [4.12 Permutation operations](algorithm.html#Permutation_operations_2)
  * [5 Synopsis](algorithm.html#Synopsis)
    * [5.1 Class template std::ranges::in_fun_result](algorithm.html#Class_template_std::ranges::in_fun_result)
    * [5.2 Class template std::ranges::in_in_result](algorithm.html#Class_template_std::ranges::in_in_result)
    * [5.3 Class template std::ranges::in_out_result](algorithm.html#Class_template_std::ranges::in_out_result)
    * [5.4 Class template std::ranges::in_in_out_result](algorithm.html#Class_template_std::ranges::in_in_out_result)
    * [5.5 Class template std::ranges::in_out_out_result](algorithm.html#Class_template_std::ranges::in_out_out_result)
    * [5.6 Class template std::ranges::min_max_result](algorithm.html#Class_template_std::ranges::min_max_result)
    * [5.7 Class template std::ranges::in_found_result](algorithm.html#Class_template_std::ranges::in_found_result)
    * [5.8 Class template std::ranges::in_value_result](algorithm.html#Class_template_std::ranges::in_value_result)
    * [5.9 Class template std::ranges::out_value_result](algorithm.html#Class_template_std::ranges::out_value_result)

  
---  
  
###  Includes  
  
[ <initializer_list>](initializer_list.html "cpp/header/initializer list")(C++11) |  [std::initializer_list](../utility/initializer_list.html "cpp/utility/initializer list") class template  
  
###  Classes  
  
Defined in namespace `std::ranges`  
  
#####  Return types (C++20)  
  
[ ranges::in_fun_result](../algorithm/ranges/return_types/in_fun_result.html "cpp/algorithm/ranges/return types/in fun result")(C++20) |  provides a way to store an iterator and a function object as a single unit   
(class template)   
[ ranges::in_in_result](../algorithm/ranges/return_types/in_in_result.html "cpp/algorithm/ranges/return types/in in result")(C++20) |  provides a way to store two iterators as a single unit   
(class template)   
[ ranges::in_out_result](../algorithm/ranges/return_types/in_out_result.html "cpp/algorithm/ranges/return types/in out result")(C++20) |  provides a way to store two iterators as a single unit   
(class template)   
[ ranges::in_in_out_result](../algorithm/ranges/return_types/in_in_out_result.html "cpp/algorithm/ranges/return types/in in out result")(C++20) |  provides a way to store three iterators as a single unit   
(class template)   
[ ranges::in_out_out_result](../algorithm/ranges/return_types/in_out_out_result.html "cpp/algorithm/ranges/return types/in out out result")(C++20) |  provides a way to store three iterators as a single unit   
(class template)   
[ ranges::min_max_result](../algorithm/ranges/return_types/min_max_result.html "cpp/algorithm/ranges/return types/min max result")(C++20) |  provides a way to store two objects or references of the same type as a single unit   
(class template)   
[ ranges::in_found_result](../algorithm/ranges/return_types/in_found_result.html "cpp/algorithm/ranges/return types/in found result")(C++20) |  provides a way to store an iterator and a boolean flag as a single unit   
(class template)   
[ ranges::in_value_result](../algorithm/ranges/return_types/in_value_result.html "cpp/algorithm/ranges/return types/in value result")(C++23) |  provides a way to store an iterator and a value as a single unit   
(class template)   
[ ranges::out_value_result](../algorithm/ranges/return_types/out_value_result.html "cpp/algorithm/ranges/return types/out value result")(C++23) |  provides a way to store an iterator and a value as a single unit   
(class template)   
  
###  Functions  
  
#####  Non-modifying sequence operations   
  
[ all_ofany_ofnone_of](../algorithm/none_of.html "cpp/algorithm/all any none of")(C++11)(C++11)(C++11) |  checks if a predicate is true for all, any or none of the elements in a range   
(function template)   
[ for_each](../algorithm/for_each.html "cpp/algorithm/for each") |  applies a unary [function object](../named_req/FunctionObject.html "cpp/named req/FunctionObject") to elements from a [range](../iterator.html#Ranges "cpp/iterator")   
(function template)   
[ for_each_n](../algorithm/for_each_n.html "cpp/algorithm/for each n")(C++17) |  applies a function object to the first N elements of a sequence   
(function template)   
[ countcount_if](../algorithm/count.html "cpp/algorithm/count") |  returns the number of elements satisfying specific criteria   
(function template)   
[ mismatch](../algorithm/mismatch.html "cpp/algorithm/mismatch") |  finds the first position where two ranges differ   
(function template)   
[ findfind_iffind_if_not](../algorithm/find.html "cpp/algorithm/find")(C++11) |  finds the first element satisfying specific criteria   
(function template)   
[ find_end](../algorithm/find_end.html "cpp/algorithm/find end") |  finds the last sequence of elements in a certain range   
(function template)   
[ find_first_of](../algorithm/find_first_of.html "cpp/algorithm/find first of") |  searches for any one of a set of elements   
(function template)   
[ adjacent_find](../algorithm/adjacent_find.html "cpp/algorithm/adjacent find") |  finds the first two adjacent items that are equal (or satisfy a given predicate)   
(function template)   
[ search](../algorithm/search.html "cpp/algorithm/search") |  searches for the first occurrence of a range of elements   
(function template)   
[ search_n](../algorithm/search_n.html "cpp/algorithm/search n") |  searches for the first occurrence of a number consecutive copies of an element in a range   
(function template)   
  
#####  Modifying sequence operations   
  
[ copycopy_if](../algorithm/copy.html "cpp/algorithm/copy")(C++11) |  copies a range of elements to a new location   
(function template)   
[ copy_n](../algorithm/copy_n.html "cpp/algorithm/copy n")(C++11) |  copies a number of elements to a new location   
(function template)   
[ copy_backward](../algorithm/copy_backward.html "cpp/algorithm/copy backward") |  copies a range of elements in backwards order   
(function template)   
[ move](../algorithm/move.html "cpp/algorithm/move")(C++11) |  moves a range of elements to a new location   
(function template)   
[ move_backward](../algorithm/move_backward.html "cpp/algorithm/move backward")(C++11) |  moves a range of elements to a new location in backwards order   
(function template)   
[ fill](../algorithm/fill.html "cpp/algorithm/fill") |  copy-assigns the given value to every element in a range   
(function template)   
[ fill_n](../algorithm/fill_n.html "cpp/algorithm/fill n") |  copy-assigns the given value to N elements in a range   
(function template)   
[ transform](../algorithm/transform.html "cpp/algorithm/transform") |  applies a function to a range of elements, storing results in a destination range   
(function template)   
[ generate](../algorithm/generate.html "cpp/algorithm/generate") |  assigns the results of successive function calls to every element in a range   
(function template)   
[ generate_n](../algorithm/generate_n.html "cpp/algorithm/generate n") |  assigns the results of successive function calls to N elements in a range   
(function template)   
[ removeremove_if](../algorithm/remove.html "cpp/algorithm/remove") |  removes elements satisfying specific criteria   
(function template)   
[ remove_copyremove_copy_if](../algorithm/remove_copy.html "cpp/algorithm/remove copy") |  copies a range of elements omitting those that satisfy specific criteria   
(function template)   
[ replacereplace_if](../algorithm/replace.html "cpp/algorithm/replace") |  replaces all values satisfying specific criteria with another value   
(function template)   
[ replace_copyreplace_copy_if](../algorithm/replace_copy.html "cpp/algorithm/replace copy") |  copies a range, replacing elements satisfying specific criteria with another value   
(function template)   
[ swap](../utility/swap.html "cpp/algorithm/swap") |  swaps the values of two objects   
(function template)   
[ swap_ranges](../algorithm/swap_ranges.html "cpp/algorithm/swap ranges") |  swaps two ranges of elements   
(function template)   
[ iter_swap](../algorithm/iter_swap.html "cpp/algorithm/iter swap") |  swaps the elements pointed to by two iterators   
(function template)   
[ reverse](../algorithm/reverse.html "cpp/algorithm/reverse") |  reverses the order of elements in a range   
(function template)   
[ reverse_copy](../algorithm/reverse_copy.html "cpp/algorithm/reverse copy") |  creates a copy of a range that is reversed   
(function template)   
[ rotate](../algorithm/rotate.html "cpp/algorithm/rotate") |  rotates the order of elements in a range   
(function template)   
[ rotate_copy](../algorithm/rotate_copy.html "cpp/algorithm/rotate copy") |  copies and rotate a range of elements   
(function template)   
[ shift_leftshift_right](../algorithm/shift.html "cpp/algorithm/shift")(C++20) |  shifts elements in a range   
(function template)   
[ random_shuffleshuffle](../algorithm/random_shuffle.html "cpp/algorithm/random shuffle")(until C++17)(C++11) |  randomly re-orders elements in a range   
(function template)   
[ sample](../algorithm/sample.html "cpp/algorithm/sample")(C++17) |  selects N random elements from a sequence   
(function template)   
[ unique](../algorithm/unique.html "cpp/algorithm/unique") |  removes consecutive duplicate elements in a range   
(function template)   
[ unique_copy](../algorithm/unique_copy.html "cpp/algorithm/unique copy") |  creates a copy of some range of elements that contains no consecutive duplicates   
(function template)   
  
#####  Partitioning operations   
  
[ is_partitioned](../algorithm/is_partitioned.html "cpp/algorithm/is partitioned")(C++11) |  determines if the range is partitioned by the given predicate   
(function template)   
[ partition](../algorithm/partition.html "cpp/algorithm/partition") |  divides a range of elements into two groups   
(function template)   
[ partition_copy](../algorithm/partition_copy.html "cpp/algorithm/partition copy")(C++11) |  copies a range dividing the elements into two groups   
(function template)   
[ stable_partition](../algorithm/stable_partition.html "cpp/algorithm/stable partition") |  divides elements into two groups while preserving their relative order   
(function template)   
[ partition_point](../algorithm/partition_point.html "cpp/algorithm/partition point")(C++11) |  locates the partition point of a partitioned range   
(function template)   
  
#####  Sorting operations   
  
[ is_sorted](../algorithm/is_sorted.html "cpp/algorithm/is sorted")(C++11) |  checks whether a range is sorted into ascending order   
(function template)   
[ is_sorted_until](../algorithm/is_sorted_until.html "cpp/algorithm/is sorted until")(C++11) |  finds the largest sorted subrange   
(function template)   
[ sort](../algorithm/sort.html "cpp/algorithm/sort") |  sorts a range into ascending order   
(function template)   
[ partial_sort](../algorithm/partial_sort.html "cpp/algorithm/partial sort") |  sorts the first N elements of a range   
(function template)   
[ partial_sort_copy](../algorithm/partial_sort_copy.html "cpp/algorithm/partial sort copy") |  copies and partially sorts a range of elements   
(function template)   
[ stable_sort](../algorithm/stable_sort.html "cpp/algorithm/stable sort") |  sorts a range of elements while preserving order between equal elements   
(function template)   
[ nth_element](../algorithm/nth_element.html "cpp/algorithm/nth element") |  partially sorts the given range making sure that it is partitioned by the given element   
(function template)   
  
#####  Binary search operations (on sorted ranges)   
  
[ lower_bound](../algorithm/lower_bound.html "cpp/algorithm/lower bound") |  returns an iterator to the first element _not less_ than the given value   
(function template)   
[ upper_bound](../algorithm/upper_bound.html "cpp/algorithm/upper bound") |  returns an iterator to the first element _greater_ than a certain value   
(function template)   
[ binary_search](../algorithm/binary_search.html "cpp/algorithm/binary search") |  determines if an element exists in a partially-ordered range   
(function template)   
[ equal_range](../algorithm/equal_range.html "cpp/algorithm/equal range") |  returns range of elements matching a specific key   
(function template)   
  
#####  Other operations on sorted ranges   
  
[ merge](../algorithm/merge.html "cpp/algorithm/merge") |  merges two sorted ranges   
(function template)   
[ inplace_merge](../algorithm/inplace_merge.html "cpp/algorithm/inplace merge") |  merges two ordered ranges in-place   
(function template)   
  
#####  Set operations (on sorted ranges)   
  
[ includes](../algorithm/includes.html "cpp/algorithm/includes") |  returns true if one sequence is a subsequence of another   
(function template)   
[ set_difference](../algorithm/set_difference.html "cpp/algorithm/set difference") |  computes the difference between two sets   
(function template)   
[ set_intersection](../algorithm/set_intersection.html "cpp/algorithm/set intersection") |  computes the intersection of two sets   
(function template)   
[ set_symmetric_difference](../algorithm/set_symmetric_difference.html "cpp/algorithm/set symmetric difference") |  computes the symmetric difference between two sets   
(function template)   
[ set_union](../algorithm/set_union.html "cpp/algorithm/set union") |  computes the union of two sets   
(function template)   
  
#####  Heap operations   
  
[ is_heap](../algorithm/is_heap.html "cpp/algorithm/is heap")(C++11) |  checks if the given range is a max heap   
(function template)   
[ is_heap_until](../algorithm/is_heap_until.html "cpp/algorithm/is heap until")(C++11) |  finds the largest subrange that is a max heap   
(function template)   
[ make_heap](../algorithm/make_heap.html "cpp/algorithm/make heap") |  creates a max heap out of a range of elements   
(function template)   
[ push_heap](../algorithm/push_heap.html "cpp/algorithm/push heap") |  adds an element to a max heap   
(function template)   
[ pop_heap](../algorithm/pop_heap.html "cpp/algorithm/pop heap") |  removes the largest element from a max heap   
(function template)   
[ sort_heap](../algorithm/sort_heap.html "cpp/algorithm/sort heap") |  turns a max heap into a range of elements sorted in ascending order   
(function template)   
  
#####  Minimum/maximum operations   
  
[ max](../algorithm/max.html "cpp/algorithm/max") |  returns the greater of the given values   
(function template)   
[ max_element](../algorithm/max_element.html "cpp/algorithm/max element") |  returns the largest element in a range   
(function template)   
[ min](../algorithm/min.html "cpp/algorithm/min") |  returns the smaller of the given values   
(function template)   
[ min_element](../algorithm/min_element.html "cpp/algorithm/min element") |  returns the smallest element in a range   
(function template)   
[ minmax](../algorithm/minmax.html "cpp/algorithm/minmax")(C++11) |  returns the smaller and larger of two elements   
(function template)   
[ minmax_element](../algorithm/minmax_element.html "cpp/algorithm/minmax element")(C++11) |  returns the smallest and the largest elements in a range   
(function template)   
[ clamp](../algorithm/clamp.html "cpp/algorithm/clamp")(C++17) |  clamps a value between a pair of boundary values   
(function template)   
  
#####  Comparison operations   
  
[ equal](../algorithm/equal.html "cpp/algorithm/equal") |  determines if two sets of elements are the same   
(function template)   
[ lexicographical_compare](../algorithm/lexicographical_compare.html "cpp/algorithm/lexicographical compare") |  returns true if one range is lexicographically less than another   
(function template)   
[ lexicographical_compare_three_way](../algorithm/lexicographical_compare_three_way.html "cpp/algorithm/lexicographical compare three way")(C++20) |  compares two ranges using three-way comparison   
(function template)   
  
#####  Permutation operations   
  
[ is_permutation](../algorithm/is_permutation.html "cpp/algorithm/is permutation")(C++11) |  determines if a sequence is a permutation of another sequence   
(function template)   
[ next_permutation](../algorithm/next_permutation.html "cpp/algorithm/next permutation") |  generates the next greater lexicographic permutation of a range of elements   
(function template)   
[ prev_permutation](../algorithm/prev_permutation.html "cpp/algorithm/prev permutation") |  generates the next smaller lexicographic permutation of a range of elements   
(function template)   
  
###  Function-like entities (C++20)  
  
Defined in namespace `std::ranges`  
  
#####  Non-modifying sequence operations   
  
[ ranges::all_ofranges::any_ofranges::none_of](../algorithm/ranges/all_any_none_of.html "cpp/algorithm/ranges/all any none of")(C++20)(C++20)(C++20) |  checks if a predicate is true for all, any or none of the elements in a range  
(algorithm function object)  
[ ranges::for_each](../algorithm/ranges/for_each.html "cpp/algorithm/ranges/for each")(C++20) |  applies a unary [function object](../named_req/FunctionObject.html "cpp/named req/FunctionObject") to elements from a [range](../iterator.html#Ranges "cpp/iterator")  
(algorithm function object)  
[ ranges::for_each_n](../algorithm/ranges/for_each_n.html "cpp/algorithm/ranges/for each n")(C++20) |  applies a function object to the first N elements of a sequence  
(algorithm function object)  
[ ranges::countranges::count_if](../algorithm/ranges/count.html "cpp/algorithm/ranges/count")(C++20)(C++20) |  returns the number of elements satisfying specific criteria  
(algorithm function object)  
[ ranges::mismatch](../algorithm/ranges/mismatch.html "cpp/algorithm/ranges/mismatch")(C++20) |  finds the first position where two ranges differ  
(algorithm function object)  
[ ranges::findranges::find_ifranges::find_if_not](../algorithm/ranges/find.html "cpp/algorithm/ranges/find")(C++20)(C++20)(C++20) |  finds the first element satisfying specific criteria  
(algorithm function object)  
[ ranges::find_lastranges::find_last_ifranges::find_last_if_not](../algorithm/ranges/find_last.html "cpp/algorithm/ranges/find last")(C++23)(C++23)(C++23) |  finds the last element satisfying specific criteria  
(algorithm function object)  
[ ranges::find_end](../algorithm/ranges/find_end.html "cpp/algorithm/ranges/find end")(C++20) |  finds the last sequence of elements in a certain range  
(algorithm function object)  
[ ranges::find_first_of](../algorithm/ranges/find_first_of.html "cpp/algorithm/ranges/find first of")(C++20) |  searches for any one of a set of elements  
(algorithm function object)  
[ ranges::adjacent_find](../algorithm/ranges/adjacent_find.html "cpp/algorithm/ranges/adjacent find")(C++20) |  finds the first two adjacent items that are equal (or satisfy a given predicate)  
(algorithm function object)  
[ ranges::search](../algorithm/ranges/search.html "cpp/algorithm/ranges/search")(C++20) |  searches for the first occurrence of a range of elements  
(algorithm function object)  
[ ranges::search_n](../algorithm/ranges/search_n.html "cpp/algorithm/ranges/search n")(C++20) |  searches for the first occurrence of a number consecutive copies of an element in a range  
(algorithm function object)  
[ ranges::containsranges::contains_subrange](../algorithm/ranges/contains.html "cpp/algorithm/ranges/contains")(C++23)(C++23) |  checks if the range contains the given element or subrange  
(algorithm function object)  
[ ranges::starts_with](../algorithm/ranges/starts_with.html "cpp/algorithm/ranges/starts with")(C++23) |  checks whether a range starts with another range  
(algorithm function object)  
[ ranges::ends_with](../algorithm/ranges/ends_with.html "cpp/algorithm/ranges/ends with")(C++23) |  checks whether a range ends with another range  
(algorithm function object)  
  
#####  Fold operations   
  
[ ranges::fold_left](../algorithm/ranges/fold_left.html "cpp/algorithm/ranges/fold left")(C++23) |  left-folds a range of elements  
(algorithm function object)  
[ ranges::fold_left_first](../algorithm/ranges/fold_left_first.html "cpp/algorithm/ranges/fold left first")(C++23) |  left-folds a range of elements using the first element as an initial value  
(algorithm function object)  
[ ranges::fold_right](../algorithm/ranges/fold_right.html "cpp/algorithm/ranges/fold right")(C++23) |  right-folds a range of elements  
(algorithm function object)  
[ ranges::fold_right_last](../algorithm/ranges/fold_right_last.html "cpp/algorithm/ranges/fold right last")(C++23) |  right-folds a range of elements using the last element as an initial value  
(algorithm function object)  
[ ranges::fold_left_with_iter](../algorithm/ranges/fold_left_with_iter.html "cpp/algorithm/ranges/fold left with iter")(C++23) |  left-folds a range of elements, and returns a [pair](../algorithm/ranges/return_types/in_value_result.html "cpp/algorithm/ranges/return types/in value result") (iterator, value)  
(algorithm function object)  
[ ranges::fold_left_first_with_iter](../algorithm/ranges/fold_left_first_with_iter.html "cpp/algorithm/ranges/fold left first with iter")(C++23) |  left-folds a range of elements using the first element as an initial value, and returns a [pair](../algorithm/ranges/return_types/in_value_result.html "cpp/algorithm/ranges/return types/in value result") (iterator, [optional](../utility/optional.html "cpp/utility/optional"))  
(algorithm function object)  
  
#####  Modifying sequence operations   
  
[ ranges::copyranges::copy_if](../algorithm/ranges/copy.html "cpp/algorithm/ranges/copy")(C++20)(C++20) |  copies a range of elements to a new location  
(algorithm function object)  
[ ranges::copy_n](../algorithm/ranges/copy_n.html "cpp/algorithm/ranges/copy n")(C++20) |  copies a number of elements to a new location  
(algorithm function object)  
[ ranges::copy_backward](../algorithm/ranges/copy_backward.html "cpp/algorithm/ranges/copy backward")(C++20) |  copies a range of elements in backwards order  
(algorithm function object)  
[ ranges::move](../algorithm/ranges/move.html "cpp/algorithm/ranges/move")(C++20) |  moves a range of elements to a new location  
(algorithm function object)  
[ ranges::move_backward](../algorithm/ranges/move_backward.html "cpp/algorithm/ranges/move backward")(C++20) |  moves a range of elements to a new location in backwards order  
(algorithm function object)  
[ ranges::fill](../algorithm/ranges/fill.html "cpp/algorithm/ranges/fill")(C++20) |  assigns a range of elements a certain value  
(algorithm function object)  
[ ranges::fill_n](../algorithm/ranges/fill_n.html "cpp/algorithm/ranges/fill n")(C++20) |  assigns a value to a number of elements  
(algorithm function object)  
[ ranges::transform](../algorithm/ranges/transform.html "cpp/algorithm/ranges/transform")(C++20) |  applies a function to a range of elements  
(algorithm function object)  
[ ranges::generate](../algorithm/ranges/generate.html "cpp/algorithm/ranges/generate")(C++20) |  saves the result of a function in a range  
(algorithm function object)  
[ ranges::generate_n](../algorithm/ranges/generate_n.html "cpp/algorithm/ranges/generate n")(C++20) |  saves the result of N applications of a function  
(algorithm function object)  
[ ranges::removeranges::remove_if](../algorithm/ranges/remove.html "cpp/algorithm/ranges/remove")(C++20)(C++20) |  removes elements satisfying specific criteria  
(algorithm function object)  
[ ranges::remove_copyranges::remove_copy_if](../algorithm/ranges/remove_copy.html "cpp/algorithm/ranges/remove copy")(C++20)(C++20) |  copies a range of elements omitting those that satisfy specific criteria  
(algorithm function object)  
[ ranges::replaceranges::replace_if](../algorithm/ranges/replace.html "cpp/algorithm/ranges/replace")(C++20)(C++20) |  replaces all values satisfying specific criteria with another value  
(algorithm function object)  
[ ranges::replace_copyranges::replace_copy_if](../algorithm/ranges/replace_copy.html "cpp/algorithm/ranges/replace copy")(C++20)(C++20) |  copies a range, replacing elements satisfying specific criteria with another value  
(algorithm function object)  
[ ranges::swap_ranges](../algorithm/ranges/swap_ranges.html "cpp/algorithm/ranges/swap ranges")(C++20) |  swaps two ranges of elements  
(algorithm function object)  
[ ranges::reverse](../algorithm/ranges/reverse.html "cpp/algorithm/ranges/reverse")(C++20) |  reverses the order of elements in a range  
(algorithm function object)  
[ ranges::reverse_copy](../algorithm/ranges/reverse_copy.html "cpp/algorithm/ranges/reverse copy")(C++20) |  creates a copy of a range that is reversed  
(algorithm function object)  
[ ranges::rotate](../algorithm/ranges/rotate.html "cpp/algorithm/ranges/rotate")(C++20) |  rotates the order of elements in a range  
(algorithm function object)  
[ ranges::rotate_copy](../algorithm/ranges/rotate_copy.html "cpp/algorithm/ranges/rotate copy")(C++20) |  copies and rotate a range of elements  
(algorithm function object)  
[ ranges::shift_leftranges::shift_right](../algorithm/ranges/shift.html "cpp/algorithm/ranges/shift")(C++23) |  shifts elements in a range  
(algorithm function object)  
[ ranges::sample](../algorithm/ranges/sample.html "cpp/algorithm/ranges/sample")(C++20) |  selects N random elements from a sequence  
(algorithm function object)  
[ ranges::shuffle](../algorithm/ranges/shuffle.html "cpp/algorithm/ranges/shuffle")(C++20) |  randomly re-orders elements in a range  
(algorithm function object)  
[ ranges::unique](../algorithm/ranges/unique.html "cpp/algorithm/ranges/unique")(C++20) |  removes consecutive duplicate elements in a range  
(algorithm function object)  
[ ranges::unique_copy](../algorithm/ranges/unique_copy.html "cpp/algorithm/ranges/unique copy")(C++20) |  creates a copy of some range of elements that contains no consecutive duplicates  
(algorithm function object)  
  
#####  Partitioning operations   
  
[ ranges::is_partitioned](../algorithm/ranges/is_partitioned.html "cpp/algorithm/ranges/is partitioned")(C++20) |  determines if the range is partitioned by the given predicate  
(algorithm function object)  
[ ranges::partition](../algorithm/ranges/partition.html "cpp/algorithm/ranges/partition")(C++20) |  divides a range of elements into two groups  
(algorithm function object)  
[ ranges::partition_copy](../algorithm/ranges/partition_copy.html "cpp/algorithm/ranges/partition copy")(C++20) |  copies a range dividing the elements into two groups  
(algorithm function object)  
[ ranges::stable_partition](../algorithm/ranges/stable_partition.html "cpp/algorithm/ranges/stable partition")(C++20) |  divides elements into two groups while preserving their relative order  
(algorithm function object)  
[ ranges::partition_point](../algorithm/ranges/partition_point.html "cpp/algorithm/ranges/partition point")(C++20) |  locates the partition point of a partitioned range  
(algorithm function object)  
  
#####  Sorting operations   
  
[ ranges::is_sorted](../algorithm/ranges/is_sorted.html "cpp/algorithm/ranges/is sorted")(C++20) |  checks whether a range is sorted into ascending order  
(algorithm function object)  
[ ranges::is_sorted_until](../algorithm/ranges/is_sorted_until.html "cpp/algorithm/ranges/is sorted until")(C++20) |  finds the largest sorted subrange  
(algorithm function object)  
[ ranges::sort](../algorithm/ranges/sort.html "cpp/algorithm/ranges/sort")(C++20) |  sorts a range into ascending order  
(algorithm function object)  
[ ranges::partial_sort](../algorithm/ranges/partial_sort.html "cpp/algorithm/ranges/partial sort")(C++20) |  sorts the first N elements of a range  
(algorithm function object)  
[ ranges::partial_sort_copy](../algorithm/ranges/partial_sort_copy.html "cpp/algorithm/ranges/partial sort copy")(C++20) |  copies and partially sorts a range of elements  
(algorithm function object)  
[ ranges::stable_sort](../algorithm/ranges/stable_sort.html "cpp/algorithm/ranges/stable sort")(C++20) |  sorts a range of elements while preserving order between equal elements  
(algorithm function object)  
[ ranges::nth_element](../algorithm/ranges/nth_element.html "cpp/algorithm/ranges/nth element")(C++20) |  partially sorts the given range making sure that it is partitioned by the given element  
(algorithm function object)  
  
#####  Binary search operations (on sorted ranges)   
  
[ ranges::lower_bound](../algorithm/ranges/lower_bound.html "cpp/algorithm/ranges/lower bound")(C++20) |  returns an iterator to the first element _not less_ than the given value  
(algorithm function object)  
[ ranges::upper_bound](../algorithm/ranges/upper_bound.html "cpp/algorithm/ranges/upper bound")(C++20) |  returns an iterator to the first element _greater_ than a certain value  
(algorithm function object)  
[ ranges::binary_search](../algorithm/ranges/binary_search.html "cpp/algorithm/ranges/binary search")(C++20) |  determines if an element exists in a partially-ordered range  
(algorithm function object)  
[ ranges::equal_range](../algorithm/ranges/equal_range.html "cpp/algorithm/ranges/equal range")(C++20) |  returns range of elements matching a specific key  
(algorithm function object)  
  
#####  Other operations on sorted ranges   
  
[ ranges::merge](../algorithm/ranges/merge.html "cpp/algorithm/ranges/merge")(C++20) |  merges two sorted ranges  
(algorithm function object)  
[ ranges::inplace_merge](../algorithm/ranges/inplace_merge.html "cpp/algorithm/ranges/inplace merge")(C++20) |  merges two ordered ranges in-place  
(algorithm function object)  
  
#####  Set operations (on sorted ranges)   
  
[ ranges::includes](../algorithm/ranges/includes.html "cpp/algorithm/ranges/includes")(C++20) |  returns true if one sequence is a subsequence of another  
(algorithm function object)  
[ ranges::set_difference](../algorithm/ranges/set_difference.html "cpp/algorithm/ranges/set difference")(C++20) |  computes the difference between two sets  
(algorithm function object)  
[ ranges::set_intersection](../algorithm/ranges/set_intersection.html "cpp/algorithm/ranges/set intersection")(C++20) |  computes the intersection of two sets  
(algorithm function object)  
[ ranges::set_symmetric_difference](../algorithm/ranges/set_symmetric_difference.html "cpp/algorithm/ranges/set symmetric difference")(C++20) |  computes the symmetric difference between two sets  
(algorithm function object)  
[ ranges::set_union](../algorithm/ranges/set_union.html "cpp/algorithm/ranges/set union")(C++20) |  computes the union of two sets  
(algorithm function object)  
  
#####  Heap operations   
  
[ ranges::is_heap](../algorithm/ranges/is_heap.html "cpp/algorithm/ranges/is heap")(C++20) |  checks if the given range is a max heap  
(algorithm function object)  
[ ranges::is_heap_until](../algorithm/ranges/is_heap_until.html "cpp/algorithm/ranges/is heap until")(C++20) |  finds the largest subrange that is a max heap  
(algorithm function object)  
[ ranges::make_heap](../algorithm/ranges/make_heap.html "cpp/algorithm/ranges/make heap")(C++20) |  creates a max heap out of a range of elements  
(algorithm function object)  
[ ranges::push_heap](../algorithm/ranges/push_heap.html "cpp/algorithm/ranges/push heap")(C++20) |  adds an element to a max heap  
(algorithm function object)  
[ ranges::pop_heap](../algorithm/ranges/pop_heap.html "cpp/algorithm/ranges/pop heap")(C++20) |  removes the largest element from a max heap  
(algorithm function object)  
[ ranges::sort_heap](../algorithm/ranges/sort_heap.html "cpp/algorithm/ranges/sort heap")(C++20) |  turns a max heap into a range of elements sorted in ascending order  
(algorithm function object)  
  
#####  Minimum/maximum operations   
  
[ ranges::max](../algorithm/ranges/max.html "cpp/algorithm/ranges/max")(C++20) |  returns the greater of the given values  
(algorithm function object)  
[ ranges::max_element](../algorithm/ranges/max_element.html "cpp/algorithm/ranges/max element")(C++20) |  returns the largest element in a range  
(algorithm function object)  
[ ranges::min](../algorithm/ranges/min.html "cpp/algorithm/ranges/min")(C++20) |  returns the smaller of the given values  
(algorithm function object)  
[ ranges::min_element](../algorithm/ranges/min_element.html "cpp/algorithm/ranges/min element")(C++20) |  returns the smallest element in a range  
(algorithm function object)  
[ ranges::minmax](../algorithm/ranges/minmax.html "cpp/algorithm/ranges/minmax")(C++20) |  returns the smaller and larger of two elements  
(algorithm function object)  
[ ranges::minmax_element](../algorithm/ranges/minmax_element.html "cpp/algorithm/ranges/minmax element")(C++20) |  returns the smallest and the largest elements in a range  
(algorithm function object)  
[ ranges::clamp](../algorithm/ranges/clamp.html "cpp/algorithm/ranges/clamp")(C++20) |  clamps a value between a pair of boundary values  
(algorithm function object)  
  
#####  Comparison operations   
  
[ ranges::equal](../algorithm/ranges/equal.html "cpp/algorithm/ranges/equal")(C++20) |  determines if two sets of elements are the same  
(algorithm function object)  
[ ranges::lexicographical_compare](../algorithm/ranges/lexicographical_compare.html "cpp/algorithm/ranges/lexicographical compare")(C++20) |  returns true if one range is lexicographically less than another  
(algorithm function object)  
  
#####  Permutation operations   
  
[ ranges::is_permutation](../algorithm/ranges/is_permutation.html "cpp/algorithm/ranges/is permutation")(C++20) |  determines if a sequence is a permutation of another sequence  
(algorithm function object)  
[ ranges::next_permutation](../algorithm/ranges/next_permutation.html "cpp/algorithm/ranges/next permutation")(C++20) |  generates the next greater lexicographic permutation of a range of elements  
(algorithm function object)  
[ ranges::prev_permutation](../algorithm/ranges/prev_permutation.html "cpp/algorithm/ranges/prev permutation")(C++20) |  generates the next smaller lexicographic permutation of a range of elements  
(algorithm function object)  
  
### Synopsis
    
    
    // mostly freestanding
    #include <initializer_list>
     
    namespace std {
      namespace ranges {
        // algorithm result types
        template<class I, class F>
          struct in_fun_result;
     
        template<class I1, class I2>
          struct in_in_result;
     
        template<class I, class O>
          struct in_out_result;
     
        template<class I1, class I2, class O>
          struct in_in_out_result;
     
        template<class I, class O1, class O2>
          struct in_out_out_result;
     
        template<class T>
          struct min_max_result;
     
        template<class I>
          struct in_found_result;
     
        template<class I, class T>
          struct in_value_result;
     
        template<class O, class T>
          struct out_value_result;
      }
     
      // non-modifying sequence operations
      // all of
      template<class InputIter, class Pred>
        constexpr bool all_of(InputIter first, InputIter last, Pred pred);
      template<class ExecutionPolicy, class ForwardIter, class Pred>
        bool all_of(ExecutionPolicy&& exec, // freestanding-deleted
                    ForwardIter first, ForwardIter last, Pred pred);
     
      namespace ranges {
        template<input_iterator I, sentinel_for<I> S, class Proj = identity,
                 indirect_unary_predicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Pred>
          constexpr bool all_of(I first, S last, Pred pred, Proj proj = {});
        template<input_range R, class Proj = identity,
                 indirect_unary_predicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R>, Proj>> Pred>
          constexpr bool all_of(R&& r, Pred pred, Proj proj = {});
      }
     
      // any of
      template<class InputIter, class Pred>
        constexpr bool any_of(InputIter first, InputIter last, Pred pred);
      template<class ExecutionPolicy, class ForwardIter, class Pred>
        bool any_of(ExecutionPolicy&& exec, // freestanding-deleted
                    ForwardIter first, ForwardIter last, Pred pred);
     
      namespace ranges {
        template<input_iterator I, sentinel_for<I> S, class Proj = identity,
                 indirect_unary_predicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Pred>
          constexpr bool any_of(I first, S last, Pred pred, Proj proj = {});
        template<input_range R, class Proj = identity,
                 indirect_unary_predicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R>, Proj>> Pred>
          constexpr bool any_of(R&& r, Pred pred, Proj proj = {});
      }
     
      // none of
      template<class InputIter, class Pred>
        constexpr bool none_of(InputIter first, InputIter last, Pred pred);
      template<class ExecutionPolicy, class ForwardIter, class Pred>
        bool none_of(ExecutionPolicy&& exec, // freestanding-deleted
                     ForwardIter first, ForwardIter last, Pred pred);
     
      namespace ranges {
        template<input_iterator I, sentinel_for<I> S, class Proj = identity,
                 indirect_unary_predicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Pred>
          constexpr bool none_of(I first, S last, Pred pred, Proj proj = {});
        template<input_range R, class Proj = identity,
                 indirect_unary_predicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R>, Proj>> Pred>
          constexpr bool none_of(R&& r, Pred pred, Proj proj = {});
      }
     
      // contains
      namespace ranges {
        template<input_iterator I, sentinel_for<I> S, class Proj = identity,
                 class T = projected_value_t<I, Proj>>
          requires indirect_binary_predicate<[ranges::equal_to](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/equal_to), [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>, const T*>
          constexpr bool contains(I first, S last, const T& value, Proj proj = {});
        template<input_range R, class Proj = identity,
                 class T = projected_value_t<iterator_t<R>, Proj>>
          requires indirect_binary_predicate<[ranges::equal_to](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/equal_to),
                                             [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R>, Proj>, const T*>
          constexpr bool contains(R&& r, const T& value, Proj proj = {});
     
        template<forward_iterator I1, sentinel_for<I1> S1,
                 forward_iterator I2, sentinel_for<I2> S2,
                 class Pred = [ranges::equal_to](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/equal_to), class Proj1 = identity,
                 class Proj2 = identity>
          requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
          constexpr bool contains_subrange(I1 first1, S1 last1, I2 first2, S2 last2,
                                           Pred pred = {}, Proj1 proj1 = {},
                                           Proj2 proj2 = {});
        template<forward_range R1, forward_range R2,
                 class Pred = [ranges::equal_to](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/equal_to), class Proj1 = identity,
                 class Proj2 = identity>
          requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
          constexpr bool contains_subrange(R1&& r1, R2&& r2,
                                           Pred pred = {}, Proj1 proj1 = {},
                                           Proj2 proj2 = {});
      }
     
      // for each
      template<class InputIter, class Function>
        constexpr Function for_each(InputIter first, InputIter last, Function f);
      template<class ExecutionPolicy, class ForwardIter, class Function>
        void for_each(ExecutionPolicy&& exec, // freestanding-deleted
                      ForwardIter first, ForwardIter last, Function f);
     
      namespace ranges {
        template<class I, class F>
          using for_each_result = in_fun_result<I, F>;
     
        template<input_iterator I, sentinel_for<I> S, class Proj = identity,
                 indirectly_unary_invocable<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Fun>
          constexpr for_each_result<I, Fun>
            for_each(I first, S last, Fun f, Proj proj = {});
        template<input_range R, class Proj = identity,
                 indirectly_unary_invocable<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R>, Proj>> Fun>
          constexpr for_each_result<borrowed_iterator_t<R>, Fun>
            for_each(R&& r, Fun f, Proj proj = {});
      }
     
      template<class InputIter, class Size, class Function>
        constexpr InputIter for_each_n(InputIter first, Size n, Function f);
      template<class ExecutionPolicy, class ForwardIter, class Size, class Function>
        ForwardIter for_each_n(ExecutionPolicy&& exec, // freestanding-deleted
                               ForwardIter first, Size n, Function f);
     
      namespace ranges {
        template<class I, class F>
          using for_each_n_result = in_fun_result<I, F>;
     
        template<input_iterator I, class Proj = identity,
                 indirectly_unary_invocable<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Fun>
          constexpr for_each_n_result<I, Fun>
            for_each_n(I first, iter_difference_t<I> n, Fun f, Proj proj = {});
      }
     
      // find
      template<class InputIter, class T = typename iterator_traits<InputIter>::value_type>
        constexpr InputIter find(InputIter first, InputIter last, const T& value);
      template<class ExecutionPolicy, class ForwardIter,
               class T = typename iterator_traits<InputIter>::value_type>
        ForwardIter find(ExecutionPolicy&& exec, // freestanding-deleted
                         ForwardIter first, ForwardIter last, const T& value);
      template<class InputIter, class Pred>
        constexpr InputIter find_if(InputIter first, InputIter last, Pred pred);
      template<class ExecutionPolicy, class ForwardIter, class Pred>
        ForwardIter find_if(ExecutionPolicy&& exec, // freestanding-deleted
                            ForwardIter first, ForwardIter last, Pred pred);
      template<class InputIter, class Pred>
        constexpr InputIter find_if_not(InputIter first, InputIter last, Pred pred);
      template<class ExecutionPolicy, class ForwardIter, class Pred>
        ForwardIter find_if_not(ExecutionPolicy&& exec, // freestanding-deleted
                                ForwardIter first, ForwardIter last, Pred pred);
     
      namespace ranges {
        template<input_iterator I, sentinel_for<I> S, class Proj = identity
                 class T = projected_value_t<I, Proj>>
          requires indirect_binary_predicate<[ranges::equal_to](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/equal_to), [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>, const T*>
          constexpr I find(I first, S last, const T& value, Proj proj = {});
        template<input_range R, class Proj = identity,
                 class T = projected_value_t<iterator_t<R>, Proj>>
          requires indirect_binary_predicate<[ranges::equal_to](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/equal_to),
                                             [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R>, Proj>, const T*>
          constexpr borrowed_iterator_t<R>
            find(R&& r, const T& value, Proj proj = {});
        template<input_iterator I, sentinel_for<I> S, class Proj = identity,
                 indirect_unary_predicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Pred>
          constexpr I find_if(I first, S last, Pred pred, Proj proj = {});
        template<input_range R, class Proj = identity,
                 indirect_unary_predicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R>, Proj>> Pred>
          constexpr borrowed_iterator_t<R>
            find_if(R&& r, Pred pred, Proj proj = {});
        template<input_iterator I, sentinel_for<I> S, class Proj = identity,
                 indirect_unary_predicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Pred>
          constexpr I find_if_not(I first, S last, Pred pred, Proj proj = {});
        template<input_range R, class Proj = identity,
                 indirect_unary_predicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R>, Proj>> Pred>
          constexpr borrowed_iterator_t<R>
            find_if_not(R&& r, Pred pred, Proj proj = {});
      }
     
      // find last
      namespace ranges {
        template<forward_iterator I, sentinel_for<I> S, class T, class Proj = identity>
          requires indirect_binary_predicate<[ranges::equal_to](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/equal_to), [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>, const T*>
          constexpr subrange<I> find_last(I first, S last, const T& value, Proj proj = {});
        template<forward_range R, class T, class Proj = identity>
          requires
            indirect_binary_predicate<[ranges::equal_to](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/equal_to),
                [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R>, Proj>, const T*>
          constexpr borrowed_subrange_t<R> find_last(R&& r, const T& value, Proj proj = {});
        template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
                 indirect_unary_predicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Pred>
          constexpr subrange<I> find_last_if(I first, S last, Pred pred, Proj proj = {});
        template<forward_range R, class Proj = identity,
                 indirect_unary_predicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R>, Proj>> Pred>
          constexpr borrowed_subrange_t<R> find_last_if(R&& r, Pred pred, Proj proj = {});
        template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
                 indirect_unary_predicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Pred>
          constexpr subrange<I> find_last_if_not(I first, S last, Pred pred, Proj proj = {});
        template<forward_range R, class Proj = identity,
                 indirect_unary_predicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R>, Proj>> Pred>
          constexpr borrowed_subrange_t<R> find_last_if_not(R&& r, Pred pred, Proj proj = {});
      }
     
      // find end
      template<class ForwardIter1, class ForwardIter2>
        constexpr ForwardIter1
          find_end(ForwardIter1 first1, ForwardIter1 last1,
                   ForwardIter2 first2, ForwardIter2 last2);
      template<class ForwardIter1, class ForwardIter2, class BinaryPred>
        constexpr ForwardIter1
          find_end(ForwardIter1 first1, ForwardIter1 last1,
                   ForwardIter2 first2, ForwardIter2 last2,
                   BinaryPred pred);
      template<class ExecutionPolicy, class ForwardIter1, class ForwardIter2>
        ForwardIter1
          find_end(ExecutionPolicy&& exec, // freestanding-deleted
                   ForwardIter1 first1, ForwardIter1 last1,
                   ForwardIter2 first2, ForwardIter2 last2);
      template<class ExecutionPolicy, class ForwardIter1,
               class ForwardIter2, class BinaryPred>
        ForwardIter1
          find_end(ExecutionPolicy&& exec, // freestanding-deleted
                   ForwardIter1 first1, ForwardIter1 last1,
                   ForwardIter2 first2, ForwardIter2 last2,
                   BinaryPred pred);
     
      namespace ranges {
        template<forward_iterator I1, sentinel_for<I1> S1, forward_iterator I2,
                 sentinel_for<I2> S2, class Pred = [ranges::equal_to](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/equal_to),
                 class Proj1 = identity, class Proj2 = identity>
          requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
          constexpr subrange<I1>
            find_end(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                     Proj1 proj1 = {}, Proj2 proj2 = {});
        template<forward_range R1, forward_range R2, class Pred = [ranges::equal_to](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/equal_to),
                 class Proj1 = identity, class Proj2 = identity>
          requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
          constexpr borrowed_subrange_t<R1>
            find_end(R1&& r1, R2&& r2, Pred pred = {},
                     Proj1 proj1 = {}, Proj2 proj2 = {});
      }
     
      // find first
      template<class InputIter, class ForwardIter>
        constexpr InputIter
          find_first_of(InputIter first1, InputIter last1,
                        ForwardIter first2, ForwardIter last2);
      template<class InputIter, class ForwardIter, class BinaryPred>
        constexpr InputIter
          find_first_of(InputIter first1, InputIter last1,
                        ForwardIter first2, ForwardIter last2,
                        BinaryPred pred);
      template<class ExecutionPolicy, class ForwardIter1, class ForwardIter2>
        ForwardIter1
          find_first_of(ExecutionPolicy&& exec, // freestanding-deleted
                        ForwardIter1 first1, ForwardIter1 last1,
                        ForwardIter2 first2, ForwardIter2 last2);
      template<class ExecutionPolicy, class ForwardIter1,
               class ForwardIter2, class BinaryPred>
        ForwardIter1
          find_first_of(ExecutionPolicy&& exec, // freestanding-deleted
                        ForwardIter1 first1, ForwardIter1 last1,
                        ForwardIter2 first2, ForwardIter2 last2,
                        BinaryPred pred);
     
      namespace ranges {
        template<input_iterator I1, sentinel_for<I1> S1, forward_iterator I2,
                 sentinel_for<I2> S2, class Pred = [ranges::equal_to](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/equal_to),
                 class Proj1 = identity, class Proj2 = identity>
          requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
          constexpr I1 find_first_of(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                                     Proj1 proj1 = {}, Proj2 proj2 = {});
        template<input_range R1, forward_range R2, class Pred = [ranges::equal_to](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/equal_to),
                 class Proj1 = identity, class Proj2 = identity>
          requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
          constexpr borrowed_iterator_t<R1>
            find_first_of(R1&& r1, R2&& r2, Pred pred = {},
                          Proj1 proj1 = {}, Proj2 proj2 = {});
      }
     
      // adjacent find
      template<class ForwardIter>
        constexpr ForwardIter adjacent_find(ForwardIter first, ForwardIter last);
      template<class ForwardIter, class BinaryPred>
        constexpr ForwardIter adjacent_find(ForwardIter first, ForwardIter last,
                                            BinaryPred pred);
      template<class ExecutionPolicy, class ForwardIter>
        ForwardIter adjacent_find(ExecutionPolicy&& exec, // freestanding-deleted
                                  ForwardIter first, ForwardIter last);
      template<class ExecutionPolicy, class ForwardIter, class BinaryPred>
        ForwardIter adjacent_find(ExecutionPolicy&& exec, // freestanding-deleted
                                  ForwardIter first, ForwardIter last, BinaryPred pred);
     
      namespace ranges {
        template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
                 indirect_binary_predicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>,
                                           [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Pred = [ranges::equal_to](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/equal_to)>
          constexpr I adjacent_find(I first, S last, Pred pred = {}, Proj proj = {});
        template<forward_range R, class Proj = identity,
                 indirect_binary_predicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R>, Proj>,
                                           [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R>, Proj>>
                                             Pred = [ranges::equal_to](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/equal_to)>
          constexpr borrowed_iterator_t<R>
            adjacent_find(R&& r, Pred pred = {}, Proj proj = {});
      }
     
      // count
      template<class InputIter, class T = typename iterator_traits<InputIter>::value_type>
        constexpr typename iterator_traits<InputIter>::difference_type
          count(InputIter first, InputIter last, const T& value);
      template<class ExecutionPolicy, class ForwardIter,
               class T = typename iterator_traits<InputIterator>::value_type>
        typename iterator_traits<ForwardIter>::difference_type
          count(ExecutionPolicy&& exec, // freestanding-deleted
                ForwardIter first, ForwardIter last, const T& value);
      template<class InputIter, class Pred>
        constexpr typename iterator_traits<InputIter>::difference_type
          count_if(InputIter first, InputIter last, Pred pred);
      template<class ExecutionPolicy, class ForwardIter, class Pred>
        typename iterator_traits<ForwardIter>::difference_type
          count_if(ExecutionPolicy&& exec, // freestanding-deleted
                   ForwardIter first, ForwardIter last, Pred pred);
     
      namespace ranges {
        template<input_iterator I, sentinel_for<I> S, class Proj = identity,
                 class T = projected_value_t<I, Proj>>
          requires indirect_binary_predicate<[ranges::equal_to](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/equal_to), [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>, const T*>
          constexpr iter_difference_t<I>
            count(I first, S last, const T& value, Proj proj = {});
        template<input_range R, class Proj = identity,
                 class T = projected_value_t<iterator_t<R>, Proj>>
          requires indirect_binary_predicate<[ranges::equal_to](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/equal_to),
                                             [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R>, Proj>, const T*>
          constexpr range_difference_t<R>
            count(R&& r, const T& value, Proj proj = {});
        template<input_iterator I, sentinel_for<I> S, class Proj = identity,
                 indirect_unary_predicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Pred>
          constexpr iter_difference_t<I>
            count_if(I first, S last, Pred pred, Proj proj = {});
        template<input_range R, class Proj = identity,
                 indirect_unary_predicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R>, Proj>> Pred>
          constexpr range_difference_t<R>
            count_if(R&& r, Pred pred, Proj proj = {});
      }
     
      // mismatch
      template<class InputIter1, class InputIter2>
        constexpr pair<InputIter1, InputIter2>
          mismatch(InputIter1 first1, InputIter1 last1,
                   InputIter2 first2);
      template<class InputIter1, class InputIter2, class BinaryPred>
        constexpr pair<InputIter1, InputIter2>
          mismatch(InputIter1 first1, InputIter1 last1,
                   InputIter2 first2, BinaryPred pred);
      template<class InputIter1, class InputIter2>
        constexpr pair<InputIter1, InputIter2>
          mismatch(InputIter1 first1, InputIter1 last1,
                   InputIter2 first2, InputIter2 last2);
      template<class InputIter1, class InputIter2, class BinaryPred>
        constexpr pair<InputIter1, InputIter2>
          mismatch(InputIter1 first1, InputIter1 last1,
                   InputIter2 first2, InputIter2 last2,
                   BinaryPred pred);
      template<class ExecutionPolicy, class ForwardIter1, class ForwardIter2>
        pair<ForwardIter1, ForwardIter2>
          mismatch(ExecutionPolicy&& exec, // freestanding-deleted
                   ForwardIter1 first1, ForwardIter1 last1,
                   ForwardIter2 first2);
      template<class ExecutionPolicy, class ForwardIter1, class ForwardIter2,
               class BinaryPred>
        pair<ForwardIter1, ForwardIter2>
          mismatch(ExecutionPolicy&& exec, // freestanding-deleted
                   ForwardIter1 first1, ForwardIter1 last1,
                   ForwardIter2 first2, BinaryPred pred);
      template<class ExecutionPolicy, class ForwardIter1, class ForwardIter2>
        pair<ForwardIter1, ForwardIter2>
          mismatch(ExecutionPolicy&& exec, // freestanding-deleted
                   ForwardIter1 first1, ForwardIter1 last1,
                   ForwardIter2 first2, ForwardIter2 last2);
      template<class ExecutionPolicy, class ForwardIter1, class ForwardIter2,
               class BinaryPred>
        pair<ForwardIter1, ForwardIter2>
          mismatch(ExecutionPolicy&& exec, // freestanding-deleted
                   ForwardIter1 first1, ForwardIter1 last1,
                   ForwardIter2 first2, ForwardIter2 last2,
                   BinaryPred pred);
     
      namespace ranges {
        template<class I1, class I2>
          using mismatch_result = in_in_result<I1, I2>;
     
        template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2,
                 sentinel_for<I2> S2, class Pred = [ranges::equal_to](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/equal_to), class Proj1 = identity,
                 class Proj2 = identity>
          requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
          constexpr mismatch_result<I1, I2>
            mismatch(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                     Proj1 proj1 = {}, Proj2 proj2 = {});
        template<input_range R1, input_range R2,
                 class Pred = [ranges::equal_to](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/equal_to), class Proj1 = identity,
                 class Proj2 = identity>
          requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
          constexpr mismatch_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>>
            mismatch(R1&& r1, R2&& r2, Pred pred = {},
                     Proj1 proj1 = {}, Proj2 proj2 = {});
      }
     
      // equal
      template<class InputIter1, class InputIter2>
        constexpr bool equal(InputIter1 first1, InputIter1 last1,
                             InputIter2 first2);
      template<class InputIter1, class InputIter2, class BinaryPred>
        constexpr bool equal(InputIter1 first1, InputIter1 last1,
                             InputIter2 first2, BinaryPred pred);
      template<class InputIter1, class InputIter2>
        constexpr bool equal(InputIter1 first1, InputIter1 last1,
                             InputIter2 first2, InputIter2 last2);
      template<class InputIter1, class InputIter2, class BinaryPred>
        constexpr bool equal(InputIter1 first1, InputIter1 last1,
                             InputIter2 first2, InputIter2 last2,
                             BinaryPred pred);
      template<class ExecutionPolicy, class ForwardIter1, class ForwardIter2>
        bool equal(ExecutionPolicy&& exec, // freestanding-deleted
                   ForwardIter1 first1, ForwardIter1 last1,
                   ForwardIter2 first2);
      template<class ExecutionPolicy, class ForwardIter1, class ForwardIter2,
               class BinaryPred>
        bool equal(ExecutionPolicy&& exec, // freestanding-deleted
                   ForwardIter1 first1, ForwardIter1 last1,
                   ForwardIter2 first2, BinaryPred pred);
      template<class ExecutionPolicy, class ForwardIter1, class ForwardIter2>
        bool equal(ExecutionPolicy&& exec, // freestanding-deleted
                   ForwardIter1 first1, ForwardIter1 last1,
                   ForwardIter2 first2, ForwardIter2 last2);
      template<class ExecutionPolicy, class ForwardIter1, class ForwardIter2,
               class BinaryPred>
        bool equal(ExecutionPolicy&& exec, // freestanding-deleted
                   ForwardIter1 first1, ForwardIter1 last1,
                   ForwardIter2 first2, ForwardIter2 last2,
                   BinaryPred pred);
     
      namespace ranges {
        template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2,
                 sentinel_for<I2> S2, class Pred = [ranges::equal_to](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/equal_to), class Proj1 = identity,
                 class Proj2 = identity>
          requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
          constexpr bool equal(I1 first1, S1 last1, I2 first2, S2 last2,
                               Pred pred = {},
                               Proj1 proj1 = {}, Proj2 proj2 = {});
        template<input_range R1, input_range R2, class Pred = [ranges::equal_to](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/equal_to),
                 class Proj1 = identity, class Proj2 = identity>
          requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
          constexpr bool equal(R1&& r1, R2&& r2, Pred pred = {},
                               Proj1 proj1 = {}, Proj2 proj2 = {});
      }
     
      // is permutation
      template<class ForwardIter1, class ForwardIter2>
        constexpr bool is_permutation(ForwardIter1 first1, ForwardIter1 last1,
                                      ForwardIter2 first2);
      template<class ForwardIter1, class ForwardIter2, class BinaryPred>
        constexpr bool is_permutation(ForwardIter1 first1, ForwardIter1 last1,
                                      ForwardIter2 first2, BinaryPred pred);
      template<class ForwardIter1, class ForwardIter2>
        constexpr bool is_permutation(ForwardIter1 first1, ForwardIter1 last1,
                                      ForwardIter2 first2, ForwardIter2 last2);
      template<class ForwardIter1, class ForwardIter2, class BinaryPred>
        constexpr bool is_permutation(ForwardIter1 first1, ForwardIter1 last1,
                                      ForwardIter2 first2, ForwardIter2 last2,
                                      BinaryPred pred);
     
      namespace ranges {
        template<forward_iterator I1, sentinel_for<I1> S1, forward_iterator I2,
                 sentinel_for<I2> S2, class Proj1 = identity, class Proj2 = identity,
                 indirect_equivalence_relation<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I1, Proj1>,
                                               [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I2, Proj2>> Pred = [ranges::equal_to](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/equal_to)>
          constexpr bool is_permutation(I1 first1, S1 last1, I2 first2, S2 last2,
                                        Pred pred = {},
                                        Proj1 proj1 = {}, Proj2 proj2 = {});
        template<forward_range R1, forward_range R2,
                 class Proj1 = identity, class Proj2 = identity,
                 indirect_equivalence_relation<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R1>, Proj1>,
                                               [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R2>, Proj2>>
                                               Pred = [ranges::equal_to](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/equal_to)>
          constexpr bool is_permutation(R1&& r1, R2&& r2, Pred pred = {},
                                        Proj1 proj1 = {}, Proj2 proj2 = {});
      }
     
      // search
      template<class ForwardIter1, class ForwardIter2>
        constexpr ForwardIter1
          search(ForwardIter1 first1, ForwardIter1 last1,
                 ForwardIter2 first2, ForwardIter2 last2);
      template<class ForwardIter1, class ForwardIter2, class BinaryPred>
        constexpr ForwardIter1
          search(ForwardIter1 first1, ForwardIter1 last1,
                 ForwardIter2 first2, ForwardIter2 last2, BinaryPred pred);
      template<class ExecutionPolicy, class ForwardIter1, class ForwardIter2>
        ForwardIter1
          search(ExecutionPolicy&& exec, // freestanding-deleted
                 ForwardIter1 first1, ForwardIter1 last1,
                 ForwardIter2 first2, ForwardIter2 last2);
      template<class ExecutionPolicy, class ForwardIter1, class ForwardIter2,
               class BinaryPred>
        ForwardIter1
          search(ExecutionPolicy&& exec, // freestanding-deleted
                 ForwardIter1 first1, ForwardIter1 last1,
                 ForwardIter2 first2, ForwardIter2 last2, BinaryPred pred);
     
      namespace ranges {
        template<forward_iterator I1, sentinel_for<I1> S1, forward_iterator I2,
                 sentinel_for<I2> S2, class Pred = [ranges::equal_to](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/equal_to),
                 class Proj1 = identity, class Proj2 = identity>
          requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
          constexpr subrange<I1>
            search(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                   Proj1 proj1 = {}, Proj2 proj2 = {});
        template<forward_range R1, forward_range R2, class Pred = [ranges::equal_to](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/equal_to),
                 class Proj1 = identity, class Proj2 = identity>
          requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
          constexpr borrowed_subrange_t<R1>
            search(R1&& r1, R2&& r2, Pred pred = {},
                   Proj1 proj1 = {}, Proj2 proj2 = {});
      }
     
      template<class ForwardIter, class Size,
               class T = typename iterator_traits<ForwardIter>::value_type>
        constexpr ForwardIter
          search_n(ForwardIter first, ForwardIter last,
                   Size count, const T& value);
      template<class ForwardIter, class Size,
               class T = typename iterator_traits<ForwardIter>::value_type, class BinaryPred>
        constexpr ForwardIter
          search_n(ForwardIter first, ForwardIter last,
                   Size count, const T& value, BinaryPred pred);
      template<class ExecutionPolicy, class ForwardIter, class Size,
               class T = typename iterator_traits<ForwardIter>::value_type>
        ForwardIter
          search_n(ExecutionPolicy&& exec, // freestanding-deleted
                   ForwardIter first, ForwardIter last,
                   Size count, const T& value);
      template<class ExecutionPolicy, class ForwardIter, class Size,
               class T = typename iterator_traits<ForwardIter>::value_type, class BinaryPred>
        ForwardIter
          search_n(ExecutionPolicy&& exec, // freestanding-deleted
                   ForwardIter first, ForwardIter last,
                   Size count, const T& value, BinaryPred pred);
     
      namespace ranges {
        template<forward_iterator I, sentinel_for<I> S,
                 class Pred = [ranges::equal_to](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/equal_to), class Proj = identity,
                 class T = projected_value_t<I, Proj>>
          requires indirectly_comparable<I, const T*, Pred, Proj>
          constexpr subrange<I>
            search_n(I first, S last, iter_difference_t<I> count,
                     const T& value, Pred pred = {}, Proj proj = {});
        template<forward_range R, class Pred = [ranges::equal_to](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/equal_to), class Proj = identity,
                 projected_value_t<iterator_t<R>, Proj>>
          requires indirectly_comparable<iterator_t<R>, const T*, Pred, Proj>
          constexpr borrowed_subrange_t<R>
            search_n(R&& r, range_difference_t<R> count,
                     const T& value, Pred pred = {}, Proj proj = {});
      }
     
      template<class ForwardIter, class Searcher>
        constexpr ForwardIter
          search(ForwardIter first, ForwardIter last, const Searcher& searcher);
     
      namespace ranges {
        // starts with
        template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2,
                 sentinel_for<I2> S2, class Pred = [ranges::equal_to](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/equal_to),
                 class Proj1 = identity, class Proj2 = identity>
          requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
          constexpr bool starts_with(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                                     Proj1 proj1 = {}, Proj2 proj2 = {});
        template<input_range R1, input_range R2, class Pred = [ranges::equal_to](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/equal_to),
                 class Proj1 = identity, class Proj2 = identity>
          requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
          constexpr bool starts_with(R1&& r1, R2&& r2, Pred pred = {},
                                     Proj1 proj1 = {}, Proj2 proj2 = {});
     
        // ends with
        template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2,
                 sentinel_for<I2> S2, class Pred = [ranges::equal_to](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/equal_to),
                 class Proj1 = identity, class Proj2 = identity>
          requires (forward_iterator<I1> || sized_sentinel_for<S1, I1>) &&
                   (forward_iterator<I2> || sized_sentinel_for<S2, I2>) &&
                   indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
          constexpr bool ends_with(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                                   Proj1 proj1 = {}, Proj2 proj2 = {});
        template<input_range R1, input_range R2, class Pred = [ranges::equal_to](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/equal_to),
                 class Proj1 = identity, class Proj2 = identity>
          requires (forward_range<R1> || sized_range<R1>) &&
                   (forward_range<R2> || sized_range<R2>) &&
                   indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
          constexpr bool ends_with(R1&& r1, R2&& r2, Pred pred = {},
                                   Proj1 proj1 = {}, Proj2 proj2 = {});
     
        // fold
        template<class F>
        class /* flipped */ {   // exposition only
          F f;                  // exposition only
     
        public:
          template<class T, class U> requires invocable<F&, U, T>
          invoke_result_t<F&, U, T> operator()(T&&, U&&);
        };
     
        template<class F, class T, class I, class U>
          concept /* indirectly-binary-left-foldable-impl */ =  // exposition only
            movable<T> && movable<U> &&
            convertible_to<T, U> && invocable<F&, U, iter_reference_t<I>> &&
            assignable_from<U&, invoke_result_t<F&, U, iter_reference_t<I>>>;
     
        template<class F, class T, class I>
          concept /* indirectly-binary-left-foldable */ =       // exposition only
            copy_constructible<F> && indirectly_readable<I> &&
            invocable<F&, T, iter_reference_t<I>> &&
            convertible_to<invoke_result_t<F&, T, iter_reference_t<I>>,
                   decay_t<invoke_result_t<F&, T, iter_reference_t<I>>>> &&
            /* indirectly-binary-left-foldable-impl */
                 <F, T, I, decay_t<invoke_result_t<F&, T, iter_reference_t<I>>>>;
     
        template<class F, class T, class I>
          concept /* indirectly-binary-right-foldable */ =      // exposition only
            /* indirectly-binary-left-foldable */</* flipped */<F>, T, I>;
     
        template<input_iterator I, sentinel_for<I> S, class T = iter_value_t<I>,
                 /* indirectly-binary-left-foldable */<T, I> F>
          constexpr auto fold_left(I first, S last, T init, F f);
     
        template<input_range R, class T = range_value_t<R>,
                 /* indirectly-binary-left-foldable */<T, iterator_t<R>> F>
          constexpr auto fold_left(R&& r, T init, F f);
     
        template<input_iterator I, sentinel_for<I> S,
                 /* indirectly-binary-left-foldable */<iter_value_t<I>, I> F>
          requires constructible_from<iter_value_t<I>, iter_reference_t<I>>
          constexpr auto fold_left_first(I first, S last, F f);
     
        template<input_range R,
                 /* indirectly-binary-left-foldable */<range_value_t<R>, iterator_t<R>> F>
          requires constructible_from<range_value_t<R>, range_reference_t<R>>
          constexpr auto fold_left_first(R&& r, F f);
     
        template<bidirectional_iterator I, sentinel_for<I> S, class T = iter_value_t<I>,
                 /* indirectly-binary-right-foldable */<T, I> F>
          constexpr auto fold_right(I first, S last, T init, F f);
     
        template<bidirectional_range R, class T = range_value_t<R>,
                 /* indirectly-binary-right-foldable */<T, iterator_t<R>> F>
          constexpr auto fold_right(R&& r, T init, F f);
     
        template<bidirectional_iterator I, sentinel_for<I> S,
                 /* indirectly-binary-right-foldable */<iter_value_t<I>, I> F>
          requires constructible_from<iter_value_t<I>, iter_reference_t<I>>
        constexpr auto fold_right_last(I first, S last, F f);
     
        template<bidirectional_range R,
                 /* indirectly-binary-right-foldable */<range_value_t<R>, iterator_t<R>> F>
          requires constructible_from<range_value_t<R>, range_reference_t<R>>
          constexpr auto fold_right_last(R&& r, F f);
     
        template<class I, class T>
          using fold_left_with_iter_result = in_value_result<I, T>;
        template<class I, class T>
          using fold_left_first_with_iter_result = in_value_result<I, T>;
     
        template<input_iterator I, sentinel_for<I> S, class T = iter_value_t<I>,
                 /* indirectly-binary-left-foldable */<T, I> F>
          constexpr /* see description */ fold_left_with_iter(I first, S last, T init, F f);
     
        template<input_range R, class T = range_value_t<R>,
                 /* indirectly-binary-left-foldable */<T, iterator_t<R>> F>
          constexpr /* see description */ fold_left_with_iter(R&& r, T init, F f);
     
        template<input_iterator I, sentinel_for<I> S,
                 /* indirectly-binary-left-foldable */<iter_value_t<I>, I> F>
          requires constructible_from<iter_value_t<I>, iter_reference_t<I>>
          constexpr /* see description */ fold_left_first_with_iter(I first, S last, F f);
     
        template<input_range R,
                 /* indirectly-binary-left-foldable */<range_value_t<R>, iterator_t<R>> F>
          requires constructible_from<range_value_t<R>, range_reference_t<R>>
          constexpr /* see description */ fold_left_first_with_iter(R&& r, F f);
      }
     
      // mutating sequence operations
      // copy
      template<class InputIter, class OutputIter>
        constexpr OutputIter copy(InputIter first, InputIter last,
                                  OutputIter result);
      template<class ExecutionPolicy, class ForwardIter1, class ForwardIter2>
        ForwardIter2 copy(ExecutionPolicy&& exec, // freestanding-deleted
                          ForwardIter1 first, ForwardIter1 last,
                          ForwardIter2 result);
     
      namespace ranges {
        template<class I, class O>
          using copy_result = in_out_result<I, O>;
     
        template<input_iterator I, sentinel_for<I> S, weakly_incrementable O>
          requires indirectly_copyable<I, O>
          constexpr copy_result<I, O> copy(I first, S last, O result);
        template<input_range R, weakly_incrementable O>
          requires indirectly_copyable<iterator_t<R>, O>
          constexpr copy_result<borrowed_iterator_t<R>, O> copy(R&& r, O result);
      }
     
      template<class InputIter, class Size, class OutputIter>
        constexpr OutputIter copy_n(InputIter first, Size n, OutputIter result);
      template<class ExecutionPolicy,
               class ForwardIter1, class Size, class ForwardIter2>
        ForwardIter2 copy_n(ExecutionPolicy&& exec, // freestanding-deleted
                            ForwardIter1 first, Size n, ForwardIter2 result);
     
      namespace ranges {
        template<class I, class O>
          using copy_n_result = in_out_result<I, O>;
     
        template<input_iterator I, weakly_incrementable O>
          requires indirectly_copyable<I, O>
          constexpr copy_n_result<I, O> copy_n(I first, iter_difference_t<I> n, O result);
      }
     
      template<class InputIter, class OutputIter, class Pred>
        constexpr OutputIter copy_if(InputIter first, InputIter last,
                                     OutputIter result, Pred pred);
      template<class ExecutionPolicy,
               class ForwardIter1, class ForwardIter2, class Pred>
        ForwardIter2 copy_if(ExecutionPolicy&& exec, // freestanding-deleted
                             ForwardIter1 first, ForwardIter1 last,
                             ForwardIter2 result, Pred pred);
     
      namespace ranges {
        template<class I, class O>
          using copy_if_result = in_out_result<I, O>;
     
        template<input_iterator I, sentinel_for<I> S, weakly_incrementable O,
                 class Proj = identity, indirect_unary_predicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Pred>
          requires indirectly_copyable<I, O>
          constexpr copy_if_result<I, O>
            copy_if(I first, S last, O result, Pred pred, Proj proj = {});
        template<input_range R, weakly_incrementable O, class Proj = identity,
                 indirect_unary_predicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R>, Proj>> Pred>
          requires indirectly_copyable<iterator_t<R>, O>
          constexpr copy_if_result<borrowed_iterator_t<R>, O>
            copy_if(R&& r, O result, Pred pred, Proj proj = {});
      }
     
      template<class BidirectionalIter1, class BidirectionalIter2>
        constexpr BidirectionalIter2
          copy_backward(BidirectionalIter1 first, BidirectionalIter1 last,
                        BidirectionalIter2 result);
     
      namespace ranges {
        template<class I1, class I2>
          using copy_backward_result = in_out_result<I1, I2>;
     
        template<bidirectional_iterator I1, sentinel_for<I1> S1, bidirectional_iterator I2>
          requires indirectly_copyable<I1, I2>
          constexpr copy_backward_result<I1, I2>
            copy_backward(I1 first, S1 last, I2 result);
        template<bidirectional_range R, bidirectional_iterator I>
          requires indirectly_copyable<iterator_t<R>, I>
          constexpr copy_backward_result<borrowed_iterator_t<R>, I>
            copy_backward(R&& r, I result);
      }
     
      // move
      template<class InputIter, class OutputIter>
        constexpr OutputIter move(InputIter first, InputIter last, OutputIter result);
      template<class ExecutionPolicy, class ForwardIter1,
               class ForwardIter2>
        ForwardIter2 move(ExecutionPolicy&& exec, // freestanding-deleted
                          ForwardIter1 first, ForwardIter1 last, ForwardIter2 result);
     
      namespace ranges {
        template<class I, class O>
          using move_result = in_out_result<I, O>;
     
        template<input_iterator I, sentinel_for<I> S, weakly_incrementable O>
          requires indirectly_movable<I, O>
          constexpr move_result<I, O> move(I first, S last, O result);
        template<input_range R, weakly_incrementable O>
          requires indirectly_movable<iterator_t<R>, O>
          constexpr move_result<borrowed_iterator_t<R>, O> move(R&& r, O result);
      }
     
      template<class BidirectionalIter1, class BidirectionalIter2>
        constexpr BidirectionalIter2
          move_backward(BidirectionalIter1 first, BidirectionalIter1 last,
                        BidirectionalIter2 result);
     
      namespace ranges {
        template<class I1, class I2>
          using move_backward_result = in_out_result<I1, I2>;
     
        template<bidirectional_iterator I1, sentinel_for<I1> S1, bidirectional_iterator I2>
          requires indirectly_movable<I1, I2>
          constexpr move_backward_result<I1, I2>
            move_backward(I1 first, S1 last, I2 result);
        template<bidirectional_range R, bidirectional_iterator I>
          requires indirectly_movable<iterator_t<R>, I>
          constexpr move_backward_result<borrowed_iterator_t<R>, I>
            move_backward(R&& r, I result);
      }
     
      // swap
      template<class ForwardIter1, class ForwardIter2>
        constexpr ForwardIter2 swap_ranges(ForwardIter1 first1, ForwardIter1 last1,
                                           ForwardIter2 first2);
      template<class ExecutionPolicy, class ForwardIter1, class ForwardIter2>
        ForwardIter2 swap_ranges(ExecutionPolicy&& exec, // freestanding-deleted
                                 ForwardIter1 first1, ForwardIter1 last1,
                                 ForwardIter2 first2);
     
      namespace ranges {
        template<class I1, class I2>
          using swap_ranges_result = in_in_result<I1, I2>;
     
        template<input_iterator I1, sentinel_for<I1> S1,
                 input_iterator I2, sentinel_for<I2> S2>
          requires indirectly_swappable<I1, I2>
          constexpr swap_ranges_result<I1, I2>
            swap_ranges(I1 first1, S1 last1, I2 first2, S2 last2);
        template<input_range R1, input_range R2>
          requires indirectly_swappable<iterator_t<R1>, iterator_t<R2>>
          constexpr swap_ranges_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>>
            swap_ranges(R1&& r1, R2&& r2);
      }
     
      template<class ForwardIter1, class ForwardIter2>
        constexpr void iter_swap(ForwardIter1 a, ForwardIter2 b);
     
      // transform
      template<class InputIter, class OutputIter, class UnaryOperation>
        constexpr OutputIter
          transform(InputIter first1, InputIter last1,
                    OutputIter result, UnaryOperation op);
      template<class InputIter1, class InputIter2, class OutputIter,
               class BinaryOperation>
        constexpr OutputIter
          transform(InputIter1 first1, InputIter1 last1,
                    InputIter2 first2, OutputIter result,
                    BinaryOperation binary_op);
      template<class ExecutionPolicy, class ForwardIter1, class ForwardIter2,
               class UnaryOperation>
        ForwardIter2
          transform(ExecutionPolicy&& exec, // freestanding-deleted
                    ForwardIter1 first1, ForwardIter1 last1,
                    ForwardIter2 result, UnaryOperation op);
      template<class ExecutionPolicy, class ForwardIter1, class ForwardIter2,
               class ForwardIter, class BinaryOperation>
        ForwardIter
          transform(ExecutionPolicy&& exec, // freestanding-deleted
                    ForwardIter1 first1, ForwardIter1 last1,
                    ForwardIter2 first2, ForwardIter result,
                    BinaryOperation binary_op);
     
      namespace ranges {
        template<class I, class O>
          using unary_transform_result = in_out_result<I, O>;
     
        template<input_iterator I, sentinel_for<I> S, weakly_incrementable O,
                 copy_constructible F, class Proj = identity>
          requires indirectly_writable<O, indirect_result_t<F&, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>>>
          constexpr unary_transform_result<I, O>
            transform(I first1, S last1, O result, F op, Proj proj = {});
        template<input_range R, weakly_incrementable O,
                 copy_constructible F, class Proj = identity>
          requires
            indirectly_writable<O, indirect_result_t<F&, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R>, Proj>>>
          constexpr unary_transform_result<borrowed_iterator_t<R>, O>
            transform(R&& r, O result, F op, Proj proj = {});
     
        template<class I1, class I2, class O>
          using binary_transform_result = in_in_out_result<I1, I2, O>;
     
        template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2,
                 sentinel_for<I2> S2, weakly_incrementable O, copy_constructible F,
                 class Proj1 = identity, class Proj2 = identity>
          requires indirectly_writable<O, indirect_result_t<F&, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I1, Proj1>,
                                                            [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I2, Proj2>>>
          constexpr binary_transform_result<I1, I2, O>
            transform(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                      F binary_op, Proj1 proj1 = {}, Proj2 proj2 = {});
        template<input_range R1, input_range R2, weakly_incrementable O,
                 copy_constructible F, class Proj1 = identity, class Proj2 = identity>
          requires indirectly_writable
                       <O, indirect_result_t<F&, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R1>, Proj1>, 
                                             [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R2>, Proj2>>>
          constexpr binary_transform_result<borrowed_iterator_t<R1>,
                                            borrowed_iterator_t<R2>, O>
            transform(R1&& r1, R2&& r2, O result,
                      F binary_op, Proj1 proj1 = {}, Proj2 proj2 = {});
      }
     
      // replace
      template<class ForwardIter, class T = typename iterator_traits<ForwardIter>::value_type>
        constexpr void replace(ForwardIter first, ForwardIter last,
                               const T& old_value, const T& new_value);
      template<class ExecutionPolicy, class ForwardIter,
               class T = typename iterator_traits<ForwardIter>::value_type>
        void replace(ExecutionPolicy&& exec, // freestanding-deleted
                     ForwardIter first, ForwardIter last,
                     const T& old_value, const T& new_value);
      template<class ForwardIter, class Pred,
               class T = typename iterator_traits<ForwardIter>::value_type>
        constexpr void replace_if(ForwardIter first, ForwardIter last,
                                  Pred pred, const T& new_value);
      template<class ExecutionPolicy, class ForwardIter, class Pred,
               class T = typename iterator_traits<ForwardIter>::value_type>
        void replace_if(ExecutionPolicy&& exec, // freestanding-deleted
                        ForwardIter first, ForwardIter last,
                        Pred pred, const T& new_value);
     
      namespace ranges {
        template<input_iterator I, sentinel_for<I> S,
                 class Proj = identity, class T1 = projected_value_t<I, Proj>, class T2 = T1>
          requires indirectly_writable<I, const T2&> &&
                   indirect_binary_predicate<[ranges::equal_to](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/equal_to), [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>, const T1*>
          constexpr I replace(I first, S last, const T1& old_value,
                              const T2& new_value, Proj proj = {});
        template<input_range R, class Proj = identity,
                 class T1 = projected_value_t<iterator_t<R>, Proj>, class T2 = T1>
          requires indirectly_writable<iterator_t<R>, const T2&> &&
                   indirect_binary_predicate<[ranges::equal_to](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/equal_to),
                                             [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R>, Proj>, const T1*>
          constexpr borrowed_iterator_t<R> replace(R&& r, const T1& old_value,
                                                   const T2& new_value, Proj proj = {});
        template<input_iterator I, sentinel_for<I> S, class Proj = identity,
                 class T = projected_value_t<I, Proj>,
                 indirect_unary_predicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Pred>
          requires indirectly_writable<I, const T&>
          constexpr I replace_if(I first, S last, Pred pred,
                                 const T& new_value, Proj proj = {});
        template<input_range R, class Proj = identity,
                 class T = projected_value_t<iterator_t<R>, Proj>,
                 indirect_unary_predicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R>, Proj>> Pred>
          requires indirectly_writable<iterator_t<R>, const T&>
          constexpr borrowed_iterator_t<R> replace_if(R&& r, Pred pred,
                                                      const T& new_value, Proj proj = {});
      }
     
      template<class InputIter, class OutputIter, class T>
        constexpr OutputIter replace_copy(InputIter first, InputIter last, OutputIter result,
                                          const T& old_value, const T& new_value);
      template<class ExecutionPolicy, class ForwardIter1, class ForwardIter2, class T>
        ForwardIter2 replace_copy(ExecutionPolicy&& exec, // freestanding-deleted
                                  ForwardIter1 first, ForwardIter1 last, ForwardIter2 result,
                                  const T& old_value, const T& new_value);
      template<class InputIter, class OutputIter, class Pred,
               class T = typename iterator_traits<OutputIter>::value_type>
        constexpr OutputIter replace_copy_if(InputIter first, InputIter last,
                                             OutputIter result,
                                             Pred pred, const T& new_value);
      template<class ExecutionPolicy, class ForwardIter1, class ForwardIter2,
               class Pred, class T = typename iterator_traits<ForwardIter2>::value_type>
        ForwardIter2 replace_copy_if(ExecutionPolicy&& exec, // freestanding-deleted
                                     ForwardIter1 first, ForwardIter1 last,
                                     ForwardIter2 result,
                                     Pred pred, const T& new_value);
     
      namespace ranges {
        template<class I, class O>
          using replace_copy_result = in_out_result<I, O>;
     
        template<input_iterator I, sentinel_for<I> S, class O, class Proj = identity,
                 class T1 = projected_value_t<I, Proj>, class T2 = iter_value_t<O>>
          requires indirectly_copyable<I, O> &&
                   indirect_binary_predicate<[ranges::equal_to](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/equal_to),
                                             [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>, const T1*> &&
                   output_iterator<O, const T2&>
          constexpr replace_copy_result<I, O>
            replace_copy(I first, S last, O result, const T1& old_value,
                         const T2& new_value, Proj proj = {});
        template<input_range R, class O, class Proj = identity,
                 class T1 = projected_value_t<iterator_t<R>, Proj>,
                 class T2 = iter_value_t<O>>
          requires indirectly_copyable<iterator_t<R>, O> &&
                   indirect_binary_predicate<[ranges::equal_to](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/equal_to),
                                             [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R>, Proj>, const T1*> &&
                   output_iterator<O, const T2&>
          constexpr replace_copy_result<borrowed_iterator_t<R>, O>
            replace_copy(R&& r, O result, const T1& old_value,
                         const T2& new_value, Proj proj = {});
     
        template<class I, class O>
          using replace_copy_if_result = in_out_result<I, O>;
     
        template<input_iterator I, sentinel_for<I> S, class O, class T = iter_value_t<O>,
                 class Proj = identity, indirect_unary_predicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Pred>
          requires indirectly_copyable<I, O> && output_iterator<O, const T&>
          constexpr replace_copy_if_result<I, O>
            replace_copy_if(I first, S last, O result, Pred pred,
                            const T& new_value, Proj proj = {});
        template<input_range R, class O, class T = iter_value_t<O>, class Proj = identity,
                 indirect_unary_predicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R>, Proj>> Pred>
          requires indirectly_copyable<iterator_t<R>, O> && output_iterator<O, const T&>
          constexpr replace_copy_if_result<borrowed_iterator_t<R>, O>
            replace_copy_if(R&& r, O result, Pred pred,
                            const T& new_value, Proj proj = {});
      }
     
      // fill
      template<class ForwardIter, class T = typename iterator_traits<ForwardIter>::value_type>
        constexpr void fill(ForwardIter first, ForwardIter last, const T& value);
      template<class ExecutionPolicy, class ForwardIter,
               class T = typename iterator_traits<ForwardIter>::value_type>
        void fill(ExecutionPolicy&& exec, // freestanding-deleted
                  ForwardIter first, ForwardIter last, const T& value);
      template<class OutputIter, class Size,
               class T = typename iterator_traits<OutputIter>::value_type>
        constexpr OutputIter fill_n(OutputIter first, Size n, const T& value);
      template<class ExecutionPolicy, class ForwardIter,
               class Size, class T = typename iterator_traits<OutputIter>::value_type>
        ForwardIter fill_n(ExecutionPolicy&& exec, // freestanding-deleted
                           ForwardIter first, Size n, const T& value);
     
      namespace ranges {
        template<class O, sentinel_for<O> S, class T = iter_value_t<O>>
          requires output_iterator<O, const T&>
          constexpr O fill(O first, S last, const T& value);
        template<class R, class T = range_value_t<R>>
          requires output_range<R, const T&>
          constexpr borrowed_iterator_t<R> fill(R&& r, const T& value);
        template<class O, class T = iter_value_t<O>>
          requires output_iterator<O, const T&>
          constexpr O fill_n(O first, iter_difference_t<O> n, const T& value);
      }
     
      // generate
      template<class ForwardIter, class Generator>
        constexpr void generate(ForwardIter first, ForwardIter last, Generator gen);
      template<class ExecutionPolicy, class ForwardIter, class Generator>
        void generate(ExecutionPolicy&& exec, // freestanding-deleted
                      ForwardIter first, ForwardIter last, Generator gen);
      template<class OutputIter, class Size, class Generator>
        constexpr OutputIter generate_n(OutputIter first, Size n, Generator gen);
      template<class ExecutionPolicy, class ForwardIter, class Size, class Generator>
        ForwardIter generate_n(ExecutionPolicy&& exec, // freestanding-deleted
                               ForwardIter first, Size n, Generator gen);
     
      namespace ranges {
        template<input_or_output_iterator O, sentinel_for<O> S, copy_constructible F>
          requires invocable<F&> && indirectly_writable<O, invoke_result_t<F&>>
          constexpr O generate(O first, S last, F gen);
        template<class R, copy_constructible F>
          requires invocable<F&> && output_range<R, invoke_result_t<F&>>
          constexpr borrowed_iterator_t<R> generate(R&& r, F gen);
        template<input_or_output_iterator O, copy_constructible F>
          requires invocable<F&> && indirectly_writable<O, invoke_result_t<F&>>
          constexpr O generate_n(O first, iter_difference_t<O> n, F gen);
      }
     
      // remove
      template<class ForwardIter, class T = typename iterator_traits<ForwardIter>::value_type>
        constexpr ForwardIter remove(ForwardIter first, ForwardIter last, const T& value);
      template<class ExecutionPolicy, class ForwardIter,
               class T = typename iterator_traits<ForwardIter>::value_type>
        ForwardIter remove(ExecutionPolicy&& exec, // freestanding-deleted
                           ForwardIter first, ForwardIter last, const T& value);
      template<class ForwardIter, class Pred>
        constexpr ForwardIter remove_if(ForwardIter first, ForwardIter last, Pred pred);
      template<class ExecutionPolicy, class ForwardIter, class Pred>
        ForwardIter remove_if(ExecutionPolicy&& exec, // freestanding-deleted
                              ForwardIter first, ForwardIter last, Pred pred);
     
      namespace ranges {
        template<permutable I, sentinel_for<I> S, class Proj = identity,
                 class T = projected_value_t<I, Proj>>
          requires indirect_binary_predicate<[ranges::equal_to](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/equal_to), [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>, const T*>
          constexpr subrange<I> remove(I first, S last, const T& value, Proj proj = {});
        template<forward_range R, class Proj = identity,
                 class T = projected_value_t<iterator_t<R>, Proj>>
          requires permutable<iterator_t<R>> &&
                   indirect_binary_predicate<[ranges::equal_to](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/equal_to),
                                             [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R>, Proj>, const T*>
          constexpr borrowed_subrange_t<R> remove(R&& r, const T& value, Proj proj = {});
        template<permutable I, sentinel_for<I> S, class Proj = identity,
                 indirect_unary_predicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Pred>
          constexpr subrange<I> remove_if(I first, S last, Pred pred, Proj proj = {});
        template<forward_range R, class Proj = identity,
                 indirect_unary_predicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R>, Proj>> Pred>
          requires permutable<iterator_t<R>>
          constexpr borrowed_subrange_t<R> remove_if(R&& r, Pred pred, Proj proj = {});
      }
     
      template<class InputIter, class OutputIter,
               class T = typename iterator_traits<InputIter>::value_type>
        constexpr OutputIter remove_copy(InputIter first, InputIter last,
                                         OutputIter result, const T& value);
      template<class ExecutionPolicy, class ForwardIter1, class ForwardIter2,
               class T = typename iterator_traits<ForwardIter1>::value_type>
        ForwardIter2 remove_copy(ExecutionPolicy&& exec, // freestanding-deleted
                                 ForwardIter1 first, ForwardIter1 last,
                                 ForwardIter2 result, const T& value);
      template<class InputIter, class OutputIter, class Pred>
        constexpr OutputIter remove_copy_if(InputIter first, InputIter last,
                                            OutputIter result, Pred pred);
      template<class ExecutionPolicy, class ForwardIter1, class ForwardIter2, class Pred>
        ForwardIter2 remove_copy_if(ExecutionPolicy&& exec, // freestanding-deleted
                                    ForwardIter1 first, ForwardIter1 last,
                                    ForwardIter2 result, Pred pred);
     
      namespace ranges {
        template<class I, class O>
          using remove_copy_result = in_out_result<I, O>;
     
        template<input_iterator I, sentinel_for<I> S, weakly_incrementable O,
                 class Proj = identity, class T = projected_value_t<I, Proj>>
          requires indirectly_copyable<I, O> &&
                   indirect_binary_predicate<[ranges::equal_to](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/equal_to), [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>, const T*>
          constexpr remove_copy_result<I, O>
            remove_copy(I first, S last, O result, const T& value, Proj proj = {});
        template<input_range R, weakly_incrementable O, class Proj = identity,
                 class T = projected_value_t<iterator_t<R>, Proj>>
          requires indirectly_copyable<iterator_t<R>, O> &&
                   indirect_binary_predicate<[ranges::equal_to](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/equal_to),
                                             [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R>, Proj>, const T*>
          constexpr remove_copy_result<borrowed_iterator_t<R>, O>
            remove_copy(R&& r, O result, const T& value, Proj proj = {});
     
        template<class I, class O>
          using remove_copy_if_result = in_out_result<I, O>;
     
        template<input_iterator I, sentinel_for<I> S, weakly_incrementable O,
                 class Proj = identity, indirect_unary_predicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Pred>
          requires indirectly_copyable<I, O>
          constexpr remove_copy_if_result<I, O>
            remove_copy_if(I first, S last, O result, Pred pred, Proj proj = {});
        template<input_range R, weakly_incrementable O, class Proj = identity,
                 indirect_unary_predicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R>, Proj>> Pred>
          requires indirectly_copyable<iterator_t<R>, O>
          constexpr remove_copy_if_result<borrowed_iterator_t<R>, O>
            remove_copy_if(R&& r, O result, Pred pred, Proj proj = {});
      }
     
      // unique
      template<class ForwardIter>
        constexpr ForwardIter unique(ForwardIter first, ForwardIter last);
      template<class ForwardIter, class BinaryPred>
        constexpr ForwardIter unique(ForwardIter first, ForwardIter last, BinaryPred pred);
      template<class ExecutionPolicy, class ForwardIter>
        ForwardIter unique(ExecutionPolicy&& exec, // freestanding-deleted
                           ForwardIter first, ForwardIter last);
      template<class ExecutionPolicy, class ForwardIter, class BinaryPred>
        ForwardIter unique(ExecutionPolicy&& exec, // freestanding-deleted
                           ForwardIter first, ForwardIter last, BinaryPred pred);
     
      namespace ranges {
        template<permutable I, sentinel_for<I> S, class Proj = identity,
                 indirect_equivalence_relation<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> C = [ranges::equal_to](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/equal_to)>
          constexpr subrange<I> unique(I first, S last, C comp = {}, Proj proj = {});
        template<forward_range R, class Proj = identity,
                 indirect_equivalence_relation
                     <[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R>, Proj>> C = [ranges::equal_to](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/equal_to)>
          requires permutable<iterator_t<R>>
          constexpr borrowed_subrange_t<R> unique(R&& r, C comp = {}, Proj proj = {});
      }
     
      template<class InputIter, class OutputIter>
        constexpr OutputIter unique_copy(InputIter first, InputIter last,
                                         OutputIter result);
      template<class InputIter, class OutputIter, class BinaryPred>
        constexpr OutputIter unique_copy(InputIter first, InputIter last,
                                         OutputIter result, BinaryPred pred);
      template<class ExecutionPolicy, class ForwardIter1, class ForwardIter2>
        ForwardIter2 unique_copy(ExecutionPolicy&& exec, // freestanding-deleted
                                 ForwardIter1 first, ForwardIter1 last,
                                 ForwardIter2 result);
      template<class ExecutionPolicy, class ForwardIter1, class ForwardIter2,
               class BinaryPred>
        ForwardIter2 unique_copy(ExecutionPolicy&& exec, // freestanding-deleted
                                 ForwardIter1 first, ForwardIter1 last,
                                 ForwardIter2 result, BinaryPred pred);
     
      namespace ranges {
        template<class I, class O>
          using unique_copy_result = in_out_result<I, O>;
     
        template<input_iterator I, sentinel_for<I> S,
                 weakly_incrementable O, class Proj = identity,
                 indirect_equivalence_relation<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> C = [ranges::equal_to](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/equal_to)>
          requires indirectly_copyable<I, O> &&
                   (forward_iterator<I> ||
                    (input_iterator<O> && same_as<iter_value_t<I>, iter_value_t<O>>) ||
                    indirectly_copyable_storable<I, O>)
          constexpr unique_copy_result<I, O>
            unique_copy(I first, S last, O result, C comp = {}, Proj proj = {});
        template<input_range R, weakly_incrementable O, class Proj = identity,
                 indirect_equivalence_relation
                     <[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R>, Proj>> C = [ranges::equal_to](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/equal_to)>
          requires indirectly_copyable<iterator_t<R>, O> &&
                   (forward_iterator<iterator_t<R>> ||
                    (input_iterator<O> && same_as<range_value_t<R>, iter_value_t<O>>) ||
                    indirectly_copyable_storable<iterator_t<R>, O>)
          constexpr unique_copy_result<borrowed_iterator_t<R>, O>
            unique_copy(R&& r, O result, C comp = {}, Proj proj = {});
      }
     
      // reverse
      template<class BidirectionalIter>
        constexpr void reverse(BidirectionalIter first, BidirectionalIter last);
      template<class ExecutionPolicy, class BidirectionalIter>
        void reverse(ExecutionPolicy&& exec, // freestanding-deleted
                     BidirectionalIter first, BidirectionalIter last);
     
      namespace ranges {
        template<bidirectional_iterator I, sentinel_for<I> S>
          requires permutable<I>
          constexpr I reverse(I first, S last);
        template<bidirectional_range R>
          requires permutable<iterator_t<R>>
          constexpr borrowed_iterator_t<R> reverse(R&& r);
      }
     
      template<class BidirectionalIter, class OutputIter>
        constexpr OutputIter reverse_copy(BidirectionalIter first, BidirectionalIter last,
                                          OutputIter result);
      template<class ExecutionPolicy, class BidirectionalIter, class ForwardIter>
        ForwardIter reverse_copy(ExecutionPolicy&& exec, // freestanding-deleted
                                 BidirectionalIter first, BidirectionalIter last,
                                 ForwardIter result);
     
      namespace ranges {
        template<class I, class O>
          using reverse_copy_result = in_out_result<I, O>;
     
        template<bidirectional_iterator I, sentinel_for<I> S, weakly_incrementable O>
          requires indirectly_copyable<I, O>
          constexpr reverse_copy_result<I, O>
            reverse_copy(I first, S last, O result);
        template<bidirectional_range R, weakly_incrementable O>
          requires indirectly_copyable<iterator_t<R>, O>
          constexpr reverse_copy_result<borrowed_iterator_t<R>, O>
            reverse_copy(R&& r, O result);
      }
     
      // rotate
      template<class ForwardIter>
        constexpr ForwardIter rotate(ForwardIter first, ForwardIter middle, ForwardIter last);
      template<class ExecutionPolicy, class ForwardIter>
        ForwardIter rotate(ExecutionPolicy&& exec, // freestanding-deleted
                           ForwardIter first, ForwardIter middle, ForwardIter last);
     
      namespace ranges {
        template<permutable I, sentinel_for<I> S>
          constexpr subrange<I> rotate(I first, I middle, S last);
        template<forward_range R>
          requires permutable<iterator_t<R>>
          constexpr borrowed_subrange_t<R> rotate(R&& r, iterator_t<R> middle);
      }
     
      template<class ForwardIter, class OutputIter>
        constexpr OutputIter rotate_copy(ForwardIter first, ForwardIter middle,
                                         ForwardIter last, OutputIter result);
      template<class ExecutionPolicy, class ForwardIter1, class ForwardIter2>
        ForwardIter2 rotate_copy(ExecutionPolicy&& exec, // freestanding-deleted
                                 ForwardIter1 first, ForwardIter1 middle,
                                 ForwardIter1 last, ForwardIter2 result);
     
      namespace ranges {
        template<class I, class O>
          using rotate_copy_result = in_out_result<I, O>;
     
        template<forward_iterator I, sentinel_for<I> S, weakly_incrementable O>
          requires indirectly_copyable<I, O>
          constexpr rotate_copy_result<I, O>
            rotate_copy(I first, I middle, S last, O result);
        template<forward_range R, weakly_incrementable O>
          requires indirectly_copyable<iterator_t<R>, O>
          constexpr rotate_copy_result<borrowed_iterator_t<R>, O>
            rotate_copy(R&& r, iterator_t<R> middle, O result);
      }
     
      // sample
      template<class PopulationIter, class SampleIter,
               class Distance, class [UniformRandomBitGenerator](../numeric/random/UniformRandomBitGenerator.html)>
        SampleIter sample(PopulationIter first, PopulationIter last,
                          SampleIter out, Distance n, [UniformRandomBitGenerator](../numeric/random/UniformRandomBitGenerator.html)&& g);
     
      namespace ranges {
        template<input_iterator I, sentinel_for<I> S,
                 weakly_incrementable O, class Gen>
          requires (forward_iterator<I> || random_access_iterator<O>) &&
                   indirectly_copyable<I, O> &&
                   uniform_random_bit_generator<remove_reference_t<Gen>>
          O sample(I first, S last, O out, iter_difference_t<I> n, Gen&& g);
        template<input_range R, weakly_incrementable O, class Gen>
          requires (forward_range<R> || random_access_iterator<O>) &&
                   indirectly_copyable<iterator_t<R>, O> &&
                   uniform_random_bit_generator<remove_reference_t<Gen>>
          O sample(R&& r, O out, range_difference_t<R> n, Gen&& g);
      }
     
      // shuffle
      template<class RandomAccessIter, class [UniformRandomBitGenerator](../numeric/random/UniformRandomBitGenerator.html)>
        void shuffle(RandomAccessIter first, RandomAccessIter last,
                     [UniformRandomBitGenerator](../numeric/random/UniformRandomBitGenerator.html)&& g);
     
      namespace ranges {
        template<random_access_iterator I, sentinel_for<I> S, class Gen>
          requires permutable<I> &&
                   uniform_random_bit_generator<remove_reference_t<Gen>>
          I shuffle(I first, S last, Gen&& g);
        template<random_access_range R, class Gen>
          requires permutable<iterator_t<R>> &&
                   uniform_random_bit_generator<remove_reference_t<Gen>>
          borrowed_iterator_t<R> shuffle(R&& r, Gen&& g);
      }
     
      // shift
      template<class ForwardIter>
        constexpr ForwardIter
          shift_left(ForwardIter first, ForwardIter last,
                     typename iterator_traits<ForwardIter>::difference_type n);
      template<class ExecutionPolicy, class ForwardIter>
        ForwardIter
          shift_left(ExecutionPolicy&& exec, // freestanding-deleted
                     ForwardIter first, ForwardIter last,
                     typename iterator_traits<ForwardIter>::difference_type n);
     
      namespace ranges {
        template<permutable I, sentinel_for<I> S>
          constexpr subrange<I> shift_left(I first, S last, iter_difference_t<I> n);
        template<forward_range R>
          requires permutable<iterator_t<R>>
          constexpr borrowed_subrange_t<R> shift_left(R&& r, range_difference_t<R> n);
      }
     
      template<class ForwardIter>
        constexpr ForwardIter
          shift_right(ForwardIter first, ForwardIter last,
                      typename iterator_traits<ForwardIter>::difference_type n);
      template<class ExecutionPolicy, class ForwardIter>
        ForwardIter
          shift_right(ExecutionPolicy&& exec, // freestanding-deleted
                      ForwardIter first, ForwardIter last,
                      typename iterator_traits<ForwardIter>::difference_type n);
     
      namespace ranges {
        template<permutable I, sentinel_for<I> S>
          constexpr subrange<I> shift_right(I first, S last, iter_difference_t<I> n);
        template<forward_range R>
          requires permutable<iterator_t<R>>
          constexpr borrowed_subrange_t<R> shift_right(R&& r, range_difference_t<R> n);
      }
     
      // sorting and related operations
      // sorting
      template<class RandomAccessIter>
        constexpr void sort(RandomAccessIter first, RandomAccessIter last);
      template<class RandomAccessIter, class Compare>
        constexpr void sort(RandomAccessIter first, RandomAccessIter last, Compare comp);
      template<class ExecutionPolicy, class RandomAccessIter>
        void sort(ExecutionPolicy&& exec, // freestanding-deleted
                  RandomAccessIter first, RandomAccessIter last);
      template<class ExecutionPolicy, class RandomAccessIter, class Compare>
        void sort(ExecutionPolicy&& exec, // freestanding-deleted
                  RandomAccessIter first, RandomAccessIter last, Compare comp);
     
      namespace ranges {
        template<random_access_iterator I, sentinel_for<I> S,
                 class Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less), class Proj = identity>
          requires sortable<I, Comp, Proj>
          constexpr I sort(I first, S last, Comp comp = {}, Proj proj = {});
        template<random_access_range R, class Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less), class Proj = identity>
          requires sortable<iterator_t<R>, Comp, Proj>
          constexpr borrowed_iterator_t<R> sort(R&& r, Comp comp = {}, Proj proj = {});
      }
     
      template<class RandomAccessIter>
        void stable_sort(RandomAccessIter first, RandomAccessIter last);               // hosted
      template<class RandomAccessIter, class Compare>
        void stable_sort(RandomAccessIter first, RandomAccessIter last, Compare comp); // hosted
      template<class ExecutionPolicy, class RandomAccessIter>
        void stable_sort(ExecutionPolicy&& exec,                                       // hosted
                         RandomAccessIter first, RandomAccessIter last);
      template<class ExecutionPolicy, class RandomAccessIter, class Compare>
        void stable_sort(ExecutionPolicy&& exec,                                       // hosted
                         RandomAccessIter first, RandomAccessIter last, Compare comp);
     
      namespace ranges {
        template<random_access_iterator I, sentinel_for<I> S,
                 class Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less), class Proj = identity>
          requires sortable<I, Comp, Proj>
          I stable_sort(I first, S last, Comp comp = {}, Proj proj = {});              // hosted
        template<random_access_range R, class Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less), class Proj = identity>
          requires sortable<iterator_t<R>, Comp, Proj>
          borrowed_iterator_t<R> stable_sort(R&& r, Comp comp = {}, Proj proj = {});   // hosted
      }
     
      template<class RandomAccessIter>
        constexpr void partial_sort(RandomAccessIter first, RandomAccessIter middle,
                                    RandomAccessIter last);
      template<class RandomAccessIter, class Compare>
        constexpr void partial_sort(RandomAccessIter first, RandomAccessIter middle,
                                    RandomAccessIter last, Compare comp);
      template<class ExecutionPolicy, class RandomAccessIter>
        void partial_sort(ExecutionPolicy&& exec, // freestanding-deleted
                          RandomAccessIter first, RandomAccessIter middle,
                          RandomAccessIter last);
      template<class ExecutionPolicy, class RandomAccessIter, class Compare>
        void partial_sort(ExecutionPolicy&& exec, // freestanding-deleted
                          RandomAccessIter first, RandomAccessIter middle,
                          RandomAccessIter last, Compare comp);
     
      namespace ranges {
        template<random_access_iterator I, sentinel_for<I> S,
                 class Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less), class Proj = identity>
          requires sortable<I, Comp, Proj>
          constexpr I
            partial_sort(I first, I middle, S last, Comp comp = {}, Proj proj = {});
        template<random_access_range R, class Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less), class Proj = identity>
          requires sortable<iterator_t<R>, Comp, Proj>
          constexpr borrowed_iterator_t<R>
            partial_sort(R&& r, iterator_t<R> middle, Comp comp = {}, Proj proj = {});
      }
     
      template<class InputIter, class RandomAccessIter>
        constexpr RandomAccessIter
          partial_sort_copy(InputIter first, InputIter last,
                            RandomAccessIter result_first,
                            RandomAccessIter result_last);
      template<class InputIter, class RandomAccessIter, class Compare>
        constexpr RandomAccessIter
          partial_sort_copy(InputIter first, InputIter last,
                            RandomAccessIter result_first,
                            RandomAccessIter result_last, Compare comp);
      template<class ExecutionPolicy, class ForwardIter, class RandomAccessIter>
        RandomAccessIter
          partial_sort_copy(ExecutionPolicy&& exec, // freestanding-deleted
                            ForwardIter first, ForwardIter last,
                            RandomAccessIter result_first,
                            RandomAccessIter result_last);
      template<class ExecutionPolicy, class ForwardIter, class RandomAccessIter,
               class Compare>
        RandomAccessIter
          partial_sort_copy(ExecutionPolicy&& exec, // freestanding-deleted
                            ForwardIter first, ForwardIter last,
                            RandomAccessIter result_first,
                            RandomAccessIter result_last, Compare comp);
     
      namespace ranges {
        template<class I, class O>
          using partial_sort_copy_result = in_out_result<I, O>;
     
        template<input_iterator I1, sentinel_for<I1> S1,
                 random_access_iterator I2, sentinel_for<I2> S2,
                 class Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less), class Proj1 = identity, class Proj2 = identity>
          requires indirectly_copyable<I1, I2> && sortable<I2, Comp, Proj2> &&
                   indirect_strict_weak_order<Comp, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I1, Proj1>,
                                              [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I2, Proj2>>
          constexpr partial_sort_copy_result<I1, I2>
            partial_sort_copy(I1 first, S1 last, I2 result_first, S2 result_last,
                              Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
        template<input_range R1, random_access_range R2, class Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less),
                 class Proj1 = identity, class Proj2 = identity>
          requires indirectly_copyable<iterator_t<R1>, iterator_t<R2>> &&
                   sortable<iterator_t<R2>, Comp, Proj2> &&
                   indirect_strict_weak_order<Comp, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R1>, Proj1>,
                                              [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R2>, Proj2>>
          constexpr partial_sort_copy_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>>
            partial_sort_copy(R1&& r, R2&& result_r, Comp comp = {},
                              Proj1 proj1 = {}, Proj2 proj2 = {});
      }
     
      template<class ForwardIter>
        constexpr bool is_sorted(ForwardIter first, ForwardIter last);
      template<class ForwardIter, class Compare>
        constexpr bool is_sorted(ForwardIter first, ForwardIter last, Compare comp);
      template<class ExecutionPolicy, class ForwardIter>
        bool is_sorted(ExecutionPolicy&& exec, // freestanding-deleted
                       ForwardIter first, ForwardIter last);
      template<class ExecutionPolicy, class ForwardIter, class Compare>
        bool is_sorted(ExecutionPolicy&& exec, // freestanding-deleted
                       ForwardIter first, ForwardIter last, Compare comp);
     
      namespace ranges {
        template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
                 indirect_strict_weak_order<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less)>
          constexpr bool is_sorted(I first, S last, Comp comp = {}, Proj proj = {});
        template<forward_range R, class Proj = identity,
                 indirect_strict_weak_order
                     <[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R>, Proj>> Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less)>
          constexpr bool is_sorted(R&& r, Comp comp = {}, Proj proj = {});
      }
     
      template<class ForwardIter>
        constexpr ForwardIter is_sorted_until(ForwardIter first, ForwardIter last);
      template<class ForwardIter, class Compare>
        constexpr ForwardIter is_sorted_until(ForwardIter first, ForwardIter last,
                                              Compare comp);
      template<class ExecutionPolicy, class ForwardIter>
        ForwardIter is_sorted_until(ExecutionPolicy&& exec, // freestanding-deleted
                                    ForwardIter first, ForwardIter last);
      template<class ExecutionPolicy, class ForwardIter, class Compare>
        ForwardIter is_sorted_until(ExecutionPolicy&& exec, // freestanding-deleted
                                    ForwardIter first, ForwardIter last,
                                    Compare comp);
     
      namespace ranges {
        template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
                 indirect_strict_weak_order<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less)>
          constexpr I is_sorted_until(I first, S last, Comp comp = {}, Proj proj = {});
        template<forward_range R, class Proj = identity,
                 indirect_strict_weak_order
                     <[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R>, Proj>> Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less)>
          constexpr borrowed_iterator_t<R>
            is_sorted_until(R&& r, Comp comp = {}, Proj proj = {});
      }
     
      // Nth element
      template<class RandomAccessIter>
        constexpr void nth_element(RandomAccessIter first, RandomAccessIter nth,
                                   RandomAccessIter last);
      template<class RandomAccessIter, class Compare>
        constexpr void nth_element(RandomAccessIter first, RandomAccessIter nth,
                                   RandomAccessIter last, Compare comp);
      template<class ExecutionPolicy, class RandomAccessIter>
        void nth_element(ExecutionPolicy&& exec, // freestanding-deleted
                         RandomAccessIter first, RandomAccessIter nth,
                         RandomAccessIter last);
      template<class ExecutionPolicy, class RandomAccessIter, class Compare>
        void nth_element(ExecutionPolicy&& exec, // freestanding-deleted
                         RandomAccessIter first, RandomAccessIter nth,
                         RandomAccessIter last, Compare comp);
     
      namespace ranges {
        template<random_access_iterator I, sentinel_for<I> S,
                 class Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less), class Proj = identity>
          requires sortable<I, Comp, Proj>
          constexpr I
            nth_element(I first, I nth, S last, Comp comp = {}, Proj proj = {});
        template<random_access_range R, class Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less), class Proj = identity>
          requires sortable<iterator_t<R>, Comp, Proj>
          constexpr borrowed_iterator_t<R>
            nth_element(R&& r, iterator_t<R> nth, Comp comp = {}, Proj proj = {});
      }
     
      // binary search
      template<class ForwardIter, class T = typename iterator_traits<ForwardIter>::value_type>
        constexpr ForwardIter lower_bound(ForwardIter first, ForwardIter last,
                                          const T& value);
      template<class ForwardIter, class T = typename iterator_traits<ForwardIter>::value_type,
               class Compare>
        constexpr ForwardIter lower_bound(ForwardIter first, ForwardIter last,
                                          const T& value, Compare comp);
     
      namespace ranges {
        template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
                 class T = projected_value_t<I, Proj>,
                 indirect_strict_weak_order<const T*, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less)>
          constexpr I
              lower_bound(I first, S last, const T& value, Comp comp = {}, Proj proj = {});
        template<forward_range R, class Proj = identity,
                 class T = projected_value_t<iterator_t<R>, Proj>,
                 indirect_strict_weak_order
                     <const T*, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R>, Proj>> Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less)>
          constexpr borrowed_iterator_t<R>
            lower_bound(R&& r, const T& value, Comp comp = {}, Proj proj = {});
      }
     
      template<class ForwardIter, class T = typename iterator_traits<ForwardIter>::value_type>
        constexpr ForwardIter upper_bound(ForwardIter first, ForwardIter last,
                                          const T& value);
      template<class ForwardIter, class T = typename iterator_traits<ForwardIter>::value_type,
               class Compare>
        constexpr ForwardIter upper_bound(ForwardIter first, ForwardIter last,
                                          const T& value, Compare comp);
     
      namespace ranges {
        template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
                 class T = projected_value_t<I, Proj>,
                 indirect_strict_weak_order<const T*, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less)>
          constexpr I
              upper_bound(I first, S last, const T& value, Comp comp = {}, Proj proj = {});
        template<forward_range R, class T, class Proj = identity,
                 class T = projected_value_t<iterator_t<R>, Proj>,
                 indirect_strict_weak_order
                     <const T*, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R>, Proj>> Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less)>
          constexpr borrowed_iterator_t<R>
            upper_bound(R&& r, const T& value, Comp comp = {}, Proj proj = {});
      }
     
      template<class ForwardIter, class T = typename iterator_traits<ForwardIter>::value_type>
        constexpr pair<ForwardIter, ForwardIter>
          equal_range(ForwardIter first, ForwardIter last, const T& value);
      template<class ForwardIter, class T = typename iterator_traits<ForwardIter>::value_type,
               class Compare>
        constexpr pair<ForwardIter, ForwardIter>
          equal_range(ForwardIter first, ForwardIter last, const T& value, Compare comp);
     
      namespace ranges {
        template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
                 class T = projected_value_t<I, Proj>,
                 indirect_strict_weak_order<const T*, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less)>
          constexpr subrange<I>
            equal_range(I first, S last, const T& value, Comp comp = {}, Proj proj = {});
        template<forward_range R, class Proj = identity,
                 class T = projected_value_t<iterator_t<R>, Proj>,
                 indirect_strict_weak_order
                     <const T*, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R>, Proj>> Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less)>
          constexpr borrowed_subrange_t<R>
            equal_range(R&& r, const T& value, Comp comp = {}, Proj proj = {});
      }
     
      template<class ForwardIter, class T = typename iterator_traits<ForwardIter>::value_type>
        constexpr bool binary_search(ForwardIter first, ForwardIter last,
                                     const T& value);
      template<class ForwardIter, class T = typename iterator_traits<ForwardIter>::value_type,
               class Compare>
        constexpr bool binary_search(ForwardIter first, ForwardIter last,
                                     const T& value, Compare comp);
     
      namespace ranges {
        template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
                 class T = projected_value_t<I, Proj>,
                 indirect_strict_weak_order<const T*, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less)>
          constexpr bool binary_search(I first, S last, const T& value,
                                       Comp comp = {}, Proj proj = {});
        template<forward_range R, class Proj = identity,
                 class T = projected_value_t<iterator_t<R>, Proj>,
                 indirect_strict_weak_order
                     <const T*, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R>, Proj>> Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less)>
          constexpr bool binary_search(R&& r, const T& value, Comp comp = {}, Proj proj = {});
      }
     
      // partitions
      template<class InputIter, class Pred>
        constexpr bool is_partitioned(InputIter first, InputIter last, Pred pred);
      template<class ExecutionPolicy, class ForwardIter, class Pred>
        bool is_partitioned(ExecutionPolicy&& exec, // freestanding-deleted
                            ForwardIter first, ForwardIter last, Pred pred);
     
      namespace ranges {
        template<input_iterator I, sentinel_for<I> S, class Proj = identity,
                 indirect_unary_predicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Pred>
          constexpr bool is_partitioned(I first, S last, Pred pred, Proj proj = {});
        template<input_range R, class Proj = identity,
                 indirect_unary_predicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R>, Proj>> Pred>
          constexpr bool is_partitioned(R&& r, Pred pred, Proj proj = {});
      }
     
      template<class ForwardIter, class Pred>
        constexpr ForwardIter partition(ForwardIter first, ForwardIter last, Pred pred);
      template<class ExecutionPolicy, class ForwardIter, class Pred>
        ForwardIter partition(ExecutionPolicy&& exec, // freestanding-deleted
                              ForwardIter first, ForwardIter last, Pred pred);
     
      namespace ranges {
        template<permutable I, sentinel_for<I> S, class Proj = identity,
                 indirect_unary_predicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Pred>
          constexpr subrange<I> partition(I first, S last, Pred pred, Proj proj = {});
        template<forward_range R, class Proj = identity,
                 indirect_unary_predicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R>, Proj>> Pred>
          requires permutable<iterator_t<R>>
          constexpr borrowed_subrange_t<R> partition(R&& r, Pred pred, Proj proj = {});
      }
     
      template<class BidirectionalIter, class Pred>
        BidirectionalIter stable_partition(BidirectionalIter first,                  // hosted
                                           BidirectionalIter last, Pred pred);
      template<class ExecutionPolicy, class BidirectionalIter, class Pred>
        BidirectionalIter stable_partition(ExecutionPolicy&& exec,                   // hosted
                                           BidirectionalIter first,
                                           BidirectionalIter last, Pred pred);
     
      namespace ranges {
        template<bidirectional_iterator I, sentinel_for<I> S, class Proj = identity,
                 indirect_unary_predicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Pred>
          requires permutable<I>
          subrange<I> stable_partition(I first, S last, Pred pred, Proj proj = {});  // hosted
        template<bidirectional_range R, class Proj = identity,
                 indirect_unary_predicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R>, Proj>> Pred>
          requires permutable<iterator_t<R>>
          borrowed_subrange_t<R> stable_partition(R&& r, Pred pred, Proj proj = {}); // hosted
      }
     
      template<class InputIter, class OutputIter1,
               class OutputIter2, class Pred>
        constexpr pair<OutputIter1, OutputIter2>
          partition_copy(InputIter first, InputIter last,
                         OutputIter1 out_true, OutputIter2 out_false, Pred pred);
      template<class ExecutionPolicy, class ForwardIter, class ForwardIter1,
               class ForwardIter2, class Pred>
        pair<ForwardIter1, ForwardIter2>
          partition_copy(ExecutionPolicy&& exec, // freestanding-deleted
                         ForwardIter first, ForwardIter last,
                         ForwardIter1 out_true, ForwardIter2 out_false, Pred pred);
     
      namespace ranges {
        template<class I, class O1, class O2>
          using partition_copy_result = in_out_out_result<I, O1, O2>;
     
        template<input_iterator I, sentinel_for<I> S,
                 weakly_incrementable O1, weakly_incrementable O2,
                 class Proj = identity, indirect_unary_predicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Pred>
          requires indirectly_copyable<I, O1> && indirectly_copyable<I, O2>
          constexpr partition_copy_result<I, O1, O2>
            partition_copy(I first, S last, O1 out_true, O2 out_false,
                           Pred pred, Proj proj = {});
        template<input_range R, weakly_incrementable O1, weakly_incrementable O2,
                 class Proj = identity,
                 indirect_unary_predicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R>, Proj>> Pred>
          requires indirectly_copyable<iterator_t<R>, O1> &&
                   indirectly_copyable<iterator_t<R>, O2>
          constexpr partition_copy_result<borrowed_iterator_t<R>, O1, O2>
            partition_copy(R&& r, O1 out_true, O2 out_false, Pred pred, Proj proj = {});
      }
     
      template<class ForwardIter, class Pred>
        constexpr ForwardIter
          partition_point(ForwardIter first, ForwardIter last, Pred pred);
     
      namespace ranges {
        template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
                 indirect_unary_predicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Pred>
          constexpr I partition_point(I first, S last, Pred pred, Proj proj = {});
        template<forward_range R, class Proj = identity,
                 indirect_unary_predicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R>, Proj>> Pred>
          constexpr borrowed_iterator_t<R>
            partition_point(R&& r, Pred pred, Proj proj = {});
      }
     
      // merge
      template<class InputIter1, class InputIter2, class OutputIter>
        constexpr OutputIter merge(InputIter1 first1, InputIter1 last1,
                                   InputIter2 first2, InputIter2 last2, OutputIter result);
      template<class InputIter1, class InputIter2, class OutputIter,
               class Compare>
        constexpr OutputIter merge(InputIter1 first1, InputIter1 last1,
                                   InputIter2 first2, InputIter2 last2,
                                   OutputIter result, Compare comp);
      template<class ExecutionPolicy, class ForwardIter1, class ForwardIter2,
               class ForwardIter>
        ForwardIter merge(ExecutionPolicy&& exec, // freestanding-deleted
                          ForwardIter1 first1, ForwardIter1 last1,
                          ForwardIter2 first2, ForwardIter2 last2, ForwardIter result);
      template<class ExecutionPolicy, class ForwardIter1, class ForwardIter2,
               class ForwardIter, class Compare>
        ForwardIter merge(ExecutionPolicy&& exec, // freestanding-deleted
                          ForwardIter1 first1, ForwardIter1 last1,
                          ForwardIter2 first2, ForwardIter2 last2,
                          ForwardIter result, Compare comp);
     
      namespace ranges {
        template<class I1, class I2, class O>
          using merge_result = in_in_out_result<I1, I2, O>;
     
        template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2,
                 sentinel_for<I2> S2, weakly_incrementable O, class Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less),
                 class Proj1 = identity, class Proj2 = identity>
          requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
          constexpr merge_result<I1, I2, O>
            merge(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                  Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
        template<input_range R1, input_range R2, weakly_incrementable O,
                 class Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less), class Proj1 = identity, class Proj2 = identity>
          requires mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
          constexpr merge_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, O>
            merge(R1&& r1, R2&& r2, O result,
                  Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
      }
     
      template<class BidirectionalIter>
        void inplace_merge(BidirectionalIter first, BidirectionalIter middle,         // hosted
                           BidirectionalIter last);
      template<class BidirectionalIter, class Compare>
        void inplace_merge(BidirectionalIter first, BidirectionalIter middle,         // hosted
                           BidirectionalIter last, Compare comp);
      template<class ExecutionPolicy, class BidirectionalIter>
        void inplace_merge(ExecutionPolicy&& exec,                                    // hosted
                           BidirectionalIter first, BidirectionalIter middle,
                           BidirectionalIter last);
      template<class ExecutionPolicy, class BidirectionalIter, class Compare>
        void inplace_merge(ExecutionPolicy&& exec,                                    // hosted
                           BidirectionalIter first, BidirectionalIter middle,
                           BidirectionalIter last, Compare comp);
     
      namespace ranges {
        template<bidirectional_iterator I, sentinel_for<I> S,
                 class Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less), class Proj = identity>
          requires sortable<I, Comp, Proj>
          I inplace_merge(I first, I middle, S last, Comp comp = {}, Proj proj = {}); // hosted
        template<bidirectional_range R, class Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less), class Proj = identity>
          requires sortable<iterator_t<R>, Comp, Proj>
          borrowed_iterator_t<R> inplace_merge(R&& r, iterator_t<R> middle,           // hosted
                                               Comp comp = {}, Proj proj = {});
      }
     
      // set operations
      template<class InputIter1, class InputIter2>
        constexpr bool includes(InputIter1 first1, InputIter1 last1,
                                InputIter2 first2, InputIter2 last2);
      template<class InputIter1, class InputIter2, class Compare>
        constexpr bool includes(InputIter1 first1, InputIter1 last1,
                                InputIter2 first2, InputIter2 last2, Compare comp);
      template<class ExecutionPolicy, class ForwardIter1, class ForwardIter2>
        bool includes(ExecutionPolicy&& exec, // freestanding-deleted
                      ForwardIter1 first1, ForwardIter1 last1,
                      ForwardIter2 first2, ForwardIter2 last2);
      template<class ExecutionPolicy, class ForwardIter1, class ForwardIter2, class Compare>
        bool includes(ExecutionPolicy&& exec, // freestanding-deleted
                      ForwardIter1 first1, ForwardIter1 last1,
                      ForwardIter2 first2, ForwardIter2 last2, Compare comp);
     
      namespace ranges {
        template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2,
                 sentinel_for<I2> S2, class Proj1 = identity, class Proj2 = identity,
                 indirect_strict_weak_order
                     <[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I1, Proj1>, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I2, Proj2>> Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less)>
          constexpr bool includes(I1 first1, S1 last1, I2 first2, S2 last2, Comp comp = {},
                                  Proj1 proj1 = {}, Proj2 proj2 = {});
        template<input_range R1, input_range R2,
                 class Proj1 = identity, class Proj2 = identity,
                 indirect_strict_weak_order
                     <[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R1>, Proj1>,
                      [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R2>, Proj2>> Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less)>
          constexpr bool includes(R1&& r1, R2&& r2, Comp comp = {},
                                  Proj1 proj1 = {}, Proj2 proj2 = {});
      }
     
      template<class InputIter1, class InputIter2, class OutputIter>
        constexpr OutputIter set_union(InputIter1 first1, InputIter1 last1,
                                       InputIter2 first2, InputIter2 last2,
                                       OutputIter result);
      template<class InputIter1, class InputIter2, class OutputIter, class Compare>
        constexpr OutputIter set_union(InputIter1 first1, InputIter1 last1,
                                       InputIter2 first2, InputIter2 last2,
                                       OutputIter result, Compare comp);
      template<class ExecutionPolicy, class ForwardIter1, class ForwardIter2,
               class ForwardIter>
        ForwardIter set_union(ExecutionPolicy&& exec, // freestanding-deleted
                              ForwardIter1 first1, ForwardIter1 last1,
                              ForwardIter2 first2, ForwardIter2 last2,
                              ForwardIter result);
      template<class ExecutionPolicy, class ForwardIter1, class ForwardIter2,
               class ForwardIter, class Compare>
        ForwardIter set_union(ExecutionPolicy&& exec, // freestanding-deleted
                              ForwardIter1 first1, ForwardIter1 last1,
                              ForwardIter2 first2, ForwardIter2 last2,
                              ForwardIter result, Compare comp);
     
      namespace ranges {
        template<class I1, class I2, class O>
          using set_union_result = in_in_out_result<I1, I2, O>;
     
        template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2,
                 sentinel_for<I2> S2, weakly_incrementable O, class Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less),
                 class Proj1 = identity, class Proj2 = identity>
          requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
          constexpr set_union_result<I1, I2, O>
            set_union(I1 first1, S1 last1, I2 first2, S2 last2, O result, Comp comp = {},
                      Proj1 proj1 = {}, Proj2 proj2 = {});
        template<input_range R1, input_range R2, weakly_incrementable O,
                 class Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less), class Proj1 = identity, class Proj2 = identity>
          requires mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
          constexpr set_union_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, O>
            set_union(R1&& r1, R2&& r2, O result, Comp comp = {},
                      Proj1 proj1 = {}, Proj2 proj2 = {});
      }
     
      template<class InputIter1, class InputIter2, class OutputIter>
        constexpr OutputIter set_intersection(InputIter1 first1, InputIter1 last1,
                                              InputIter2 first2, InputIter2 last2,
                                              OutputIter result);
      template<class InputIter1, class InputIter2, class OutputIter, class Compare>
        constexpr OutputIter set_intersection(InputIter1 first1, InputIter1 last1,
                                              InputIter2 first2, InputIter2 last2,
                                              OutputIter result, Compare comp);
      template<class ExecutionPolicy, class ForwardIter1, class ForwardIter2,
               class ForwardIter>
        ForwardIter set_intersection(ExecutionPolicy&& exec, // freestanding-deleted
                                     ForwardIter1 first1, ForwardIter1 last1,
                                     ForwardIter2 first2, ForwardIter2 last2,
                                     ForwardIter result);
      template<class ExecutionPolicy, class ForwardIter1, class ForwardIter2,
               class ForwardIter, class Compare>
        ForwardIter set_intersection(ExecutionPolicy&& exec, // freestanding-deleted
                                     ForwardIter1 first1, ForwardIter1 last1,
                                     ForwardIter2 first2, ForwardIter2 last2,
                                     ForwardIter result, Compare comp);
     
      namespace ranges {
        template<class I1, class I2, class O>
          using set_intersection_result = in_in_out_result<I1, I2, O>;
     
        template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2,
                 sentinel_for<I2> S2, weakly_incrementable O, class Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less),
                 class Proj1 = identity, class Proj2 = identity>
          requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
          constexpr set_intersection_result<I1, I2, O>
            set_intersection(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                             Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
        template<input_range R1, input_range R2, weakly_incrementable O,
                 class Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less), class Proj1 = identity, class Proj2 = identity>
          requires mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
          constexpr set_intersection_result<borrowed_iterator_t<R1>,
                                            borrowed_iterator_t<R2>, O>
            set_intersection(R1&& r1, R2&& r2, O result,
                             Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
      }
     
      template<class InputIter1, class InputIter2, class OutputIter>
        constexpr OutputIter set_difference(InputIter1 first1, InputIter1 last1,
                                            InputIter2 first2, InputIter2 last2,
                                            OutputIter result);
      template<class InputIter1, class InputIter2, class OutputIter, class Compare>
        constexpr OutputIter set_difference(InputIter1 first1, InputIter1 last1,
                                            InputIter2 first2, InputIter2 last2,
                                            OutputIter result, Compare comp);
      template<class ExecutionPolicy, class ForwardIter1, class ForwardIter2,
               class ForwardIter>
        ForwardIter set_difference(ExecutionPolicy&& exec, // freestanding-deleted
                                   ForwardIter1 first1, ForwardIter1 last1,
                                   ForwardIter2 first2, ForwardIter2 last2,
                                   ForwardIter result);
      template<class ExecutionPolicy, class ForwardIter1, class ForwardIter2,
               class ForwardIter, class Compare>
        ForwardIter set_difference(ExecutionPolicy&& exec, // freestanding-deleted
                                   ForwardIter1 first1, ForwardIter1 last1,
                                   ForwardIter2 first2, ForwardIter2 last2,
                                   ForwardIter result, Compare comp);
     
      namespace ranges {
        template<class I, class O>
          using set_difference_result = in_out_result<I, O>;
     
        template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2,
                 sentinel_for<I2> S2, weakly_incrementable O, class Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less),
                 class Proj1 = identity, class Proj2 = identity>
          requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
          constexpr set_difference_result<I1, O>
            set_difference(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                           Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
        template<input_range R1, input_range R2, weakly_incrementable O,
                 class Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less), class Proj1 = identity, class Proj2 = identity>
          requires mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
          constexpr set_difference_result<borrowed_iterator_t<R1>, O>
            set_difference(R1&& r1, R2&& r2, O result,
                           Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
      }
     
      template<class InputIter1, class InputIter2, class OutputIter>
        constexpr OutputIter set_symmetric_difference(InputIter1 first1, InputIter1 last1,
                                                      InputIter2 first2, InputIter2 last2,
                                                      OutputIter result);
      template<class InputIter1, class InputIter2, class OutputIter, class Compare>
        constexpr OutputIter set_symmetric_difference(InputIter1 first1, InputIter1 last1,
                                                      InputIter2 first2, InputIter2 last2,
                                                      OutputIter result, Compare comp);
      template<class ExecutionPolicy, class ForwardIter1, class ForwardIter2,
               class ForwardIter>
        ForwardIter set_symmetric_difference(ExecutionPolicy&& exec, // freestanding-deleted
                                             ForwardIter1 first1, ForwardIter1 last1,
                                             ForwardIter2 first2, ForwardIter2 last2,
                                             ForwardIter result);
      template<class ExecutionPolicy, class ForwardIter1, class ForwardIter2,
               class ForwardIter, class Compare>
        ForwardIter set_symmetric_difference(ExecutionPolicy&& exec, // freestanding-deleted
                                             ForwardIter1 first1, ForwardIter1 last1,
                                             ForwardIter2 first2, ForwardIter2 last2,
                                             ForwardIter result, Compare comp);
     
      namespace ranges {
        template<class I1, class I2, class O>
          using set_symmetric_difference_result = in_in_out_result<I1, I2, O>;
     
        template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2,
                 sentinel_for<I2> S2, weakly_incrementable O, class Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less),
                 class Proj1 = identity, class Proj2 = identity>
          requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
          constexpr set_symmetric_difference_result<I1, I2, O>
            set_symmetric_difference(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                                     Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
        template<input_range R1, input_range R2, weakly_incrementable O,
                 class Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less), class Proj1 = identity, class Proj2 = identity>
          requires mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
          constexpr set_symmetric_difference_result<borrowed_iterator_t<R1>,
                                                    borrowed_iterator_t<R2>, O>
            set_symmetric_difference(R1&& r1, R2&& r2, O result, Comp comp = {},
                                     Proj1 proj1 = {}, Proj2 proj2 = {});
      }
     
      // heap operations
      template<class RandomAccessIter>
        constexpr void push_heap(RandomAccessIter first, RandomAccessIter last);
      template<class RandomAccessIter, class Compare>
        constexpr void push_heap(RandomAccessIter first, RandomAccessIter last,
                                 Compare comp);
     
      namespace ranges {
        template<random_access_iterator I, sentinel_for<I> S,
                 class Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less), class Proj = identity>
          requires sortable<I, Comp, Proj>
          constexpr I push_heap(I first, S last, Comp comp = {}, Proj proj = {});
        template<random_access_range R, class Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less), class Proj = identity>
          requires sortable<iterator_t<R>, Comp, Proj>
          constexpr borrowed_iterator_t<R> push_heap(R&& r, Comp comp = {}, Proj proj = {});
      }
     
      template<class RandomAccessIter>
        constexpr void pop_heap(RandomAccessIter first, RandomAccessIter last);
      template<class RandomAccessIter, class Compare>
        constexpr void pop_heap(RandomAccessIter first, RandomAccessIter last,
                                Compare comp);
     
      namespace ranges {
        template<random_access_iterator I, sentinel_for<I> S,
                 class Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less), class Proj = identity>
          requires sortable<I, Comp, Proj>
          constexpr I pop_heap(I first, S last, Comp comp = {}, Proj proj = {});
        template<random_access_range R, class Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less), class Proj = identity>
          requires sortable<iterator_t<R>, Comp, Proj>
          constexpr borrowed_iterator_t<R> pop_heap(R&& r, Comp comp = {}, Proj proj = {});
      }
     
      template<class RandomAccessIter>
        constexpr void make_heap(RandomAccessIter first, RandomAccessIter last);
      template<class RandomAccessIter, class Compare>
        constexpr void make_heap(RandomAccessIter first, RandomAccessIter last,
                                 Compare comp);
     
      namespace ranges {
        template<random_access_iterator I, sentinel_for<I> S,
                 class Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less), class Proj = identity>
          requires sortable<I, Comp, Proj>
          constexpr I make_heap(I first, S last, Comp comp = {}, Proj proj = {});
        template<random_access_range R, class Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less), class Proj = identity>
          requires sortable<iterator_t<R>, Comp, Proj>
          constexpr borrowed_iterator_t<R> make_heap(R&& r, Comp comp = {}, Proj proj = {});
      }
     
      template<class RandomAccessIter>
        constexpr void sort_heap(RandomAccessIter first, RandomAccessIter last);
      template<class RandomAccessIter, class Compare>
        constexpr void sort_heap(RandomAccessIter first, RandomAccessIter last,
                                 Compare comp);
     
      namespace ranges {
        template<random_access_iterator I, sentinel_for<I> S,
                 class Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less), class Proj = identity>
          requires sortable<I, Comp, Proj>
          constexpr I sort_heap(I first, S last, Comp comp = {}, Proj proj = {});
        template<random_access_range R, class Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less), class Proj = identity>
          requires sortable<iterator_t<R>, Comp, Proj>
          constexpr borrowed_iterator_t<R> sort_heap(R&& r, Comp comp = {}, Proj proj = {});
      }
     
      template<class RandomAccessIter>
        constexpr bool is_heap(RandomAccessIter first, RandomAccessIter last);
      template<class RandomAccessIter, class Compare>
        constexpr bool is_heap(RandomAccessIter first, RandomAccessIter last,
                               Compare comp);
      template<class ExecutionPolicy, class RandomAccessIter>
        bool is_heap(ExecutionPolicy&& exec, // freestanding-deleted
                     RandomAccessIter first, RandomAccessIter last);
      template<class ExecutionPolicy, class RandomAccessIter, class Compare>
        bool is_heap(ExecutionPolicy&& exec, // freestanding-deleted
                     RandomAccessIter first, RandomAccessIter last, Compare comp);
     
      namespace ranges {
        template<random_access_iterator I, sentinel_for<I> S, class Proj = identity,
                 indirect_strict_weak_order<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less)>
          constexpr bool is_heap(I first, S last, Comp comp = {}, Proj proj = {});
        template<random_access_range R, class Proj = identity,
                 indirect_strict_weak_order
                     <[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R>, Proj>> Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less)>
          constexpr bool is_heap(R&& r, Comp comp = {}, Proj proj = {});
      }
     
      template<class RandomAccessIter>
        constexpr RandomAccessIter
          is_heap_until(RandomAccessIter first, RandomAccessIter last);
      template<class RandomAccessIter, class Compare>
        constexpr RandomAccessIter
          is_heap_until(RandomAccessIter first, RandomAccessIter last, Compare comp);
      template<class ExecutionPolicy, class RandomAccessIter>
        RandomAccessIter
          is_heap_until(ExecutionPolicy&& exec, // freestanding-deleted
                        RandomAccessIter first, RandomAccessIter last);
      template<class ExecutionPolicy, class RandomAccessIter, class Compare>
        RandomAccessIter
          is_heap_until(ExecutionPolicy&& exec, // freestanding-deleted
                        RandomAccessIter first, RandomAccessIter last, Compare comp);
     
      namespace ranges {
        template<random_access_iterator I, sentinel_for<I> S, class Proj = identity,
                 indirect_strict_weak_order<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less)>
          constexpr I is_heap_until(I first, S last, Comp comp = {}, Proj proj = {});
        template<random_access_range R, class Proj = identity,
                 indirect_strict_weak_order
                     <[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R>, Proj>> Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less)>
          constexpr borrowed_iterator_t<R>
            is_heap_until(R&& r, Comp comp = {}, Proj proj = {});
      }
     
      // minimum and maximum
      template<class T> constexpr const T& min(const T& a, const T& b);
      template<class T, class Compare>
        constexpr const T& min(const T& a, const T& b, Compare comp);
      template<class T>
        constexpr T min(initializer_list<T> t);
      template<class T, class Compare>
        constexpr T min(initializer_list<T> t, Compare comp);
     
      namespace ranges {
        template<class T, class Proj = identity,
                 indirect_strict_weak_order<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<const T*, Proj>> Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less)>
          constexpr const T& min(const T& a, const T& b, Comp comp = {}, Proj proj = {});
        template<copyable T, class Proj = identity,
                 indirect_strict_weak_order<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<const T*, Proj>> Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less)>
          constexpr T min(initializer_list<T> r, Comp comp = {}, Proj proj = {});
        template<input_range R, class Proj = identity,
                 indirect_strict_weak_order
                     <[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R>, Proj>> Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less)>
          requires indirectly_copyable_storable<iterator_t<R>, range_value_t<R>*>
          constexpr range_value_t<R> min(R&& r, Comp comp = {}, Proj proj = {});
      }
     
      template<class T> constexpr const T& max(const T& a, const T& b);
      template<class T, class Compare>
        constexpr const T& max(const T& a, const T& b, Compare comp);
      template<class T>
        constexpr T max(initializer_list<T> t);
      template<class T, class Compare>
        constexpr T max(initializer_list<T> t, Compare comp);
     
      namespace ranges {
        template<class T, class Proj = identity,
                 indirect_strict_weak_order<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<const T*, Proj>> Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less)>
          constexpr const T& max(const T& a, const T& b, Comp comp = {}, Proj proj = {});
        template<copyable T, class Proj = identity,
                 indirect_strict_weak_order<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<const T*, Proj>> Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less)>
          constexpr T max(initializer_list<T> r, Comp comp = {}, Proj proj = {});
        template<input_range R, class Proj = identity,
                 indirect_strict_weak_order
                     <[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R>, Proj>> Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less)>
          requires indirectly_copyable_storable<iterator_t<R>, range_value_t<R>*>
          constexpr range_value_t<R> max(R&& r, Comp comp = {}, Proj proj = {});
      }
     
      template<class T> constexpr pair<const T&, const T&> minmax(const T& a, const T& b);
      template<class T, class Compare>
        constexpr pair<const T&, const T&> minmax(const T& a, const T& b, Compare comp);
      template<class T>
        constexpr pair<T, T> minmax(initializer_list<T> t);
      template<class T, class Compare>
        constexpr pair<T, T> minmax(initializer_list<T> t, Compare comp);
     
      namespace ranges {
        template<class T>
          using minmax_result = min_max_result<T>;
     
        template<class T, class Proj = identity,
                 indirect_strict_weak_order<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<const T*, Proj>> Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less)>
          constexpr minmax_result<const T&>
            minmax(const T& a, const T& b, Comp comp = {}, Proj proj = {});
        template<copyable T, class Proj = identity,
                 indirect_strict_weak_order<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<const T*, Proj>> Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less)>
          constexpr minmax_result<T>
            minmax(initializer_list<T> r, Comp comp = {}, Proj proj = {});
        template<input_range R, class Proj = identity,
                 indirect_strict_weak_order
                     <[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R>, Proj>> Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less)>
          requires indirectly_copyable_storable<iterator_t<R>, range_value_t<R>*>
          constexpr minmax_result<range_value_t<R>>
            minmax(R&& r, Comp comp = {}, Proj proj = {});
      }
     
      template<class ForwardIter>
        constexpr ForwardIter min_element(ForwardIter first, ForwardIter last);
      template<class ForwardIter, class Compare>
        constexpr ForwardIter min_element(ForwardIter first, ForwardIter last,
                                          Compare comp);
      template<class ExecutionPolicy, class ForwardIter>
        ForwardIter min_element(ExecutionPolicy&& exec, // freestanding-deleted
                                ForwardIter first, ForwardIter last);
      template<class ExecutionPolicy, class ForwardIter, class Compare>
        ForwardIter min_element(ExecutionPolicy&& exec, // freestanding-deleted
                                ForwardIter first, ForwardIter last,
                                Compare comp);
     
      namespace ranges {
        template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
                 indirect_strict_weak_order<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less)>
          constexpr I min_element(I first, S last, Comp comp = {}, Proj proj = {});
        template<forward_range R, class Proj = identity,
                 indirect_strict_weak_order
                     <[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R>, Proj>> Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less)>
          constexpr borrowed_iterator_t<R>
            min_element(R&& r, Comp comp = {}, Proj proj = {});
      }
     
      template<class ForwardIter>
        constexpr ForwardIter max_element(ForwardIter first, ForwardIter last);
      template<class ForwardIter, class Compare>
        constexpr ForwardIter max_element(ForwardIter first, ForwardIter last,
                                          Compare comp);
      template<class ExecutionPolicy, class ForwardIter>
        ForwardIter max_element(ExecutionPolicy&& exec, // freestanding-deleted
                                ForwardIter first, ForwardIter last);
      template<class ExecutionPolicy, class ForwardIter, class Compare>
        ForwardIter max_element(ExecutionPolicy&& exec, // freestanding-deleted
                                ForwardIter first, ForwardIter last,
                                Compare comp);
     
      namespace ranges {
        template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
                 indirect_strict_weak_order<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less)>
          constexpr I max_element(I first, S last, Comp comp = {}, Proj proj = {});
        template<forward_range R, class Proj = identity,
                 indirect_strict_weak_order
                     <[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R>, Proj>> Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less)>
          constexpr borrowed_iterator_t<R>
            max_element(R&& r, Comp comp = {}, Proj proj = {});
      }
     
      template<class ForwardIter>
        constexpr pair<ForwardIter, ForwardIter>
          minmax_element(ForwardIter first, ForwardIter last);
      template<class ForwardIter, class Compare>
        constexpr pair<ForwardIter, ForwardIter>
          minmax_element(ForwardIter first, ForwardIter last, Compare comp);
      template<class ExecutionPolicy, class ForwardIter>
        pair<ForwardIter, ForwardIter>
          minmax_element(ExecutionPolicy&& exec, // freestanding-deleted
                         ForwardIter first, ForwardIter last);
      template<class ExecutionPolicy, class ForwardIter, class Compare>
        pair<ForwardIter, ForwardIter>
          minmax_element(ExecutionPolicy&& exec, // freestanding-deleted
                         ForwardIter first, ForwardIter last, Compare comp);
     
      namespace ranges {
        template<class I>
          using minmax_element_result = min_max_result<I>;
     
        template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
                 indirect_strict_weak_order<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less)>
          constexpr minmax_element_result<I>
            minmax_element(I first, S last, Comp comp = {}, Proj proj = {});
        template<forward_range R, class Proj = identity,
                 indirect_strict_weak_order
                     <[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R>, Proj>> Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less)>
          constexpr minmax_element_result<borrowed_iterator_t<R>>
            minmax_element(R&& r, Comp comp = {}, Proj proj = {});
      }
     
      // bounded value
      template<class T>
        constexpr const T& clamp(const T& v, const T& lo, const T& hi);
      template<class T, class Compare>
        constexpr const T& clamp(const T& v, const T& lo, const T& hi, Compare comp);
     
      namespace ranges {
        template<class T, class Proj = identity,
                 indirect_strict_weak_order<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<const T*, Proj>> Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less)>
          constexpr const T&
            clamp(const T& v, const T& lo, const T& hi, Comp comp = {}, Proj proj = {});
      }
     
      // lexicographical comparison
      template<class InputIter1, class InputIter2>
        constexpr bool lexicographical_compare(InputIter1 first1, InputIter1 last1,
                                               InputIter2 first2, InputIter2 last2);
      template<class InputIter1, class InputIter2, class Compare>
        constexpr bool lexicographical_compare(InputIter1 first1, InputIter1 last1,
                                               InputIter2 first2, InputIter2 last2,
                                               Compare comp);
      template<class ExecutionPolicy, class ForwardIter1, class ForwardIter2>
        bool lexicographical_compare(ExecutionPolicy&& exec, // freestanding-deleted
                                     ForwardIter1 first1, ForwardIter1 last1,
                                     ForwardIter2 first2, ForwardIter2 last2);
      template<class ExecutionPolicy, class ForwardIter1, class ForwardIter2,
               class Compare>
        bool lexicographical_compare(ExecutionPolicy&& exec, // freestanding-deleted
                                     ForwardIter1 first1, ForwardIter1 last1,
                                     ForwardIter2 first2, ForwardIter2 last2,
                                     Compare comp);
     
      namespace ranges {
        template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2,
                 sentinel_for<I2> S2, class Proj1 = identity, class Proj2 = identity,
                 indirect_strict_weak_order
                     <[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I1, Proj1>, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I2, Proj2>> Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less)>
          constexpr bool
            lexicographical_compare(I1 first1, S1 last1, I2 first2, S2 last2,
                                    Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
        template<input_range R1, input_range R2, class Proj1 = identity,
                 class Proj2 = identity,
                 indirect_strict_weak_order
                     <[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R1>, Proj1>,
                                [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R2>, Proj2>> Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less)>
          constexpr bool
            lexicographical_compare(R1&& r1, R2&& r2, Comp comp = {},
                                    Proj1 proj1 = {}, Proj2 proj2 = {});
      }
     
      // three-way comparison algorithms
      template<class InputIter1, class InputIter2, class Cmp>
        constexpr auto lexicographical_compare_three_way(InputIter1 b1, InputIter1 e1,
                                                         InputIter2 b2, InputIter2 e2,
                                                         Cmp comp)
            -> decltype(comp(*b1, *b2));
      template<class InputIter1, class InputIter2>
        constexpr auto lexicographical_compare_three_way(InputIter1 b1, InputIter1 e1,
                                                         InputIter2 b2, InputIter2 e2);
     
      // permutations
      template<class BidirectionalIter>
        constexpr bool next_permutation(BidirectionalIter first,
                                        BidirectionalIter last);
      template<class BidirectionalIter, class Compare>
        constexpr bool next_permutation(BidirectionalIter first,
                                        BidirectionalIter last, Compare comp);
     
      namespace ranges {
        template<class I>
          using next_permutation_result = in_found_result<I>;
     
        template<bidirectional_iterator I, sentinel_for<I> S, class Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less),
                 class Proj = identity>
          requires sortable<I, Comp, Proj>
          constexpr next_permutation_result<I>
            next_permutation(I first, S last, Comp comp = {}, Proj proj = {});
        template<bidirectional_range R, class Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less), class Proj = identity>
          requires sortable<iterator_t<R>, Comp, Proj>
          constexpr next_permutation_result<borrowed_iterator_t<R>>
            next_permutation(R&& r, Comp comp = {}, Proj proj = {});
      }
     
      template<class BidirectionalIter>
        constexpr bool prev_permutation(BidirectionalIter first,
                                        BidirectionalIter last);
      template<class BidirectionalIter, class Compare>
        constexpr bool prev_permutation(BidirectionalIter first,
                                        BidirectionalIter last, Compare comp);
     
      namespace ranges {
        template<class I>
          using prev_permutation_result = in_found_result<I>;
     
        template<bidirectional_iterator I, sentinel_for<I> S, class Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less),
                 class Proj = identity>
          requires sortable<I, Comp, Proj>
          constexpr prev_permutation_result<I>
            prev_permutation(I first, S last, Comp comp = {}, Proj proj = {});
        template<bidirectional_range R, class Comp = [ranges::less](http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less), class Proj = identity>
          requires sortable<iterator_t<R>, Comp, Proj>
          constexpr prev_permutation_result<borrowed_iterator_t<R>>
            prev_permutation(R&& r, Comp comp = {}, Proj proj = {});
      }
    }

#### Class template [std::ranges::in_fun_result](../algorithm/ranges/return_types/in_fun_result.html "cpp/algorithm/ranges/return types/in fun result")
    
    
    namespace std::ranges {
      template<class I, class F>
      struct in_fun_result {
        [[no_unique_address]] I in;
        [[no_unique_address]] F fun;
     
        template<class I2, class F2>
          requires convertible_to<const I&, I2> && convertible_to<const F&, F2>
        constexpr operator in_fun_result<I2, F2>() const & {
          return {in, fun};
        }
     
        template<class I2, class F2>
          requires convertible_to<I, I2> && convertible_to<F, F2>
        constexpr operator in_fun_result<I2, F2>() && {
          return {std::move(in), std::move(fun)};
        }
      };
    }

#### Class template [std::ranges::in_in_result](../algorithm/ranges/return_types/in_in_result.html "cpp/algorithm/ranges/return types/in in result")
    
    
    namespace std::ranges {
      template<class I1, class I2>
      struct in_in_result {
        [[no_unique_address]] I1 in1;
        [[no_unique_address]] I2 in2;
     
        template<class II1, class II2>
          requires convertible_to<const I1&, II1> && convertible_to<const I2&, II2>
        constexpr operator in_in_result<II1, II2>() const & {
          return {in1, in2};
        }
     
        template<class II1, class II2>
          requires convertible_to<I1, II1> && convertible_to<I2, II2>
        constexpr operator in_in_result<II1, II2>() && {
          return {std::move(in1), std::move(in2)};
        }
      };
    }

#### Class template [std::ranges::in_out_result](../algorithm/ranges/return_types/in_out_result.html "cpp/algorithm/ranges/return types/in out result")
    
    
    namespace std::ranges {
      template<class I, class O>
      struct in_out_result {
        [[no_unique_address]] I in;
        [[no_unique_address]] O out;
     
        template<class I2, class O2>
          requires convertible_to<const I&, I2> && convertible_to<const O&, O2>
        constexpr operator in_out_result<I2, O2>() const & {
          return {in, out};
        }
     
        template<class I2, class O2>
          requires convertible_to<I, I2> && convertible_to<O, O2>
        constexpr operator in_out_result<I2, O2>() && {
          return {std::move(in), std::move(out)};
        }
      };
    }

#### Class template [std::ranges::in_in_out_result](../algorithm/ranges/return_types/in_in_out_result.html "cpp/algorithm/ranges/return types/in in out result")
    
    
    namespace std::ranges {
      template<class I1, class I2, class O>
      struct in_in_out_result {
        [[no_unique_address]] I1 in1;
        [[no_unique_address]] I2 in2;
        [[no_unique_address]] O  out;
     
        template<class II1, class II2, class OO>
          requires convertible_to<const I1&, II1> &&
                   convertible_to<const I2&, II2> &&
                   convertible_to<const O&, OO>
        constexpr operator in_in_out_result<II1, II2, OO>() const & {
          return {in1, in2, out};
        }
     
        template<class II1, class II2, class OO>
          requires convertible_to<I1, II1> &&
                   convertible_to<I2, II2> &&
                   convertible_to<O, OO>
        constexpr operator in_in_out_result<II1, II2, OO>() && {
          return {std::move(in1), std::move(in2), std::move(out)};
        }
      };
    }

#### Class template [std::ranges::in_out_out_result](../algorithm/ranges/return_types/in_out_out_result.html "cpp/algorithm/ranges/return types/in out out result")
    
    
    namespace std::ranges {
      template<class I, class O1, class O2>
      struct in_out_out_result {
        [[no_unique_address]] I  in;
        [[no_unique_address]] O1 out1;
        [[no_unique_address]] O2 out2;
     
        template<class II, class OO1, class OO2>
          requires convertible_to<const I&, II> &&
                   convertible_to<const O1&, OO1> &&
                   convertible_to<const O2&, OO2>
        constexpr operator in_out_out_result<II, OO1, OO2>() const & {
          return {in, out1, out2};
        }
     
        template<class II, class OO1, class OO2>
          requires convertible_to<I, II> &&
                   convertible_to<O1, OO1> &&
                   convertible_to<O2, OO2>
        constexpr operator in_out_out_result<II, OO1, OO2>() && {
          return {std::move(in), std::move(out1), std::move(out2)};
        }
      };
    }

#### Class template [std::ranges::min_max_result](../algorithm/ranges/return_types/min_max_result.html "cpp/algorithm/ranges/return types/min max result")
    
    
    namespace std::ranges {
      template<class T>
      struct min_max_result {
        [[no_unique_address]] T min;
        [[no_unique_address]] T max;
     
        template<class T2>
          requires convertible_to<const T&, T2>
        constexpr operator min_max_result<T2>() const & {
          return {min, max};
        }
     
        template<class T2>
          requires convertible_to<T, T2>
        constexpr operator min_max_result<T2>() && {
          return {std::move(min), std::move(max)};
        }
      };
    }

#### Class template [std::ranges::in_found_result](../algorithm/ranges/return_types/in_found_result.html "cpp/algorithm/ranges/return types/in found result")
    
    
    namespace std::ranges {
      template<class I>
      struct in_found_result {
        [[no_unique_address]] I in;
        bool found;
     
        template<class I2>
          requires convertible_to<const I&, I2>
        constexpr operator in_found_result<I2>() const & {
          return {in, found};
        }
        template<class I2>
          requires convertible_to<I, I2>
        constexpr operator in_found_result<I2>() && {
          return {std::move(in), found};
        }
      };
    }

#### Class template std::ranges::in_value_result
    
    
    namespace std::ranges {
    template<class I, class T>
      struct in_value_result {
        [[no_unique_address]] I in;
        [[no_unique_address]] T value;
     
        template<class I2, class T2>
          requires convertible_to<const I&, I2> && convertible_to<const T&, T2>
        constexpr operator in_value_result<I2, T2>() const & {
          return {in, value};
        }
     
        template<class I2, class T2>
          requires convertible_to<I, I2> && convertible_to<T, T2>
        constexpr operator in_value_result<I2, T2>() && {
          return {std::move(in), std::move(value)};
        }
      };
    }

#### Class template std::ranges::out_value_result
    
    
    namespace std::ranges {
    template<class O, class T>
      struct out_value_result {
        [[no_unique_address]] O out;
        [[no_unique_address]] T value;
     
        template<class O2, class T2>
          requires convertible_to<const O&, O2> && convertible_to<const T&, T2>
        constexpr operator out_value_result<O2, T2>() const & {
          return {out, value};
        }
     
        template<class O2, class T2>
          requires convertible_to<O, O2> && convertible_to<T, T2>
        constexpr operator out_value_result<O2, T2>() && {
          return {std::move(out), std::move(value)};
        }
      };
    }
