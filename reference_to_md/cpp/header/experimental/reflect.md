[C++](../../../cpp.html "cpp")

[Compiler support](../../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../../freestanding.html "cpp/freestanding")  
[Language](../../language.html "cpp/language")  
[Standard library](../../standard_library.html "cpp/standard library")  
[Standard library headers](../../headers.html "cpp/header")  
[Named requirements](../../iterator/concepts.html "cpp/named req")  
[Feature test macros](../../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../../utility.html#Language_support "cpp/utility")  
[Concepts library](../../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../../error.html "cpp/error")  
[Memory management library](../../memory.html "cpp/memory")  
[Metaprogramming library](../../meta.html "cpp/meta") (C++11)  
[General utilities library](../../utility.html "cpp/utility")  
[Containers library](../../container.html "cpp/container")  
[Iterators library](../../iterator.html "cpp/iterator")  
[Ranges library](../../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../../algorithm.html "cpp/algorithm")  
[Strings library](../../string.html "cpp/string")  
[Text processing library](../../text.html "cpp/text")  
[Numerics library](../../numeric.html "cpp/numeric")  
[Date and time library](../../chrono.html "cpp/chrono")  
[Input/output library](../../io.html "cpp/io")  
[Filesystem library](../../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../../atomic.html "cpp/thread") (C++11)  
[Execution control library](../../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../../experimental.html "cpp/experimental")  
[Symbols index](../../symbol_index.html "cpp/symbol index")  
[External libraries](../../links/libs.html "cpp/links/libs")  
  


[Standard library headers](../../headers.html "cpp/header")

| [Language support](../../headers.html#Language_support_library "cpp/header")  
---  
[`<cfloat>`](../cfloat.html "cpp/header/cfloat")  
[`<climits>`](../climits.html "cpp/header/climits")  
[`<compare>`](../compare.html "cpp/header/compare") (C++20)  
[`<contracts>`](../contracts.html "cpp/header/contracts") (C++26)  
[`<coroutine>`](../coroutine.html "cpp/header/coroutine") (C++20)  
[`<csetjmp>`](../csetjmp.html "cpp/header/csetjmp")  
[`<csignal>`](../csignal.html "cpp/header/csignal")  
[`<cstdarg>`](../cstdarg.html "cpp/header/cstdarg")  
[`<cstddef>`](../cstddef.html "cpp/header/cstddef")  
[`<cstdint>`](../cstdint.html "cpp/header/cstdint") (C++11)  
[`<cstdlib>`](../cstdlib.html "cpp/header/cstdlib")  
[`<exception>`](../exception.html "cpp/header/exception")  
[`<initializer_list>`](../initializer_list.html "cpp/header/initializer list") (C++11)` `  
[`<limits>`](../limits.html "cpp/header/limits")  
[`<new>`](../new.html "cpp/header/new")  
[`<source_location>`](../source_location.html "cpp/header/source location") (C++20)  
[`<stdfloat>`](../stdfloat.html "cpp/header/stdfloat") (C++23)  
[`<typeinfo>`](../typeinfo.html "cpp/header/typeinfo")  
[`<version>`](../version.html "cpp/header/version") (C++20)  
[Concepts](../../headers.html#Concepts_library "cpp/header")  
[`<concepts>`](../concepts.html "cpp/header/concepts") (C++20)  
[Diagnostics](../../headers.html#Diagnostics_library "cpp/header")  
[`<cassert>`](../cassert.html "cpp/header/cassert")  
[`<cerrno>`](../cerrno.html "cpp/header/cerrno")  
[`<debugging>`](../debugging.html "cpp/header/debugging") (C++26)  
[`<stacktrace>`](../stacktrace.html "cpp/header/stacktrace") (C++23)  
[`<stdexcept>`](../stdexcept.html "cpp/header/stdexcept")  
[`<system_error>`](../system_error.html "cpp/header/system error") (C++11)  
[Memory management](../../headers.html#Memory_management_library "cpp/header")  
[`<memory>`](../memory.html "cpp/header/memory")  
[`<memory_resource>`](../memory_resource.html "cpp/header/memory resource") (C++17)  
[`<scoped_allocator>`](../scoped_allocator.html "cpp/header/scoped allocator") (C++11)  
[Metaprogramming](../../headers.html#Metaprogramming_library "cpp/header")  
[`<type_traits>`](../type_traits.html "cpp/header/type traits") (C++11)  
[`<ratio>`](../ratio.html "cpp/header/ratio") (C++11)  
  
  
  
| [General utilities](../../headers.html#General_utilities_library "cpp/header")  
---  
[`<any>`](../any.html "cpp/header/any") (C++17)  
[`<bitset>`](../bitset.html "cpp/header/bitset")  
[`<bit>`](../bit.html "cpp/header/bit") (C++20)  
[`<charconv>`](../charconv.html "cpp/header/charconv") (C++17)  
[`<expected>`](../expected.html "cpp/header/expected") (C++23)  
[`<format>`](../format.html "cpp/header/format") (C++20)  
[`<functional>`](../functional.html "cpp/header/functional")  
[`<optional>`](../optional.html "cpp/header/optional") (C++17)  
[`<stdbit.h>`](../stdbit.h.html "cpp/header/stdbit.h") (C++26)  
[`<tuple>`](../tuple.html "cpp/header/tuple") (C++11)  
[`<typeindex>`](../typeindex.html "cpp/header/typeindex") (C++11)  
[`<utility>`](../utility.html "cpp/header/utility")  
[`<variant>`](../variant.html "cpp/header/variant") (C++17)  
[Containers](../../headers.html#Containers_library "cpp/header")  
[`<array>`](../array.html "cpp/header/array") (C++11)  
[`<deque>`](../deque.html "cpp/header/deque")  
[`<flat_map>`](../flat_map.html "cpp/header/flat map") (C++23)  
[`<flat_set>`](../flat_set.html "cpp/header/flat set") (C++23)  
[`<forward_list>`](../forward_list.html "cpp/header/forward list") (C++11)  
[`<hive>`](../hive.html "cpp/header/hive") (C++26)  
[`<inplace_vector>`](../inplace_vector.html "cpp/header/inplace vector") (C++26)` `  
[`<list>`](../list.html "cpp/header/list")  
[`<map>`](../map.html "cpp/header/map")  
[`<mdspan>`](../mdspan.html "cpp/header/mdspan") (C++23)  
[`<queue>`](../queue.html "cpp/header/queue")  
[`<set>`](../set.html "cpp/header/set")  
[`<span>`](../span.html "cpp/header/span") (C++20)  
[`<stack>`](../stack.html "cpp/header/stack")  
[`<unordered_map>`](../unordered_map.html "cpp/header/unordered map") (C++11)  
[`<unordered_set>`](../unordered_set.html "cpp/header/unordered set") (C++11)  
[`<vector>`](../vector.html "cpp/header/vector")  
[Iterators](../../headers.html#Iterators_library "cpp/header")  
[`<iterator>`](../iterator.html "cpp/header/iterator")  
[Ranges](../../headers.html#Ranges_library "cpp/header")  
[`<generator>`](../generator.html "cpp/header/generator") (C++23)  
[`<ranges>`](../ranges.html "cpp/header/ranges") (C++20)  
  
| [Algorithms](../../headers.html#Algorithms_library "cpp/header")  
---  
[`<algorithm>`](../algorithm.html "cpp/header/algorithm")  
[`<numeric>`](../numeric.html "cpp/header/numeric")  
[Strings](../../headers.html#Strings_library "cpp/header")  
[`<cctype>`](../cctype.html "cpp/header/cctype")  
[`<cstring>`](../cstring.html "cpp/header/cstring")  
[`<cuchar>`](../cuchar.html "cpp/header/cuchar") (C++11)  
[`<cwchar>`](../cwchar.html "cpp/header/cwchar")  
[`<cwctype>`](../cwctype.html "cpp/header/cwctype")  
[`<string_view>`](../string_view.html "cpp/header/string view") (C++17)  
[`<string>`](../string.html "cpp/header/string")  
[Text processing](../../headers.html#Text_processing_library "cpp/header")  
[`<clocale>`](../clocale.html "cpp/header/clocale")  
[`<codecvt>`](../codecvt.html "cpp/header/codecvt") (C++11/17/26*)  
[`<locale>`](../locale.html "cpp/header/locale")  
[`<regex>`](../regex.html "cpp/header/regex") (C++11)  
[`<text_encoding>`](../text_encoding.html "cpp/header/text encoding") (C++26)` `  
[Numerics](../../headers.html#Numerics_library "cpp/header")  
[`<cfenv>`](../cfenv.html "cpp/header/cfenv") (C++11)  
[`<cmath>`](../cmath.html "cpp/header/cmath")  
[`<complex>`](../complex.html "cpp/header/complex")  
[`<linalg>`](../linalg.html "cpp/header/linalg") (C++26)  
[`<numbers>`](../numbers.html "cpp/header/numbers") (C++20)  
[`<random>`](../random.html "cpp/header/random") (C++11)  
[`<simd>`](../simd.html "cpp/header/simd") (C++26)  
[`<stdckdint.h>`](../stdckdint.h.html "cpp/header/stdckdint.h") (C++26)  
[`<valarray>`](../valarray.html "cpp/header/valarray")  
[Time](../../headers.html#Time_library "cpp/header")  
[`<chrono>`](../chrono.html "cpp/header/chrono") (C++11)  
[`<ctime>`](../ctime.html "cpp/header/ctime")  
[C compatibility](../../headers.html#C_compatibility_headers "cpp/header")  
[`<ccomplex>`](../ccomplex.html "cpp/header/ccomplex") (C++11/17/20*)  
[`<ciso646>`](../ciso646.html "cpp/header/ciso646") (until C++20)  
[`<cstdalign>`](../cstdalign.html "cpp/header/cstdalign") (C++11/17/20*)  
[`<cstdbool>`](../cstdbool.html "cpp/header/cstdbool") (C++11/17/20*)  
[`<ctgmath>`](../ctgmath.html "cpp/header/ctgmath") (C++11/17/20*)  
  
| [Input/output](../../headers.html#Input.2Foutput_library "cpp/header")  
---  
[`<cinttypes>`](../cinttypes.html "cpp/header/cinttypes") (C++11)  
[`<cstdio>`](../cstdio.html "cpp/header/cstdio")  
[`<filesystem>`](../filesystem.html "cpp/header/filesystem") (C++17)  
[`<fstream>`](../fstream.html "cpp/header/fstream")  
[`<iomanip>`](../iomanip.html "cpp/header/iomanip")  
[`<iosfwd>`](../iosfwd.html "cpp/header/iosfwd")  
[`<iostream>`](../iostream.html "cpp/header/iostream")  
[`<ios>`](../ios.html "cpp/header/ios")  
[`<istream>`](../istream.html "cpp/header/istream")  
[`<ostream>`](../ostream.html "cpp/header/ostream")  
[`<print>`](../print.html "cpp/header/print") (C++23)  
[`<spanstream>`](../spanstream.html "cpp/header/spanstream") (C++23)  
[`<sstream>`](../sstream.html "cpp/header/sstream")  
[`<streambuf>`](../streambuf.html "cpp/header/streambuf")  
[`<strstream>`](../strstream.html "cpp/header/strstream") (C++98/26*)  
[`<syncstream>`](../syncstream.html "cpp/header/syncstream") (C++20)  
[Concurrency support](../../headers.html#Concurrency_support_library "cpp/header")  
[`<atomic>`](../atomic.html "cpp/header/atomic") (C++11)  
[`<barrier>`](../barrier.html "cpp/header/barrier") (C++20)  
[`<condition_variable>`](../condition_variable.html "cpp/header/condition variable") (C++11)  
[`<future>`](../future.html "cpp/header/future") (C++11)  
[`<hazard_pointer>`](../hazard_pointer.html "cpp/header/hazard pointer") (C++26)  
[`<latch>`](../latch.html "cpp/header/latch") (C++20)  
[`<mutex>`](../mutex.html "cpp/header/mutex") (C++11)  
[`<rcu>`](../rcu.html "cpp/header/rcu") (C++26)  
[`<semaphore>`](../semaphore.html "cpp/header/semaphore") (C++20)  
[`<shared_mutex>`](../shared_mutex.html "cpp/header/shared mutex") (C++14)  
[`<stdatomic.h>`](../stdatomic.h.html "cpp/header/stdatomic.h") (C++23)  
[`<stop_token>`](../stop_token.html "cpp/header/stop token") (C++20)  
[`<thread>`](../thread.html "cpp/header/thread") (C++11)  
[Execution support](../../headers.html#Multi-purpose_headers "cpp/header")  
[`<execution>`](../execution.html "cpp/header/execution") (C++17)  
  
  
  
  
  
  
  
  
  


[Experimental library headers](../experimental.html "cpp/header/experimental")

Execution [P2300](https://wg21.link/P2300)  
---  
[`<experimental/execution>`](execution.html "cpp/header/experimental/execution")  
Filesystem TS  
[`<experimental/filesystem>`](filesystem.html "cpp/header/experimental/filesystem")  
Parallelism TS (v1, v2)  
| `experimental/algorithm`  
---  
`experimental/execution_policy`  
`experimental/exception_list`  
  
| `experimental/numeric`  
---  
[`<experimental/simd>`](simd.html "cpp/header/experimental/simd")  
`experimental/task_block`  
  
Library Fundamentals TS (v1, v2, v3)  
| `experimental/algorithm`  
---  
[`<experimental/any>`](any.html "cpp/header/experimental/any")  
`experimental/array`  
`experimental/chrono`  
`experimental/deque`  
`experimental/forward_list`  
[`<experimental/functional>`](functional.html "cpp/header/experimental/functional")  
`experimental/future`  
`experimental/iterator`  
`experimental/list`  
`experimental/map`  
`experimental/memory`  
[`<experimental/memory_resource>`](memory_resource.html "cpp/header/experimental/memory resource")  
`experimental/numeric`  
[`<experimental/optional>`](optional.html "cpp/header/experimental/optional")  
`experimental/propagate_const`  
  
| `experimental/random`  
---  
`experimental/ratio`  
`experimental/regex`  
`experimental/scope`  
`experimental/set`  
`experimental/source_location`  
`experimental/string`  
[`<experimental/string_view>`](string_view.html "cpp/header/experimental/string view")  
`experimental/system_error`  
`experimental/tuple`  
`experimental/type_traits`  
`experimental/unordered_map`  
`experimental/unordered_set`  
`experimental/utility`  
`experimental/vector`  
  
  
  
Concurrency TS  
| `experimental/atomic`  
---  
`experimental/barrier`  
  
| `experimental/future`  
---  
`experimental/latch`  
  
Ranges TS  
| [`<experimental/ranges/algorithm>`](ranges/algorithm.html "cpp/header/experimental/ranges/algorithm")  
---  
[`<experimental/ranges/concepts>`](ranges/concepts.html "cpp/header/experimental/ranges/concepts")  
[`<experimental/ranges/functional>`](ranges/functional.html "cpp/header/experimental/ranges/functional")  
[`<experimental/ranges/iterator>`](ranges/iterator.html "cpp/header/experimental/ranges/iterator")  
  
| [`<experimental/ranges/random>`](ranges/random.html "cpp/header/experimental/ranges/random")  
---  
[`<experimental/ranges/tuple>`](ranges/tuple.html "cpp/header/experimental/ranges/tuple")  
[`<experimental/ranges/type_traits>`](ranges/type_traits.html "cpp/header/experimental/ranges/type traits")  
[`<experimental/ranges/utility>`](ranges/utility.html "cpp/header/experimental/ranges/utility")  
  
Coroutines TS  
`experimental/coroutine`  
Networking TS  
| `experimental/buffer`  
---  
`experimental/executor`  
`experimental/internet`  
`experimental/io_context`  
  
| [`<experimental/net>`](net.html "cpp/header/experimental/net")  
---  
`experimental/netfwd`  
`experimental/socket`  
`experimental/timer`  
  
Reflection TS  
**`< experimental/reflect>`**  
  


This header is part of the [Reflection TS](../../experimental/reflect.html "cpp/experimental/reflect"). 

Defined in namespace `std::experimental::reflect`  
---  
Defined in inline namespace `std::experimental::reflect::v1`  
| 

## Contents

  * [1 Concepts](reflect.html#Concepts)
  * [2 Classes](reflect.html#Classes)
    * [2.1 Object operations](reflect.html#Object_operations)
    * [2.2 ObjectSequence operations](reflect.html#ObjectSequence_operations)
    * [2.3 Named operations](reflect.html#Named_operations)
    * [2.4 Alias operations](reflect.html#Alias_operations)
    * [2.5 Type operations](reflect.html#Type_operations)
    * [2.6 ScopeMember operations](reflect.html#ScopeMember_operations)
    * [2.7 Base operations](reflect.html#Base_operations)
    * [2.8 RecordMember and Base operations](reflect.html#RecordMember_and_Base_operations)
    * [2.9 Record operations](reflect.html#Record_operations)
    * [2.10 Enum operations](reflect.html#Enum_operations)
    * [2.11 Variable operations](reflect.html#Variable_operations)
    * [2.12 FunctionParameter operations](reflect.html#FunctionParameter_operations)
    * [2.13 Callable operations](reflect.html#Callable_operations)
    * [2.14 Variable and Callable operations](reflect.html#Variable_and_Callable_operations)
    * [2.15 Namespace and Callable operations](reflect.html#Namespace_and_Callable_operations)
    * [2.16 ParenthesizedExpression operations](reflect.html#ParenthesizedExpression_operations)
    * [2.17 FunctionCallExpression operations](reflect.html#FunctionCallExpression_operations)
    * [2.18 FunctionalTypeConversion operations](reflect.html#FunctionalTypeConversion_operations)
    * [2.19 Variable and Function operations](reflect.html#Variable_and_Function_operations)
    * [2.20 MemberFunction operations](reflect.html#MemberFunction_operations)
    * [2.21 Record and MemberFunction operations](reflect.html#Record_and_MemberFunction_operations)
    * [2.22 Variable and MemberFunction operations](reflect.html#Variable_and_MemberFunction_operations)
    * [2.23 SpecialMemberFunction operations](reflect.html#SpecialMemberFunction_operations)
    * [2.24 Constructor and ConversionOperator operations](reflect.html#Constructor_and_ConversionOperator_operations)
    * [2.25 MemberFunction and Destructor operations](reflect.html#MemberFunction_and_Destructor_operations)
    * [2.26 Lambda operations](reflect.html#Lambda_operations)
    * [2.27 LambdaCapture operations](reflect.html#LambdaCapture_operations)
  * [3 Synopsis](reflect.html#Synopsis)

  
---  
  
###  Concepts  
  
[ Object](../../experimental/reflect/Object.html "cpp/experimental/reflect/Object")(reflection TS) |  specifies that a type is a meta-object type   
(concept)  
[ ObjectSequence](../../experimental/reflect/ObjectSequence.html "cpp/experimental/reflect/ObjectSequence")(reflection TS) |  specifies that a meta-object type is a meta-object sequence type   
(concept)  
[ TemplateParameterScope](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/TemplateParameterScope&action=edit&redlink=1 "cpp/experimental/reflect/TemplateParameterScope \(page does not exist\)")(reflection TS) |  specifies that a meta-object type reflects a template parameter scope   
(concept)  
[ Named](../../experimental/reflect/Named.html "cpp/experimental/reflect/Named")(reflection TS) |  specifies that a meta-object type reflects an entity or alias with an associated (possibly empty) name   
(concept)  
[ Alias](../../experimental/reflect/Alias.html "cpp/experimental/reflect/Alias")(reflection TS) |  specifies that a meta-object type reflects a type alias, namespace alias, or an alias introduced by a using-declaration   
(concept)  
[ RecordMember](../../experimental/reflect/RecordMember.html "cpp/experimental/reflect/RecordMember")(reflection TS) |  specifies that a meta-object type reflects a member-declaration of a class   
(concept)  
[ Enumerator](../../experimental/reflect/Enumerator.html "cpp/experimental/reflect/Enumerator")(reflection TS) |  specifies that a meta-object type reflects an enumerator   
(concept)  
[ Variable](../../experimental/reflect/Variable.html "cpp/experimental/reflect/Variable")(reflection TS) |  specifies that a meta-object type reflects a variable or data member   
(concept)  
[ ScopeMember](../../experimental/reflect/ScopeMember.html "cpp/experimental/reflect/ScopeMember")(reflection TS) |  specifies that a meta-object type satisfies `RecordMember`, `Enumerator`, or `Variable`, or reflects a namespace other than the global namespace   
(concept)  
[ Typed](../../experimental/reflect/Typed.html "cpp/experimental/reflect/Typed")(reflection TS) |  specifies that a meta-object type reflects an entity with a type   
(concept)  
[ Namespace](../../experimental/reflect/Namespace.html "cpp/experimental/reflect/Namespace")(reflection TS) |  specifies that a meta-object type reflects a namespace   
(concept)  
[ GlobalScope](../../experimental/reflect/GlobalScope.html "cpp/experimental/reflect/GlobalScope")(reflection TS) |  specifies that a meta-object type reflects the global namespace   
(concept)  
[ Class](../../experimental/reflect/Class.html "cpp/experimental/reflect/Class")(reflection TS) |  specifies that a meta-object type reflects a non-union class type   
(concept)  
[ Enum](../../experimental/reflect/Enum.html "cpp/experimental/reflect/Enum")(reflection TS) |  specifies that a meta-object type reflects an enumeration type   
(concept)  
[ Record](../../experimental/reflect/Record.html "cpp/experimental/reflect/Record")(reflection TS) |  specifies that a meta-object type reflects a class type   
(concept)  
[ Scope](../../experimental/reflect/Scope.html "cpp/experimental/reflect/Scope")(reflection TS) |  specifies that a meta-object type reflects a namespace, class, enumeration, function, closure type, a template parameter scope   
(concept)  
[ Type](../../experimental/reflect/Type.html "cpp/experimental/reflect/Type")(reflection TS) |  specifies that a meta-object type reflects a type   
(concept)  
[ Constant](../../experimental/reflect/Constant.html "cpp/experimental/reflect/Constant")(reflection TS) |  specifies that a meta-object type reflects an enumerator or a constexpr variable   
(concept)  
[ Base](../../experimental/reflect/Base.html "cpp/experimental/reflect/Base")(reflection TS) |  specifies that a meta-object type reflects a direct base class obtained from `get_base_classes`   
(concept)  
[ FunctionParameter](../../experimental/reflect/FunctionParameter.html "cpp/experimental/reflect/FunctionParameter")(reflection TS) |  specifies that a meta-object type reflects a function parameter   
(concept)  
[ Callable](../../experimental/reflect/Callable.html "cpp/experimental/reflect/Callable")(reflection TS) |  specifies that a meta-object type reflects a function (including constructors and destructors)   
(concept)  
[ Expression](../../experimental/reflect/Expression.html "cpp/experimental/reflect/Expression")(reflection TS) |  specifies that a meta-object type reflects an expression   
(concept)  
[ ParenthesizedExpression](../../experimental/reflect/ParenthesizedExpression.html "cpp/experimental/reflect/ParenthesizedExpression")(reflection TS) |  specifies that a meta-object type reflects a parenthesized expression   
(concept)  
[ FunctionCallExpression](../../experimental/reflect/FunctionCallExpression.html "cpp/experimental/reflect/FunctionCallExpression")(reflection TS) |  specifies that a meta-object type reflects a function-call-expression   
(concept)  
[ FunctionalTypeConversion](../../experimental/reflect/FunctionalTypeConversion.html "cpp/experimental/reflect/FunctionalTypeConversion")(reflection TS) |  specifies that a meta-object type reflects a functional-type-conv-expression   
(concept)  
[ Function](../../experimental/reflect/Function.html "cpp/experimental/reflect/Function")(reflection TS) |  specifies that a meta-object type reflects a function (excluding constructors and destructors)   
(concept)  
[ MemberFunction](../../experimental/reflect/MemberFunction.html "cpp/experimental/reflect/MemberFunction")(reflection TS) |  specifies that a meta-object type reflects a member function (excluding constructors and destructors)   
(concept)  
[ SpecialMemberFunction](../../experimental/reflect/SpecialMemberFunction.html "cpp/experimental/reflect/SpecialMemberFunction")(reflection TS) |  specifies that a meta-object type reflects a special member function   
(concept)  
[ Constructor](../../experimental/reflect/Constructor.html "cpp/experimental/reflect/Constructor")(reflection TS) |  specifies that a meta-object type reflects a constructor   
(concept)  
[ Destructor](../../experimental/reflect/Destructor.html "cpp/experimental/reflect/Destructor")(reflection TS) |  specifies that a meta-object type reflects a destructor   
(concept)  
[ Operator](../../experimental/reflect/Operator.html "cpp/experimental/reflect/Operator")(reflection TS) |  specifies that a meta-object type reflects an operator function or a conversion function   
(concept)  
[ ConversionOperator](../../experimental/reflect/ConversionOperator.html "cpp/experimental/reflect/ConversionOperator")(reflection TS) |  specifies that a meta-object type reflects a conversion function   
(concept)  
[ Lambda](../../experimental/reflect/Lambda.html "cpp/experimental/reflect/Lambda")(reflection TS) |  specifies that a meta-object type reflects the closure type of a non-generic lambda   
(concept)  
[ LambdaCapture](../../experimental/reflect/LambdaCapture.html "cpp/experimental/reflect/LambdaCapture")(reflection TS) |  specifies that a meta-object type reflects a lambda capture   
(concept)  
  
###  Classes  
  
#####  `Object` operations   
  
[ reflects_same](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/reflects_same&action=edit&redlink=1 "cpp/experimental/reflect/reflects same \(page does not exist\)")(reflection TS) |  checks if two meta-object types reflect the same entity or alias   
(class template)  
[ get_source_line](../../experimental/reflect/get_source_line.html "cpp/experimental/reflect/get source line")(reflection TS) |  obtains the presumed line number of the declaration of the reflected entity or alias   
(class template)  
[ get_source_column](../../experimental/reflect/get_source_column.html "cpp/experimental/reflect/get source column")(reflection TS) |  obtains the implementation-defined column number of the declaration of the reflected entity or alias   
(class template)  
[ get_source_file_name](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/get_source_file_name&action=edit&redlink=1 "cpp/experimental/reflect/get source file name \(page does not exist\)")(reflection TS) |  obtains the presumed file name of the declaration of the reflected entity or alias   
(class template)  
  
#####  `ObjectSequence` operations   
  
[ get_size](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/get_size&action=edit&redlink=1 "cpp/experimental/reflect/get size \(page does not exist\)")(reflection TS) |  obtains the size of a meta-object sequence   
(class template)  
[ get_element](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/get_element&action=edit&redlink=1 "cpp/experimental/reflect/get element \(page does not exist\)")(reflection TS) |  obtains the meta-object type with specified index in a sequence   
(class template)  
[ unpack_sequence](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/unpack_sequence&action=edit&redlink=1 "cpp/experimental/reflect/unpack sequence \(page does not exist\)")(reflection TS) |  applies a template to the meta-object sequence   
(class template)  
  
#####  `Named` operations   
  
[ is_unnamed](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/is_unnamed&action=edit&redlink=1 "cpp/experimental/reflect/is unnamed \(page does not exist\)")(reflection TS) |  checks if the reflected entity or alias is named   
(class template)  
[ get_name](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/get_name&action=edit&redlink=1 "cpp/experimental/reflect/get name \(page does not exist\)")(reflection TS) |  obtains the unqualified name of the reflected entity or alias   
(class template)  
[ get_display_name](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/get_display_name&action=edit&redlink=1 "cpp/experimental/reflect/get display name \(page does not exist\)")(reflection TS) |  obtains the implementation-defined display name of the reflected entity or alias   
(class template)  
  
#####  `Alias` operations   
  
[ get_alias](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/get_alias&action=edit&redlink=1 "cpp/experimental/reflect/get alias \(page does not exist\)")(reflection TS) |  obtains the meta-object type reflecting the associated entity of the reflected alias   
(class template)  
  
#####  `Type` operations   
  
[ get_type](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/get_type&action=edit&redlink=1 "cpp/experimental/reflect/get type \(page does not exist\)")(reflection TS) |  obtains the meta-object type reflecting the type of the reflected entity or alias   
(class template)  
[ get_reflected_type](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/get_reflected_type&action=edit&redlink=1 "cpp/experimental/reflect/get reflected type \(page does not exist\)")(reflection TS) |  obtains the type of the reflected entity or alias   
(class template)  
[ is_enum](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/is_enum&action=edit&redlink=1 "cpp/experimental/reflect/is enum \(page does not exist\)")(reflection TS) |  checks if the meta-object type reflects an enumeration type   
(class template)  
[ is_union](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/is_union&action=edit&redlink=1 "cpp/experimental/reflect/is union \(page does not exist\)")(reflection TS) |  checks if the meta-object type reflects a union type   
(class template)  
[ uses_class_keyuses_struct_key](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/uses_key&action=edit&redlink=1 "cpp/experimental/reflect/uses key \(page does not exist\)")(reflection TS) |  checks if the meta-object type reflects a non-union class type whose declaration uses class or struct respectively   
(class template)  
  
#####  `ScopeMember` operations   
  
[ get_scope](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/get_scope&action=edit&redlink=1 "cpp/experimental/reflect/get scope \(page does not exist\)")(reflection TS) |  obtains the meta-object type reflecting the scope of the reflected entity or alias   
(class template)  
  
#####  `Base` operations   
  
[ get_class](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/get_class&action=edit&redlink=1 "cpp/experimental/reflect/get class \(page does not exist\)")(reflection TS) |  obtains the meta-object type reflecting the base class in the given base class relationship   
(class template)  
  
#####  `RecordMember` and `Base` operations   
  
[ is_public](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/is_public&action=edit&redlink=1 "cpp/experimental/reflect/is public \(page does not exist\)")(reflection TS) |  checks if the reflected member or base class is public   
(class template)  
[ is_protected](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/is_protected&action=edit&redlink=1 "cpp/experimental/reflect/is protected \(page does not exist\)")(reflection TS) |  checks if the reflected member or base class is protected   
(class template)  
[ is_private](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/is_private&action=edit&redlink=1 "cpp/experimental/reflect/is private \(page does not exist\)")(reflection TS) |  checks if the reflected member or base class is private   
(class template)  
  
#####  `Record` operations   
  
[ get_public_data_membersget_accessible_data_membersget_data_members](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/get_data_members&action=edit&redlink=1 "cpp/experimental/reflect/get data members \(page does not exist\)")(reflection TS) |  obtains a meta-object sequence type whose elements reflect public, accessible, or all data members of the reflected class   
(class template)  
[ get_public_member_functionsget_accessible_member_functionsget_member_functions](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/get_member_functions&action=edit&redlink=1 "cpp/experimental/reflect/get member functions \(page does not exist\)")(reflection TS) |  obtains a meta-object sequence type whose elements reflect public, accessible, or all member functions of the reflected class   
(class template)  
[ get_constructors](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/get_constructors&action=edit&redlink=1 "cpp/experimental/reflect/get constructors \(page does not exist\)")(reflection TS) |  obtains a meta-object sequence type whose elements reflect all constructors of the reflected class   
(class template)  
[ get_operators](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/get_operators&action=edit&redlink=1 "cpp/experimental/reflect/get operators \(page does not exist\)")(reflection TS) |  obtains a meta-object sequence type whose elements reflect all operator functions and conversion functions declared in the reflected class   
(class template)  
[ get_destructor](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/get_destructor&action=edit&redlink=1 "cpp/experimental/reflect/get destructor \(page does not exist\)")(reflection TS) |  obtains the meta-object type reflecting the destructor of the reflected class   
(class template)  
[ get_public_member_typesget_accessible_member_typesget_member_types](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/get_member_types&action=edit&redlink=1 "cpp/experimental/reflect/get member types \(page does not exist\)")(reflection TS) |  obtains a meta-object sequence type whose elements reflect public, accessible, or all nested type or member typedefs of the reflected class   
(class template)  
[ get_public_base_classesget_accessible_base_classesget_base_classes](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/get_base_classes&action=edit&redlink=1 "cpp/experimental/reflect/get base classes \(page does not exist\)")(reflection TS) |  obtains a meta-object sequence type whose elements reflect public, accessible, or all base classes of the reflected class   
(class template)  
  
#####  `Enum` operations   
  
[ is_scoped_enum](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/is_scoped_enum&action=edit&redlink=1 "cpp/experimental/reflect/is scoped enum \(page does not exist\)")(reflection TS) |  checks whether the reflected enumeration is scoped   
(class template)  
[ get_enumerators](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/get_enumerators&action=edit&redlink=1 "cpp/experimental/reflect/get enumerators \(page does not exist\)")(reflection TS) |  obtains a meta-object sequence type whose elements reflects the enumerators of the reflected enumeration   
(class template)  
[ get_underlying_type](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/get_underlying_type&action=edit&redlink=1 "cpp/experimental/reflect/get underlying type \(page does not exist\)")(reflection TS) |  obtains the meta-object type reflecting the underlying type of the reflected enumeration   
(class template)  
  
#####  `Variable` operations   
  
[ get_constant](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/get_constant&action=edit&redlink=1 "cpp/experimental/reflect/get constant \(page does not exist\)")(reflection TS) |  obtains the value of the reflected variable which is a constant expression   
(class template)  
[ is_thread_local](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/is_thread_local&action=edit&redlink=1 "cpp/experimental/reflect/is thread local \(page does not exist\)")(reflection TS) |  checks if the variable is declared with thread_local   
(class template)  
  
#####  `FunctionParameter` operations   
  
[ has_default_argument](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/has_default_argument&action=edit&redlink=1 "cpp/experimental/reflect/has default argument \(page does not exist\)")(reflection TS) |  checks whether the reflected parameter has a default argument   
(class template)  
  
#####  `Callable` operations   
  
[ get_parameters](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/get_parameters&action=edit&redlink=1 "cpp/experimental/reflect/get parameters \(page does not exist\)")(reflection TS) |  obtains a meta-object sequence type whose elements reflects the parameters of the reflected function   
(class template)  
[ is_vararg](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/is_vararg&action=edit&redlink=1 "cpp/experimental/reflect/is vararg \(page does not exist\)")(reflection TS) |  checks whether the parameter list of the reflected function contains an ellipsis parameter   
(class template)  
[ is_noexcept](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/is_noexcept&action=edit&redlink=1 "cpp/experimental/reflect/is noexcept \(page does not exist\)")(reflection TS) |  checks whether the reflected function is non-throwing   
(class template)  
[ is_deleted](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/is_deleted&action=edit&redlink=1 "cpp/experimental/reflect/is deleted \(page does not exist\)")(reflection TS) |  checks whether the reflected function is deleted   
(class template)  
  
#####  `Variable` and `Callable` operations   
  
[ is_constexpr](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/is_constexpr&action=edit&redlink=1 "cpp/experimental/reflect/is constexpr \(page does not exist\)")(reflection TS) |  checks if the reflected variable or function is constexpr   
(class template)  
  
#####  `Namespace` and `Callable` operations   
  
[ is_inline](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/is_inline&action=edit&redlink=1 "cpp/experimental/reflect/is inline \(page does not exist\)")(reflection TS) |  checks whether the reflected namespace or function is inline   
(class template)  
  
#####  `ParenthesizedExpression` operations   
  
[ get_subexpression](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/get_subexpression&action=edit&redlink=1 "cpp/experimental/reflect/get subexpression \(page does not exist\)")(reflection TS) |  obtains the meta-object type reflecting the unparenthesized expression of the reflected parethesized expression   
(class template)  
  
#####  `FunctionCallExpression` operations   
  
[ get_callable](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/get_callable&action=edit&redlink=1 "cpp/experimental/reflect/get callable \(page does not exist\)")(reflection TS) |  obtains the meta-object type reflecting the function in the reflected function-call-expression   
(class template)  
  
#####  `FunctionalTypeConversion` operations   
  
[ get_constructor](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/get_constructor&action=edit&redlink=1 "cpp/experimental/reflect/get constructor \(page does not exist\)")(reflection TS) |  obtains the meta-object type reflecting the constructor in reflected functional-type-conv-expression   
(class template)  
  
#####  `Variable` and `Function` operations   
  
[ get_pointer](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/get_pointer&action=edit&redlink=1 "cpp/experimental/reflect/get pointer \(page does not exist\)")(reflection TS) |  get the address of the reflected variable or function, or the pointer-to-member value to the reflected non-static member   
(class template)  
  
#####  `MemberFunction` operations   
  
[ is_constis_volatilehas_lvalueref_qualifierhas_rvalueref_qualifier](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/is_qualified&action=edit&redlink=1 "cpp/experimental/reflect/is qualified \(page does not exist\)")(reflection TS) |  checks if the reflected member function is declared with const, volatile, &, or && qualifier respectively   
(class template)  
[ is_override](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/is_override&action=edit&redlink=1 "cpp/experimental/reflect/is override \(page does not exist\)")(reflection TS) |  checks if the reflected member function overrides a member function of base class   
(class template)  
  
#####  `Record` and `MemberFunction` operations   
  
[ is_final](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/is_final&action=edit&redlink=1 "cpp/experimental/reflect/is final \(page does not exist\)")(reflection TS) |  checks if the reflected class or member function is marked with final   
(class template)  
  
#####  `Variable` and `MemberFunction` operations   
  
[ is_static](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/is_static&action=edit&redlink=1 "cpp/experimental/reflect/is static \(page does not exist\)")(reflection TS) |  checks if the reflected variable is of static storage duration, or the reflected member function is static   
(class template)  
  
#####  `SpecialMemberFunction` operations   
  
[ is_implicitly_declared](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/is_implicitly_declared&action=edit&redlink=1 "cpp/experimental/reflect/is implicitly declared \(page does not exist\)")(reflection TS) |  checks if the reflected special member function is implicitly declared   
(class template)  
[ is_defaulted](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/is_defaulted&action=edit&redlink=1 "cpp/experimental/reflect/is defaulted \(page does not exist\)")(reflection TS) |  checks if the reflected special member function is defaulted in its first declaration   
(class template)  
  
#####  `Constructor` and `ConversionOperator` operations   
  
[ is_explicit](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/is_explicit&action=edit&redlink=1 "cpp/experimental/reflect/is explicit \(page does not exist\)")(reflection TS) |  checks if the reflected constructor or conversion function is declared with explicit   
(class template)  
  
#####  `MemberFunction` and `Destructor` operations   
  
[ is_virtual](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/is_virtual&action=edit&redlink=1 "cpp/experimental/reflect/is virtual \(page does not exist\)")(reflection TS) |  checks if the reflected member function is virtual   
(class template)  
[ is_pure_virtual](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/is_pure_virtual&action=edit&redlink=1 "cpp/experimental/reflect/is pure virtual \(page does not exist\)")(reflection TS) |  checks if the reflected member function is pure virtual   
(class template)  
  
#####  `Lambda` operations   
  
[ get_captures](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/get_captures&action=edit&redlink=1 "cpp/experimental/reflect/get captures \(page does not exist\)")(reflection TS) |  obtains a meta-object sequence type whose elements reflect the captures of the reflected closure type   
(class template)  
[ uses_default_copy_captureuses_default_reference_capture](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/uses_default_capture&action=edit&redlink=1 "cpp/experimental/reflect/uses default capture \(page does not exist\)")(reflection TS) |  checks if the capture-default of the lambda expression of the reflected closure type is `=` or `&` respectively   
(class template)  
[ is_call_operator_const](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/is_call_operator_const&action=edit&redlink=1 "cpp/experimental/reflect/is call operator const \(page does not exist\)")(reflection TS) |  checks if the `operator()` of the reflected closure type is declared with const   
(class template)  
  
#####  `LambdaCapture` operations   
  
[ is_explictly_captured](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/is_explictly_captured&action=edit&redlink=1 "cpp/experimental/reflect/is explictly captured \(page does not exist\)")(reflection TS) |  checks if the reflected lambda capture is explicitly captured   
(class template)  
[ is_init_capture](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/reflect/is_init_capture&action=edit&redlink=1 "cpp/experimental/reflect/is init capture \(page does not exist\)")(reflection TS) |  checks if the reflected lambda capture is an init-capture   
(class template)  
  
### Synopsis
    
    
    namespace std::experimental::reflect {
    inline namespace v1 {
     
    // 21.12.3 Concepts for meta-object types
    template <class T>
    concept Object = /* see description */;
    template <class T>
    concept ObjectSequence = /* see description */; // refines Object
    template <class T>
    concept TemplateParameterScope = /* see description */; // refines Scope
    template <class T>
    concept Named = /* see description */;          // refines Object
    template <class T>
    concept Alias = /* see description */;          // refines Named and ScopeMember
    template <class T>
    concept RecordMember = /* see description */;   // refines ScopeMember
    template <class T>
    concept Enumerator = /* see description */;     // refines Constant
    template <class T>
    concept Variable = /* see description */;       // refines Typed and ScopeMember
    template <class T>
    concept ScopeMember = /* see description */;    // refines Named
    template <class T>
    concept Typed = /* see description */;          // refines Object
    template <class T>
    concept Namespace = /* see description */;      // refines Named and Scope
    template <class T>
    concept GlobalScope = /* see description */;    // refines Namespace
    template <class T>
    concept Class = /* see description */;          // refines Record
    template <class T>
    concept Enum = /* see description */;           // refines Type, Scope, and ScopeMember
    template <class T>
    concept Record = /* see description */;         // refines Type, Scope, and ScopeMember
    template <class T>
    concept Scope = /* see description */;          // refines Object
    template <class T>
    concept Type = /* see description */;           // refines Named
    template <class T>
    concept Constant = /* see description */;       // refines Typed and ScopeMember
    template <class T>
    concept Base = /* see description */;           // refines Object
    template <class T>
    concept FunctionParameter = /* see description */; // refines Typed and ScopeMember
    template <class T>
    concept Callable = /* see description */;       // refines Scope and ScopeMember
    template <class T>
    concept Expression = /* see description */;     // refines Object
    template <class T>
    concept ParenthesizedExpression = /* see description */; // refines Expression
    template <class T>
    concept FunctionCallExpression = /* see description */; // refines Expression
    template <class T>
    concept FunctionalTypeConversion = /* see description */; // refines Expression
    template <class T>
    concept Function = /* see description */;       // refines Typed and Callable
    template <class T>
    concept MemberFunction = /* see description */; // refines RecordMember and Function
    template <class T>
    concept SpecialMemberFunction = /* see description */; // refines RecordMember
    template <class T>
    concept Constructor = /* see description */;    // refines Callable and RecordMember
    template <class T>
    concept Destructor = /* see description */;     // refines Callable and SpecialMemberFunction
    template <class T>
    concept Operator = /* see description */;       // refines Function
    template <class T>
    concept ConversionOperator = /* see description */; // refines MemberFunction and Operator
    template <class T>
    concept Lambda = /* see description */;         // refines Type and Scope
    template <class T>
    concept LambdaCapture = /* see description */;  // refines Variable
     
    // 21.12.4 Meta-object operations
    // Multi-concept operations
    template <Object T> struct is_public;
    template <Object T> struct is_protected;
    template <Object T> struct is_private;
    template <Object T> struct is_constexpr;
    template <Object T> struct is_static;
    template <Object T> struct is_final;
    template <Object T> struct is_explicit;
    template <Object T> struct is_inline;
    template <Object T> struct is_virtual;
    template <Object T> struct is_pure_virtual;
    template <Object T> struct get_pointer;
     
    template <class T>
    requires RecordMember<T> || Base<T>
      constexpr auto is_public_v = is_public<T>::value;
    template <class T>
    requires RecordMember<T> || Base<T>
      constexpr auto is_protected_v = is_protected<T>::value;
    template <class T>
    requires RecordMember<T> || Base<T>
      constexpr auto is_private_v = is_private<T>::value;
    template <class T>
    requires Variable<T> || Callable<T>
      constexpr auto is_constexpr_v = is_constexpr<T>::value;
    template <class T>
    requires Variable<T> || MemberFunction<T>
      constexpr auto is_static_v = is_static<T>::value;
    template <class T>
    requires Class<T> || MemberFunction<T>
      constexpr auto is_final_v = is_final<T>::value;
    template <class T>
    requires Constructor<T> || ConversionOperator<T>
      constexpr auto is_explicit_v = is_explicit<T>::value;
    template <class T>
    requires Namespace<T> || Callable<T>
      constexpr auto is_inline_v = is_inline<T>::value;
    template <class T>
    requires Base<T> || MemberFunction<T> || Destructor<T>
      constexpr auto is_virtual_v = is_virtual<T>::value;
    template <class T>
    requires MemberFunction<T> || Destructor<T>
      constexpr auto is_pure_virtual_v = is_pure_virtual<T>::value;
    template <class T>
    requires Variable<T> || Function<T>
      constexpr auto get_pointer_v = get_pointer<T>::value;
     
    // 21.12.4.1 Object operations
    template <Object T1, Object T2> struct reflects_same;
    template <Object T> struct get_source_line;
    template <Object T> struct get_source_column;
    template <Object T> struct get_source_file_name;
     
    template <Object T1, Object T2>
      constexpr auto reflects_same_v = reflects_same<T1, T2>::value;
    template <class T>
      constexpr auto get_source_line_v = get_source_line<T>::value;
    template <class T>
      constexpr auto get_source_column_v = get_source_column<T>::value;
    template <class T>
      constexpr auto get_source_file_name_v = get_source_file_name<T>::value;
     
    // 21.12.4.2 ObjectSequence operations
    template <ObjectSequence T> struct get_size;
    template <size_t I, ObjectSequence T> struct get_element;
    template <template <class...> class Tpl, ObjectSequence T>
      struct unpack_sequence;
     
    template <ObjectSequence T>
      constexpr auto get_size_v = get_size<T>::value;
    template <size_t I, ObjectSequence T>
      using get_element_t = typename get_element<I, T>::type;
    template <template <class...> class Tpl, ObjectSequence T>
      using unpack_sequence_t = typename unpack_sequence<Tpl, T>::type;
     
    // 21.12.4.3 Named operations
    template <Named T> struct is_unnamed;
    template <Named T> struct get_name;
    template <Named T> struct get_display_name;
     
    template <Named T>
      constexpr auto is_unnamed_v = is_unnamed<T>::value;
    template <Named T>
      constexpr auto get_name_v = get_name<T>::value;
    template <Named T>
      constexpr auto get_display_name_v = get_display_name<T>::value;
     
    // 21.12.4.4 Alias operations
    template <Alias T> struct get_aliased;
     
    template <Alias T>
      using get_aliased_t = typename get_aliased<T>::type;
     
    // 21.12.4.5 Type operations
    template <Typed T> struct get_type;
    template <Type T> struct get_reflected_type;
    template <Type T> struct is_enum;
    template <Class T> struct uses_class_key;
    template <Class T> struct uses_struct_key;
    template <Type T> struct is_union;
     
    template <Typed T>
      using get_type_t = typename get_type<T>::type;
    template <Type T>
      using get_reflected_type_t = typename get_reflected_type<T>::type;
    template <Type T>
      constexpr auto is_enum_v = is_enum<T>::value;
    template <Class T>
      constexpr auto uses_class_key_v = uses_class_key<T>::value;
    template <Class T>
      constexpr auto uses_struct_key_v = uses_struct_key<T>::value;
    template <Type T>
      constexpr auto is_union_v = is_union<T>::value;
     
    // 21.12.4.6 Member operations
    template <ScopeMember T> struct get_scope;
    template <RecordMember T> struct is_public<T>;
    template <RecordMember T> struct is_protected<T>;
    template <RecordMember T> struct is_private<T>;
    template <ScopeMember T>
      using get_scope_t = typename get_scope<T>::type;
     
    // 21.12.4.7 Record operations
    template <Record T> struct get_public_data_members;
    template <Record T> struct get_accessible_data_members;
    template <Record T> struct get_data_members;
    template <Record T> struct get_public_member_functions;
    template <Record T> struct get_accessible_member_functions;
    template <Record T> struct get_member_functions;
    template <Record T> struct get_public_member_types;
    template <Record T> struct get_accessible_member_types;
    template <Record T> struct get_member_types;
    template <Record T> struct get_constructors;
    template <Record T> struct get_destructor;
    template <Record T> struct get_operators;
    template <Class T> struct get_public_base_classes;
    template <Class T> struct get_accessible_base_classes;
    template <Class T> struct get_base_classes;
    template <Class T> struct is_final<T>;
     
    template <Record T>
      using get_public_data_members_t = typename get_public_data_members<T>::type;
    template <Record T>
      using get_accessible_data_members_t = typename get_accessible_data_members<T>::type;
    template <Record T>
      using get_data_members_t = typename get_data_members<T>::type;
    template <Record T>
      using get_public_member_functions_t = typename get_public_member_functions<T>::type;
    template <Record T>
      using get_accessible_member_functions_t = typename get_accessible_member_functions<T>::type;
    template <Record T>
      using get_member_functions_t = typename get_member_functions<T>::type;
    template <Record T>
      using get_public_member_types_t = typename get_public_member_types<T>::type;
    template <Record T>
      using get_accessible_member_types_t = typename get_accessible_member_types<T>::type;
    template <Record T>
      using get_member_types_t = typename get_member_types<T>::type;
    template <Record T>
      using get_constructors_t = typename get_constructors<T>::type;
    template <Record T>
      using get_destructor_t = typename get_destructor<T>::type;
    template <Record T>
      using get_operators_t = typename get_operators<T>::type;
    template <Class T>
      using get_public_base_classes_t = typename get_public_base_classes<T>::type;
    template <Class T>
      using get_accessible_base_classes_t = typename get_accessible_base_classes<T>::type;
    template <Class T>
      using get_base_classes_t = typename get_base_classes<T>::type;
     
    // 21.12.4.8 Enum operations
    template <Enum T> struct is_scoped_enum;
    template <Enum T> struct get_enumerators;
    template <Enum T> struct get_underlying_type;
     
    template <Enum T>
      constexpr auto is_scoped_enum_v = is_scoped_enum<T>::value;
    template <Enum T>
      using get_enumerators_t = typename get_enumerators<T>::type;
    template <Enum T>
      using get_underlying_type_t = typename get_underlying_type<T>::type;
     
    // 21.12.4.9 Value operations
    template <Constant T> struct get_constant;
    template <Variable T> struct is_constexpr<T>;
    template <Variable T> struct is_static<T>;
    template <Variable T> struct is_thread_local;
    template <Variable T> struct get_pointer<T>;
     
    template <Constant T>
      constexpr auto get_constant_v = get_constant<T>::value;
    template <Variable T>
      constexpr auto is_thread_local_v = is_thread_local<T>::value;
     
    // 21.12.4.10 Base operations
    template <Base T> struct get_class;
    template <Base T> struct is_virtual<T>;
    template <Base T> struct is_public<T>;
    template <Base T> struct is_protected<T>;
    template <Base T> struct is_private<T>;
     
    template <Base T>
      using get_class_t = typename get_class<T>::type;
     
    // 21.12.4.11 Namespace operations
    template <Namespace T> struct is_inline<T>;
     
    // 21.12.4.12 FunctionParameter operations
    template <FunctionParameter T> struct has_default_argument;
     
    template <FunctionParameter T>
      constexpr auto has_default_argument_v = has_default_argument<T>::value;
     
    // 21.12.4.13 Callable operations
    template <Callable T> struct get_parameters;
    template <Callable T> struct is_vararg;
    template <Callable T> struct is_constexpr<T>;
    template <Callable T> struct is_noexcept;
    template <Callable T> struct is_inline<T>;
    template <Callable T> struct is_deleted;
     
    template <Callable T>
      using get_parameters_t = typename get_parameters<T>::type;
    template <Callable T>
      constexpr auto is_vararg_v = is_vararg<T>::value;
    template <Callable T>
      constexpr auto is_deleted_v = is_deleted<T>::value;
     
    // 21.12.4.14 ParenthesizedExpression operations
    template <ParenthesizedExpression T> struct get_subexpression;
     
    template <ParenthesizedExpression T>
      using get_subexpression_t = typename get_subexpression<T>::type;
     
    // 21.12.4.15 FunctionCallExpression operations
    template <FunctionCallExpression T> struct get_callable;
     
    template <FunctionCallExpression T>
      using get_callable_t = typename get_callable<T>::type;
     
    // 21.12.4.16 FunctionalTypeConversion operations
    template <FunctionalTypeConversion T> struct get_constructor;
     
    template <FunctionalTypeConversion T>
      using get_constructor_t = typename get_constructor<T>::type;
     
    // 21.12.4.17 Function operations
    template <Function T> struct get_pointer<T>;
     
    // 21.12.4.18 MemberFunction operations
    template <MemberFunction T> struct is_static<T>;
    template <MemberFunction T> struct is_const;
    template <MemberFunction T> struct is_volatile;
    template <MemberFunction T> struct has_lvalueref_qualifier;
    template <MemberFunction T> struct has_rvalueref_qualifier;
    template <MemberFunction T> struct is_virtual<T>;
    template <MemberFunction T> struct is_pure_virtual<T>;
    template <MemberFunction T> struct is_override;
    template <MemberFunction T> struct is_final<T>;
     
    template <MemberFunction T>
      constexpr auto is_const_v = is_const<T>::value;
    template <MemberFunction T>
      constexpr auto is_volatile_v = is_volatile<T>::value;
    template <MemberFunction T>
      constexpr auto has_lvalueref_qualifier_v = has_lvalueref_qualifier<T>::value;
    template <MemberFunction T>
      constexpr auto has_rvalueref_qualifier_v = has_rvalueref_qualifier<T>::value;
    template <MemberFunction T>
      constexpr auto is_override_v = is_override<T>::value;
     
    // 21.12.4.19 SpecialMemberFunction operations
    template <SpecialMemberFunction T> struct is_implicitly_declared;
    template <SpecialMemberFunction T> struct is_defaulted;
     
    template <SpecialMemberFunction T>
      constexpr auto is_implicitly_declared_v = is_implicitly_declared<T>::value;
    template <SpecialMemberFunction T>
      constexpr auto is_defaulted_v = is_defaulted<T>::value;
     
    // 21.12.4.20 Constructor operations
    template <Constructor T> struct is_explicit<T>;
     
    // 21.12.4.21 Destructor operations
    template <Destructor T> struct is_virtual<T>;
    template <Destructor T> struct is_pure_virtual<T>;
     
    // 21.12.4.22 ConversionOperator operations
    template <ConversionOperator T> struct is_explicit<T>;
     
    // 21.12.4.23 Lambda operations
    template <Lambda T> struct get_captures;
    template <Lambda T> struct uses_default_copy_capture;
    template <Lambda T> struct uses_default_reference_capture;
    template <Lambda T> struct is_call_operator_const;
     
    template <Lambda T>
      using get_captures_t = typename get_captures<T>::type;
    template <Lambda T>
      constexpr auto uses_default_copy_capture_v = uses_default_copy_capture<T>::value;
    template <Lambda T>
      constexpr auto uses_default_reference_capture_v = uses_default_reference_capture<T>::value;
    template <Lambda T>
      constexpr auto is_call_operator_const_v = is_call_operator_const<T>::value;
     
    // 21.12.4.24 LambdaCapture operations
    template <LambdaCapture T> struct is_explicitly_captured;
    template <LambdaCapture T> struct is_init_capture;
     
    template <LambdaCapture T>
      constexpr auto is_explicitly_captured_v = is_explicitly_captured<T>::value;
    template <LambdaCapture T>
      constexpr auto is_init_capture_v = is_init_capture<T>::value;
     
    } // inline namespace v1
    } // namespace std::experimental::reflect
