[C++](../../../../cpp.html "cpp")

[Compiler support](../../../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../../../freestanding.html "cpp/freestanding")  
[Language](../../../language.html "cpp/language")  
[Standard library](../../../standard_library.html "cpp/standard library")  
[Standard library headers](../../../headers.html "cpp/header")  
[Named requirements](../../../iterator/concepts.html "cpp/named req")  
[Feature test macros](../../../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../../../utility.html#Language_support "cpp/utility")  
[Concepts library](../../../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../../../error.html "cpp/error")  
[Memory management library](../../../memory.html "cpp/memory")  
[Metaprogramming library](../../../meta.html "cpp/meta") (C++11)  
[General utilities library](../../../utility.html "cpp/utility")  
[Containers library](../../../container.html "cpp/container")  
[Iterators library](../../../iterator.html "cpp/iterator")  
[Ranges library](../../../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../../../algorithm.html "cpp/algorithm")  
[Strings library](../../../string.html "cpp/string")  
[Text processing library](../../../text.html "cpp/text")  
[Numerics library](../../../numeric.html "cpp/numeric")  
[Date and time library](../../../chrono.html "cpp/chrono")  
[Input/output library](../../../io.html "cpp/io")  
[Filesystem library](../../../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../../../atomic.html "cpp/thread") (C++11)  
[Execution control library](../../../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../../../experimental.html "cpp/experimental")  
[Symbols index](../../../symbol_index.html "cpp/symbol index")  
[External libraries](../../../links/libs.html "cpp/links/libs")  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/navbar_content&action=edit)

[Standard library headers](../../../headers.html "cpp/header")

| [Language support](../../../headers.html#Language_support_library "cpp/header")  
---  
[`<cfloat>`](../../cfloat.html "cpp/header/cfloat")  
[`<climits>`](../../climits.html "cpp/header/climits")  
[`<compare>`](../../compare.html "cpp/header/compare") (C++20)  
[`<contracts>`](../../contracts.html "cpp/header/contracts") (C++26)  
[`<coroutine>`](../../coroutine.html "cpp/header/coroutine") (C++20)  
[`<csetjmp>`](../../csetjmp.html "cpp/header/csetjmp")  
[`<csignal>`](../../csignal.html "cpp/header/csignal")  
[`<cstdarg>`](../../cstdarg.html "cpp/header/cstdarg")  
[`<cstddef>`](../../cstddef.html "cpp/header/cstddef")  
[`<cstdint>`](../../cstdint.html "cpp/header/cstdint") (C++11)  
[`<cstdlib>`](../../cstdlib.html "cpp/header/cstdlib")  
[`<exception>`](../../exception.html "cpp/header/exception")  
[`<initializer_list>`](../../initializer_list.html "cpp/header/initializer list") (C++11)` `  
[`<limits>`](../../limits.html "cpp/header/limits")  
[`<new>`](../../new.html "cpp/header/new")  
[`<source_location>`](../../source_location.html "cpp/header/source location") (C++20)  
[`<stdfloat>`](../../stdfloat.html "cpp/header/stdfloat") (C++23)  
[`<typeinfo>`](../../typeinfo.html "cpp/header/typeinfo")  
[`<version>`](../../version.html "cpp/header/version") (C++20)  
[Concepts](../../../headers.html#Concepts_library "cpp/header")  
[`<concepts>`](../../concepts.html "cpp/header/concepts") (C++20)  
[Diagnostics](../../../headers.html#Diagnostics_library "cpp/header")  
[`<cassert>`](../../cassert.html "cpp/header/cassert")  
[`<cerrno>`](../../cerrno.html "cpp/header/cerrno")  
[`<debugging>`](../../debugging.html "cpp/header/debugging") (C++26)  
[`<stacktrace>`](../../stacktrace.html "cpp/header/stacktrace") (C++23)  
[`<stdexcept>`](../../stdexcept.html "cpp/header/stdexcept")  
[`<system_error>`](../../system_error.html "cpp/header/system error") (C++11)  
[Memory management](../../../headers.html#Memory_management_library "cpp/header")  
[`<memory>`](../../memory.html "cpp/header/memory")  
[`<memory_resource>`](../../memory_resource.html "cpp/header/memory resource") (C++17)  
[`<scoped_allocator>`](../../scoped_allocator.html "cpp/header/scoped allocator") (C++11)  
[Metaprogramming](../../../headers.html#Metaprogramming_library "cpp/header")  
[`<type_traits>`](../../type_traits.html "cpp/header/type traits") (C++11)  
[`<ratio>`](../../ratio.html "cpp/header/ratio") (C++11)  
  
  
  
| [General utilities](../../../headers.html#General_utilities_library "cpp/header")  
---  
[`<any>`](../../any.html "cpp/header/any") (C++17)  
[`<bitset>`](../../bitset.html "cpp/header/bitset")  
[`<bit>`](../../bit.html "cpp/header/bit") (C++20)  
[`<charconv>`](../../charconv.html "cpp/header/charconv") (C++17)  
[`<expected>`](../../expected.html "cpp/header/expected") (C++23)  
[`<format>`](../../format.html "cpp/header/format") (C++20)  
[`<functional>`](../../functional.html "cpp/header/functional")  
[`<optional>`](../../optional.html "cpp/header/optional") (C++17)  
[`<stdbit.h>`](../../stdbit.h.html "cpp/header/stdbit.h") (C++26)  
[`<tuple>`](../../tuple.html "cpp/header/tuple") (C++11)  
[`<typeindex>`](../../typeindex.html "cpp/header/typeindex") (C++11)  
[`<utility>`](../../utility.html "cpp/header/utility")  
[`<variant>`](../../variant.html "cpp/header/variant") (C++17)  
[Containers](../../../headers.html#Containers_library "cpp/header")  
[`<array>`](../../array.html "cpp/header/array") (C++11)  
[`<deque>`](../../deque.html "cpp/header/deque")  
[`<flat_map>`](../../flat_map.html "cpp/header/flat map") (C++23)  
[`<flat_set>`](../../flat_set.html "cpp/header/flat set") (C++23)  
[`<forward_list>`](../../forward_list.html "cpp/header/forward list") (C++11)  
[`<hive>`](../../hive.html "cpp/header/hive") (C++26)  
[`<inplace_vector>`](../../inplace_vector.html "cpp/header/inplace vector") (C++26)` `  
[`<list>`](../../list.html "cpp/header/list")  
[`<map>`](../../map.html "cpp/header/map")  
[`<mdspan>`](../../mdspan.html "cpp/header/mdspan") (C++23)  
[`<queue>`](../../queue.html "cpp/header/queue")  
[`<set>`](../../set.html "cpp/header/set")  
[`<span>`](../../span.html "cpp/header/span") (C++20)  
[`<stack>`](../../stack.html "cpp/header/stack")  
[`<unordered_map>`](../../unordered_map.html "cpp/header/unordered map") (C++11)  
[`<unordered_set>`](../../unordered_set.html "cpp/header/unordered set") (C++11)  
[`<vector>`](../../vector.html "cpp/header/vector")  
[Iterators](../../../headers.html#Iterators_library "cpp/header")  
[`<iterator>`](../../iterator.html "cpp/header/iterator")  
[Ranges](../../../headers.html#Ranges_library "cpp/header")  
[`<generator>`](../../generator.html "cpp/header/generator") (C++23)  
[`<ranges>`](../../ranges.html "cpp/header/ranges") (C++20)  
  
| [Algorithms](../../../headers.html#Algorithms_library "cpp/header")  
---  
[`<algorithm>`](../../algorithm.html "cpp/header/algorithm")  
[`<numeric>`](../../numeric.html "cpp/header/numeric")  
[Strings](../../../headers.html#Strings_library "cpp/header")  
[`<cctype>`](../../cctype.html "cpp/header/cctype")  
[`<cstring>`](../../cstring.html "cpp/header/cstring")  
[`<cuchar>`](../../cuchar.html "cpp/header/cuchar") (C++11)  
[`<cwchar>`](../../cwchar.html "cpp/header/cwchar")  
[`<cwctype>`](../../cwctype.html "cpp/header/cwctype")  
[`<string_view>`](../../string_view.html "cpp/header/string view") (C++17)  
[`<string>`](../../string.html "cpp/header/string")  
[Text processing](../../../headers.html#Text_processing_library "cpp/header")  
[`<clocale>`](../../clocale.html "cpp/header/clocale")  
[`<codecvt>`](../../codecvt.html "cpp/header/codecvt") (C++11/17/26*)  
[`<locale>`](../../locale.html "cpp/header/locale")  
[`<regex>`](../../regex.html "cpp/header/regex") (C++11)  
[`<text_encoding>`](../../text_encoding.html "cpp/header/text encoding") (C++26)` `  
[Numerics](../../../headers.html#Numerics_library "cpp/header")  
[`<cfenv>`](../../cfenv.html "cpp/header/cfenv") (C++11)  
[`<cmath>`](../../cmath.html "cpp/header/cmath")  
[`<complex>`](../../complex.html "cpp/header/complex")  
[`<linalg>`](../../linalg.html "cpp/header/linalg") (C++26)  
[`<numbers>`](../../numbers.html "cpp/header/numbers") (C++20)  
[`<random>`](../../random.html "cpp/header/random") (C++11)  
[`<simd>`](../../simd.html "cpp/header/simd") (C++26)  
[`<stdckdint.h>`](../../stdckdint.h.html "cpp/header/stdckdint.h") (C++26)  
[`<valarray>`](../../valarray.html "cpp/header/valarray")  
[Time](../../../headers.html#Time_library "cpp/header")  
[`<chrono>`](../../chrono.html "cpp/header/chrono") (C++11)  
[`<ctime>`](../../ctime.html "cpp/header/ctime")  
[C compatibility](../../../headers.html#C_compatibility_headers "cpp/header")  
[`<ccomplex>`](../../ccomplex.html "cpp/header/ccomplex") (C++11/17/20*)  
[`<ciso646>`](../../ciso646.html "cpp/header/ciso646") (until C++20)  
[`<cstdalign>`](../../cstdalign.html "cpp/header/cstdalign") (C++11/17/20*)  
[`<cstdbool>`](../../cstdbool.html "cpp/header/cstdbool") (C++11/17/20*)  
[`<ctgmath>`](../../ctgmath.html "cpp/header/ctgmath") (C++11/17/20*)  
  
| [Input/output](../../../headers.html#Input.2Foutput_library "cpp/header")  
---  
[`<cinttypes>`](../../cinttypes.html "cpp/header/cinttypes") (C++11)  
[`<cstdio>`](../../cstdio.html "cpp/header/cstdio")  
[`<filesystem>`](../../filesystem.html "cpp/header/filesystem") (C++17)  
[`<fstream>`](../../fstream.html "cpp/header/fstream")  
[`<iomanip>`](../../iomanip.html "cpp/header/iomanip")  
[`<iosfwd>`](../../iosfwd.html "cpp/header/iosfwd")  
[`<iostream>`](../../iostream.html "cpp/header/iostream")  
[`<ios>`](../../ios.html "cpp/header/ios")  
[`<istream>`](../../istream.html "cpp/header/istream")  
[`<ostream>`](../../ostream.html "cpp/header/ostream")  
[`<print>`](../../print.html "cpp/header/print") (C++23)  
[`<spanstream>`](../../spanstream.html "cpp/header/spanstream") (C++23)  
[`<sstream>`](../../sstream.html "cpp/header/sstream")  
[`<streambuf>`](../../streambuf.html "cpp/header/streambuf")  
[`<strstream>`](../../strstream.html "cpp/header/strstream") (C++98/26*)  
[`<syncstream>`](../../syncstream.html "cpp/header/syncstream") (C++20)  
[Concurrency support](../../../headers.html#Concurrency_support_library "cpp/header")  
[`<atomic>`](../../atomic.html "cpp/header/atomic") (C++11)  
[`<barrier>`](../../barrier.html "cpp/header/barrier") (C++20)  
[`<condition_variable>`](../../condition_variable.html "cpp/header/condition variable") (C++11)  
[`<future>`](../../future.html "cpp/header/future") (C++11)  
[`<hazard_pointer>`](../../hazard_pointer.html "cpp/header/hazard pointer") (C++26)  
[`<latch>`](../../latch.html "cpp/header/latch") (C++20)  
[`<mutex>`](../../mutex.html "cpp/header/mutex") (C++11)  
[`<rcu>`](../../rcu.html "cpp/header/rcu") (C++26)  
[`<semaphore>`](../../semaphore.html "cpp/header/semaphore") (C++20)  
[`<shared_mutex>`](../../shared_mutex.html "cpp/header/shared mutex") (C++14)  
[`<stdatomic.h>`](../../stdatomic.h.html "cpp/header/stdatomic.h") (C++23)  
[`<stop_token>`](../../stop_token.html "cpp/header/stop token") (C++20)  
[`<thread>`](../../thread.html "cpp/header/thread") (C++11)  
[Execution support](../../../headers.html#Multi-purpose_headers "cpp/header")  
[`<execution>`](../../execution.html "cpp/header/execution") (C++17)  
  
  
  
  
  
  
  
  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/navbar_content&action=edit)

[Experimental library headers](../../experimental.html "cpp/header/experimental")

Execution [P2300](https://wg21.link/P2300)  
---  
[`<experimental/execution>`](../execution.html "cpp/header/experimental/execution")  
Filesystem TS  
[`<experimental/filesystem>`](../filesystem.html "cpp/header/experimental/filesystem")  
Parallelism TS (v1, v2)  
| `experimental/algorithm`  
---  
`experimental/execution_policy`  
`experimental/exception_list`  
  
| `experimental/numeric`  
---  
[`<experimental/simd>`](../simd.html "cpp/header/experimental/simd")  
`experimental/task_block`  
  
Library Fundamentals TS (v1, v2, v3)  
| `experimental/algorithm`  
---  
[`<experimental/any>`](../any.html "cpp/header/experimental/any")  
`experimental/array`  
`experimental/chrono`  
`experimental/deque`  
`experimental/forward_list`  
[`<experimental/functional>`](../functional.html "cpp/header/experimental/functional")  
`experimental/future`  
`experimental/iterator`  
`experimental/list`  
`experimental/map`  
`experimental/memory`  
[`<experimental/memory_resource>`](../memory_resource.html "cpp/header/experimental/memory resource")  
`experimental/numeric`  
[`<experimental/optional>`](../optional.html "cpp/header/experimental/optional")  
`experimental/propagate_const`  
  
| `experimental/random`  
---  
`experimental/ratio`  
`experimental/regex`  
`experimental/scope`  
`experimental/set`  
`experimental/source_location`  
`experimental/string`  
[`<experimental/string_view>`](../string_view.html "cpp/header/experimental/string view")  
`experimental/system_error`  
`experimental/tuple`  
`experimental/type_traits`  
`experimental/unordered_map`  
`experimental/unordered_set`  
`experimental/utility`  
`experimental/vector`  
  
  
  
Concurrency TS  
| `experimental/atomic`  
---  
`experimental/barrier`  
  
| `experimental/future`  
---  
`experimental/latch`  
  
Ranges TS  
| **`< experimental/ranges/algorithm>`**  
---  
[`<experimental/ranges/concepts>`](concepts.html "cpp/header/experimental/ranges/concepts")  
[`<experimental/ranges/functional>`](functional.html "cpp/header/experimental/ranges/functional")  
[`<experimental/ranges/iterator>`](iterator.html "cpp/header/experimental/ranges/iterator")  
  
| [`<experimental/ranges/random>`](random.html "cpp/header/experimental/ranges/random")  
---  
[`<experimental/ranges/tuple>`](tuple.html "cpp/header/experimental/ranges/tuple")  
[`<experimental/ranges/type_traits>`](type_traits.html "cpp/header/experimental/ranges/type traits")  
[`<experimental/ranges/utility>`](utility.html "cpp/header/experimental/ranges/utility")  
  
Coroutines TS  
`experimental/coroutine`  
Networking TS  
| `experimental/buffer`  
---  
`experimental/executor`  
`experimental/internet`  
`experimental/io_context`  
  
| [`<experimental/net>`](../net.html "cpp/header/experimental/net")  
---  
`experimental/netfwd`  
`experimental/socket`  
`experimental/timer`  
  
Reflection TS  
[`<experimental/reflect>`](../reflect.html "cpp/header/experimental/reflect")  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/experimental/navbar_content&action=edit)

This header is part of the [ranges](../../../experimental/ranges.html "cpp/experimental/ranges") library. 

## Contents

  * [1 Tag specifiers](algorithm.html#Tag_specifiers)
  * [2 Non-modifying sequence operations](algorithm.html#Non-modifying_sequence_operations)
  * [3 Modifying sequence operations](algorithm.html#Modifying_sequence_operations)
  * [4 Partitioning operations](algorithm.html#Partitioning_operations)
  * [5 Sorting operations](algorithm.html#Sorting_operations)
  * [6 Binary search operations (on sorted ranges)](algorithm.html#Binary_search_operations_.28on_sorted_ranges.29)
  * [7 Set operations (on sorted ranges)](algorithm.html#Set_operations_.28on_sorted_ranges.29)
  * [8 Heap operations](algorithm.html#Heap_operations)
  * [9 Minimum/maximum operations](algorithm.html#Minimum.2Fmaximum_operations)
  * [10 Permutation operations](algorithm.html#Permutation_operations)
  * [11 Synopsis](algorithm.html#Synopsis)

  
---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/header/experimental/ranges/algorithm&action=edit&section=1 "Edit section: Tag specifiers")] Tag specifiers 

Defined in namespace `std::experimental::ranges::tag`  
---  
[ inin1in2outout1out2funminmaxbeginend](../../../experimental/ranges/algorithm/tags.html "cpp/experimental/ranges/algorithm/tags") |  tag specifiers for use with ranges::tagged   
(class) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_tags&action=edit)  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/header/experimental/ranges/algorithm&action=edit&section=2 "Edit section: Non-modifying sequence operations")] Non-modifying sequence operations 

Defined in namespace `std::experimental::ranges`  
---  
[ all_ofany_ofnone_of](../../../experimental/ranges/algorithm/all_any_none_of.html "cpp/experimental/ranges/algorithm/all any none of") |  checks if a predicate is true for all, any or none of the elements in a range   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_all_any_none_of&action=edit)  
[ for_each](../../../experimental/ranges/algorithm/for_each.html "cpp/experimental/ranges/algorithm/for each") |  applies a function to a range of elements   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_for_each&action=edit)  
[ countcount_if](../../../experimental/ranges/algorithm/count.html "cpp/experimental/ranges/algorithm/count") |  returns the number of elements satisfying specific criteria   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_count&action=edit)  
[ mismatch](../../../experimental/ranges/algorithm/mismatch.html "cpp/experimental/ranges/algorithm/mismatch") |  finds the first position where two ranges differ   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_mismatch&action=edit)  
[ equal](../../../experimental/ranges/algorithm/equal.html "cpp/experimental/ranges/algorithm/equal") |  determines if two sets of elements are the same   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_equal&action=edit)  
[ lexicographical_compare](../../../experimental/ranges/algorithm/lexicographical_compare.html "cpp/experimental/ranges/algorithm/lexicographical compare") |  returns true if one range is lexicographically less than another   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_lexicographical_compare&action=edit)  
[ findfind_iffind_if_not](../../../experimental/ranges/algorithm/find.html "cpp/experimental/ranges/algorithm/find") |  finds the first element satisfying specific criteria   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_find&action=edit)  
[ find_end](../../../experimental/ranges/algorithm/find_end.html "cpp/experimental/ranges/algorithm/find end") |  finds the last sequence of elements in a certain range   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_find_end&action=edit)  
[ find_first_of](../../../experimental/ranges/algorithm/find_first_of.html "cpp/experimental/ranges/algorithm/find first of") |  searches for any one of a set of elements   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_find_first_of&action=edit)  
[ adjacent_find](../../../experimental/ranges/algorithm/adjacent_find.html "cpp/experimental/ranges/algorithm/adjacent find") |  finds the first two adjacent items that are equal (or satisfy a given predicate)   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_adjacent_find&action=edit)  
[ search](../../../experimental/ranges/algorithm/search.html "cpp/experimental/ranges/algorithm/search") |  searches for a range of elements   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_search&action=edit)  
[ search_n](../../../experimental/ranges/algorithm/search_n.html "cpp/experimental/ranges/algorithm/search n") |  searches for a number consecutive copies of an element in a range   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_search_n&action=edit)  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/header/experimental/ranges/algorithm&action=edit&section=3 "Edit section: Modifying sequence operations")] Modifying sequence operations 

Defined in namespace `std::experimental::ranges`  
---  
[ copycopy_if](../../../experimental/ranges/algorithm/copy.html "cpp/experimental/ranges/algorithm/copy") |  copies a range of elements to a new location   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_copy&action=edit)  
[ copy_n](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/copy_n&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/copy n \(page does not exist\)") |  copies a number of elements to a new location   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_copy_n&action=edit)  
[ copy_backward](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/copy_backward&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/copy backward \(page does not exist\)") |  copies a range of elements in backwards order   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_copy_backward&action=edit)  
[ move](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/move&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/move \(page does not exist\)") |  moves a range of elements to a new location   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_move&action=edit)  
[ move_backward](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/move_backward&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/move backward \(page does not exist\)") |  moves a range of elements to a new location in backwards order   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_move_backward&action=edit)  
[ fill](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/fill&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/fill \(page does not exist\)") |  assigns a range of elements a certain value   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_fill&action=edit)  
[ fill_n](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/fill_n&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/fill n \(page does not exist\)") |  assigns a value to a number of elements   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_fill_n&action=edit)  
[ transform](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/transform&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/transform \(page does not exist\)") |  applies a function to a range of elements   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_transform&action=edit)  
[ generate](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/generate&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/generate \(page does not exist\)") |  saves the result of a function in a range   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_generate&action=edit)  
[ generate_n](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/generate_n&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/generate n \(page does not exist\)") |  saves the result of N applications of a function   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_generate_n&action=edit)  
[ removeremove_if](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/remove&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/remove \(page does not exist\)") |  removes elements satisfying specific criteria   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_remove&action=edit)  
[ remove_copyremove_copy_if](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/remove_copy&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/remove copy \(page does not exist\)") |  copies a range of elements omitting those that satisfy specific criteria   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_remove_copy&action=edit)  
[ replacereplace_if](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/replace&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/replace \(page does not exist\)") |  replaces all values satisfying specific criteria with another value   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_replace&action=edit)  
[ replace_copyreplace_copy_if](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/replace_copy&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/replace copy \(page does not exist\)") |  copies a range, replacing elements satisfying specific criteria with another value   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_replace_copy&action=edit)  
[ swap_ranges](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/swap_ranges&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/swap ranges \(page does not exist\)") |  swaps two ranges of elements   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_swap_ranges&action=edit)  
[ reverse](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/reverse&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/reverse \(page does not exist\)") |  reverses the order of elements in a range   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_reverse&action=edit)  
[ reverse_copy](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/reverse_copy&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/reverse copy \(page does not exist\)") |  creates a copy of a range that is reversed   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_reverse_copy&action=edit)  
[ rotate](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/rotate&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/rotate \(page does not exist\)") |  rotates the order of elements in a range   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_rotate&action=edit)  
[ rotate_copy](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/rotate_copy&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/rotate copy \(page does not exist\)") |  copies and rotate a range of elements   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_rotate_copy&action=edit)  
[ shuffle](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/shuffle&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/shuffle \(page does not exist\)") |  randomly re-orders elements in a range   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_shuffle&action=edit)  
[ unique](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/unique&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/unique \(page does not exist\)") |  removes consecutive duplicate elements in a range   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_unique&action=edit)  
[ unique_copy](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/unique_copy&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/unique copy \(page does not exist\)") |  creates a copy of some range of elements that contains no consecutive duplicates   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_unique_copy&action=edit)  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/header/experimental/ranges/algorithm&action=edit&section=4 "Edit section: Partitioning operations")] Partitioning operations 

Defined in namespace `std::experimental::ranges`  
---  
[ is_partitioned](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/is_partitioned&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/is partitioned \(page does not exist\)") |  determines if the range is partitioned by the given predicate   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_is_partitioned&action=edit)  
[ partition](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/partition&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/partition \(page does not exist\)") |  divides a range of elements into two groups   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_partition&action=edit)  
[ partition_copy](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/partition_copy&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/partition copy \(page does not exist\)") |  copies a range dividing the elements into two groups   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_partition_copy&action=edit)  
[ stable_partition](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/stable_partition&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/stable partition \(page does not exist\)") |  divides elements into two groups while preserving their relative order   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_stable_partition&action=edit)  
[ partition_point](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/partition_point&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/partition point \(page does not exist\)") |  locates the partition point of a partitioned range   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_partition_point&action=edit)  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/header/experimental/ranges/algorithm&action=edit&section=5 "Edit section: Sorting operations")] Sorting operations 

Defined in namespace `std::experimental::ranges`  
---  
[ is_sorted](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/is_sorted&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/is sorted \(page does not exist\)") |  checks whether a range is sorted into ascending order   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_is_sorted&action=edit)  
[ is_sorted_until](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/is_sorted_until&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/is sorted until \(page does not exist\)") |  finds the largest sorted subrange   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_is_sorted_until&action=edit)  
[ sort](../../../experimental/ranges/algorithm/sort.html "cpp/experimental/ranges/algorithm/sort") |  sorts a range into ascending order   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_sort&action=edit)  
[ partial_sort](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/partial_sort&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/partial sort \(page does not exist\)") |  sorts the first N elements of a range   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_partial_sort&action=edit)  
[ partial_sort_copy](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/partial_sort_copy&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/partial sort copy \(page does not exist\)") |  copies and partially sorts a range of elements   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_partial_sort_copy&action=edit)  
[ stable_sort](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/stable_sort&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/stable sort \(page does not exist\)") |  sorts a range of elements while preserving order between equal elements   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_stable_sort&action=edit)  
[ nth_element](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/nth_element&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/nth element \(page does not exist\)") |  partially sorts the given range making sure that it is partitioned by the given element   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_nth_element&action=edit)  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/header/experimental/ranges/algorithm&action=edit&section=6 "Edit section: Binary search operations \(on sorted ranges\)")] Binary search operations (on sorted ranges) 

Defined in namespace `std::experimental::ranges`  
---  
[ lower_bound](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/lower_bound&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/lower bound \(page does not exist\)") |  returns an iterator to the first element _not less_ than the given value   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_lower_bound&action=edit)  
[ upper_bound](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/upper_bound&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/upper bound \(page does not exist\)") |  returns an iterator to the first element _greater_ than a certain value   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_upper_bound&action=edit)  
[ binary_search](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/binary_search&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/binary search \(page does not exist\)") |  determines if an element exists in a certain range   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_binary_search&action=edit)  
[ equal_range](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/equal_range&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/equal range \(page does not exist\)") |  returns range of elements matching a specific key   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_equal_range&action=edit)  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/header/experimental/ranges/algorithm&action=edit&section=7 "Edit section: Set operations \(on sorted ranges\)")] Set operations (on sorted ranges) 

Defined in namespace `std::experimental::ranges`  
---  
[ merge](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/merge&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/merge \(page does not exist\)") |  merges two sorted ranges   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_merge&action=edit)  
[ inplace_merge](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/inplace_merge&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/inplace merge \(page does not exist\)") |  merges two ordered ranges in-place   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_inplace_merge&action=edit)  
[ includes](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/includes&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/includes \(page does not exist\)") |  returns true if one set is a subset of another   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_includes&action=edit)  
[ set_difference](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/set_difference&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/set difference \(page does not exist\)") |  computes the difference between two sets   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_set_difference&action=edit)  
[ set_intersection](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/set_intersection&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/set intersection \(page does not exist\)") |  computes the intersection of two sets   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_set_intersection&action=edit)  
[ set_symmetric_difference](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/set_symmetric_difference&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/set symmetric difference \(page does not exist\)") |  computes the symmetric difference between two sets   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_set_symmetric_difference&action=edit)  
[ set_union](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/set_union&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/set union \(page does not exist\)") |  computes the union of two sets   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_set_union&action=edit)  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/header/experimental/ranges/algorithm&action=edit&section=8 "Edit section: Heap operations")] Heap operations 

Defined in namespace `std::experimental::ranges`  
---  
[ is_heap](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/is_heap&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/is heap \(page does not exist\)") |  checks if the given range is a max heap   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_is_heap&action=edit)  
[ is_heap_until](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/is_heap_until&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/is heap until \(page does not exist\)") |  finds the largest subrange that is a max heap   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_is_heap_until&action=edit)  
[ make_heap](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/make_heap&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/make heap \(page does not exist\)") |  creates a max heap out of a range of elements   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_make_heap&action=edit)  
[ push_heap](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/push_heap&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/push heap \(page does not exist\)") |  adds an element to a max heap   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_push_heap&action=edit)  
[ pop_heap](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/pop_heap&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/pop heap \(page does not exist\)") |  removes the largest element from a max heap   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_pop_heap&action=edit)  
[ sort_heap](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/sort_heap&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/sort heap \(page does not exist\)") |  turns a max heap into a range of elements sorted in ascending order   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_sort_heap&action=edit)  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/header/experimental/ranges/algorithm&action=edit&section=9 "Edit section: Minimum/maximum operations")] Minimum/maximum operations 

Defined in namespace `std::experimental::ranges`  
---  
[ max](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/max&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/max \(page does not exist\)") |  returns the greater of the given values   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_max&action=edit)  
[ max_element](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/max_element&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/max element \(page does not exist\)") |  returns the largest element in a range   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_max_element&action=edit)  
[ min](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/min&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/min \(page does not exist\)") |  returns the smaller of the given values   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_min&action=edit)  
[ min_element](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/min_element&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/min element \(page does not exist\)") |  returns the smallest element in a range   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_min_element&action=edit)  
[ minmax](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/minmax&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/minmax \(page does not exist\)") |  returns the smaller and larger of two elements   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_minmax&action=edit)  
[ minmax_element](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/minmax_element&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/minmax element \(page does not exist\)") |  returns the smallest and the largest elements in a range   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_minmax_element&action=edit)  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/header/experimental/ranges/algorithm&action=edit&section=10 "Edit section: Permutation operations")] Permutation operations 

Defined in namespace `std::experimental::ranges`  
---  
[ is_permutation](../../../experimental/ranges/algorithm/is_permutation.html "cpp/experimental/ranges/algorithm/is permutation") |  determines if a sequence is a permutation of another sequence   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_is_permutation&action=edit)  
[ next_permutation](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/next_permutation&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/next permutation \(page does not exist\)") |  generates the next greater lexicographic permutation of a range of elements   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_next_permutation&action=edit)  
[ prev_permutation](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/algorithm/prev_permutation&action=edit&redlink=1 "cpp/experimental/ranges/algorithm/prev permutation \(page does not exist\)") |  generates the next smaller lexicographic permutation of a range of elements   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/ranges/algorithm/dsc_prev_permutation&action=edit)  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/header/experimental/ranges/algorithm&action=edit&section=11 "Edit section: Synopsis")] Synopsis 
    
    
    #include <initializer_list>
     
    namespace std { namespace experimental { namespace ranges { inline namespace v1 {
     
    namespace tag {
      struct in;
      struct in1;
      struct in2;
      struct out;
      struct out1;
      struct out2;
      struct fun;
      struct min;
      struct max;
      struct begin;
      struct end;
    }
     
    template <InputIterator I, Sentinel<I> S, class Proj = identity,
        IndirectUnaryPredicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Pred>
      bool all_of(I first, S last, Pred pred, Proj proj = Proj{});
     
    template <InputRange Rng, class Proj = identity,
        IndirectUnaryPredicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng>, Proj>> Pred>
      bool all_of(Rng&& rng, Pred pred, Proj proj = Proj{});
     
    template <InputIterator I, Sentinel<I> S, class Proj = identity,
        IndirectUnaryPredicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Pred>
      bool any_of(I first, S last, Pred pred, Proj proj = Proj{});
     
    template <InputRange Rng, class Proj = identity,
        IndirectUnaryPredicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng>, Proj>> Pred>
      bool any_of(Rng&& rng, Pred pred, Proj proj = Proj{});
     
    template <InputIterator I, Sentinel<I> S, class Proj = identity,
        IndirectUnaryPredicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Pred>
      bool none_of(I first, S last, Pred pred, Proj proj = Proj{});
     
    template <InputRange Rng, class Proj = identity,
        IndirectUnaryPredicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng>, Proj>> Pred>
      bool none_of(Rng&& rng, Pred pred, Proj proj = Proj{});
     
    template <InputIterator I, Sentinel<I> S, class Proj = identity,
        IndirectUnaryInvocable<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Fun>
      tagged_pair<[tag::in](../../../experimental/ranges/algorithm/tags.html)(I), [tag::fun](../../../experimental/ranges/algorithm/tags.html)(Fun)>
        for_each(I first, S last, Fun f, Proj proj = Proj{});
     
    template <InputRange Rng, class Proj = identity,
        IndirectUnaryInvocable<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng>, Proj>> Fun>
      tagged_pair<[tag::in](../../../experimental/ranges/algorithm/tags.html)(safe_iterator_t<Rng>), [tag::fun](../../../experimental/ranges/algorithm/tags.html)(Fun)>
        for_each(Rng&& rng, Fun f, Proj proj = Proj{});
     
    template <InputIterator I, Sentinel<I> S, class T, class Proj = identity>
      requires IndirectRelation<equal_to<>, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>, const T*>
      I find(I first, S last, const T& value, Proj proj = Proj{});
     
    template <InputRange Rng, class T, class Proj = identity>
      requires IndirectRelation<equal_to<>, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng>, Proj>, const T*>
      safe_iterator_t<Rng>
        find(Rng&& rng, const T& value, Proj proj = Proj{});
     
    template <InputIterator I, Sentinel<I> S, class Proj = identity,
        IndirectUnaryPredicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Pred>
      I find_if(I first, S last, Pred pred, Proj proj = Proj{});
     
    template <InputRange Rng, class Proj = identity,
        IndirectUnaryPredicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng>, Proj>> Pred>
      safe_iterator_t<Rng>
        find_if(Rng&& rng, Pred pred, Proj proj = Proj{});
     
    template <InputIterator I, Sentinel<I> S, class Proj = identity,
        IndirectUnaryPredicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Pred>
      I find_if_not(I first, S last, Pred pred, Proj proj = Proj{});
     
    template <InputRange Rng, class Proj = identity,
        IndirectUnaryPredicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng>, Proj>> Pred>
      safe_iterator_t<Rng>
        find_if_not(Rng&& rng, Pred pred, Proj proj = Proj{});
     
    template <ForwardIterator I1, Sentinel<I1> S1, ForwardIterator I2,
        Sentinel<I2> S2, class Proj = identity,
        IndirectRelation<I2, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I1, Proj>> Pred = equal_to<>>
      I1
        find_end(I1 first1, S1 last1, I2 first2, S2 last2,
                 Pred pred = Pred{}, Proj proj = Proj{});
     
    template <ForwardRange Rng1, ForwardRange Rng2, class Proj = identity,
        IndirectRelation<iterator_t<Rng2>,
          [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng>, Proj>> Pred = equal_to<>>
      safe_iterator_t<Rng1>
        find_end(Rng1&& rng1, Rng2&& rng2, Pred pred = Pred{}, Proj proj = Proj{});
     
    template <InputIterator I1, Sentinel<I1> S1, ForwardIterator I2, Sentinel<I2> S2,
        class Proj1 = identity, class Proj2 = identity,
        IndirectRelation<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I1, Proj1>, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I2, Proj2>> Pred = equal_to<>>
      I1
        find_first_of(I1 first1, S1 last1, I2 first2, S2 last2,
                      Pred pred = Pred{},
                      Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
     
    template <InputRange Rng1, ForwardRange Rng2, class Proj1 = identity,
        class Proj2 = identity,
        IndirectRelation<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng1>, Proj1>,
          [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng2>, Proj2>> Pred = equal_to<>>
      safe_iterator_t<Rng1>
        find_first_of(Rng1&& rng1, Rng2&& rng2,
                      Pred pred = Pred{},
                      Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
     
    template <ForwardIterator I, Sentinel<I> S, class Proj = identity,
        IndirectRelation<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Pred = equal_to<>>
      I
        adjacent_find(I first, S last, Pred pred = Pred{},
                      Proj proj = Proj{});
     
    template <ForwardRange Rng, class Proj = identity,
        IndirectRelation<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng>, Proj>> Pred = equal_to<>>
      safe_iterator_t<Rng>
        adjacent_find(Rng&& rng, Pred pred = Pred{}, Proj proj = Proj{});
     
    template <InputIterator I, Sentinel<I> S, class T, class Proj = identity>
      requires IndirectRelation<equal_to<>, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>, const T*>
      difference_type_t<I>
        count(I first, S last, const T& value, Proj proj = Proj{});
     
    template <InputRange Rng, class T, class Proj = identity>
      requires IndirectRelation<equal_to<>, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng>, Proj>, const T*>
      difference_type_t<iterator_t<Rng>>
        count(Rng&& rng, const T& value, Proj proj = Proj{});
     
    template <InputIterator I, Sentinel<I> S, class Proj = identity,
        IndirectUnaryPredicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Pred>
      difference_type_t<I>
        count_if(I first, S last, Pred pred, Proj proj = Proj{});
     
    template <InputRange Rng, class Proj = identity,
        IndirectUnaryPredicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng>, Proj>> Pred>
      difference_type_t<iterator_t<Rng>>
        count_if(Rng&& rng, Pred pred, Proj proj = Proj{});
     
    template <InputIterator I1, Sentinel<I1> S1, InputIterator I2, Sentinel<I2> S2,
        class Proj1 = identity, class Proj2 = identity,
        IndirectRelation<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I1, Proj1>, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I2, Proj2>> Pred = equal_to<>>
      tagged_pair<[tag::in1](../../../experimental/ranges/algorithm/tags.html)(I1), [tag::in2](../../../experimental/ranges/algorithm/tags.html)(I2)>
        mismatch(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = Pred{},
                 Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
     
    template <InputRange Rng1, InputRange Rng2,
        class Proj1 = identity, class Proj2 = identity,
        IndirectRelation<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng1>, Proj1>,
          [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng2>, Proj2>> Pred = equal_to<>>
      tagged_pair<[tag::in1](../../../experimental/ranges/algorithm/tags.html)(safe_iterator_t<Rng1>),
                  [tag::in2](../../../experimental/ranges/algorithm/tags.html)(safe_iterator_t<Rng2>)>
        mismatch(Rng1&& rng1, Rng2&& rng2, Pred pred = Pred{},
                 Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
     
    template <InputIterator I1, Sentinel<I1> S1, InputIterator I2, Sentinel<I2> S2,
        class Pred = equal_to<>, class Proj1 = identity, class Proj2 = identity>
      requires IndirectlyComparable<I1, I2, Pred, Proj1, Proj2>
      bool equal(I1 first1, S1 last1, I2 first2, S2 last2,
                 Pred pred = Pred{},
                 Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
     
    template <InputRange Rng1, InputRange Rng2, class Pred = equal_to<>,
        class Proj1 = identity, class Proj2 = identity>
      requires IndirectlyComparable<iterator_t<Rng1>, iterator_t<Rng2>, Pred, Proj1, Proj2>
      bool equal(Rng1&& rng1, Rng2&& rng2, Pred pred = Pred{},
                 Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
     
    template <ForwardIterator I1, Sentinel<I1> S1, ForwardIterator I2,
        Sentinel<I2> S2, class Pred = equal_to<>, class Proj1 = identity,
        class Proj2 = identity>
      requires IndirectlyComparable<I1, I2, Pred, Proj1, Proj2>
      bool is_permutation(I1 first1, S1 last1, I2 first2, S2 last2,
                          Pred pred = Pred{},
                          Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
     
    template <ForwardRange Rng1, ForwardRange Rng2, class Pred = equal_to<>,
        class Proj1 = identity, class Proj2 = identity>
      requires IndirectlyComparable<iterator_t<Rng1>, iterator_t<Rng2>, Pred, Proj1, Proj2>
      bool is_permutation(Rng1&& rng1, Rng2&& rng2, Pred pred = Pred{},
                          Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
     
    template <ForwardIterator I1, Sentinel<I1> S1, ForwardIterator I2,
        Sentinel<I2> S2, class Pred = equal_to<>,
        class Proj1 = identity, class Proj2 = identity>
      requires IndirectlyComparable<I1, I2, Pred, Proj1, Proj2>
      I1
        search(I1 first1, S1 last1, I2 first2, S2 last2,
               Pred pred = Pred{},
               Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
     
    template <ForwardRange Rng1, ForwardRange Rng2, class Pred = equal_to<>,
        class Proj1 = identity, class Proj2 = identity>
      requires IndirectlyComparable<iterator_t<Rng1>, iterator_t<Rng2>, Pred, Proj1, Proj2>
      safe_iterator_t<Rng1>
        search(Rng1&& rng1, Rng2&& rng2, Pred pred = Pred{},
               Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
     
    template <ForwardIterator I, Sentinel<I> S, class T,
        class Pred = equal_to<>, class Proj = identity>
      requires IndirectlyComparable<I, const T*, Pred, Proj>
      I
        search_n(I first, S last, difference_type_t<I> count,
                 const T& value, Pred pred = Pred{},
                 Proj proj = Proj{});
     
    template <ForwardRange Rng, class T, class Pred = equal_to<>,
        class Proj = identity>
      requires IndirectlyComparable<iterator_t<Rng>, const T*, Pred, Proj>
      safe_iterator_t<Rng>
        search_n(Rng&& rng, difference_type_t<iterator_t<Rng>> count,
                 const T& value, Pred pred = Pred{}, Proj proj = Proj{});
     
    template <InputIterator I, Sentinel<I> S, WeaklyIncrementable O>
      requires IndirectlyCopyable<I, O>
      tagged_pair<[tag::in](../../../experimental/ranges/algorithm/tags.html)(I), [tag::out](../../../experimental/ranges/algorithm/tags.html)(O)>
        copy(I first, S last, O result);
     
    template <InputRange Rng, WeaklyIncrementable O>
      requires IndirectlyCopyable<iterator_t<Rng>, O>
      tagged_pair<[tag::in](../../../experimental/ranges/algorithm/tags.html)(safe_iterator_t<Rng>), [tag::out](../../../experimental/ranges/algorithm/tags.html)(O)>
        copy(Rng&& rng, O result);
     
    template <InputIterator I, WeaklyIncrementable O>
      requires IndirectlyCopyable<I, O>
      tagged_pair<[tag::in](../../../experimental/ranges/algorithm/tags.html)(I), [tag::out](../../../experimental/ranges/algorithm/tags.html)(O)>
        copy_n(I first, difference_type_t<I> n, O result);
     
    template <InputIterator I, Sentinel<I> S, WeaklyIncrementable O, class Proj = identity,
        IndirectUnaryPredicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Pred>
      requires IndirectlyCopyable<I, O>
      tagged_pair<[tag::in](../../../experimental/ranges/algorithm/tags.html)(I), [tag::out](../../../experimental/ranges/algorithm/tags.html)(O)>
        copy_if(I first, S last, O result, Pred pred, Proj proj = Proj{});
     
    template <InputRange Rng, WeaklyIncrementable O, class Proj = identity,
        IndirectUnaryPredicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng>, Proj>> Pred>
      requires IndirectlyCopyable<iterator_t<Rng>, O>
      tagged_pair<[tag::in](../../../experimental/ranges/algorithm/tags.html)(safe_iterator_t<Rng>), [tag::out](../../../experimental/ranges/algorithm/tags.html)(O)>
        copy_if(Rng&& rng, O result, Pred pred, Proj proj = Proj{});
     
    template <BidirectionalIterator I1, Sentinel<I1> S1, BidirectionalIterator I2>
      requires IndirectlyCopyable<I1, I2>
      tagged_pair<[tag::in](../../../experimental/ranges/algorithm/tags.html)(I1), [tag::out](../../../experimental/ranges/algorithm/tags.html)(I2)>
        copy_backward(I1 first, S1 last, I2 result);
     
    template <BidirectionalRange Rng, BidirectionalIterator I>
      requires IndirectlyCopyable<iterator_t<Rng>, I>
      tagged_pair<[tag::in](../../../experimental/ranges/algorithm/tags.html)(safe_iterator_t<Rng>), [tag::out](../../../experimental/ranges/algorithm/tags.html)(I)>
        copy_backward(Rng&& rng, I result);
     
    template <InputIterator I, Sentinel<I> S, WeaklyIncrementable O>
      requires IndirectlyMovable<I, O>
      tagged_pair<[tag::in](../../../experimental/ranges/algorithm/tags.html)(I), [tag::out](../../../experimental/ranges/algorithm/tags.html)(O)>
        move(I first, S last, O result);
     
    template <InputRange Rng, WeaklyIncrementable O>
      requires IndirectlyMovable<iterator_t<Rng>, O>
      tagged_pair<[tag::in](../../../experimental/ranges/algorithm/tags.html)(safe_iterator_t<Rng>), [tag::out](../../../experimental/ranges/algorithm/tags.html)(O)>
        move(Rng&& rng, O result);
     
    template <BidirectionalIterator I1, Sentinel<I1> S1, BidirectionalIterator I2>
      requires IndirectlyMovable<I1, I2>
      tagged_pair<[tag::in](../../../experimental/ranges/algorithm/tags.html)(I1), [tag::out](../../../experimental/ranges/algorithm/tags.html)(I2)>
        move_backward(I1 first, S1 last, I2 result);
     
    template <BidirectionalRange Rng, BidirectionalIterator I>
      requires IndirectlyMovable<iterator_t<Rng>, I>
      tagged_pair<[tag::in](../../../experimental/ranges/algorithm/tags.html)(safe_iterator_t<Rng>), [tag::out](../../../experimental/ranges/algorithm/tags.html)(I)>
        move_backward(Rng&& rng, I result);
     
    template <ForwardIterator I1, Sentinel<I1> S1, ForwardIterator I2, Sentinel<I2> S2>
      requires IndirectlySwappable<I1, I2>
      tagged_pair<[tag::in1](../../../experimental/ranges/algorithm/tags.html)(I1), [tag::in2](../../../experimental/ranges/algorithm/tags.html)(I2)>
        swap_ranges(I1 first1, S1 last1, I2 first2, S2 last2);
     
    template <ForwardRange Rng1, ForwardRange Rng2>
      requires IndirectlySwappable<iterator_t<Rng1>, iterator_t<Rng2>>
      tagged_pair<[tag::in1](../../../experimental/ranges/algorithm/tags.html)(safe_iterator_t<Rng1>), [tag::in2](../../../experimental/ranges/algorithm/tags.html)(safe_iterator_t<Rng2>)>
        swap_ranges(Rng1&& rng1, Rng2&& rng2);
     
    template <InputIterator I, Sentinel<I> S, WeaklyIncrementable O,
        CopyConstructible F, class Proj = identity>
      requires Writable<O, indirect_result_of_t<F&([projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>)>>
      tagged_pair<[tag::in](../../../experimental/ranges/algorithm/tags.html)(I), [tag::out](../../../experimental/ranges/algorithm/tags.html)(O)>
        transform(I first, S last, O result, F op, Proj proj = Proj{});
     
    template <InputRange Rng, WeaklyIncrementable O, CopyConstructible F,
        class Proj = identity>
      requires Writable<O, indirect_result_of_t<F&(
        [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<R>, Proj>)>>
      tagged_pair<[tag::in](../../../experimental/ranges/algorithm/tags.html)(safe_iterator_t<Rng>), [tag::out](../../../experimental/ranges/algorithm/tags.html)(O)>
        transform(Rng&& rng, O result, F op, Proj proj = Proj{});
     
    template <InputIterator I1, Sentinel<I1> S1, InputIterator I2, Sentinel<I2> S2,
        WeaklyIncrementable O, CopyConstructible F, class Proj1 = identity,
        class Proj2 = identity>
      requires Writable<O, indirect_result_of_t<F&([projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I1, Proj1>,
        [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I2, Proj2>)>>
      tagged_tuple<[tag::in1](../../../experimental/ranges/algorithm/tags.html)(I1), [tag::in2](../../../experimental/ranges/algorithm/tags.html)(I2), [tag::out](../../../experimental/ranges/algorithm/tags.html)(O)>
        transform(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                  F binary_op, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
     
    template <InputRange Rng1, InputRange Rng2, WeaklyIncrementable O,
        CopyConstructible F, class Proj1 = identity, class Proj2 = identity>
      requires Writable<O, indirect_result_of_t<F&(
        [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng1>, Proj1>, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng2>, Proj2>)>>
      tagged_tuple<[tag::in1](../../../experimental/ranges/algorithm/tags.html)(safe_iterator_t<Rng1>),
                   [tag::in2](../../../experimental/ranges/algorithm/tags.html)(safe_iterator_t<Rng2>),
                   [tag::out](../../../experimental/ranges/algorithm/tags.html)(O)>
        transform(Rng1&& rng1, Rng2&& rng2, O result,
                  F binary_op, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
     
    template <InputIterator I, Sentinel<I> S, class T1, class T2, class Proj = identity>
      requires Writable<I, const T2&> &&
        IndirectRelation<equal_to<>, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>, const T1*>
      I
        replace(I first, S last, const T1& old_value, const T2& new_value, Proj proj = Proj{});
     
    template <InputRange Rng, class T1, class T2, class Proj = identity>
      requires Writable<iterator_t<Rng>, const T2&> &&
        IndirectRelation<equal_to<>, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng>, Proj>, const T1*>
      safe_iterator_t<Rng>
        replace(Rng&& rng, const T1& old_value, const T2& new_value, Proj proj = Proj{});
     
    template <InputIterator I, Sentinel<I> S, class T, class Proj = identity,
        IndirectUnaryPredicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Pred>
      requires Writable<I, const T&>
      I
        replace_if(I first, S last, Pred pred, const T& new_value, Proj proj = Proj{});
     
    template <InputRange Rng, class T, class Proj = identity,
        IndirectUnaryPredicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng>, Proj>> Pred>
      requires Writable<iterator_t<Rng>, const T&>
      safe_iterator_t<Rng>
        replace_if(Rng&& rng, Pred pred, const T& new_value, Proj proj = Proj{});
     
    template <InputIterator I, Sentinel<I> S, class T1, class T2, OutputIterator<const T2&> O,
        class Proj = identity>
      requires IndirectlyCopyable<I, O> &&
        IndirectRelation<equal_to<>, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>, const T1*>
      tagged_pair<[tag::in](../../../experimental/ranges/algorithm/tags.html)(I), [tag::out](../../../experimental/ranges/algorithm/tags.html)(O)>
        replace_copy(I first, S last, O result, const T1& old_value, const T2& new_value,
                     Proj proj = Proj{});
     
    template <InputRange Rng, class T1, class T2, OutputIterator<const T2&> O,
        class Proj = identity>
      requires IndirectlyCopyable<iterator_t<Rng>, O> &&
        IndirectRelation<equal_to<>, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng>, Proj>, const T1*>
      tagged_pair<[tag::in](../../../experimental/ranges/algorithm/tags.html)(safe_iterator_t<Rng>), [tag::out](../../../experimental/ranges/algorithm/tags.html)(O)>
        replace_copy(Rng&& rng, O result, const T1& old_value, const T2& new_value,
                     Proj proj = Proj{});
     
    template <InputIterator I, Sentinel<I> S, class T, OutputIterator<const T&> O,
        class Proj = identity, IndirectUnaryPredicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Pred>
      requires IndirectlyCopyable<I, O>
      tagged_pair<[tag::in](../../../experimental/ranges/algorithm/tags.html)(I), [tag::out](../../../experimental/ranges/algorithm/tags.html)(O)>
        replace_copy_if(I first, S last, O result, Pred pred, const T& new_value,
                        Proj proj = Proj{});
     
    template <InputRange Rng, class T, OutputIterator<const T&> O, class Proj = identity,
        IndirectUnaryPredicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng>, Proj>> Pred>
      requires IndirectlyCopyable<iterator_t<Rng>, O>
      tagged_pair<[tag::in](../../../experimental/ranges/algorithm/tags.html)(safe_iterator_t<Rng>), [tag::out](../../../experimental/ranges/algorithm/tags.html)(O)>
        replace_copy_if(Rng&& rng, O result, Pred pred, const T& new_value,
                        Proj proj = Proj{});
     
    template <class T, OutputIterator<const T&> O, Sentinel<O> S>
      O fill(O first, S last, const T& value);
     
    template <class T, OutputRange<const T&> Rng>
      safe_iterator_t<Rng>
        fill(Rng&& rng, const T& value);
     
    template <class T, OutputIterator<const T&> O>
      O fill_n(O first, difference_type_t<O> n, const T& value);
     
    template <Iterator O, Sentinel<O> S, CopyConstructible F>
      requires Invocable<F&> && Writable<O, result_of_t<F&()>>
      O generate(O first, S last, F gen);
     
    template <class Rng, CopyConstructible F>
      requires Invocable<F&> && OutputRange<Rng, result_of_t<F&()>>
      safe_iterator_t<Rng>
        generate(Rng&& rng, F gen);
     
    template <Iterator O, CopyConstructible F>
      requires Invocable<F&> && Writable<O, result_of_t<F&()>>
      O generate_n(O first, difference_type_t<O> n, F gen);
     
    template <ForwardIterator I, Sentinel<I> S, class T, class Proj = identity>
      requires Permutable<I> &&
        IndirectRelation<equal_to<>, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>, const T*>
      I remove(I first, S last, const T& value, Proj proj = Proj{});
     
    template <ForwardRange Rng, class T, class Proj = identity>
      requires Permutable<iterator_t<Rng>> &&
        IndirectRelation<equal_to<>, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng>, Proj>, const T*>
      safe_iterator_t<Rng>
        remove(Rng&& rng, const T& value, Proj proj = Proj{});
     
    template <ForwardIterator I, Sentinel<I> S, class Proj = identity,
        IndirectUnaryPredicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Pred>
      requires Permutable<I>
        I remove_if(I first, S last, Pred pred, Proj proj = Proj{});
     
    template <ForwardRange Rng, class Proj = identity,
        IndirectUnaryPredicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng>, Proj>> Pred>
      requires Permutable<iterator_t<Rng>>
      safe_iterator_t<Rng>
        remove_if(Rng&& rng, Pred pred, Proj proj = Proj{});
     
    template <InputIterator I, Sentinel<I> S, WeaklyIncrementable O, class T,
        class Proj = identity>
      requires IndirectlyCopyable<I, O> &&
        IndirectRelation<equal_to<>, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>, const T*>
      tagged_pair<[tag::in](../../../experimental/ranges/algorithm/tags.html)(I), [tag::out](../../../experimental/ranges/algorithm/tags.html)(O)>
        remove_copy(I first, S last, O result, const T& value, Proj proj = Proj{});
     
    template <InputRange Rng, WeaklyIncrementable O, class T, class Proj = identity>
      requires IndirectlyCopyable<iterator_t<Rng>, O> &&
        IndirectRelation<equal_to<>, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng>, Proj>, const T*>
      tagged_pair<[tag::in](../../../experimental/ranges/algorithm/tags.html)(safe_iterator_t<Rng>), [tag::out](../../../experimental/ranges/algorithm/tags.html)(O)>
        remove_copy(Rng&& rng, O result, const T& value, Proj proj = Proj{});
     
    template <InputIterator I, Sentinel<I> S, WeaklyIncrementable O,
        class Proj = identity, IndirectUnaryPredicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Pred>
      requires IndirectlyCopyable<I, O>
      tagged_pair<[tag::in](../../../experimental/ranges/algorithm/tags.html)(I), [tag::out](../../../experimental/ranges/algorithm/tags.html)(O)>
        remove_copy_if(I first, S last, O result, Pred pred, Proj proj = Proj{});
     
    template <InputRange Rng, WeaklyIncrementable O, class Proj = identity,
        IndirectUnaryPredicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng>, Proj>> Pred>
      requires IndirectlyCopyable<iterator_t<Rng>, O>
      tagged_pair<[tag::in](../../../experimental/ranges/algorithm/tags.html)(safe_iterator_t<Rng>), [tag::out](../../../experimental/ranges/algorithm/tags.html)(O)>
        remove_copy_if(Rng&& rng, O result, Pred pred, Proj proj = Proj{});
     
    template <ForwardIterator I, Sentinel<I> S, class Proj = identity,
        IndirectRelation<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> R = equal_to<>>
      requires Permutable<I>
      I unique(I first, S last, R comp = R{}, Proj proj = Proj{});
     
    template <ForwardRange Rng, class Proj = identity,
        IndirectRelation<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng>, Proj>> R = equal_to<>>
      requires Permutable<iterator_t<Rng>>
      safe_iterator_t<Rng>
        unique(Rng&& rng, R comp = R{}, Proj proj = Proj{});
     
    template <InputIterator I, Sentinel<I> S, WeaklyIncrementable O,
        class Proj = identity, IndirectRelation<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> R = equal_to<>>
      requires IndirectlyCopyable<I, O> &&
        (ForwardIterator<I> ||
        (InputIterator<O> && Same<value_type_t<I>, value_type_t<O>>) ||
        IndirectlyCopyableStorable<I, O>)
      tagged_pair<[tag::in](../../../experimental/ranges/algorithm/tags.html)(I), [tag::out](../../../experimental/ranges/algorithm/tags.html)(O)>
        unique_copy(I first, S last, O result, R comp = R{}, Proj proj = Proj{});
     
    template <InputRange Rng, WeaklyIncrementable O, class Proj = identity,
        IndirectRelation<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng>, Proj>> R = equal_to<>>
      requires IndirectlyCopyable<iterator_t<Rng>, O> &&
        (ForwardIterator<iterator_t<Rng>> ||
        (InputIterator<O> && Same<value_type_t<iterator_t<Rng>>, value_type_t<O>>) ||
        IndirectlyCopyableStorable<iterator_t<Rng>, O>)
      tagged_pair<[tag::in](../../../experimental/ranges/algorithm/tags.html)(safe_iterator_t<Rng>), [tag::out](../../../experimental/ranges/algorithm/tags.html)(O)>
        unique_copy(Rng&& rng, O result, R comp = R{}, Proj proj = Proj{});
     
    template <BidirectionalIterator I, Sentinel<I> S>
      requires Permutable<I>
      I reverse(I first, S last);
     
    template <BidirectionalRange Rng>
      requires Permutable<iterator_t<Rng>>
      safe_iterator_t<Rng>
        reverse(Rng&& rng);
     
    template <BidirectionalIterator I, Sentinel<I> S, WeaklyIncrementable O>
      requires IndirectlyCopyable<I, O>
      tagged_pair<[tag::in](../../../experimental/ranges/algorithm/tags.html)(I), [tag::out](../../../experimental/ranges/algorithm/tags.html)(O)> reverse_copy(I first, S last, O result);
     
    template <BidirectionalRange Rng, WeaklyIncrementable O>
      requires IndirectlyCopyable<iterator_t<Rng>, O>
      tagged_pair<[tag::in](../../../experimental/ranges/algorithm/tags.html)(safe_iterator_t<Rng>), [tag::out](../../../experimental/ranges/algorithm/tags.html)(O)>
        reverse_copy(Rng&& rng, O result);
     
    template <ForwardIterator I, Sentinel<I> S>
      requires Permutable<I>
      tagged_pair<[tag::begin](../../../experimental/ranges/algorithm/tags.html)(I), [tag::end](../../../experimental/ranges/algorithm/tags.html)(I)>
        rotate(I first, I middle, S last);
     
    template <ForwardRange Rng>
      requires Permutable<iterator_t<Rng>>
      tagged_pair<[tag::begin](../../../experimental/ranges/algorithm/tags.html)(safe_iterator_t<Rng>),
                  [tag::end](../../../experimental/ranges/algorithm/tags.html)(safe_iterator_t<Rng>)>
        rotate(Rng&& rng, iterator_t<Rng> middle);
     
    template <ForwardIterator I, Sentinel<I> S, WeaklyIncrementable O>
      requires IndirectlyCopyable<I, O>
      tagged_pair<[tag::in](../../../experimental/ranges/algorithm/tags.html)(I), [tag::out](../../../experimental/ranges/algorithm/tags.html)(O)>
        rotate_copy(I first, I middle, S last, O result);
     
    template <ForwardRange Rng, WeaklyIncrementable O>
      requires IndirectlyCopyable<iterator_t<Rng>, O>
      tagged_pair<[tag::in](../../../experimental/ranges/algorithm/tags.html)(safe_iterator_t<Rng>), [tag::out](../../../experimental/ranges/algorithm/tags.html)(O)>
        rotate_copy(Rng&& rng, iterator_t<Rng> middle, O result);
     
    template <RandomAccessIterator I, Sentinel<I> S, class Gen>
      requires Permutable<I> &&
        UniformRandomNumberGenerator<remove_reference_t<Gen>> &&
        ConvertibleTo<result_of_t<Gen&()>, difference_type_t<I>>
      I shuffle(I first, S last, Gen&& g);
     
    template <RandomAccessRange Rng, class Gen>
      requires Permutable<I> &&
        UniformRandomNumberGenerator<remove_reference_t<Gen>> &&
        ConvertibleTo<result_of_t<Gen&()>, difference_type_t<I>>
      safe_iterator_t<Rng>
        shuffle(Rng&& rng, Gen&& g);
     
    template <InputIterator I, Sentinel<I> S, class Proj = identity,
        IndirectUnaryPredicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Pred>
      bool is_partitioned(I first, S last, Pred pred, Proj proj = Proj{});
     
    template <InputRange Rng, class Proj = identity,
        IndirectUnaryPredicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng>, Proj>> Pred>
      bool
        is_partitioned(Rng&& rng, Pred pred, Proj proj = Proj{});
     
    template <ForwardIterator I, Sentinel<I> S, class Proj = identity,
        IndirectUnaryPredicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Pred>
      requires Permutable<I>
        I partition(I first, S last, Pred pred, Proj proj = Proj{});
     
    template <ForwardRange Rng, class Proj = identity,
        IndirectUnaryPredicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng>, Proj>> Pred>
      requires Permutable<iterator_t<Rng>>
      safe_iterator_t<Rng>
        partition(Rng&& rng, Pred pred, Proj proj = Proj{});
     
    template <BidirectionalIterator I, Sentinel<I> S, class Proj = identity,
        IndirectUnaryPredicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Pred>
      requires Permutable<I>
      I stable_partition(I first, S last, Pred pred, Proj proj = Proj{});
     
    template <BidirectionalRange Rng, class Proj = identity,
        IndirectUnaryPredicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng>, Proj>> Pred>
      requires Permutable<iterator_t<Rng>>
      safe_iterator_t<Rng>
        stable_partition(Rng&& rng, Pred pred, Proj proj = Proj{});
     
    template <InputIterator I, Sentinel<I> S, WeaklyIncrementable O1, WeaklyIncrementable O2,
        class Proj = identity, IndirectUnaryPredicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Pred>
      requires IndirectlyCopyable<I, O1> && IndirectlyCopyable<I, O2>
      tagged_tuple<[tag::in](../../../experimental/ranges/algorithm/tags.html)(I), [tag::out1](../../../experimental/ranges/algorithm/tags.html)(O1), [tag::out2](../../../experimental/ranges/algorithm/tags.html)(O2)>
        partition_copy(I first, S last, O1 out_true, O2 out_false, Pred pred,
                       Proj proj = Proj{});
     
    template <InputRange Rng, WeaklyIncrementable O1, WeaklyIncrementable O2,
        class Proj = identity,
        IndirectUnaryPredicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng>, Proj>> Pred>
      requires IndirectlyCopyable<iterator_t<Rng>, O1> &&
        IndirectlyCopyable<iterator_t<Rng>, O2>
      tagged_tuple<[tag::in](../../../experimental/ranges/algorithm/tags.html)(safe_iterator_t<Rng>), [tag::out1](../../../experimental/ranges/algorithm/tags.html)(O1), [tag::out2](../../../experimental/ranges/algorithm/tags.html)(O2)>
        partition_copy(Rng&& rng, O1 out_true, O2 out_false, Pred pred, Proj proj = Proj{});
     
    template <ForwardIterator I, Sentinel<I> S, class Proj = identity,
        IndirectUnaryPredicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Pred>
      I partition_point(I first, S last, Pred pred, Proj proj = Proj{});
     
    template <ForwardRange Rng, class Proj = identity,
        IndirectUnaryPredicate<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng>, Proj>> Pred>
      safe_iterator_t<Rng>
        partition_point(Rng&& rng, Pred pred, Proj proj = Proj{});
     
    template <RandomAccessIterator I, Sentinel<I> S, class Comp = less<>,
        class Proj = identity>
      requires Sortable<I, Comp, Proj>
        I sort(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});
     
    template <RandomAccessRange Rng, class Comp = less<>, class Proj = identity>
      requires Sortable<iterator_t<Rng>, Comp, Proj>
      safe_iterator_t<Rng>
        sort(Rng&& rng, Comp comp = Comp{}, Proj proj = Proj{});
     
    template <RandomAccessIterator I, Sentinel<I> S, class Comp = less<>,
        class Proj = identity>
      requires Sortable<I, Comp, Proj>
        I stable_sort(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});
     
    template <RandomAccessRange Rng, class Comp = less<>, class Proj = identity>
      requires Sortable<iterator_t<Rng>, Comp, Proj>
      safe_iterator_t<Rng>
        stable_sort(Rng&& rng, Comp comp = Comp{}, Proj proj = Proj{});
     
    template <RandomAccessIterator I, Sentinel<I> S, class Comp = less<>,
        class Proj = identity>
      requires Sortable<I, Comp, Proj>
        I partial_sort(I first, I middle, S last, Comp comp = Comp{}, Proj proj = Proj{});
     
    template <RandomAccessRange Rng, class Comp = less<>, class Proj = identity>
      requires Sortable<iterator_t<Rng>, Comp, Proj>
      safe_iterator_t<Rng>
        partial_sort(Rng&& rng, iterator_t<Rng> middle, Comp comp = Comp{},
                     Proj proj = Proj{});
     
    template <InputIterator I1, Sentinel<I1> S1, RandomAccessIterator I2, Sentinel<I2> S2,
        class Comp = less<>, class Proj1 = identity, class Proj2 = identity>
      requires IndirectlyCopyable<I1, I2> && Sortable<I2, Comp, Proj2> &&
        IndirectStrictWeakOrder<Comp, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I1, Proj1>, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I2, Proj2>>
      I2
        partial_sort_copy(I1 first, S1 last, I2 result_first, S2 result_last,
                          Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
     
    template <InputRange Rng1, RandomAccessRange Rng2, class Comp = less<>,
        class Proj1 = identity, class Proj2 = identity>
      requires IndirectlyCopyable<iterator_t<Rng1>, iterator_t<Rng2>> &&
        Sortable<iterator_t<Rng2>, Comp, Proj2> &&
        IndirectStrictWeakOrder<Comp, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng1>, Proj1>,
          [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng2>, Proj2>>
      safe_iterator_t<Rng2>
        partial_sort_copy(Rng1&& rng, Rng2&& result_rng, Comp comp = Comp{},
                          Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
     
    template <ForwardIterator I, Sentinel<I> S, class Proj = identity,
        IndirectStrictWeakOrder<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Comp = less<>>
      bool is_sorted(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});
     
    template <ForwardRange Rng, class Proj = identity,
        IndirectStrictWeakOrder<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng>, Proj>> Comp = less<>>
      bool
        is_sorted(Rng&& rng, Comp comp = Comp{}, Proj proj = Proj{});
     
    template <ForwardIterator I, Sentinel<I> S, class Proj = identity,
        IndirectStrictWeakOrder<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Comp = less<>>
      I is_sorted_until(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});
     
    template <ForwardRange Rng, class Proj = identity,
        IndirectStrictWeakOrder<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng>, Proj>> Comp = less<>>
      safe_iterator_t<Rng>
        is_sorted_until(Rng&& rng, Comp comp = Comp{}, Proj proj = Proj{});
     
    template <RandomAccessIterator I, Sentinel<I> S, class Comp = less<>,
        class Proj = identity>
      requires Sortable<I, Comp, Proj>
        I nth_element(I first, I nth, S last, Comp comp = Comp{}, Proj proj = Proj{});
     
    template <RandomAccessRange Rng, class Comp = less<>, class Proj = identity>
      requires Sortable<iterator_t<Rng>, Comp, Proj>
      safe_iterator_t<Rng>
        nth_element(Rng&& rng, iterator_t<Rng> nth, Comp comp = Comp{}, Proj proj = Proj{});
     
    template <ForwardIterator I, Sentinel<I> S, class T, class Proj = identity,
        IndirectStrictWeakOrder<const T*, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Comp = less<>>
      I
        lower_bound(I first, S last, const T& value, Comp comp = Comp{},
                    Proj proj = Proj{});
     
    template <ForwardRange Rng, class T, class Proj = identity,
        IndirectStrictWeakOrder<const T*, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng>, Proj>> Comp = less<>>
      safe_iterator_t<Rng>
        lower_bound(Rng&& rng, const T& value, Comp comp = Comp{}, Proj proj = Proj{});
     
    template <ForwardIterator I, Sentinel<I> S, class T, class Proj = identity,
        IndirectStrictWeakOrder<const T*, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Comp = less<>>
      I
        upper_bound(I first, S last, const T& value, Comp comp = Comp{}, Proj proj = Proj{});
     
    template <ForwardRange Rng, class T, class Proj = identity,
        IndirectStrictWeakOrder<const T*, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng>, Proj>> Comp = less<>>
      safe_iterator_t<Rng>
        upper_bound(Rng&& rng, const T& value, Comp comp = Comp{}, Proj proj = Proj{});
     
    template <ForwardIterator I, Sentinel<I> S, class T, class Proj = identity,
        IndirectStrictWeakOrder<const T*, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Comp = less<>>
      tagged_pair<[tag::begin](../../../experimental/ranges/algorithm/tags.html)(I), [tag::end](../../../experimental/ranges/algorithm/tags.html)(I)>
        equal_range(I first, S last, const T& value, Comp comp = Comp{}, Proj proj = Proj{});
     
    template <ForwardRange Rng, class T, class Proj = identity,
        IndirectStrictWeakOrder<const T*, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng>, Proj>> Comp = less<>>
      tagged_pair<[tag::begin](../../../experimental/ranges/algorithm/tags.html)(safe_iterator_t<Rng>),
                  [tag::end](../../../experimental/ranges/algorithm/tags.html)(safe_iterator_t<Rng>)>
        equal_range(Rng&& rng, const T& value, Comp comp = Comp{}, Proj proj = Proj{});
     
    template <ForwardIterator I, Sentinel<I> S, class T, class Proj = identity,
        IndirectStrictWeakOrder<const T*, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Comp = less<>>
      bool
        binary_search(I first, S last, const T& value, Comp comp = Comp{},
                      Proj proj = Proj{});
     
    template <ForwardRange Rng, class T, class Proj = identity,
        IndirectStrictWeakOrder<const T*, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng>, Proj>> Comp = less<>>
      bool
        binary_search(Rng&& rng, const T& value, Comp comp = Comp{},
                      Proj proj = Proj{});
     
    template <InputIterator I1, Sentinel<I1> S1, InputIterator I2, Sentinel<I2> S2,
        WeaklyIncrementable O, class Comp = less<>, class Proj1 = identity,
        class Proj2 = identity>
      requires Mergeable<I1, I2, O, Comp, Proj1, Proj2>
      tagged_tuple<[tag::in1](../../../experimental/ranges/algorithm/tags.html)(I1), [tag::in2](../../../experimental/ranges/algorithm/tags.html)(I2), [tag::out](../../../experimental/ranges/algorithm/tags.html)(O)>
        merge(I1 first1, S1 last1, I2 first2, S2 last2, O result,
              Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
     
    template <InputRange Rng1, InputRange Rng2, WeaklyIncrementable O, class Comp = less<>,
        class Proj1 = identity, class Proj2 = identity>
      requires Mergeable<iterator_t<Rng1>, iterator_t<Rng2>, O, Comp, Proj1, Proj2>
      tagged_tuple<[tag::in1](../../../experimental/ranges/algorithm/tags.html)(safe_iterator_t<Rng1>),
                   [tag::in2](../../../experimental/ranges/algorithm/tags.html)(safe_iterator_t<Rng2>),
                   [tag::out](../../../experimental/ranges/algorithm/tags.html)(O)>
        merge(Rng1&& rng1, Rng2&& rng2, O result,
              Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
     
    template <BidirectionalIterator I, Sentinel<I> S, class Comp = less<>,
        class Proj = identity>
      requires Sortable<I, Comp, Proj>
      I
        inplace_merge(I first, I middle, S last, Comp comp = Comp{}, Proj proj = Proj{});
     
    template <BidirectionalRange Rng, class Comp = less<>, class Proj = identity>
      requires Sortable<iterator_t<Rng>, Comp, Proj>
      safe_iterator_t<Rng>
        inplace_merge(Rng&& rng, iterator_t<Rng> middle, Comp comp = Comp{},
                      Proj proj = Proj{});
     
    template <InputIterator I1, Sentinel<I1> S1, InputIterator I2, Sentinel<I2> S2,
        class Proj1 = identity, class Proj2 = identity,
        IndirectStrictWeakOrder<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I1, Proj1>, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I2, Proj2>> Comp = less<>>
      bool
        includes(I1 first1, S1 last1, I2 first2, S2 last2, Comp comp = Comp{},
                 Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
     
    template <InputRange Rng1, InputRange Rng2, class Proj1 = identity,
        class Proj2 = identity,
        IndirectStrictWeakOrder<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng1>, Proj1>,
          [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng2>, Proj2>> Comp = less<>>
      bool
        includes(Rng1&& rng1, Rng2&& rng2, Comp comp = Comp{},
                 Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
     
    template <InputIterator I1, Sentinel<I1> S1, InputIterator I2, Sentinel<I2> S2,
        WeaklyIncrementable O, class Comp = less<>,
        class Proj1 = identity, class Proj2 = identity>
      requires Mergeable<I1, I2, O, Comp, Proj1, Proj2>
      tagged_tuple<[tag::in1](../../../experimental/ranges/algorithm/tags.html)(I1), [tag::in2](../../../experimental/ranges/algorithm/tags.html)(I2), [tag::out](../../../experimental/ranges/algorithm/tags.html)(O)>
        set_union(I1 first1, S1 last1, I2 first2, S2 last2, O result, Comp comp = Comp{},
                  Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
     
    template <InputRange Rng1, InputRange Rng2, WeaklyIncrementable O,
        class Comp = less<>, class Proj1 = identity, class Proj2 = identity>
      requires Mergeable<iterator_t<Rng1>, iterator_t<Rng2>, O, Comp, Proj1, Proj2>
      tagged_tuple<[tag::in1](../../../experimental/ranges/algorithm/tags.html)(safe_iterator_t<Rng1>),
                   [tag::in2](../../../experimental/ranges/algorithm/tags.html)(safe_iterator_t<Rng2>),
                   [tag::out](../../../experimental/ranges/algorithm/tags.html)(O)>
        set_union(Rng1&& rng1, Rng2&& rng2, O result, Comp comp = Comp{},
                  Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
     
    template <InputIterator I1, Sentinel<I1> S1, InputIterator I2, Sentinel<I2> S2,
        WeaklyIncrementable O, class Comp = less<>,
        class Proj1 = identity, class Proj2 = identity>
      requires Mergeable<I1, I2, O, Comp, Proj1, Proj2>
      O
        set_intersection(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                         Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
     
    template <InputRange Rng1, InputRange Rng2, WeaklyIncrementable O,
        class Comp = less<>, class Proj1 = identity, class Proj2 = identity>
      requires Mergeable<iterator_t<Rng1>, iterator_t<Rng2>, O, Comp, Proj1, Proj2>
      O
        set_intersection(Rng1&& rng1, Rng2&& rng2, O result,
                         Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
     
    template <InputIterator I1, Sentinel<I1> S1, InputIterator I2, Sentinel<I2> S2,
        WeaklyIncrementable O, class Comp = less<>,
        class Proj1 = identity, class Proj2 = identity>
      requires Mergeable<I1, I2, O, Comp, Proj1, Proj2>
      tagged_pair<[tag::in1](../../../experimental/ranges/algorithm/tags.html)(I1), [tag::out](../../../experimental/ranges/algorithm/tags.html)(O)>
        set_difference(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                       Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
     
    template <InputRange Rng1, InputRange Rng2, WeaklyIncrementable O,
        class Comp = less<>, class Proj1 = identity, class Proj2 = identity>
      requires Mergeable<iterator_t<Rng1>, iterator_t<Rng2>, O, Comp, Proj1, Proj2>
      tagged_pair<[tag::in1](../../../experimental/ranges/algorithm/tags.html)(safe_iterator_t<Rng1>), [tag::out](../../../experimental/ranges/algorithm/tags.html)(O)>
        set_difference(Rng1&& rng1, Rng2&& rng2, O result,
                       Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
     
    template <InputIterator I1, Sentinel<I1> S1, InputIterator I2, Sentinel<I2> S2,
        WeaklyIncrementable O, class Comp = less<>,
        class Proj1 = identity, class Proj2 = identity>
      requires Mergeable<I1, I2, O, Comp, Proj1, Proj2>
      tagged_tuple<[tag::in1](../../../experimental/ranges/algorithm/tags.html)(I1), [tag::in2](../../../experimental/ranges/algorithm/tags.html)(I2), [tag::out](../../../experimental/ranges/algorithm/tags.html)(O)>
        set_symmetric_difference(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                                 Comp comp = Comp{}, Proj1 proj1 = Proj1{},
                                 Proj2 proj2 = Proj2{});
     
    template <InputRange Rng1, InputRange Rng2, WeaklyIncrementable O,
        class Comp = less<>, class Proj1 = identity, class Proj2 = identity>
      requires Mergeable<iterator_t<Rng1>, iterator_t<Rng2>, O, Comp, Proj1, Proj2>
      tagged_tuple<[tag::in1](../../../experimental/ranges/algorithm/tags.html)(safe_iterator_t<Rng1>),
                   [tag::in2](../../../experimental/ranges/algorithm/tags.html)(safe_iterator_t<Rng2>),
                   [tag::out](../../../experimental/ranges/algorithm/tags.html)(O)>
        set_symmetric_difference(Rng1&& rng1, Rng2&& rng2, O result, Comp comp = Comp{},
                                 Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
     
    template <RandomAccessIterator I, Sentinel<I> S, class Comp = less<>,
        class Proj = identity>
      requires Sortable<I, Comp, Proj>
      I push_heap(I first, S last, Comp comp = Comp{}, Proj proj == Proj{});
     
    template <RandomAccessRange Rng, class Comp = less<>, class Proj = identity>
      requires Sortable<iterator_t<Rng>, Comp, Proj>
      safe_iterator_t<Rng>
        push_heap(Rng&& rng, Comp comp = Comp{}, Proj proj = Proj{});
     
    template <RandomAccessIterator I, Sentinel<I> S, class Comp = less<>,
        class Proj = identity>
      requires Sortable<I, Comp, Proj>
      I pop_heap(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});
     
    template <RandomAccessRange Rng, class Comp = less<>, class Proj = identity>
      requires Sortable<iterator_t<Rng>, Comp, Proj>
      safe_iterator_t<Rng>
        pop_heap(Rng&& rng, Comp comp = Comp{}, Proj proj = Proj{});
     
    template <RandomAccessIterator I, Sentinel<I> S, class Comp = less<>,
        class Proj = identity>
      requires Sortable<I, Comp, Proj>
      I make_heap(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});
     
    template <RandomAccessRange Rng, class Comp = less<>, class Proj = identity>
      requires Sortable<iterator_t<Rng>, Comp, Proj>
      safe_iterator_t<Rng>
        make_heap(Rng&& rng, Comp comp = Comp{}, Proj proj = Proj{});
     
    template <RandomAccessIterator I, Sentinel<I> S, class Comp = less<>,
        class Proj = identity>
      requires Sortable<I, Comp, Proj>
      I sort_heap(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});
     
    template <RandomAccessRange Rng, class Comp = less<>, class Proj = identity>
      requires Sortable<iterator_t<Rng>, Comp, Proj>
      safe_iterator_t<Rng>
        sort_heap(Rng&& rng, Comp comp = Comp{}, Proj proj = Proj{});
     
    template <RandomAccessIterator I, Sentinel<I> S, class Proj = identity,
        IndirectStrictWeakOrder<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Comp = less<>>
      bool is_heap(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});
     
    template <RandomAccessRange Rng, class Proj = identity,
        IndirectStrictWeakOrder<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng>, Proj>> Comp = less<>>
      bool
        is_heap(Rng&& rng, Comp comp = Comp{}, Proj proj = Proj{});
     
    template <RandomAccessIterator I, Sentinel<I> S, class Proj = identity,
        IndirectStrictWeakOrder<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Comp = less<>>
      I is_heap_until(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});
     
    template <RandomAccessRange Rng, class Proj = identity,
        IndirectStrictWeakOrder<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng>, Proj>> Comp = less<>>
      safe_iterator_t<Rng>
        is_heap_until(Rng&& rng, Comp comp = Comp{}, Proj proj = Proj{});
     
    template <class T, class Proj = identity,
        IndirectStrictWeakOrder<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<const T*, Proj>> Comp = less<>>
      constexpr const T& min(const T& a, const T& b, Comp comp = Comp{}, Proj proj = Proj{});
     
    template <Copyable T, class Proj = identity,
        IndirectStrictWeakOrder<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<const T*, Proj>> Comp = less<>>
      constexpr T min(initializer_list<T> t, Comp comp = Comp{}, Proj proj = Proj{});
     
    template <InputRange Rng, class Proj = identity,
        IndirectStrictWeakOrder<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng>, Proj>> Comp = less<>>
      requires Copyable<value_type_t<iterator_t<Rng>>>
      value_type_t<iterator_t<Rng>>
        min(Rng&& rng, Comp comp = Comp{}, Proj proj = Proj{});
     
    template <class T, class Proj = identity,
        IndirectStrictWeakOrder<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<const T*, Proj>> Comp = less<>>
      constexpr const T& max(const T& a, const T& b, Comp comp = Comp{}, Proj proj = Proj{});
     
    template <Copyable T, class Proj = identity,
        IndirectStrictWeakOrder<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<const T*, Proj>> Comp = less<>>
      constexpr T max(initializer_list<T> t, Comp comp = Comp{}, Proj proj = Proj{});
     
    template <InputRange Rng, class Proj = identity,
        IndirectStrictWeakOrder<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng>, Proj>> Comp = less<>>
      requires Copyable<value_type_t<iterator_t<Rng>>>
      value_type_t<iterator_t<Rng>>
        max(Rng&& rng, Comp comp = Comp{}, Proj proj = Proj{});
     
    template <class T, class Proj = identity,
        IndirectStrictWeakOrder<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<const T*, Proj>> Comp = less<>>
      constexpr tagged_pair<[tag::min](../../../experimental/ranges/algorithm/tags.html)(const T&), [tag::max](../../../experimental/ranges/algorithm/tags.html)(const T&)>
        minmax(const T& a, const T& b, Comp comp = Comp{}, Proj proj = Proj{});
     
    template <Copyable T, class Proj = identity,
        IndirectStrictWeakOrder<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<const T*, Proj>> Comp = less<>>
      constexpr tagged_pair<[tag::min](../../../experimental/ranges/algorithm/tags.html)(T), [tag::max](../../../experimental/ranges/algorithm/tags.html)(T)>
        minmax(initializer_list<T> t, Comp comp = Comp{}, Proj proj = Proj{});
     
    template <InputRange Rng, class Proj = identity,
        IndirectStrictWeakOrder<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng>, Proj>> Comp = less<>>
      requires Copyable<value_type_t<iterator_t<Rng>>>
      tagged_pair<[tag::min](../../../experimental/ranges/algorithm/tags.html)(value_type_t<iterator_t<Rng>>),
                  [tag::max](../../../experimental/ranges/algorithm/tags.html)(value_type_t<iterator_t<Rng>>)>
        minmax(Rng&& rng, Comp comp = Comp{}, Proj proj = Proj{});
     
    template <ForwardIterator I, Sentinel<I> S, class Proj = identity,
        IndirectStrictWeakOrder<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Comp = less<>>
      I min_element(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});
     
    template <ForwardRange Rng, class Proj = identity,
        IndirectStrictWeakOrder<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng>, Proj>> Comp = less<>>
      safe_iterator_t<Rng>
        min_element(Rng&& rng, Comp comp = Comp{}, Proj proj = Proj{});
     
    template <ForwardIterator I, Sentinel<I> S, class Proj = identity,
        IndirectStrictWeakOrder<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Comp = less<>>
      I max_element(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});
     
    template <ForwardRange Rng, class Proj = identity,
        IndirectStrictWeakOrder<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng>, Proj>> Comp = less<>>
      safe_iterator_t<Rng>
        max_element(Rng&& rng, Comp comp = Comp{}, Proj proj = Proj{});
     
    template <ForwardIterator I, Sentinel<I> S, class Proj = identity,
        IndirectStrictWeakOrder<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>> Comp = less<>>
      tagged_pair<[tag::min](../../../experimental/ranges/algorithm/tags.html)(I), [tag::max](../../../experimental/ranges/algorithm/tags.html)(I)>
        minmax_element(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});
     
    template <ForwardRange Rng, class Proj = identity,
        IndirectStrictWeakOrder<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng>, Proj>> Comp = less<>>
      tagged_pair<[tag::min](../../../experimental/ranges/algorithm/tags.html)(safe_iterator_t<Rng>),
                  [tag::max](../../../experimental/ranges/algorithm/tags.html)(safe_iterator_t<Rng>)>
        minmax_element(Rng&& rng, Comp comp = Comp{}, Proj proj = Proj{});
     
    template <InputIterator I1, Sentinel<I1> S1, InputIterator I2, Sentinel<I2> S2,
        class Proj1 = identity, class Proj2 = identity,
        IndirectStrictWeakOrder<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I1, Proj1>, [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I2, Proj2>> Comp = less<>>
      bool
        lexicographical_compare(I1 first1, S1 last1, I2 first2, S2 last2,
                                Comp comp = Comp{},
                                Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
     
    template <InputRange Rng1, InputRange Rng2, class Proj1 = identity,
        class Proj2 = identity,
        IndirectStrictWeakOrder<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng1>, Proj1>,
          [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<iterator_t<Rng2>, Proj2>> Comp = less<>>
      bool
        lexicographical_compare(Rng1&& rng1, Rng2&& rng2, Comp comp = Comp{},
                                Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
     
    template <BidirectionalIterator I, Sentinel<I> S, class Comp = less<>,
        class Proj = identity>
      requires Sortable<I, Comp, Proj>
      bool next_permutation(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});
     
    template <BidirectionalRange Rng, class Comp = less<>,
        class Proj = identity>
      requires Sortable<iterator_t<Rng>, Comp, Proj>
      bool
        next_permutation(Rng&& rng, Comp comp = Comp{}, Proj proj = Proj{});
     
    template <BidirectionalIterator I, Sentinel<I> S, class Comp = less<>,
        class Proj = identity>
      requires Sortable<I, Comp, Proj>
      bool prev_permutation(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});
     
    template <BidirectionalRange Rng, class Comp = less<>,
        class Proj = identity>
      requires Sortable<iterator_t<Rng>, Comp, Proj>
      bool
        prev_permutation(Rng&& rng, Comp comp = Comp{}, Proj proj = Proj{});
     
    }}}}
