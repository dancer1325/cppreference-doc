[C++](../../../../cpp.html "cpp")

[Compiler support](../../../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../../../freestanding.html "cpp/freestanding")  
[Language](../../../language.html "cpp/language")  
[Standard library](../../../standard_library.html "cpp/standard library")  
[Standard library headers](../../../headers.html "cpp/header")  
[Named requirements](../../../iterator/concepts.html "cpp/named req")  
[Feature test macros](../../../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../../../utility.html#Language_support "cpp/utility")  
[Concepts library](../../../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../../../error.html "cpp/error")  
[Memory management library](../../../memory.html "cpp/memory")  
[Metaprogramming library](../../../meta.html "cpp/meta") (C++11)  
[General utilities library](../../../utility.html "cpp/utility")  
[Containers library](../../../container.html "cpp/container")  
[Iterators library](../../../iterator.html "cpp/iterator")  
[Ranges library](../../../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../../../algorithm.html "cpp/algorithm")  
[Strings library](../../../string.html "cpp/string")  
[Text processing library](../../../text.html "cpp/text")  
[Numerics library](../../../numeric.html "cpp/numeric")  
[Date and time library](../../../chrono.html "cpp/chrono")  
[Input/output library](../../../io.html "cpp/io")  
[Filesystem library](../../../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../../../atomic.html "cpp/thread") (C++11)  
[Execution control library](../../../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../../../experimental.html "cpp/experimental")  
[Symbols index](../../../symbol_index.html "cpp/symbol index")  
[External libraries](../../../links/libs.html "cpp/links/libs")  
  


[Standard library headers](../../../headers.html "cpp/header")

| [Language support](../../../headers.html#Language_support_library "cpp/header")  
---  
[`<cfloat>`](../../cfloat.html "cpp/header/cfloat")  
[`<climits>`](../../climits.html "cpp/header/climits")  
[`<compare>`](../../compare.html "cpp/header/compare") (C++20)  
[`<contracts>`](../../contracts.html "cpp/header/contracts") (C++26)  
[`<coroutine>`](../../coroutine.html "cpp/header/coroutine") (C++20)  
[`<csetjmp>`](../../csetjmp.html "cpp/header/csetjmp")  
[`<csignal>`](../../csignal.html "cpp/header/csignal")  
[`<cstdarg>`](../../cstdarg.html "cpp/header/cstdarg")  
[`<cstddef>`](../../cstddef.html "cpp/header/cstddef")  
[`<cstdint>`](../../cstdint.html "cpp/header/cstdint") (C++11)  
[`<cstdlib>`](../../cstdlib.html "cpp/header/cstdlib")  
[`<exception>`](../../exception.html "cpp/header/exception")  
[`<initializer_list>`](../../initializer_list.html "cpp/header/initializer list") (C++11)` `  
[`<limits>`](../../limits.html "cpp/header/limits")  
[`<new>`](../../new.html "cpp/header/new")  
[`<source_location>`](../../source_location.html "cpp/header/source location") (C++20)  
[`<stdfloat>`](../../stdfloat.html "cpp/header/stdfloat") (C++23)  
[`<typeinfo>`](../../typeinfo.html "cpp/header/typeinfo")  
[`<version>`](../../version.html "cpp/header/version") (C++20)  
[Concepts](../../../headers.html#Concepts_library "cpp/header")  
[`<concepts>`](../../concepts.html "cpp/header/concepts") (C++20)  
[Diagnostics](../../../headers.html#Diagnostics_library "cpp/header")  
[`<cassert>`](../../cassert.html "cpp/header/cassert")  
[`<cerrno>`](../../cerrno.html "cpp/header/cerrno")  
[`<debugging>`](../../debugging.html "cpp/header/debugging") (C++26)  
[`<stacktrace>`](../../stacktrace.html "cpp/header/stacktrace") (C++23)  
[`<stdexcept>`](../../stdexcept.html "cpp/header/stdexcept")  
[`<system_error>`](../../system_error.html "cpp/header/system error") (C++11)  
[Memory management](../../../headers.html#Memory_management_library "cpp/header")  
[`<memory>`](../../memory.html "cpp/header/memory")  
[`<memory_resource>`](../../memory_resource.html "cpp/header/memory resource") (C++17)  
[`<scoped_allocator>`](../../scoped_allocator.html "cpp/header/scoped allocator") (C++11)  
[Metaprogramming](../../../headers.html#Metaprogramming_library "cpp/header")  
[`<type_traits>`](../../type_traits.html "cpp/header/type traits") (C++11)  
[`<ratio>`](../../ratio.html "cpp/header/ratio") (C++11)  
  
  
  
| [General utilities](../../../headers.html#General_utilities_library "cpp/header")  
---  
[`<any>`](../../any.html "cpp/header/any") (C++17)  
[`<bitset>`](../../bitset.html "cpp/header/bitset")  
[`<bit>`](../../bit.html "cpp/header/bit") (C++20)  
[`<charconv>`](../../charconv.html "cpp/header/charconv") (C++17)  
[`<expected>`](../../expected.html "cpp/header/expected") (C++23)  
[`<format>`](../../format.html "cpp/header/format") (C++20)  
[`<functional>`](../../functional.html "cpp/header/functional")  
[`<optional>`](../../optional.html "cpp/header/optional") (C++17)  
[`<stdbit.h>`](../../stdbit.h.html "cpp/header/stdbit.h") (C++26)  
[`<tuple>`](../../tuple.html "cpp/header/tuple") (C++11)  
[`<typeindex>`](../../typeindex.html "cpp/header/typeindex") (C++11)  
[`<utility>`](../../utility.html "cpp/header/utility")  
[`<variant>`](../../variant.html "cpp/header/variant") (C++17)  
[Containers](../../../headers.html#Containers_library "cpp/header")  
[`<array>`](../../array.html "cpp/header/array") (C++11)  
[`<deque>`](../../deque.html "cpp/header/deque")  
[`<flat_map>`](../../flat_map.html "cpp/header/flat map") (C++23)  
[`<flat_set>`](../../flat_set.html "cpp/header/flat set") (C++23)  
[`<forward_list>`](../../forward_list.html "cpp/header/forward list") (C++11)  
[`<hive>`](../../hive.html "cpp/header/hive") (C++26)  
[`<inplace_vector>`](../../inplace_vector.html "cpp/header/inplace vector") (C++26)` `  
[`<list>`](../../list.html "cpp/header/list")  
[`<map>`](../../map.html "cpp/header/map")  
[`<mdspan>`](../../mdspan.html "cpp/header/mdspan") (C++23)  
[`<queue>`](../../queue.html "cpp/header/queue")  
[`<set>`](../../set.html "cpp/header/set")  
[`<span>`](../../span.html "cpp/header/span") (C++20)  
[`<stack>`](../../stack.html "cpp/header/stack")  
[`<unordered_map>`](../../unordered_map.html "cpp/header/unordered map") (C++11)  
[`<unordered_set>`](../../unordered_set.html "cpp/header/unordered set") (C++11)  
[`<vector>`](../../vector.html "cpp/header/vector")  
[Iterators](../../../headers.html#Iterators_library "cpp/header")  
[`<iterator>`](../../iterator.html "cpp/header/iterator")  
[Ranges](../../../headers.html#Ranges_library "cpp/header")  
[`<generator>`](../../generator.html "cpp/header/generator") (C++23)  
[`<ranges>`](../../ranges.html "cpp/header/ranges") (C++20)  
  
| [Algorithms](../../../headers.html#Algorithms_library "cpp/header")  
---  
[`<algorithm>`](../../algorithm.html "cpp/header/algorithm")  
[`<numeric>`](../../numeric.html "cpp/header/numeric")  
[Strings](../../../headers.html#Strings_library "cpp/header")  
[`<cctype>`](../../cctype.html "cpp/header/cctype")  
[`<cstring>`](../../cstring.html "cpp/header/cstring")  
[`<cuchar>`](../../cuchar.html "cpp/header/cuchar") (C++11)  
[`<cwchar>`](../../cwchar.html "cpp/header/cwchar")  
[`<cwctype>`](../../cwctype.html "cpp/header/cwctype")  
[`<string_view>`](../../string_view.html "cpp/header/string view") (C++17)  
[`<string>`](../../string.html "cpp/header/string")  
[Text processing](../../../headers.html#Text_processing_library "cpp/header")  
[`<clocale>`](../../clocale.html "cpp/header/clocale")  
[`<codecvt>`](../../codecvt.html "cpp/header/codecvt") (C++11/17/26*)  
[`<locale>`](../../locale.html "cpp/header/locale")  
[`<regex>`](../../regex.html "cpp/header/regex") (C++11)  
[`<text_encoding>`](../../text_encoding.html "cpp/header/text encoding") (C++26)` `  
[Numerics](../../../headers.html#Numerics_library "cpp/header")  
[`<cfenv>`](../../cfenv.html "cpp/header/cfenv") (C++11)  
[`<cmath>`](../../cmath.html "cpp/header/cmath")  
[`<complex>`](../../complex.html "cpp/header/complex")  
[`<linalg>`](../../linalg.html "cpp/header/linalg") (C++26)  
[`<numbers>`](../../numbers.html "cpp/header/numbers") (C++20)  
[`<random>`](../../random.html "cpp/header/random") (C++11)  
[`<simd>`](../../simd.html "cpp/header/simd") (C++26)  
[`<stdckdint.h>`](../../stdckdint.h.html "cpp/header/stdckdint.h") (C++26)  
[`<valarray>`](../../valarray.html "cpp/header/valarray")  
[Time](../../../headers.html#Time_library "cpp/header")  
[`<chrono>`](../../chrono.html "cpp/header/chrono") (C++11)  
[`<ctime>`](../../ctime.html "cpp/header/ctime")  
[C compatibility](../../../headers.html#C_compatibility_headers "cpp/header")  
[`<ccomplex>`](../../ccomplex.html "cpp/header/ccomplex") (C++11/17/20*)  
[`<ciso646>`](../../ciso646.html "cpp/header/ciso646") (until C++20)  
[`<cstdalign>`](../../cstdalign.html "cpp/header/cstdalign") (C++11/17/20*)  
[`<cstdbool>`](../../cstdbool.html "cpp/header/cstdbool") (C++11/17/20*)  
[`<ctgmath>`](../../ctgmath.html "cpp/header/ctgmath") (C++11/17/20*)  
  
| [Input/output](../../../headers.html#Input.2Foutput_library "cpp/header")  
---  
[`<cinttypes>`](../../cinttypes.html "cpp/header/cinttypes") (C++11)  
[`<cstdio>`](../../cstdio.html "cpp/header/cstdio")  
[`<filesystem>`](../../filesystem.html "cpp/header/filesystem") (C++17)  
[`<fstream>`](../../fstream.html "cpp/header/fstream")  
[`<iomanip>`](../../iomanip.html "cpp/header/iomanip")  
[`<iosfwd>`](../../iosfwd.html "cpp/header/iosfwd")  
[`<iostream>`](../../iostream.html "cpp/header/iostream")  
[`<ios>`](../../ios.html "cpp/header/ios")  
[`<istream>`](../../istream.html "cpp/header/istream")  
[`<ostream>`](../../ostream.html "cpp/header/ostream")  
[`<print>`](../../print.html "cpp/header/print") (C++23)  
[`<spanstream>`](../../spanstream.html "cpp/header/spanstream") (C++23)  
[`<sstream>`](../../sstream.html "cpp/header/sstream")  
[`<streambuf>`](../../streambuf.html "cpp/header/streambuf")  
[`<strstream>`](../../strstream.html "cpp/header/strstream") (C++98/26*)  
[`<syncstream>`](../../syncstream.html "cpp/header/syncstream") (C++20)  
[Concurrency support](../../../headers.html#Concurrency_support_library "cpp/header")  
[`<atomic>`](../../atomic.html "cpp/header/atomic") (C++11)  
[`<barrier>`](../../barrier.html "cpp/header/barrier") (C++20)  
[`<condition_variable>`](../../condition_variable.html "cpp/header/condition variable") (C++11)  
[`<future>`](../../future.html "cpp/header/future") (C++11)  
[`<hazard_pointer>`](../../hazard_pointer.html "cpp/header/hazard pointer") (C++26)  
[`<latch>`](../../latch.html "cpp/header/latch") (C++20)  
[`<mutex>`](../../mutex.html "cpp/header/mutex") (C++11)  
[`<rcu>`](../../rcu.html "cpp/header/rcu") (C++26)  
[`<semaphore>`](../../semaphore.html "cpp/header/semaphore") (C++20)  
[`<shared_mutex>`](../../shared_mutex.html "cpp/header/shared mutex") (C++14)  
[`<stdatomic.h>`](../../stdatomic.h.html "cpp/header/stdatomic.h") (C++23)  
[`<stop_token>`](../../stop_token.html "cpp/header/stop token") (C++20)  
[`<thread>`](../../thread.html "cpp/header/thread") (C++11)  
[Execution support](../../../headers.html#Multi-purpose_headers "cpp/header")  
[`<execution>`](../../execution.html "cpp/header/execution") (C++17)  
  
  
  
  
  
  
  
  
  


[Experimental library headers](../../experimental.html "cpp/header/experimental")

Execution [P2300](https://wg21.link/P2300)  
---  
[`<experimental/execution>`](../execution.html "cpp/header/experimental/execution")  
Filesystem TS  
[`<experimental/filesystem>`](../filesystem.html "cpp/header/experimental/filesystem")  
Parallelism TS (v1, v2)  
| `experimental/algorithm`  
---  
`experimental/execution_policy`  
`experimental/exception_list`  
  
| `experimental/numeric`  
---  
[`<experimental/simd>`](../simd.html "cpp/header/experimental/simd")  
`experimental/task_block`  
  
Library Fundamentals TS (v1, v2, v3)  
| `experimental/algorithm`  
---  
[`<experimental/any>`](../any.html "cpp/header/experimental/any")  
`experimental/array`  
`experimental/chrono`  
`experimental/deque`  
`experimental/forward_list`  
[`<experimental/functional>`](../functional.html "cpp/header/experimental/functional")  
`experimental/future`  
`experimental/iterator`  
`experimental/list`  
`experimental/map`  
`experimental/memory`  
[`<experimental/memory_resource>`](../memory_resource.html "cpp/header/experimental/memory resource")  
`experimental/numeric`  
[`<experimental/optional>`](../optional.html "cpp/header/experimental/optional")  
`experimental/propagate_const`  
  
| `experimental/random`  
---  
`experimental/ratio`  
`experimental/regex`  
`experimental/scope`  
`experimental/set`  
`experimental/source_location`  
`experimental/string`  
[`<experimental/string_view>`](../string_view.html "cpp/header/experimental/string view")  
`experimental/system_error`  
`experimental/tuple`  
`experimental/type_traits`  
`experimental/unordered_map`  
`experimental/unordered_set`  
`experimental/utility`  
`experimental/vector`  
  
  
  
Concurrency TS  
| `experimental/atomic`  
---  
`experimental/barrier`  
  
| `experimental/future`  
---  
`experimental/latch`  
  
Ranges TS  
| [`<experimental/ranges/algorithm>`](algorithm.html "cpp/header/experimental/ranges/algorithm")  
---  
[`<experimental/ranges/concepts>`](concepts.html "cpp/header/experimental/ranges/concepts")  
[`<experimental/ranges/functional>`](functional.html "cpp/header/experimental/ranges/functional")  
**`< experimental/ranges/iterator>`**  
  
| [`<experimental/ranges/random>`](random.html "cpp/header/experimental/ranges/random")  
---  
[`<experimental/ranges/tuple>`](tuple.html "cpp/header/experimental/ranges/tuple")  
[`<experimental/ranges/type_traits>`](type_traits.html "cpp/header/experimental/ranges/type traits")  
[`<experimental/ranges/utility>`](utility.html "cpp/header/experimental/ranges/utility")  
  
Coroutines TS  
`experimental/coroutine`  
Networking TS  
| `experimental/buffer`  
---  
`experimental/executor`  
`experimental/internet`  
`experimental/io_context`  
  
| [`<experimental/net>`](../net.html "cpp/header/experimental/net")  
---  
`experimental/netfwd`  
`experimental/socket`  
`experimental/timer`  
  
Reflection TS  
[`<experimental/reflect>`](../reflect.html "cpp/header/experimental/reflect")  
  


This header is part of the [ranges](../../../experimental/ranges.html "cpp/experimental/ranges") library. 

## Contents

  * [1 Iterator-related concepts](iterator.html#Iterator-related_concepts)
    * [1.1 Iterator concepts](iterator.html#Iterator_concepts)
    * [1.2 Indirect callable concepts](iterator.html#Indirect_callable_concepts)
    * [1.3 Common algorithm requirements](iterator.html#Common_algorithm_requirements)
    * [1.4 Concept utilities](iterator.html#Concept_utilities)
  * [2 Iterator primitives](iterator.html#Iterator_primitives)
    * [2.1 Iterator utilities](iterator.html#Iterator_utilities)
    * [2.2 Iterator traits](iterator.html#Iterator_traits)
    * [2.3 Iterator category tags](iterator.html#Iterator_category_tags)
    * [2.4 std::iterator_traits specializations](iterator.html#std::iterator_traits_specializations)
    * [2.5 Iterator operations](iterator.html#Iterator_operations)
  * [3 Iterator adaptors](iterator.html#Iterator_adaptors)
  * [4 Stream iterators](iterator.html#Stream_iterators)
  * [5 Synopsis](iterator.html#Synopsis)

  
---  
  
### Iterator-related concepts

Defined in namespace `std::experimental::ranges`  
---  
  
#### Iterator concepts

[ Readable](../../../experimental/ranges/iterator/Readable.html "cpp/experimental/ranges/iterator/Readable") |  specifies that a type is readable by applying operator `*`   
(concept)   
---|---  
[ Writable](../../../experimental/ranges/iterator/Writable.html "cpp/experimental/ranges/iterator/Writable") |  specifies that a value can be written to an iterator's referenced object   
(concept)   
[ WeaklyIncrementable](../../../experimental/ranges/iterator/WeaklyIncrementable.html "cpp/experimental/ranges/iterator/WeaklyIncrementable") |  specifies that a [`Semiregular`](../../../experimental/ranges/concepts/Semiregular.html "cpp/experimental/ranges/concepts/Semiregular") type can be incremented with pre- and post-increment operators   
(concept)   
[ Incrementable](../../../experimental/ranges/iterator/Incrementable.html "cpp/experimental/ranges/iterator/Incrementable") |  specifies that the increment operation on a [`WeaklyIncrementable`](../../../experimental/ranges/iterator/WeaklyIncrementable.html "cpp/experimental/ranges/iterator/WeaklyIncrementable") type is equality-preserving and that the type is [`EqualityComparable`](../../../experimental/ranges/concepts/EqualityComparable.html "cpp/experimental/ranges/concepts/EqualityComparable")   
(concept)   
[ Iterator](../../../experimental/ranges/iterator/Iterator.html "cpp/experimental/ranges/iterator/Iterator") |  specifies that objects of a type can be incremented and dereferenced   
(concept)   
[ Sentinel](../../../experimental/ranges/iterator/Sentinel.html "cpp/experimental/ranges/iterator/Sentinel") |  specifies that objects of a type is a sentinel for an [`Iterator`](../../../experimental/ranges/iterator/Iterator.html "cpp/experimental/ranges/iterator/Iterator") type   
(concept)   
[ SizedSentinel](../../../experimental/ranges/iterator/SizedSentinel.html "cpp/experimental/ranges/iterator/SizedSentinel") |  specifies that the `-` operator can be applied to an iterator and a sentinel to calculate their difference in constant time   
(concept)   
[ InputIterator](../../../experimental/ranges/iterator/InputIterator.html "cpp/experimental/ranges/iterator/InputIterator") |  specifies that a type is an input iterator, that is, its referenced values can be read and it can be both pre- and post-incremented   
(concept)   
[ OutputIterator](../../../experimental/ranges/iterator/OutputIterator.html "cpp/experimental/ranges/iterator/OutputIterator") |  specifies that a type is an output iterator for a given value type, that is, values of that type can be written to it and it can be both pre- and post-incremented   
(concept)   
[ ForwardIterator](../../../experimental/ranges/iterator/ForwardIterator.html "cpp/experimental/ranges/iterator/ForwardIterator") |  specifies that an [`InputIterator`](../../../experimental/ranges/iterator/InputIterator.html "cpp/experimental/ranges/iterator/InputIterator") is a forward iterator, supporting equality comparison and multi-pass   
(concept)   
[ BidirectionalIterator](../../../experimental/ranges/iterator/BidirectionalIterator.html "cpp/experimental/ranges/iterator/BidirectionalIterator") |  specifies that a [`ForwardIterator`](../../../experimental/ranges/iterator/ForwardIterator.html "cpp/experimental/ranges/iterator/ForwardIterator") is a bidirectional iterator, supporting movement backwards   
(concept)   
[ RandomAccessIterator](../../../experimental/ranges/iterator/RandomAccessIterator.html "cpp/experimental/ranges/iterator/RandomAccessIterator") |  specifies that a [`BidirectionalIterator`](../../../experimental/ranges/iterator/BidirectionalIterator.html "cpp/experimental/ranges/iterator/BidirectionalIterator") is a random-access iterator, supporting advancement in constant time and subscripting   
(concept)   
  
#### Indirect callable concepts

[ IndirectUnaryInvocableIndirectRegularUnaryInvocable](../../../experimental/ranges/iterator/IndirectUnaryInvocable.html "cpp/experimental/ranges/iterator/IndirectUnaryInvocable") |  specifies that a callable type can be invoked with the result of dereferencing a [`Readable`](../../../experimental/ranges/iterator/Readable.html "cpp/experimental/ranges/iterator/Readable") type   
(concept)   
---|---  
[ IndirectUnaryPredicate](../../../experimental/ranges/iterator/IndirectUnaryPredicate.html "cpp/experimental/ranges/iterator/IndirectUnaryPredicate") |  specifies that a callable object, when invoked with the result of dereferencing a [`Readable`](../../../experimental/ranges/iterator/Readable.html "cpp/experimental/ranges/iterator/Readable") type, satisfies [`Predicate`](../../../experimental/ranges/concepts/Predicate.html "cpp/experimental/ranges/concepts/Predicate")   
(concept)   
[ IndirectRelation](../../../experimental/ranges/iterator/IndirectRelation.html "cpp/experimental/ranges/iterator/IndirectRelation") |  specifies that a callable object, when invoked with the result of dereferencing some [`Readable`](../../../experimental/ranges/iterator/Readable.html "cpp/experimental/ranges/iterator/Readable") types, satisfies [`Relation`](../../../experimental/ranges/concepts/Relation.html "cpp/experimental/ranges/concepts/Relation")   
(concept)   
[ IndirectStrictWeakOrder](../../../experimental/ranges/iterator/IndirectStrictWeakOrder.html "cpp/experimental/ranges/iterator/IndirectStrictWeakOrder") |  specifies that a callable object, when invoked with the result of dereferencing some [`Readable`](../../../experimental/ranges/iterator/Readable.html "cpp/experimental/ranges/iterator/Readable") types, satisfies [`StrictWeakOrder`](../../../experimental/ranges/concepts/StrictWeakOrder.html "cpp/experimental/ranges/concepts/StrictWeakOrder")   
(concept)   
  
#### Common algorithm requirements

[ IndirectlyMovable](../../../experimental/ranges/iterator/IndirectlyMovable.html "cpp/experimental/ranges/iterator/IndirectlyMovable") |  specifies that values may be moved from a [`Readable`](../../../experimental/ranges/iterator/Readable.html "cpp/experimental/ranges/iterator/Readable") type to a [`Writable`](../../../experimental/ranges/iterator/Writable.html "cpp/experimental/ranges/iterator/Writable") type   
(concept)   
---|---  
[ IndirectlyMovableStorable](../../../experimental/ranges/iterator/IndirectlyMovableStorable.html "cpp/experimental/ranges/iterator/IndirectlyMovableStorable") |  specifies that values may be moved from a [`Readable`](../../../experimental/ranges/iterator/Readable.html "cpp/experimental/ranges/iterator/Readable") type to a [`Writable`](../../../experimental/ranges/iterator/Writable.html "cpp/experimental/ranges/iterator/Writable") type and that the move may be performed via an intermediate object   
(concept)   
[ IndirectlyCopyable](../../../experimental/ranges/iterator/IndirectlyCopyable.html "cpp/experimental/ranges/iterator/IndirectlyCopyable") |  specifies that values may be copied from a [`Readable`](../../../experimental/ranges/iterator/Readable.html "cpp/experimental/ranges/iterator/Readable") type to a [`Writable`](../../../experimental/ranges/iterator/Writable.html "cpp/experimental/ranges/iterator/Writable") type   
(concept)   
[ IndirectlyCopyableStorable](../../../experimental/ranges/iterator/IndirectlyCopyableStorable.html "cpp/experimental/ranges/iterator/IndirectlyCopyableStorable") |  specifies that values may be copied from a [`Readable`](../../../experimental/ranges/iterator/Readable.html "cpp/experimental/ranges/iterator/Readable") type to a [`Writable`](../../../experimental/ranges/iterator/Writable.html "cpp/experimental/ranges/iterator/Writable") type and that the copy may be performed via an intermediate object   
(concept)   
[ IndirectlySwappable](../../../experimental/ranges/iterator/IndirectlySwappable.html "cpp/experimental/ranges/iterator/IndirectlySwappable") |  specifies that the values referenced by two [`Readable`](../../../experimental/ranges/iterator/Readable.html "cpp/experimental/ranges/iterator/Readable") types can be swapped   
(concept)   
[ IndirectlyComparable](../../../experimental/ranges/iterator/IndirectlyComparable.html "cpp/experimental/ranges/iterator/IndirectlyComparable") |  specifies that the values referenced by two [`Readable`](../../../experimental/ranges/iterator/Readable.html "cpp/experimental/ranges/iterator/Readable") types can be compared   
(concept)   
[ Permutable](../../../experimental/ranges/iterator/Permutable.html "cpp/experimental/ranges/iterator/Permutable") |  specifies the common requirements of algorithms that reorder elements in place   
(concept)   
[ Mergeable](../../../experimental/ranges/iterator/Mergeable.html "cpp/experimental/ranges/iterator/Mergeable") |  specifies the requirements of algorithms that merge sorted sequences into an output sequence by copying elements   
(concept)   
[ Sortable](../../../experimental/ranges/iterator/Sortable.html "cpp/experimental/ranges/iterator/Sortable") |  specifies the common requirements of algorithms that permute sequences into ordered sequences   
(concept)   
  
#### Concept utilities

[ indirect_result_of](../../../experimental/ranges/iterator/indirect_result_of.html "cpp/experimental/ranges/iterator/indirect result of") |  compute the result of invoking a callable object on the result of dereferencing some set of [`Readable`](../../../experimental/ranges/iterator/Readable.html "cpp/experimental/ranges/iterator/Readable") types   
(class template)   
---|---  
[ projected](../../../experimental/ranges/iterator/projected.html "cpp/experimental/ranges/iterator/projected") |  helper template for specifying the constraints on algorithms that accept projections   
(class template)   
  
### Iterator primitives

#### Iterator utilities

Defined in namespace `std::experimental::ranges`  
---  
[ iter_move](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/iterator/iter_move&action=edit&redlink=1 "cpp/experimental/ranges/iterator/iter move \(page does not exist\)") |  casts the result of dereferencing an object to its associated rvalue reference type  
(customization point object)  
[ iter_swap](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/iterator/iter_swap&action=edit&redlink=1 "cpp/experimental/ranges/iterator/iter swap \(page does not exist\)") |  swap the values referenced by two dereferenceable objects  
(customization point object)  
  
#### Iterator traits

Defined in namespace `std::experimental::ranges`  
---  
[ difference_type](../../../experimental/ranges/iterator/difference_type.html "cpp/experimental/ranges/iterator/difference type") |  obtains the difference type of a [`WeaklyIncrementable`](../../../experimental/ranges/iterator/WeaklyIncrementable.html "cpp/experimental/ranges/iterator/WeaklyIncrementable") type   
(class template)   
[ value_type](../../../experimental/ranges/iterator/value_type.html "cpp/experimental/ranges/iterator/value type") |  obtains the value type of a [`Readable`](../../../experimental/ranges/iterator/Readable.html "cpp/experimental/ranges/iterator/Readable") type   
(class template)   
[ iterator_category](../../../experimental/ranges/iterator/iterator_category.html "cpp/experimental/ranges/iterator/iterator category") |  obtains the iterator category of an input iterator type   
(class template)   
[ iterator_traits](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/iterator/iterator_traits&action=edit&redlink=1 "cpp/experimental/ranges/iterator/iterator traits \(page does not exist\)") |  compatibility traits class that collects an iterator’s associated types  
(alias template)  
[ reference_trvalue_reference_titer_common_reference_t](../../../experimental/ranges/iterator/reference_t.html "cpp/experimental/ranges/iterator/reference t") |  obtains a dereferenceable object's associated reference types  
(alias template)  
  
#### Iterator category tags

Defined in namespace `std::experimental::ranges`  
---  
[ input_iterator_tagoutput_iterator_tagforward_iterator_tagbidirectional_iterator_tagrandom_access_iterator_tag](../../../experimental/ranges/iterator/iterator_tags.html "cpp/experimental/ranges/iterator/iterator tags") |  empty class types used to indicate iterator categories   
(class)   
  
#### [std::iterator_traits](../../../iterator/iterator_traits.html "cpp/iterator/iterator traits") specializations

Defined in namespace `std`  
---  
[ std::iterator_traits<InputIterator>std::iterator_traits<OutputIterator>](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/iterator/std_iter_traits&action=edit&redlink=1 "cpp/experimental/ranges/iterator/std iter traits \(page does not exist\)") |  specializes [std::iterator_traits](../../../iterator/iterator_traits.html "cpp/iterator/iterator traits") for ranges TS iterators   
(class template specialization)   
  
#### Iterator operations

Defined in namespace `std::experimental::ranges`  
---  
[ advance](../../../experimental/ranges/iterator/advance.html "cpp/experimental/ranges/iterator/advance") |  advances an iterator by given distance   
(function template)   
[ distance](../../../experimental/ranges/iterator/distance.html "cpp/experimental/ranges/iterator/distance") |  returns the distance between an iterator and a sentinel, or between the beginning and the end of a range   
(function template)   
[ next](../../../experimental/ranges/iterator/next.html "cpp/experimental/ranges/iterator/next") |  increment an iterator   
(function template)   
[ prev](../../../experimental/ranges/iterator/prev.html "cpp/experimental/ranges/iterator/prev") |  decrement an iterator   
(function template)   
  
### Iterator adaptors

Defined in namespace `std::experimental::ranges`  
---  
[ reverse_iterator](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/iterator/reverse_iterator&action=edit&redlink=1 "cpp/experimental/ranges/iterator/reverse iterator \(page does not exist\)") |  iterator adaptor for reverse-order traversal   
(class template)   
[ back_insert_iterator](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/iterator/back_insert_iterator&action=edit&redlink=1 "cpp/experimental/ranges/iterator/back insert iterator \(page does not exist\)") |  iterator adaptor for insertion at the end of a container   
(class template)   
[ front_insert_iterator](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/iterator/front_insert_iterator&action=edit&redlink=1 "cpp/experimental/ranges/iterator/front insert iterator \(page does not exist\)") |  iterator adaptor for insertion at the front of a container   
(class template)   
[ insert_iterator](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/iterator/insert_iterator&action=edit&redlink=1 "cpp/experimental/ranges/iterator/insert iterator \(page does not exist\)") |  iterator adaptor for insertion into a container   
(class template)   
[ move_iterator](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/iterator/move_iterator&action=edit&redlink=1 "cpp/experimental/ranges/iterator/move iterator \(page does not exist\)") |  iterator adaptor which dereferences to an rvalue reference   
(class template)   
[ move_sentinel](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/iterator/move_sentinel&action=edit&redlink=1 "cpp/experimental/ranges/iterator/move sentinel \(page does not exist\)") |  sentinel adaptor for use with `move_iterator`   
(class template)   
[ common_iterator](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/iterator/common_iterator&action=edit&redlink=1 "cpp/experimental/ranges/iterator/common iterator \(page does not exist\)") |  adapt an iterator-sentinel pair into a common iterator type for use with legacy algorithms   
(class template)   
[ counted_iterator](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/iterator/counted_iterator&action=edit&redlink=1 "cpp/experimental/ranges/iterator/counted iterator \(page does not exist\)") |  iterator adaptor that keeps track of its distance from its starting position   
(class template)   
[ default_sentinel](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/iterator/default_sentinel&action=edit&redlink=1 "cpp/experimental/ranges/iterator/default sentinel \(page does not exist\)") |  empty sentinel type for use with iterator types that know the bound of their range   
(class)   
[ dangling](../../../experimental/ranges/iterator/dangling.html "cpp/experimental/ranges/iterator/dangling") |  wrapper for a possibly dangling iterator   
(class template)   
[ safe_iterator_t](../../../experimental/ranges/iterator/dangling.html "cpp/experimental/ranges/iterator/dangling") |  alias template that wraps the iterator type of an rvalue range with `dangling`  
(alias template)  
[ unreachable](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/iterator/unreachable&action=edit&redlink=1 "cpp/experimental/ranges/iterator/unreachable \(page does not exist\)") |  sentinel type used with any iterator to denote an infinite range   
(class)   
  
### Stream iterators

Defined in namespace `std::experimental::ranges`  
---  
[ istream_iterator](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/iterator/istream_iterator&action=edit&redlink=1 "cpp/experimental/ranges/iterator/istream iterator \(page does not exist\)") |  input iterator that reads from [std::basic_istream](../../../io/basic_istream.html "cpp/io/basic istream")   
(class template)   
[ ostream_iterator](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/iterator/ostream_iterator&action=edit&redlink=1 "cpp/experimental/ranges/iterator/ostream iterator \(page does not exist\)") |  output iterator that writes to [std::basic_ostream](../../../io/basic_ostream.html "cpp/io/basic ostream")   
(class template)   
[ istreambuf_iterator](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/iterator/istreambuf_iterator&action=edit&redlink=1 "cpp/experimental/ranges/iterator/istreambuf iterator \(page does not exist\)") |  input iterator that reads from [std::basic_streambuf](../../../io/basic_streambuf.html "cpp/io/basic streambuf")   
(class template)   
[ ostreambuf_iterator](https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/ranges/iterator/ostreambuf_iterator&action=edit&redlink=1 "cpp/experimental/ranges/iterator/ostreambuf iterator \(page does not exist\)") |  output iterator that writes to [std::basic_streambuf](../../../io/basic_streambuf.html "cpp/io/basic streambuf")   
(class template)   
  
### Synopsis
    
    
    namespace std { namespace experimental { namespace ranges { inline namespace v1 {
     
    template <class T> concept bool /* dereferenceable */ // exposition only
      = requires(T& t) { {*t} -> auto&&; };
     
    namespace {
      constexpr /* unspecified */ iter_move = /* unspecified */;
      constexpr /* unspecified */ iter_swap = /* unspecified */;
    }
     
    template <class> struct difference_type;
    template <class T> using difference_type_t
      = typename difference_type<T>::type;
     
    template <class> struct value_type;
    template <class T> using value_type_t
      = typename value_type<T>::type;
     
    template <class> struct iterator_category;
    template <class T> using iterator_category_t
      = typename iterator_category<T>::type;
     
    template </* dereferenceable */ T> using reference_t
      = decltype(*declval<T&>());
     
    template </* dereferenceable */ T>
        requires /* see definition */ using rvalue_reference_t
      = decltype([ranges::iter_move](../../../iterator/ranges/iter_move.html)(declval<T&>()));
     
    template <class In>
    concept bool Readable = /* see definition */;
     
    template <class Out, class T>
    concept bool Writable = /* see definition */;
     
    template <class I>
    concept bool WeaklyIncrementable = /* see definition */;
     
    template <class I>
    concept bool Incrementable = /* see definition */;
     
    template <class I>
    concept bool Iterator = /* see definition */;
     
    template <class S, class I>
    concept bool Sentinel = /* see definition */;
     
    template <class S, class I>
      constexpr bool disable_sized_sentinel = false;
     
    template <class S, class I>
    concept bool SizedSentinel = /* see definition */;
     
    template <class I>
    concept bool InputIterator = /* see definition */;
     
    template <class I>
    concept bool OutputIterator = /* see definition */;
     
    template <class I>
    concept bool ForwardIterator = /* see definition */;
     
    template <class I>
    concept bool BidirectionalIterator = /* see definition */;
     
    template <class I>
    concept bool RandomAccessIterator = /* see definition */;
     
    template <class F, class I>
    concept bool IndirectUnaryInvocable = /* see definition */;
     
    template <class F, class I>
    concept bool IndirectRegularUnaryInvocable = /* see definition */;
     
    template <class F, class I>
    concept bool IndirectUnaryPredicate = /* see definition */;
     
    template <class F, class I1, class I2 = I1>
    concept bool IndirectRelation = /* see definition */;
     
    template <class F, class I1, class I2 = I1>
    concept bool IndirectStrictWeakOrder = /* see definition */;
     
    template <class> struct indirect_result_of;
     
    template <class F, class... Is>
      requires Invocable<F, reference_t<Is>...>
    struct indirect_result_of<F(Is...)>;
     
    template <class F>
    using indirect_result_of_t
      = typename indirect_result_of<F>::type;
     
    template <Readable I, IndirectRegularUnaryInvocable<I> Proj>
    struct [projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected);
     
    template <WeaklyIncrementable I, class Proj>
    struct difference_type<[projected](http://en.cppreference.com/w/cpp/ranges-placeholder/iterator/projected)<I, Proj>>;
     
    template <class In, class Out>
    concept bool IndirectlyMovable = /* see definition */;
     
    template <class In, class Out>
    concept bool IndirectlyMovableStorable = /* see definition */;
     
    template <class In, class Out>
    concept bool IndirectlyCopyable = /* see definition */;
     
    template <class In, class Out>
    concept bool IndirectlyCopyableStorable = /* see definition */;
     
    template <class I1, class I2 = I1>
    concept bool IndirectlySwappable = /* see definition */;
     
    template <class I1, class I2, class R = equal_to<>, class P1 = identity,
        class P2 = identity>
    concept bool IndirectlyComparable = /* see definition */;
     
    template <class I>
    concept bool Permutable = /* see definition */;
     
    template <class I1, class I2, class Out,
        class R = less<>, class P1 = identity, class P2 = identity>
    concept bool Mergeable = /* see definition */;
     
    template <class I, class R = less<>, class P = identity>
    concept bool Sortable = /* see definition */;
     
    template <class Iterator> using iterator_traits = /* see definition */;
     
    template <Readable T> using iter_common_reference_t
      = common_reference_t<reference_t<T>, value_type_t<T>&>;
     
    struct output_iterator_tag { };
    struct input_iterator_tag { };
    struct forward_iterator_tag : input_iterator_tag { };
    struct bidirectional_iterator_tag : forward_iterator_tag { };
    struct random_access_iterator_tag : bidirectional_iterator_tag { };
     
    namespace {
      constexpr /* unspecified */ advance = /* unspecified */;
      constexpr /* unspecified */ distance = /* unspecified */;
      constexpr /* unspecified */ next = /* unspecified */;
      constexpr /* unspecified */ prev = /* unspecified */;
    }
     
    template <BidirectionalIterator I> class reverse_iterator;
     
    template <class I1, class I2>
        requires EqualityComparableWith<I1, I2>
      constexpr bool operator==(
        const reverse_iterator<I1>& x,
        const reverse_iterator<I2>& y);
    template <class I1, class I2>
        requires EqualityComparableWith<I1, I2>
      constexpr bool operator!=(
        const reverse_iterator<I1>& x,
        const reverse_iterator<I2>& y);
    template <class I1, class I2>
        requires StrictTotallyOrderedWith<I1, I2>
      constexpr bool operator<(
        const reverse_iterator<I1>& x,
        const reverse_iterator<I2>& y);
    template <class I1, class I2>
        requires StrictTotallyOrderedWith<I1, I2>
      constexpr bool operator>(
        const reverse_iterator<I1>& x,
        const reverse_iterator<I2>& y);
    template <class I1, class I2>
        requires StrictTotallyOrderedWith<I1, I2>
      constexpr bool operator>=(
        const reverse_iterator<I1>& x,
        const reverse_iterator<I2>& y);
    template <class I1, class I2>
        requires StrictTotallyOrderedWith<I1, I2>
      constexpr bool operator<=(
        const reverse_iterator<I1>& x,
        const reverse_iterator<I2>& y);
     
    template <class I1, class I2>
        requires SizedSentinel<I1, I2>
      constexpr difference_type_t<I2> operator-(
        const reverse_iterator<I1>& x,
        const reverse_iterator<I2>& y);
    template <RandomAccessIterator I>
      constexpr reverse_iterator<I> operator+(
        difference_type_t<I> n,
        const reverse_iterator<I>& x);
     
    template <BidirectionalIterator I>
    constexpr reverse_iterator<I> make_reverse_iterator(I i);
     
    template <class Container> class back_insert_iterator;
    template <class Container>
      back_insert_iterator<Container> back_inserter(Container& x);
     
    template <class Container> class front_insert_iterator;
    template <class Container>
      front_insert_iterator<Container> front_inserter(Container& x);
     
    template <class Container> class insert_iterator;
    template <class Container>
      insert_iterator<Container> inserter(Container& x, iterator_t<Container> i);
     
    template <InputIterator I> class move_iterator;
     
    template <class I1, class I2>
        requires EqualityComparableWith<I1, I2>
      constexpr bool operator==(
        const move_iterator<I1>& x, const move_iterator<I2>& y);
    template <class I1, class I2>
        requires EqualityComparableWith<I1, I2>
      constexpr bool operator!=(
        const move_iterator<I1>& x, const move_iterator<I2>& y);
    template <class I1, class I2>
        requires StrictTotallyOrderedWith<I1, I2>
      constexpr bool operator<(
        const move_iterator<I1>& x, const move_iterator<I2>& y);
    template <class I1, class I2>
        requires StrictTotallyOrderedWith<I1, I2>
      constexpr bool operator<=(
        const move_iterator<I1>& x, const move_iterator<I2>& y);
    template <class I1, class I2>
        requires StrictTotallyOrderedWith<I1, I2>
      constexpr bool operator>(
        const move_iterator<I1>& x, const move_iterator<I2>& y);
    template <class I1, class I2>
        requires StrictTotallyOrderedWith<I1, I2>
      constexpr bool operator>=(
        const move_iterator<I1>& x, const move_iterator<I2>& y);
     
    template <class I1, class I2>
        requires SizedSentinel<I1, I2>
      constexpr difference_type_t<I2> operator-(
        const move_iterator<I1>& x,
        const move_iterator<I2>& y);
    template <RandomAccessIterator I>
      constexpr move_iterator<I> operator+(
        difference_type_t<I> n,
        const move_iterator<I>& x);
     
    template <InputIterator I>
      constexpr move_iterator<I> make_move_iterator(I i);
     
    template <Semiregular S> class move_sentinel;
     
    template <class I, Sentinel<I> S>
      constexpr bool operator==(
        const move_iterator<I>& i, const move_sentinel<S>& s);
    template <class I, Sentinel<I> S>
      constexpr bool operator==(
        const move_sentinel<S>& s, const move_iterator<I>& i);
    template <class I, Sentinel<I> S>
      constexpr bool operator!=(
        const move_iterator<I>& i, const move_sentinel<S>& s);
    template <class I, Sentinel<I> S>
      constexpr bool operator!=(
        const move_sentinel<S>& s, const move_iterator<I>& i);
     
    template <class I, SizedSentinel<I> S>
      constexpr difference_type_t<I> operator-(
        const move_sentinel<S>& s, const move_iterator<I>& i);
    template <class I, SizedSentinel<I> S>
      constexpr difference_type_t<I> operator-(
        const move_iterator<I>& i, const move_sentinel<S>& s);
     
    template <Semiregular S>
      constexpr move_sentinel<S> make_move_sentinel(S s);
     
    template <Iterator I, Sentinel<I> S>
      requires !Same<I, S>
    class common_iterator;
     
    template <Readable I, class S>
    struct value_type<common_iterator<I, S>>;
     
    template <InputIterator I, class S>
    struct iterator_category<common_iterator<I, S>>;
     
    template <ForwardIterator I, class S>
    struct iterator_category<common_iterator<I, S>>;
     
    template <class I1, class I2, Sentinel<I2> S1, Sentinel<I1> S2>
    bool operator==(
      const common_iterator<I1, S1>& x, const common_iterator<I2, S2>& y);
    template <class I1, class I2, Sentinel<I2> S1, Sentinel<I1> S2>
      requires EqualityComparableWith<I1, I2>
    bool operator==(
      const common_iterator<I1, S1>& x, const common_iterator<I2, S2>& y);
    template <class I1, class I2, Sentinel<I2> S1, Sentinel<I1> S2>
    bool operator!=(
      const common_iterator<I1, S1>& x, const common_iterator<I2, S2>& y);
     
    template <class I2, SizedSentinel<I2> I1, SizedSentinel<I2> S1, SizedSentinel<I1> S2>
    difference_type_t<I2> operator-(
      const common_iterator<I1, S1>& x, const common_iterator<I2, S2>& y);
     
    class default_sentinel;
     
    template <Iterator I> class counted_iterator;
     
    template <class I1, class I2>
        requires Common<I1, I2>
      constexpr bool operator==(
        const counted_iterator<I1>& x, const counted_iterator<I2>& y);
    constexpr bool operator==(
      const counted_iterator<auto>& x, default_sentinel);
    constexpr bool operator==(
      default_sentinel, const counted_iterator<auto>& x);
    template <class I1, class I2>
        requires Common<I1, I2>
      constexpr bool operator!=(
        const counted_iterator<I1>& x, const counted_iterator<I2>& y);
    constexpr bool operator!=(
      const counted_iterator<auto>& x, default_sentinel y);
    constexpr bool operator!=(
      default_sentinel x, const counted_iterator<auto>& y);
    template <class I1, class I2>
        requires Common<I1, I2>
      constexpr bool operator<(
        const counted_iterator<I1>& x, const counted_iterator<I2>& y);
    template <class I1, class I2>
        requires Common<I1, I2>
      constexpr bool operator<=(
        const counted_iterator<I1>& x, const counted_iterator<I2>& y);
    template <class I1, class I2>
        requires Common<I1, I2>
      constexpr bool operator>(
        const counted_iterator<I1>& x, const counted_iterator<I2>& y);
    template <class I1, class I2>
        requires Common<I1, I2>
      constexpr bool operator>=(
        const counted_iterator<I1>& x, const counted_iterator<I2>& y);
     
    template <class I1, class I2>
        requires Common<I1, I2>
      constexpr difference_type_t<I2> operator-(
        const counted_iterator<I1>& x, const counted_iterator<I2>& y);
    template <class I>
      constexpr difference_type_t<I> operator-(
        const counted_iterator<I>& x, default_sentinel y);
    template <class I>
      constexpr difference_type_t<I> operator-(
        default_sentinel x, const counted_iterator<I>& y);
    template <RandomAccessIterator I>
      constexpr counted_iterator<I>
        operator+(difference_type_t<I> n, const counted_iterator<I>& x);
     
    template <Iterator I>
      constexpr counted_iterator<I> make_counted_iterator(I i, difference_type_t<I> n);
     
    class unreachable;
    template <Iterator I>
      constexpr bool operator==(const I&, unreachable) noexcept;
    template <Iterator I>
      constexpr bool operator==(unreachable, const I&) noexcept;
    template <Iterator I>
      constexpr bool operator!=(const I&, unreachable) noexcept;
    template <Iterator I>
      constexpr bool operator!=(unreachable, const I&) noexcept;
     
    template <class T> class dangling;
     
    template <class T, class CharT = char, class Traits = char_traits<CharT>,
        class Distance = ptrdiff_t>
      class istream_iterator;
     
    template <class T, class CharT, class Traits, class Distance>
      bool operator==(const istream_iterator<T, CharT, Traits, Distance>& x,
        const istream_iterator<T, CharT, Traits, Distance>& y);
    template <class T, class CharT, class Traits, class Distance>
      bool operator==(default_sentinel x,
        const istream_iterator<T, CharT, Traits, Distance>& y);
    template <class T, class CharT, class Traits, class Distance>
      bool operator==(const istream_iterator<T, CharT, Traits, Distance>& x,
        default_sentinel y);
    template <class T, class CharT, class Traits, class Distance>
      bool operator!=(const istream_iterator<T, CharT, Traits, Distance>& x,
        const istream_iterator<T, CharT, Traits, Distance>& y);
    template <class T, class CharT, class Traits, class Distance>
      bool operator!=(default_sentinel x,
        const istream_iterator<T, CharT, Traits, Distance>& y);
    template <class T, class CharT, class Traits, class Distance>
      bool operator!=(const istream_iterator<T, CharT, Traits, Distance>& x,
        default_sentinel y);
     
    template <class T, class CharT = char, class Traits = char_traits<CharT>>
      class ostream_iterator;
     
    template <class CharT, class Traits = char_traits<CharT> >
      class istreambuf_iterator;
     
    template <class CharT, class Traits>
      bool operator==(const istreambuf_iterator<CharT, Traits>& a,
        const istreambuf_iterator<CharT, Traits>& b);
    template <class CharT, class Traits>
      bool operator==(default_sentinel a,
        const istreambuf_iterator<CharT, Traits>& b);
    template <class CharT, class Traits>
      bool operator==(const istreambuf_iterator<CharT, Traits>& a,
        default_sentinel b);
    template <class CharT, class Traits>
      bool operator!=(const istreambuf_iterator<CharT, Traits>& a,
        const istreambuf_iterator<CharT, Traits>& b);
    template <class CharT, class Traits>
      bool operator!=(default_sentinel a,
        const istreambuf_iterator<CharT, Traits>& b);
    template <class CharT, class Traits>
      bool operator!=(const istreambuf_iterator<CharT, Traits>& a,
        default_sentinel b);
     
    template <class CharT, class Traits = char_traits<CharT> >
      class ostreambuf_iterator;
     
    }}}}
     
    namespace std {
      template <experimental::ranges::Iterator Out>
        struct iterator_traits<Out>;
      template <experimental::ranges::InputIterator In>
        struct iterator_traits<In>;
      template <experimental::ranges::InputIterator In>
          requires experimental::ranges::Sentinel<In, In>
        struct iterator_traits;
    }
