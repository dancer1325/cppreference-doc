[C++](../../cpp.html "cpp")

[Compiler support](../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../freestanding.html "cpp/freestanding")  
[Language](../language.html "cpp/language")  
[Standard library](../standard_library.html "cpp/standard library")  
[Standard library headers](../headers.html "cpp/header")  
[Named requirements](../iterator/concepts.html "cpp/named req")  
[Feature test macros](../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../utility.html#Language_support "cpp/utility")  
[Concepts library](../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../error.html "cpp/error")  
[Memory management library](../memory.html "cpp/memory")  
[Metaprogramming library](../meta.html "cpp/meta") (C++11)  
[General utilities library](../utility.html "cpp/utility")  
[Containers library](../container.html "cpp/container")  
[Iterators library](../iterator.html "cpp/iterator")  
[Ranges library](../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../algorithm.html "cpp/algorithm")  
[Strings library](../string.html "cpp/string")  
[Text processing library](../text.html "cpp/text")  
[Numerics library](../numeric.html "cpp/numeric")  
[Date and time library](../chrono.html "cpp/chrono")  
[Input/output library](../io.html "cpp/io")  
[Filesystem library](../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../atomic.html "cpp/thread") (C++11)  
[Execution control library](../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../experimental.html "cpp/experimental")  
[Symbols index](../symbol_index.html "cpp/symbol index")  
[External libraries](../links/libs.html "cpp/links/libs")  
  


[Standard library headers](../headers.html "cpp/header")

| [Language support](../headers.html#Language_support_library "cpp/header")  
---  
[`<cfloat>`](cfloat.html "cpp/header/cfloat")  
[`<climits>`](climits.html "cpp/header/climits")  
[`<compare>`](compare.html "cpp/header/compare") (C++20)  
[`<contracts>`](contracts.html "cpp/header/contracts") (C++26)  
[`<coroutine>`](coroutine.html "cpp/header/coroutine") (C++20)  
[`<csetjmp>`](csetjmp.html "cpp/header/csetjmp")  
[`<csignal>`](csignal.html "cpp/header/csignal")  
[`<cstdarg>`](cstdarg.html "cpp/header/cstdarg")  
[`<cstddef>`](cstddef.html "cpp/header/cstddef")  
[`<cstdint>`](cstdint.html "cpp/header/cstdint") (C++11)  
[`<cstdlib>`](cstdlib.html "cpp/header/cstdlib")  
[`<exception>`](exception.html "cpp/header/exception")  
[`<initializer_list>`](initializer_list.html "cpp/header/initializer list") (C++11)` `  
[`<limits>`](limits.html "cpp/header/limits")  
[`<new>`](new.html "cpp/header/new")  
[`<source_location>`](source_location.html "cpp/header/source location") (C++20)  
[`<stdfloat>`](stdfloat.html "cpp/header/stdfloat") (C++23)  
[`<typeinfo>`](typeinfo.html "cpp/header/typeinfo")  
[`<version>`](version.html "cpp/header/version") (C++20)  
[Concepts](../headers.html#Concepts_library "cpp/header")  
[`<concepts>`](concepts.html "cpp/header/concepts") (C++20)  
[Diagnostics](../headers.html#Diagnostics_library "cpp/header")  
[`<cassert>`](cassert.html "cpp/header/cassert")  
[`<cerrno>`](cerrno.html "cpp/header/cerrno")  
[`<debugging>`](debugging.html "cpp/header/debugging") (C++26)  
[`<stacktrace>`](stacktrace.html "cpp/header/stacktrace") (C++23)  
[`<stdexcept>`](stdexcept.html "cpp/header/stdexcept")  
[`<system_error>`](system_error.html "cpp/header/system error") (C++11)  
[Memory management](../headers.html#Memory_management_library "cpp/header")  
[`<memory>`](memory.html "cpp/header/memory")  
[`<memory_resource>`](memory_resource.html "cpp/header/memory resource") (C++17)  
[`<scoped_allocator>`](scoped_allocator.html "cpp/header/scoped allocator") (C++11)  
[Metaprogramming](../headers.html#Metaprogramming_library "cpp/header")  
[`<type_traits>`](type_traits.html "cpp/header/type traits") (C++11)  
[`<ratio>`](ratio.html "cpp/header/ratio") (C++11)  
  
  
  
| [General utilities](../headers.html#General_utilities_library "cpp/header")  
---  
[`<any>`](any.html "cpp/header/any") (C++17)  
[`<bitset>`](bitset.html "cpp/header/bitset")  
[`<bit>`](bit.html "cpp/header/bit") (C++20)  
[`<charconv>`](charconv.html "cpp/header/charconv") (C++17)  
[`<expected>`](expected.html "cpp/header/expected") (C++23)  
[`<format>`](format.html "cpp/header/format") (C++20)  
[`<functional>`](functional.html "cpp/header/functional")  
[`<optional>`](optional.html "cpp/header/optional") (C++17)  
[`<stdbit.h>`](stdbit.h.html "cpp/header/stdbit.h") (C++26)  
[`<tuple>`](tuple.html "cpp/header/tuple") (C++11)  
[`<typeindex>`](typeindex.html "cpp/header/typeindex") (C++11)  
[`<utility>`](utility.html "cpp/header/utility")  
[`<variant>`](variant.html "cpp/header/variant") (C++17)  
[Containers](../headers.html#Containers_library "cpp/header")  
[`<array>`](array.html "cpp/header/array") (C++11)  
[`<deque>`](deque.html "cpp/header/deque")  
[`<flat_map>`](flat_map.html "cpp/header/flat map") (C++23)  
[`<flat_set>`](flat_set.html "cpp/header/flat set") (C++23)  
[`<forward_list>`](forward_list.html "cpp/header/forward list") (C++11)  
[`<hive>`](hive.html "cpp/header/hive") (C++26)  
[`<inplace_vector>`](inplace_vector.html "cpp/header/inplace vector") (C++26)` `  
[`<list>`](list.html "cpp/header/list")  
[`<map>`](map.html "cpp/header/map")  
[`<mdspan>`](mdspan.html "cpp/header/mdspan") (C++23)  
[`<queue>`](queue.html "cpp/header/queue")  
[`<set>`](set.html "cpp/header/set")  
[`<span>`](span.html "cpp/header/span") (C++20)  
[`<stack>`](stack.html "cpp/header/stack")  
[`<unordered_map>`](unordered_map.html "cpp/header/unordered map") (C++11)  
[`<unordered_set>`](unordered_set.html "cpp/header/unordered set") (C++11)  
[`<vector>`](vector.html "cpp/header/vector")  
[Iterators](../headers.html#Iterators_library "cpp/header")  
[`<iterator>`](iterator.html "cpp/header/iterator")  
[Ranges](../headers.html#Ranges_library "cpp/header")  
[`<generator>`](generator.html "cpp/header/generator") (C++23)  
[`<ranges>`](ranges.html "cpp/header/ranges") (C++20)  
  
| [Algorithms](../headers.html#Algorithms_library "cpp/header")  
---  
[`<algorithm>`](algorithm.html "cpp/header/algorithm")  
[`<numeric>`](numeric.html "cpp/header/numeric")  
[Strings](../headers.html#Strings_library "cpp/header")  
[`<cctype>`](cctype.html "cpp/header/cctype")  
[`<cstring>`](cstring.html "cpp/header/cstring")  
[`<cuchar>`](cuchar.html "cpp/header/cuchar") (C++11)  
[`<cwchar>`](cwchar.html "cpp/header/cwchar")  
[`<cwctype>`](cwctype.html "cpp/header/cwctype")  
[`<string_view>`](string_view.html "cpp/header/string view") (C++17)  
[`<string>`](string.html "cpp/header/string")  
[Text processing](../headers.html#Text_processing_library "cpp/header")  
[`<clocale>`](clocale.html "cpp/header/clocale")  
[`<codecvt>`](codecvt.html "cpp/header/codecvt") (C++11/17/26*)  
[`<locale>`](locale.html "cpp/header/locale")  
**`< regex>`** (C++11)  
[`<text_encoding>`](text_encoding.html "cpp/header/text encoding") (C++26)` `  
[Numerics](../headers.html#Numerics_library "cpp/header")  
[`<cfenv>`](cfenv.html "cpp/header/cfenv") (C++11)  
[`<cmath>`](cmath.html "cpp/header/cmath")  
[`<complex>`](complex.html "cpp/header/complex")  
[`<linalg>`](linalg.html "cpp/header/linalg") (C++26)  
[`<numbers>`](numbers.html "cpp/header/numbers") (C++20)  
[`<random>`](random.html "cpp/header/random") (C++11)  
[`<simd>`](simd.html "cpp/header/simd") (C++26)  
[`<stdckdint.h>`](stdckdint.h.html "cpp/header/stdckdint.h") (C++26)  
[`<valarray>`](valarray.html "cpp/header/valarray")  
[Time](../headers.html#Time_library "cpp/header")  
[`<chrono>`](chrono.html "cpp/header/chrono") (C++11)  
[`<ctime>`](ctime.html "cpp/header/ctime")  
[C compatibility](../headers.html#C_compatibility_headers "cpp/header")  
[`<ccomplex>`](ccomplex.html "cpp/header/ccomplex") (C++11/17/20*)  
[`<ciso646>`](ciso646.html "cpp/header/ciso646") (until C++20)  
[`<cstdalign>`](cstdalign.html "cpp/header/cstdalign") (C++11/17/20*)  
[`<cstdbool>`](cstdbool.html "cpp/header/cstdbool") (C++11/17/20*)  
[`<ctgmath>`](ctgmath.html "cpp/header/ctgmath") (C++11/17/20*)  
  
| [Input/output](../headers.html#Input.2Foutput_library "cpp/header")  
---  
[`<cinttypes>`](cinttypes.html "cpp/header/cinttypes") (C++11)  
[`<cstdio>`](cstdio.html "cpp/header/cstdio")  
[`<filesystem>`](filesystem.html "cpp/header/filesystem") (C++17)  
[`<fstream>`](fstream.html "cpp/header/fstream")  
[`<iomanip>`](iomanip.html "cpp/header/iomanip")  
[`<iosfwd>`](iosfwd.html "cpp/header/iosfwd")  
[`<iostream>`](iostream.html "cpp/header/iostream")  
[`<ios>`](ios.html "cpp/header/ios")  
[`<istream>`](istream.html "cpp/header/istream")  
[`<ostream>`](ostream.html "cpp/header/ostream")  
[`<print>`](print.html "cpp/header/print") (C++23)  
[`<spanstream>`](spanstream.html "cpp/header/spanstream") (C++23)  
[`<sstream>`](sstream.html "cpp/header/sstream")  
[`<streambuf>`](streambuf.html "cpp/header/streambuf")  
[`<strstream>`](strstream.html "cpp/header/strstream") (C++98/26*)  
[`<syncstream>`](syncstream.html "cpp/header/syncstream") (C++20)  
[Concurrency support](../headers.html#Concurrency_support_library "cpp/header")  
[`<atomic>`](atomic.html "cpp/header/atomic") (C++11)  
[`<barrier>`](barrier.html "cpp/header/barrier") (C++20)  
[`<condition_variable>`](condition_variable.html "cpp/header/condition variable") (C++11)  
[`<future>`](future.html "cpp/header/future") (C++11)  
[`<hazard_pointer>`](hazard_pointer.html "cpp/header/hazard pointer") (C++26)  
[`<latch>`](latch.html "cpp/header/latch") (C++20)  
[`<mutex>`](mutex.html "cpp/header/mutex") (C++11)  
[`<rcu>`](rcu.html "cpp/header/rcu") (C++26)  
[`<semaphore>`](semaphore.html "cpp/header/semaphore") (C++20)  
[`<shared_mutex>`](shared_mutex.html "cpp/header/shared mutex") (C++14)  
[`<stdatomic.h>`](stdatomic.h.html "cpp/header/stdatomic.h") (C++23)  
[`<stop_token>`](stop_token.html "cpp/header/stop token") (C++20)  
[`<thread>`](thread.html "cpp/header/thread") (C++11)  
[Execution support](../headers.html#Multi-purpose_headers "cpp/header")  
[`<execution>`](execution.html "cpp/header/execution") (C++17)  
  
  
  
  
  
  
  
  
  


This header is part of the [text processing](../text.html "cpp/text") library. 

| 

## Contents

  * [1 Includes](regex.html#Includes)
  * [2 Classes](regex.html#Classes)
    * [2.1 regex constant types](regex.html#regex_constant_types)
  * [3 Functions](regex.html#Functions)
    * [3.1 Algorithm](regex.html#Algorithm)
    * [3.2 Non-member operations](regex.html#Non-member_operations)
    * [3.3 Range access](regex.html#Range_access)
  * [4 Synopsis](regex.html#Synopsis)
    * [4.1 Bitmask type std::regex_constants::syntax_option_type](regex.html#Bitmask_type_std::regex_constants::syntax_option_type)
    * [4.2 Bitmask type std::regex_constants::match_flag_type](regex.html#Bitmask_type_std::regex_constants::match_flag_type)
    * [4.3 Enumerated type std::regex_constants::error_type](regex.html#Enumerated_type_std::regex_constants::error_type)
    * [4.4 Class std::regex_error](regex.html#Class_std::regex_error)
    * [4.5 Class template std::regex_traits](regex.html#Class_template_std::regex_traits)
    * [4.6 Class template std::basic_regex](regex.html#Class_template_std::basic_regex)
    * [4.7 Class template std::sub_match](regex.html#Class_template_std::sub_match)
    * [4.8 Class template std::match_results](regex.html#Class_template_std::match_results)

  
---  
  
###  Includes  
  
[ <compare>](compare.html "cpp/header/compare")(C++20) |  [Three-way comparison operator](../language/operator_comparison.html#Three-way_comparison "cpp/language/operator comparison") support  
[ <initializer_list>](initializer_list.html "cpp/header/initializer list")(C++11) |  [std::initializer_list](../utility/initializer_list.html "cpp/utility/initializer list") class template  
  
###  Classes  
  
[ basic_regex](../regex/basic_regex.html "cpp/regex/basic regex")(C++11) |  regular expression object   
(class template)   
[std::regex](../regex/basic_regex.html "cpp/regex/basic regex") |  [std::basic_regex](../regex/basic_regex.html)<char> (typedef)  
[std::wregex](../regex/basic_regex.html "cpp/regex/basic regex") |  [std::basic_regex](../regex/basic_regex.html)<wchar_t> (typedef)  
[ sub_match](../regex/sub_match.html "cpp/regex/sub match")(C++11) |  identifies the sequence of characters matched by a sub-expression   
(class template)   
[std::csub_match](../regex/sub_match.html "cpp/regex/sub match") |  [std::sub_match](../regex/sub_match.html)<const char*> (typedef)  
[std::wcsub_match](../regex/sub_match.html "cpp/regex/sub match") |  [std::sub_match](../regex/sub_match.html)<const wchar_t*> (typedef)  
[std::ssub_match](../regex/sub_match.html "cpp/regex/sub match") |  [std::sub_match](../regex/sub_match.html)<std::string::const_iterator> (typedef)  
[std::wssub_match](../regex/sub_match.html "cpp/regex/sub match") |  [std::sub_match](../regex/sub_match.html)<std::wstring::const_iterator> (typedef)  
[ match_results](../regex/match_results.html "cpp/regex/match results")(C++11) |  identifies one regular expression match, including all sub-expression matches   
(class template)   
[std::cmatch](../regex/match_results.html "cpp/regex/match results") |  [std::match_results](../regex/match_results.html)<const char*> (typedef)  
[std::wcmatch](../regex/match_results.html "cpp/regex/match results") |  [std::match_results](../regex/match_results.html)<const wchar_t*> (typedef)  
[std::smatch](../regex/match_results.html "cpp/regex/match results") |  [std::match_results](../regex/match_results.html)<std::string::const_iterator> (typedef)  
[std::wsmatch](../regex/match_results.html "cpp/regex/match results") |  [std::match_results](../regex/match_results.html)<std::wstring::const_iterator> (typedef)  
[ regex_iterator](../regex/regex_iterator.html "cpp/regex/regex iterator")(C++11) |  iterates through all regex matches within a character sequence   
(class template)   
[std::cregex_iterator](../regex/regex_iterator.html "cpp/regex/regex iterator") |  [std::regex_iterator](../regex/regex_iterator.html)<const char*> (typedef)  
[std::wcregex_iterator](../regex/regex_iterator.html "cpp/regex/regex iterator") |  [std::regex_iterator](../regex/regex_iterator.html)<const wchar_t*> (typedef)  
[std::sregex_iterator](../regex/regex_iterator.html "cpp/regex/regex iterator") |  [std::regex_iterator](../regex/regex_iterator.html)<std::string::const_iterator> (typedef)  
[std::wsregex_iterator](../regex/regex_iterator.html "cpp/regex/regex iterator") |  [std::regex_iterator](../regex/regex_iterator.html)<std::wstring::const_iterator> (typedef)  
[ regex_token_iterator](../regex/regex_token_iterator.html "cpp/regex/regex token iterator")(C++11) |  iterates through the specified sub-expressions within all regex matches in a given string or through unmatched substrings   
(class template)   
[std::cregex_token_iterator](../regex/regex_token_iterator.html "cpp/regex/regex token iterator") |  [std::regex_token_iterator](../regex/regex_token_iterator.html)<const char*> (typedef)  
[std::wcregex_token_iterator](../regex/regex_token_iterator.html "cpp/regex/regex token iterator") |  [std::regex_token_iterator](../regex/regex_token_iterator.html)<const wchar_t*> (typedef)  
[std::sregex_token_iterator](../regex/regex_token_iterator.html "cpp/regex/regex token iterator") |  [std::regex_token_iterator](../regex/regex_token_iterator.html)<std::string::const_iterator> (typedef)  
[std::wsregex_token_iterator](../regex/regex_token_iterator.html "cpp/regex/regex token iterator") |  [std::regex_token_iterator](../regex/regex_token_iterator.html)<std::wstring::const_iterator> (typedef)  
[ regex_error](../regex/regex_error.html "cpp/regex/regex error")(C++11) |  reports errors generated by the regular expressions library   
(class)   
[ regex_traits](../regex/regex_traits.html "cpp/regex/regex traits")(C++11) |  provides metainformation about a character type, required by the regex library   
(class template)   
  
#####  regex constant types   
  
Defined in namespace `std::regex_constants`  
[ syntax_option_type](../regex/syntax_option_type.html "cpp/regex/syntax option type")(C++11) |  general options controlling regex behavior   
(typedef)   
[ match_flag_type](../regex/match_flag_type.html "cpp/regex/match flag type")(C++11) |  options specific to matching   
(typedef)   
[ error_type](../regex/error_type.html "cpp/regex/error type")(C++11) |  describes different types of matching errors   
(typedef)   
  
###  Functions  
  
#####  Algorithm   
  
[ regex_match](../regex/regex_match.html "cpp/regex/regex match")(C++11) |  attempts to match a regular expression to an entire character sequence   
(function template)   
[ regex_search](../regex/regex_search.html "cpp/regex/regex search")(C++11) |  attempts to match a regular expression to any part of a character sequence   
(function template)   
[ regex_replace](../regex/regex_replace.html "cpp/regex/regex replace")(C++11) |  replaces occurrences of a regular expression with formatted replacement text   
(function template)   
  
#####  Non-member operations   
  
[ std::swap(std::basic_regex)](../regex/basic_regex/swap2.html "cpp/regex/basic regex/swap2")(C++11) |  specializes the [std::swap](../utility/swap.html "cpp/algorithm/swap") algorithm   
(function template)   
[ operator==operator!=operator<operator<=operator>operator>=operator<=>](../regex/sub_match/operator_cmp.html "cpp/regex/sub match/operator cmp")(removed in C++20)(removed in C++20)(removed in C++20)(removed in C++20)(removed in C++20)(C++20) |  compares a `sub_match` with another `sub_match`, a string, or a character   
(function template)   
[ operator<<](../regex/sub_match/operator_ltlt.html "cpp/regex/sub match/operator ltlt") |  outputs the matched character subsequence   
(function template)   
[ operator==operator!=](../regex/match_results/operator_cmp.html "cpp/regex/match results/operator cmp")(removed in C++20) |  lexicographically compares the values in the two match result   
(function template)   
[ std::swap(std::match_results)](../regex/match_results/swap2.html "cpp/regex/match results/swap2")(C++11) |  specializes the [`std::swap`](../utility/swap.html "cpp/algorithm/swap") algorithm   
(function template)   
  
#####  Range access   
  
[ begincbegin](../iterator/begin.html "cpp/iterator/begin")(C++11)(C++14) |  returns an iterator to the beginning of a container or array   
(function template)   
[ endcend](../iterator/end.html "cpp/iterator/end")(C++11)(C++14) |  returns an iterator to the end of a container or array   
(function template)   
[ rbegincrbegin](../iterator/rbegin.html "cpp/iterator/rbegin")(C++14) |  returns a reverse iterator to the beginning of a container or array   
(function template)   
[ rendcrend](../iterator/rend.html "cpp/iterator/rend")(C++14) |  returns a reverse end iterator for a container or array   
(function template)   
[ sizessize](../iterator/size.html "cpp/iterator/size")(C++17)(C++20) |  returns the size of a container or array   
(function template)   
[ empty](../iterator/empty.html "cpp/iterator/empty")(C++17) |  checks whether the container is empty   
(function template)   
[ data](../iterator/data.html "cpp/iterator/data")(C++17) |  obtains the pointer to the underlying array   
(function template)   
  
### Synopsis
    
    
    #include <compare>
    #include <initializer_list>
     
    namespace std {
      // regex constants
      namespace regex_constants {
        using syntax_option_type = /*T1*/;
        using match_flag_type = /*T2*/;
        using error_type = /*T3*/;
      }
     
      // class regex_error
      class regex_error;
     
      // class template regex_traits
      template<class CharT> struct regex_traits;
     
      // class template basic_regex
      template<class CharT, class Traits = regex_traits<CharT>> class basic_regex;
     
      using regex  = basic_regex<char>;
      using wregex = basic_regex<wchar_t>;
     
      // basic_regex swap
      template<class CharT, class Traits>
        void swap(basic_regex<CharT, Traits>& e1, basic_regex<CharT, Traits>& e2);
     
      // class template sub_match
      template<class BiIt>
        class sub_match;
     
      using csub_match  = sub_match<const char*>;
      using wcsub_match = sub_match<const wchar_t*>;
      using ssub_match  = sub_match<string::const_iterator>;
      using wssub_match = sub_match<wstring::const_iterator>;
     
      // sub_match non-member operators
      template<class BiIt>
        bool operator==(const sub_match<BiIt>& lhs, const sub_match<BiIt>& rhs);
      template<class BiIt>
        auto operator<=>(const sub_match<BiIt>& lhs, const sub_match<BiIt>& rhs);
     
      template<class BiIt, class ST, class SA>
        bool operator==(
          const sub_match<BiIt>& lhs,
          const basic_string<typename iterator_traits<BiIt>::value_type, ST, SA>& rhs);
      template<class BiIt, class ST, class SA>
        auto operator<=>(
          const sub_match<BiIt>& lhs,
          const basic_string<typename iterator_traits<BiIt>::value_type, ST, SA>& rhs);
     
      template<class BiIt>
        bool operator==(const sub_match<BiIt>& lhs,
                        const typename iterator_traits<BiIt>::value_type* rhs);
      template<class BiIt>
        auto operator<=>(const sub_match<BiIt>& lhs,
                         const typename iterator_traits<BiIt>::value_type* rhs);
     
      template<class BiIt>
        bool operator==(const sub_match<BiIt>& lhs,
                        const typename iterator_traits<BiIt>::value_type& rhs);
      template<class BiIt>
        auto operator<=>(const sub_match<BiIt>& lhs,
                         const typename iterator_traits<BiIt>::value_type& rhs);
     
      template<class CharT, class ST, class BiIt>
        basic_ostream<CharT, ST>&
          operator<<(basic_ostream<CharT, ST>& os, const sub_match<BiIt>& m);
     
      // class template match_results
      template<class BiIt,
               class Allocator = allocator<sub_match<BiIt>>>
        class match_results;
     
      using cmatch  = match_results<const char*>;
      using wcmatch = match_results<const wchar_t*>;
      using smatch  = match_results<string::const_iterator>;
      using wsmatch = match_results<wstring::const_iterator>;
     
      // match_results comparisons
      template<class BiIt, class Allocator>
        bool operator==(const match_results<BiIt, Allocator>& m1,
                        const match_results<BiIt, Allocator>& m2);
     
      // match_results swap
      template<class BiIt, class Allocator>
        void swap(match_results<BiIt, Allocator>& m1, match_results<BiIt, Allocator>& m2);
     
      // function template regex_match
      template<class BiIt, class Allocator, class CharT, class Traits>
        bool regex_match(BiIt first, BiIt last,
                         match_results<BiIt, Allocator>& m,
                         const basic_regex<CharT, Traits>& e,
                         regex_constants::match_flag_type flags =
                           regex_constants::match_default);
      template<class BiIt, class CharT, class Traits>
        bool regex_match(BiIt first, BiIt last,
                         const basic_regex<CharT, Traits>& e,
                         regex_constants::match_flag_type flags =
                           regex_constants::match_default);
      template<class CharT, class Allocator, class Traits>
        bool regex_match(const CharT* str, match_results<const CharT*, Allocator>& m,
                         const basic_regex<CharT, Traits>& e,
                         regex_constants::match_flag_type flags =
                           regex_constants::match_default);
      template<class ST, class SA, class Allocator, class CharT, class Traits>
        bool regex_match(const basic_string<CharT, ST, SA>& s,
                         match_results<typename basic_string<CharT, ST, SA>::const_iterator,
                                       Allocator>& m,
                         const basic_regex<CharT, Traits>& e,
                         regex_constants::match_flag_type flags =
                           regex_constants::match_default);
      template<class ST, class SA, class Allocator, class CharT, class Traits>
        bool regex_match(const basic_string<CharT, ST, SA>&&,
                         match_results<typename basic_string<CharT, ST, SA>::const_iterator,
                                       Allocator>&,
                         const basic_regex<CharT, Traits>&,
                         regex_constants::match_flag_type =
                           regex_constants::match_default) = delete;
      template<class CharT, class Traits>
        bool regex_match(const CharT* str,
                         const basic_regex<CharT, Traits>& e,
                         regex_constants::match_flag_type flags =
                           regex_constants::match_default);
      template<class ST, class SA, class CharT, class Traits>
        bool regex_match(const basic_string<CharT, ST, SA>& s,
                         const basic_regex<CharT, Traits>& e,
                         regex_constants::match_flag_type flags =
                           regex_constants::match_default);
     
      // function template regex_search
      template<class BiIt, class Allocator, class CharT, class Traits>
        bool regex_search(BiIt first, BiIt last,
                          match_results<BiIt, Allocator>& m,
                          const basic_regex<CharT, Traits>& e,
                          regex_constants::match_flag_type flags =
                            regex_constants::match_default);
      template<class BiIt, class CharT, class Traits>
        bool regex_search(BiItfirst, BiIt last,
                          const basic_regex<CharT, Traits>& e,
                          regex_constants::match_flag_type flags =
                            regex_constants::match_default);
      template<class CharT, class Allocator, class Traits>
        bool regex_search(const CharT* str,
                          match_results<const CharT*, Allocator>& m,
                          const basic_regex<CharT, Traits>& e,
                          regex_constants::match_flag_type flags =
                            regex_constants::match_default);
      template<class CharT, class Traits>
        bool regex_search(const CharT* str,
                          const basic_regex<CharT, Traits>& e,
                          regex_constants::match_flag_type flags =
                            regex_constants::match_default);
      template<class ST, class SA, class CharT, class Traits>
        bool regex_search(const basic_string<CharT, ST, SA>& s,
                          const basic_regex<CharT, Traits>& e,
                          regex_constants::match_flag_type flags =
                            regex_constants::match_default);
      template<class ST, class SA, class Allocator, class CharT, class Traits>
        bool regex_search(const basic_string<CharT, ST, SA>& s,
                          match_results<typename basic_string<CharT, ST, SA>::const_iterator,
                                        Allocator>& m,
                          const basic_regex<CharT, Traits>& e,
                          regex_constants::match_flag_type flags =
                            regex_constants::match_default);
      template<class ST, class SA, class Allocator, class CharT, class Traits>
        bool regex_search(const basic_string<CharT, ST, SA>&&,
                          match_results<typename basic_string<CharT, ST, SA>::const_iterator,
                                        Allocator>&,
                          const basic_regex<CharT, Traits>&,
                          regex_constants::match_flag_type
                            = regex_constants::match_default) = delete;
     
      // function template regex_replace
      template<class OutputIt, class BiIt,
                class Traits, class CharT, class ST, class SA>
        OutputIt
          regex_replace(OutputIt out,
                        BiIt first, BiIt last,
                        const basic_regex<CharT, Traits>& e,
                        const basic_string<CharT, ST, SA>& fmt,
                        regex_constants::match_flag_type flags =
                          regex_constants::match_default);
      template<class OutputIt, class BiIt, class Traits, class CharT>
        OutputIt
          regex_replace(OutputIt out,
                        BiIt first, BiIt last,
                        const basic_regex<CharT, Traits>& e,
                        const CharT* fmt,
                        regex_constants::match_flag_type flags =
                          regex_constants::match_default);
      template<class Traits, class CharT, class ST, class SA, class FST, class FSA>
        basic_string<CharT, ST, SA>
          regex_replace(const basic_string<CharT, ST, SA>& s,
                        const basic_regex<CharT, Traits>& e,
                        const basic_string<CharT, FST, FSA>& fmt,
                        regex_constants::match_flag_type flags =
                          regex_constants::match_default);
      template<class Traits, class CharT, class ST, class SA>
        basic_string<CharT, ST, SA>
          regex_replace(const basic_string<CharT, ST, SA>& s,
                        const basic_regex<CharT, Traits>& e,
                        const CharT* fmt,
                        regex_constants::match_flag_type flags =
                          regex_constants::match_default);
      template<class Traits, class CharT, class ST, class SA>
        basic_string<CharT>
          regex_replace(const CharT* s,
                        const basic_regex<CharT, Traits>& e,
                        const basic_string<CharT, ST, SA>& fmt,
                        regex_constants::match_flag_type flags =
                          regex_constants::match_default);
      template<class Traits, class CharT>
        basic_string<CharT>
          regex_replace(const CharT* s,
                        const basic_regex<CharT, Traits>& e,
                        const CharT* fmt,
                        regex_constants::match_flag_type flags =
                          regex_constants::match_default);
     
      // class template regex_iterator
      template<class BiIt,
                class CharT = typename iterator_traits<BiIt>::value_type,
                class Traits = regex_traits<CharT>>
        class regex_iterator;
     
      using cregex_iterator  = regex_iterator<const char*>;
      using wcregex_iterator = regex_iterator<const wchar_t*>;
      using sregex_iterator  = regex_iterator<string::const_iterator>;
      using wsregex_iterator = regex_iterator<wstring::const_iterator>;
     
      // class template regex_token_iterator
      template<class BiIt,
                class CharT = typename iterator_traits<BiIt>::value_type,
                class Traits = regex_traits<CharT>>
        class regex_token_iterator;
     
      using cregex_token_iterator  = regex_token_iterator<const char*>;
      using wcregex_token_iterator = regex_token_iterator<const wchar_t*>;
      using sregex_token_iterator  = regex_token_iterator<string::const_iterator>;
      using wsregex_token_iterator = regex_token_iterator<wstring::const_iterator>;
     
      namespace pmr {
        template<class BiIt>
          using match_results =
            [std::match_results](../regex/match_results.html)<BiIt, polymorphic_allocator<sub_match<BiIt>>>;
     
        using cmatch  = match_results<const char*>;
        using wcmatch = match_results<const wchar_t*>;
        using smatch  = match_results<string::const_iterator>;
        using wsmatch = match_results<wstring::const_iterator>;
      }
    }

#### Bitmask type [std::regex_constants::syntax_option_type](../regex/syntax_option_type.html "cpp/regex/syntax option type")
    
    
    namespace std::regex_constants {
      using syntax_option_type = /*T1*/;
      inline constexpr syntax_option_type icase = /* unspecified */;
      inline constexpr syntax_option_type nosubs = /* unspecified */;
      inline constexpr syntax_option_type optimize = /* unspecified */;
      inline constexpr syntax_option_type collate = /* unspecified */;
      inline constexpr syntax_option_type ECMAScript = /* unspecified */;
      inline constexpr syntax_option_type basic = /* unspecified */;
      inline constexpr syntax_option_type extended = /* unspecified */;
      inline constexpr syntax_option_type awk = /* unspecified */;
      inline constexpr syntax_option_type grep = /* unspecified */;
      inline constexpr syntax_option_type egrep = /* unspecified */;
      inline constexpr syntax_option_type multiline = /* unspecified */;
    }

#### Bitmask type [std::regex_constants::match_flag_type](../regex/match_flag_type.html "cpp/regex/match flag type")
    
    
    namespace std::regex_constants {
      using match_flag_type = /*T2*/;
      inline constexpr match_flag_type match_default = {};
      inline constexpr match_flag_type match_not_bol = /* unspecified */;
      inline constexpr match_flag_type match_not_eol = /* unspecified */;
      inline constexpr match_flag_type match_not_bow = /* unspecified */;
      inline constexpr match_flag_type match_not_eow = /* unspecified */;
      inline constexpr match_flag_type match_any = /* unspecified */;
      inline constexpr match_flag_type match_not_null = /* unspecified */;
      inline constexpr match_flag_type match_continuous = /* unspecified */;
      inline constexpr match_flag_type match_prev_avail = /* unspecified */;
      inline constexpr match_flag_type format_default = {};
      inline constexpr match_flag_type format_sed = /* unspecified */;
      inline constexpr match_flag_type format_no_copy = /* unspecified */;
      inline constexpr match_flag_type format_first_only = /* unspecified */;
    }

#### Enumerated type [std::regex_constants::error_type](../regex/error_type.html "cpp/regex/error type")
    
    
    namespace std::regex_constants {
      using error_type = /*T3*/;
      inline constexpr error_type error_collate = /* unspecified */;
      inline constexpr error_type error_ctype = /* unspecified */;
      inline constexpr error_type error_escape = /* unspecified */;
      inline constexpr error_type error_backref = /* unspecified */;
      inline constexpr error_type error_brack = /* unspecified */;
      inline constexpr error_type error_paren = /* unspecified */;
      inline constexpr error_type error_brace = /* unspecified */;
      inline constexpr error_type error_badbrace = /* unspecified */;
      inline constexpr error_type error_range = /* unspecified */;
      inline constexpr error_type error_space = /* unspecified */;
      inline constexpr error_type error_badrepeat = /* unspecified */;
      inline constexpr error_type error_complexity = /* unspecified */;
      inline constexpr error_type error_stack = /* unspecified */;
    }

#### Class [std::regex_error](../regex/regex_error.html "cpp/regex/regex error")
    
    
    namespace std {
      class regex_error : public runtime_error {
      public:
        explicit regex_error(regex_constants::error_type ecode);
        regex_constants::error_type code() const;
      };
    }

#### Class template [std::regex_traits](../regex/regex_traits.html "cpp/regex/regex traits")
    
    
    namespace std {
      template<class CharT>
        struct regex_traits {
          using char_type       = CharT;
          using string_type     = basic_string<char_type>;
          using locale_type     = locale;
          using char_class_type = /* bitmask-type */;
     
          regex_traits();
          static size_t length(const char_type* p);
          CharT translate(CharT c) const;
          CharT translate_nocase(CharT c) const;
          template<class ForwardIt>
            string_type transform(ForwardIt first, ForwardIt last) const;
          template<class ForwardIt>
            string_type transform_primary(ForwardIt first, ForwardIt last) const;
          template<class ForwardIt>
            string_type lookup_collatename(ForwardIt first, ForwardIt last) const;
          template<class ForwardIt>
            char_class_type lookup_classname(ForwardIt first, ForwardIt last,
                                             bool icase = false) const;
          bool isctype(CharT c, char_class_type f) const;
          int value(CharT ch, int radix) const;
          locale_type imbue(locale_type l);
          locale_type getloc() const;
        };
    }

#### Class template [std::basic_regex](../regex/basic_regex.html "cpp/regex/basic regex")
    
    
    namespace std {
      template<class CharT, class Traits = regex_traits<CharT>>
        class basic_regex {
        public:
          // types
          using value_type  =          CharT;
          using Traits_type =          Traits;
          using string_type = typename Traits::string_type;
          using flag_type   =          regex_constants::syntax_option_type;
          using locale_type = typename Traits::locale_type;
     
          // constants
          static constexpr flag_type icase = regex_constants::icase;
          static constexpr flag_type nosubs = regex_constants::nosubs;
          static constexpr flag_type optimize = regex_constants::optimize;
          static constexpr flag_type collate = regex_constants::collate;
          static constexpr flag_type ECMAScript = regex_constants::ECMAScript;
          static constexpr flag_type basic = regex_constants::basic;
          static constexpr flag_type extended = regex_constants::extended;
          static constexpr flag_type awk = regex_constants::awk;
          static constexpr flag_type grep = regex_constants::grep;
          static constexpr flag_type egrep = regex_constants::egrep;
          static constexpr flag_type multiline = regex_constants::multiline;
     
          // construct/copy/destroy
          basic_regex();
          explicit basic_regex(const CharT* p, flag_type f = regex_constants::ECMAScript);
          basic_regex(const CharT* p, size_t len, flag_type f = regex_constants::ECMAScript);
          basic_regex(const basic_regex&);
          basic_regex(basic_regex&&) noexcept;
          template<class ST, class SA>
            explicit basic_regex(const basic_string<CharT, ST, SA>& s,
                                 flag_type f = regex_constants::ECMAScript);
          template<class ForwardIt>
            basic_regex(ForwardIt first, ForwardIt last,
                        flag_type f = regex_constants::ECMAScript);
          basic_regex(initializer_list<CharT> il, flag_type f = regex_constants::ECMAScript);
     
          ~basic_regex();
     
          // assign
          basic_regex& operator=(const basic_regex& e);
          basic_regex& operator=(basic_regex&& e) noexcept;
          basic_regex& operator=(const CharT* p);
          basic_regex& operator=(initializer_list<CharT> il);
          template<class ST, class SA>
            basic_regex& operator=(const basic_string<CharT, ST, SA>& s);
     
          basic_regex& assign(const basic_regex& e);
          basic_regex& assign(basic_regex&& e) noexcept;
          basic_regex& assign(const CharT* p, flag_type f = regex_constants::ECMAScript);
          basic_regex& assign(const CharT* p, size_t len,
                              flag_type f = regex_constants::ECMAScript);
          template<class ST, class SA>
            basic_regex& assign(const basic_string<CharT, ST, SA>& s,
                                flag_type f = regex_constants::ECMAScript);
          template<class InputIt>
            basic_regex& assign(InputIt first, InputIt last,
                                flag_type f = regex_constants::ECMAScript);
          basic_regex& assign(initializer_list<CharT>,
                              flag_type f = regex_constants::ECMAScript);
     
          // const operations
          unsigned mark_count() const;
          flag_type flags() const;
     
          // locale
          locale_type imbue(locale_type loc);
          locale_type getloc() const;
     
          // swap
          void swap(basic_regex&);
        };
     
      template<class ForwardIt>
        basic_regex(ForwardIt, ForwardIt,
                    regex_constants::syntax_option_type = regex_constants::ECMAScript)
          -> basic_regex<typename iterator_traits<ForwardIt>::value_type>;
    }

#### Class template [std::sub_match](../regex/sub_match.html "cpp/regex/sub match")
    
    
    namespace std {
      template<class BiIt>
        class sub_match : public pair<BiIt, BiIt> {
        public:
          using value_type      = typename iterator_traits<BiIt>::value_type;
          using difference_type = typename iterator_traits<BiIt>::difference_type;
          using iterator        = BiIt;
          using string_type     = basic_string<value_type>;
     
          bool matched;
     
          constexpr sub_match();
     
          difference_type length() const;
          operator string_type() const;
          string_type str() const;
     
          int compare(const sub_match& s) const;
          int compare(const string_type& s) const;
          int compare(const value_type* s) const;
     
          void swap(sub_match& s) noexcept(/* see description */);
        };
    }

#### Class template [std::match_results](../regex/match_results.html "cpp/regex/match results")
    
    
    namespace std {
      template<class BiIt,
               class Allocator = allocator<sub_match<BiIt>>>
        class match_results {
        public:
          using value_type      = sub_match<BiIt>;
          using const_reference = const value_type&;
          using reference       = value_type&;
          using const_iterator  = /* implementation-defined */;
          using iterator        = const_iterator;
          using difference_type = typename iterator_traits<BiIt>::difference_type;
          using size_type       = typename allocator_traits<Allocator>::size_type;
          using allocator_type  = Allocator;
          using char_type       = typename iterator_traits<BiIt>::value_type;
          using string_type     = basic_string<char_type>;
     
          // construct/copy/destroy
          match_results() : match_results(Allocator()) {}
          explicit match_results(const Allocator& a);
          match_results(const match_results& m);
          match_results(const match_results& m, const Allocator& a);
          match_results(match_results&& m) noexcept;
          match_results(match_results&& m, const Allocator& a);
          match_results& operator=(const match_results& m);
          match_results& operator=(match_results&& m);
          ~match_results();
     
          // state
          bool ready() const;
     
          // size
          size_type size() const;
          size_type max_size() const;
          bool empty() const;
     
          // element access
          difference_type length(size_type sub = 0) const;
          difference_type position(size_type sub = 0) const;
          string_type str(size_type sub = 0) const;
          const_reference operator[](size_type n) const;
     
          const_reference prefix() const;
          const_reference suffix() const;
          const_iterator begin() const;
          const_iterator end() const;
          const_iterator cbegin() const;
          const_iterator cend() const;
     
          // format
          template<class OutputIt>
            OutputIt
              format(OutputIt out,
                     const char_type* fmt_first, const char_type* fmt_last,
                     regex_constants::match_flag_type flags =
                       regex_constants::format_default) const;
          template<class OutputIt, class ST, class SA>
            OutputIt
              format(OutputIt out,
                     const basic_string<char_type, ST, SA>& fmt,
                     regex_constants::match_flag_type flags =
                       regex_constants::format_default) const;
          template<class ST, class SA>
            basic_string<char_type, ST, SA>
              format(const basic_string<char_type, ST, SA>& fmt,
                     regex_constants::match_flag_type flags =
                       regex_constants::format_default) const;
          string_type
            format(const char_type* fmt,
                   regex_constants::match_flag_type flags =
                     regex_constants::format_default) const;
     
          // allocator
          allocator_type get_allocator() const;
     
          // swap
          void swap(match_results& that);
        };
    }
