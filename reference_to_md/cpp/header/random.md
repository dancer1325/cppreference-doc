[C++](../../cpp.html "cpp")

[Compiler support](../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../freestanding.html "cpp/freestanding")  
[Language](../language.html "cpp/language")  
[Standard library](../standard_library.html "cpp/standard library")  
[Standard library headers](../headers.html "cpp/header")  
[Named requirements](../iterator/concepts.html "cpp/named req")  
[Feature test macros](../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../utility.html#Language_support "cpp/utility")  
[Concepts library](../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../error.html "cpp/error")  
[Memory management library](../memory.html "cpp/memory")  
[Metaprogramming library](../meta.html "cpp/meta") (C++11)  
[General utilities library](../utility.html "cpp/utility")  
[Containers library](../container.html "cpp/container")  
[Iterators library](../iterator.html "cpp/iterator")  
[Ranges library](../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../algorithm.html "cpp/algorithm")  
[Strings library](../string.html "cpp/string")  
[Text processing library](../text.html "cpp/text")  
[Numerics library](../numeric.html "cpp/numeric")  
[Date and time library](../chrono.html "cpp/chrono")  
[Input/output library](../io.html "cpp/io")  
[Filesystem library](../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../atomic.html "cpp/thread") (C++11)  
[Execution control library](../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../experimental.html "cpp/experimental")  
[Symbols index](../symbol_index.html "cpp/symbol index")  
[External libraries](../links/libs.html "cpp/links/libs")  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/navbar_content&action=edit)

[Standard library headers](../headers.html "cpp/header")

| [Language support](../headers.html#Language_support_library "cpp/header")  
---  
[`<cfloat>`](cfloat.html "cpp/header/cfloat")  
[`<climits>`](climits.html "cpp/header/climits")  
[`<compare>`](compare.html "cpp/header/compare") (C++20)  
[`<contracts>`](contracts.html "cpp/header/contracts") (C++26)  
[`<coroutine>`](coroutine.html "cpp/header/coroutine") (C++20)  
[`<csetjmp>`](csetjmp.html "cpp/header/csetjmp")  
[`<csignal>`](csignal.html "cpp/header/csignal")  
[`<cstdarg>`](cstdarg.html "cpp/header/cstdarg")  
[`<cstddef>`](cstddef.html "cpp/header/cstddef")  
[`<cstdint>`](cstdint.html "cpp/header/cstdint") (C++11)  
[`<cstdlib>`](cstdlib.html "cpp/header/cstdlib")  
[`<exception>`](exception.html "cpp/header/exception")  
[`<initializer_list>`](initializer_list.html "cpp/header/initializer list") (C++11)` `  
[`<limits>`](limits.html "cpp/header/limits")  
[`<new>`](new.html "cpp/header/new")  
[`<source_location>`](source_location.html "cpp/header/source location") (C++20)  
[`<stdfloat>`](stdfloat.html "cpp/header/stdfloat") (C++23)  
[`<typeinfo>`](typeinfo.html "cpp/header/typeinfo")  
[`<version>`](version.html "cpp/header/version") (C++20)  
[Concepts](../headers.html#Concepts_library "cpp/header")  
[`<concepts>`](concepts.html "cpp/header/concepts") (C++20)  
[Diagnostics](../headers.html#Diagnostics_library "cpp/header")  
[`<cassert>`](cassert.html "cpp/header/cassert")  
[`<cerrno>`](cerrno.html "cpp/header/cerrno")  
[`<debugging>`](debugging.html "cpp/header/debugging") (C++26)  
[`<stacktrace>`](stacktrace.html "cpp/header/stacktrace") (C++23)  
[`<stdexcept>`](stdexcept.html "cpp/header/stdexcept")  
[`<system_error>`](system_error.html "cpp/header/system error") (C++11)  
[Memory management](../headers.html#Memory_management_library "cpp/header")  
[`<memory>`](memory.html "cpp/header/memory")  
[`<memory_resource>`](memory_resource.html "cpp/header/memory resource") (C++17)  
[`<scoped_allocator>`](scoped_allocator.html "cpp/header/scoped allocator") (C++11)  
[Metaprogramming](../headers.html#Metaprogramming_library "cpp/header")  
[`<type_traits>`](type_traits.html "cpp/header/type traits") (C++11)  
[`<ratio>`](ratio.html "cpp/header/ratio") (C++11)  
  
  
  
| [General utilities](../headers.html#General_utilities_library "cpp/header")  
---  
[`<any>`](any.html "cpp/header/any") (C++17)  
[`<bitset>`](bitset.html "cpp/header/bitset")  
[`<bit>`](bit.html "cpp/header/bit") (C++20)  
[`<charconv>`](charconv.html "cpp/header/charconv") (C++17)  
[`<expected>`](expected.html "cpp/header/expected") (C++23)  
[`<format>`](format.html "cpp/header/format") (C++20)  
[`<functional>`](functional.html "cpp/header/functional")  
[`<optional>`](optional.html "cpp/header/optional") (C++17)  
[`<stdbit.h>`](stdbit.h.html "cpp/header/stdbit.h") (C++26)  
[`<tuple>`](tuple.html "cpp/header/tuple") (C++11)  
[`<typeindex>`](typeindex.html "cpp/header/typeindex") (C++11)  
[`<utility>`](utility.html "cpp/header/utility")  
[`<variant>`](variant.html "cpp/header/variant") (C++17)  
[Containers](../headers.html#Containers_library "cpp/header")  
[`<array>`](array.html "cpp/header/array") (C++11)  
[`<deque>`](deque.html "cpp/header/deque")  
[`<flat_map>`](flat_map.html "cpp/header/flat map") (C++23)  
[`<flat_set>`](flat_set.html "cpp/header/flat set") (C++23)  
[`<forward_list>`](forward_list.html "cpp/header/forward list") (C++11)  
[`<hive>`](hive.html "cpp/header/hive") (C++26)  
[`<inplace_vector>`](inplace_vector.html "cpp/header/inplace vector") (C++26)` `  
[`<list>`](list.html "cpp/header/list")  
[`<map>`](map.html "cpp/header/map")  
[`<mdspan>`](mdspan.html "cpp/header/mdspan") (C++23)  
[`<queue>`](queue.html "cpp/header/queue")  
[`<set>`](set.html "cpp/header/set")  
[`<span>`](span.html "cpp/header/span") (C++20)  
[`<stack>`](stack.html "cpp/header/stack")  
[`<unordered_map>`](unordered_map.html "cpp/header/unordered map") (C++11)  
[`<unordered_set>`](unordered_set.html "cpp/header/unordered set") (C++11)  
[`<vector>`](vector.html "cpp/header/vector")  
[Iterators](../headers.html#Iterators_library "cpp/header")  
[`<iterator>`](iterator.html "cpp/header/iterator")  
[Ranges](../headers.html#Ranges_library "cpp/header")  
[`<generator>`](generator.html "cpp/header/generator") (C++23)  
[`<ranges>`](ranges.html "cpp/header/ranges") (C++20)  
  
| [Algorithms](../headers.html#Algorithms_library "cpp/header")  
---  
[`<algorithm>`](algorithm.html "cpp/header/algorithm")  
[`<numeric>`](numeric.html "cpp/header/numeric")  
[Strings](../headers.html#Strings_library "cpp/header")  
[`<cctype>`](cctype.html "cpp/header/cctype")  
[`<cstring>`](cstring.html "cpp/header/cstring")  
[`<cuchar>`](cuchar.html "cpp/header/cuchar") (C++11)  
[`<cwchar>`](cwchar.html "cpp/header/cwchar")  
[`<cwctype>`](cwctype.html "cpp/header/cwctype")  
[`<string_view>`](string_view.html "cpp/header/string view") (C++17)  
[`<string>`](string.html "cpp/header/string")  
[Text processing](../headers.html#Text_processing_library "cpp/header")  
[`<clocale>`](clocale.html "cpp/header/clocale")  
[`<codecvt>`](codecvt.html "cpp/header/codecvt") (C++11/17/26*)  
[`<locale>`](locale.html "cpp/header/locale")  
[`<regex>`](regex.html "cpp/header/regex") (C++11)  
[`<text_encoding>`](text_encoding.html "cpp/header/text encoding") (C++26)` `  
[Numerics](../headers.html#Numerics_library "cpp/header")  
[`<cfenv>`](cfenv.html "cpp/header/cfenv") (C++11)  
[`<cmath>`](cmath.html "cpp/header/cmath")  
[`<complex>`](complex.html "cpp/header/complex")  
[`<linalg>`](linalg.html "cpp/header/linalg") (C++26)  
[`<numbers>`](numbers.html "cpp/header/numbers") (C++20)  
**`< random>`** (C++11)  
[`<simd>`](simd.html "cpp/header/simd") (C++26)  
[`<stdckdint.h>`](stdckdint.h.html "cpp/header/stdckdint.h") (C++26)  
[`<valarray>`](valarray.html "cpp/header/valarray")  
[Time](../headers.html#Time_library "cpp/header")  
[`<chrono>`](chrono.html "cpp/header/chrono") (C++11)  
[`<ctime>`](ctime.html "cpp/header/ctime")  
[C compatibility](../headers.html#C_compatibility_headers "cpp/header")  
[`<ccomplex>`](ccomplex.html "cpp/header/ccomplex") (C++11/17/20*)  
[`<ciso646>`](ciso646.html "cpp/header/ciso646") (until C++20)  
[`<cstdalign>`](cstdalign.html "cpp/header/cstdalign") (C++11/17/20*)  
[`<cstdbool>`](cstdbool.html "cpp/header/cstdbool") (C++11/17/20*)  
[`<ctgmath>`](ctgmath.html "cpp/header/ctgmath") (C++11/17/20*)  
  
| [Input/output](../headers.html#Input.2Foutput_library "cpp/header")  
---  
[`<cinttypes>`](cinttypes.html "cpp/header/cinttypes") (C++11)  
[`<cstdio>`](cstdio.html "cpp/header/cstdio")  
[`<filesystem>`](filesystem.html "cpp/header/filesystem") (C++17)  
[`<fstream>`](fstream.html "cpp/header/fstream")  
[`<iomanip>`](iomanip.html "cpp/header/iomanip")  
[`<iosfwd>`](iosfwd.html "cpp/header/iosfwd")  
[`<iostream>`](iostream.html "cpp/header/iostream")  
[`<ios>`](ios.html "cpp/header/ios")  
[`<istream>`](istream.html "cpp/header/istream")  
[`<ostream>`](ostream.html "cpp/header/ostream")  
[`<print>`](print.html "cpp/header/print") (C++23)  
[`<spanstream>`](spanstream.html "cpp/header/spanstream") (C++23)  
[`<sstream>`](sstream.html "cpp/header/sstream")  
[`<streambuf>`](streambuf.html "cpp/header/streambuf")  
[`<strstream>`](strstream.html "cpp/header/strstream") (C++98/26*)  
[`<syncstream>`](syncstream.html "cpp/header/syncstream") (C++20)  
[Concurrency support](../headers.html#Concurrency_support_library "cpp/header")  
[`<atomic>`](atomic.html "cpp/header/atomic") (C++11)  
[`<barrier>`](barrier.html "cpp/header/barrier") (C++20)  
[`<condition_variable>`](condition_variable.html "cpp/header/condition variable") (C++11)  
[`<future>`](future.html "cpp/header/future") (C++11)  
[`<hazard_pointer>`](hazard_pointer.html "cpp/header/hazard pointer") (C++26)  
[`<latch>`](latch.html "cpp/header/latch") (C++20)  
[`<mutex>`](mutex.html "cpp/header/mutex") (C++11)  
[`<rcu>`](rcu.html "cpp/header/rcu") (C++26)  
[`<semaphore>`](semaphore.html "cpp/header/semaphore") (C++20)  
[`<shared_mutex>`](shared_mutex.html "cpp/header/shared mutex") (C++14)  
[`<stdatomic.h>`](stdatomic.h.html "cpp/header/stdatomic.h") (C++23)  
[`<stop_token>`](stop_token.html "cpp/header/stop token") (C++20)  
[`<thread>`](thread.html "cpp/header/thread") (C++11)  
[Execution support](../headers.html#Multi-purpose_headers "cpp/header")  
[`<execution>`](execution.html "cpp/header/execution") (C++17)  
  
  
  
  
  
  
  
  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/navbar_content&action=edit)

This header is part of the [pseudo-random number generation](../numeric/random.html "cpp/numeric/random") library. 

| 

## Contents

  * [1 Includes](random.html#Includes)
  * [2 Concepts](random.html#Concepts)
    * [2.1 Uniform random bit generator requirements](random.html#Uniform_random_bit_generator_requirements)
  * [3 Classes](random.html#Classes)
    * [3.1 Random number engines](random.html#Random_number_engines)
    * [3.2 Random number engine adaptors](random.html#Random_number_engine_adaptors)
    * [3.3 Predefined generators](random.html#Predefined_generators)
    * [3.4 Non-deterministic random numbers](random.html#Non-deterministic_random_numbers)
    * [3.5 Uniform distributions](random.html#Uniform_distributions)
    * [3.6 Bernoulli distributions](random.html#Bernoulli_distributions)
    * [3.7 Poisson distributions](random.html#Poisson_distributions)
    * [3.8 Normal distributions](random.html#Normal_distributions)
    * [3.9 Sampling distributions](random.html#Sampling_distributions)
    * [3.10 Utilities](random.html#Utilities)
  * [4 Functions](random.html#Functions)
  * [5 Synopsis](random.html#Synopsis)
    * [5.1 Concept uniform_random_bit_generator](random.html#Concept_uniform_random_bit_generator)
    * [5.2 Class template std::linear_congruential_engine](random.html#Class_template_std::linear_congruential_engine)
    * [5.3 Class template std::mersenne_twister_engine](random.html#Class_template_std::mersenne_twister_engine)
    * [5.4 Class template std::subtract_with_carry_engine](random.html#Class_template_std::subtract_with_carry_engine)
    * [5.5 Class template std::philox_engine](random.html#Class_template_std::philox_engine)
    * [5.6 Class template std::discard_block_engine](random.html#Class_template_std::discard_block_engine)
    * [5.7 Class template std::independent_bits_engine](random.html#Class_template_std::independent_bits_engine)
    * [5.8 Class template std::shuffle_order_engine](random.html#Class_template_std::shuffle_order_engine)
    * [5.9 Engines and engine adaptors with predefined parameters](random.html#Engines_and_engine_adaptors_with_predefined_parameters)
    * [5.10 Class std::random_device](random.html#Class_std::random_device)
    * [5.11 Class std::seed_seq](random.html#Class_std::seed_seq)
    * [5.12 Class template std::uniform_int_distribution](random.html#Class_template_std::uniform_int_distribution)
    * [5.13 Class template std::uniform_real_distribution](random.html#Class_template_std::uniform_real_distribution)
    * [5.14 Class std::bernoulli_distribution](random.html#Class_std::bernoulli_distribution)
    * [5.15 Class template std::binomial_distribution](random.html#Class_template_std::binomial_distribution)
    * [5.16 Class template std::geometric_distribution](random.html#Class_template_std::geometric_distribution)
    * [5.17 Class template std::negative_binomial_distribution](random.html#Class_template_std::negative_binomial_distribution)
    * [5.18 Class template std::poisson_distribution](random.html#Class_template_std::poisson_distribution)
    * [5.19 Class template std::exponential_distribution](random.html#Class_template_std::exponential_distribution)
    * [5.20 Class template std::gamma_distribution](random.html#Class_template_std::gamma_distribution)
    * [5.21 Class template std::weibull_distribution](random.html#Class_template_std::weibull_distribution)
    * [5.22 Class template std::extreme_value_distribution](random.html#Class_template_std::extreme_value_distribution)
    * [5.23 Class template std::normal_distribution](random.html#Class_template_std::normal_distribution)
    * [5.24 Class template std::lognormal_distribution](random.html#Class_template_std::lognormal_distribution)
    * [5.25 Class template std::chi_squared_distribution](random.html#Class_template_std::chi_squared_distribution)
    * [5.26 Class template std::cauchy_distribution](random.html#Class_template_std::cauchy_distribution)
    * [5.27 Class template std::fisher_f_distribution](random.html#Class_template_std::fisher_f_distribution)
    * [5.28 Class template std::student_t_distribution](random.html#Class_template_std::student_t_distribution)
    * [5.29 Class template std::discrete_distribution](random.html#Class_template_std::discrete_distribution)
    * [5.30 Class template std::piecewise_constant_distribution](random.html#Class_template_std::piecewise_constant_distribution)
    * [5.31 Class template std::piecewise_linear_distribution](random.html#Class_template_std::piecewise_linear_distribution)

  
---  
  
###  Includes  
  
[ <initializer_list>](initializer_list.html "cpp/header/initializer list")(C++11) |  [std::initializer_list](../utility/initializer_list.html "cpp/utility/initializer list") class template[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_initializer_list&action=edit)  
  
###  Concepts  
  
#####  Uniform random bit generator requirements   
  
[ uniform_random_bit_generator](../numeric/random/UniformRandomBitGenerator.html "cpp/numeric/random/uniform random bit generator")(C++20) |  specifies that a type qualifies as a uniform random bit generator   
(concept) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/numeric/random/dsc_uniform_random_bit_generator&action=edit)  
  
###  Classes  
  
#####  Random number engines   
  
[ linear_congruential_engine](../numeric/random/linear_congruential_engine.html "cpp/numeric/random/linear congruential engine")(C++11) |  implements [linear congruential](https://en.wikipedia.org/wiki/Linear_congruential_generator "enwiki:Linear congruential generator") algorithm   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/numeric/random/dsc_linear_congruential_engine&action=edit)  
[ mersenne_twister_engine](../numeric/random/mersenne_twister_engine.html "cpp/numeric/random/mersenne twister engine")(C++11) |  implements [Mersenne twister](https://en.wikipedia.org/wiki/Mersenne_twister "enwiki:Mersenne twister") algorithm   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/numeric/random/dsc_mersenne_twister_engine&action=edit)  
[ subtract_with_carry_engine](../numeric/random/subtract_with_carry_engine.html "cpp/numeric/random/subtract with carry engine")(C++11) |  implements a subtract-with-carry ([lagged Fibonacci](https://en.wikipedia.org/wiki/Lagged_Fibonacci_generator "enwiki:Lagged Fibonacci generator")) algorithm   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/numeric/random/dsc_subtract_with_carry_engine&action=edit)  
[ philox_engine](../numeric/random/philox_engine.html "cpp/numeric/random/philox engine")(C++26) |  a counter-based parallelizable generator   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/numeric/random/dsc_philox_engine&action=edit)  
  
#####  Random number engine adaptors   
  
[ discard_block_engine](../numeric/random/discard_block_engine.html "cpp/numeric/random/discard block engine")(C++11) |  discards some output of a random number engine   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/numeric/random/dsc_discard_block_engine&action=edit)  
[ independent_bits_engine](../numeric/random/independent_bits_engine.html "cpp/numeric/random/independent bits engine")(C++11) |  packs the output of a random number engine into blocks of a specified number of bits   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/numeric/random/dsc_independent_bits_engine&action=edit)  
[ shuffle_order_engine](../numeric/random/shuffle_order_engine.html "cpp/numeric/random/shuffle order engine")(C++11) |  delivers the output of a random number engine in a different order   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/numeric/random/dsc_shuffle_order_engine&action=edit)  
  
#####  Predefined generators   
  
---  
`minstd_rand0` (C++11) |  [std::linear_congruential_engine](../numeric/random/linear_congruential_engine.html)<[std::uint_fast32_t](../types/integer.html),  
` `16807, 0, 2147483647>  
Discovered in 1969 by Lewis, Goodman and Miller, adopted as "Minimal standard" in 1988 by Park and Miller[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/numeric/random/dsc_minstd_rand0&action=edit)  
`minstd_rand` (C++11) |  [std::linear_congruential_engine](../numeric/random/linear_congruential_engine.html)<[std::uint_fast32_t](../types/integer.html),  
` `48271, 0, 2147483647>  
Newer "Minimum standard", recommended by Park, Miller, and Stockmeyer in 1993[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/numeric/random/dsc_minstd_rand&action=edit)  
`mt19937` (C++11) |  [std::mersenne_twister_engine](../numeric/random/mersenne_twister_engine.html)<[std::uint_fast32_t](../types/integer.html),  
` `32, 624, 397, 31,  
` `0x9908b0df, 11,  
` `0xffffffff, 7,  
` `0x9d2c5680, 15,  
` `0xefc60000, 18, 1812433253>  
32-bit Mersenne Twister by Matsumoto and Nishimura, 1998[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/numeric/random/dsc_mt19937&action=edit)  
`mt19937_64` (C++11) |  [std::mersenne_twister_engine](../numeric/random/mersenne_twister_engine.html)<[std::uint_fast64_t](../types/integer.html),  
` `64, 312, 156, 31,  
` `0xb5026f5aa96619e9, 29,  
` `0x5555555555555555, 17,  
` `0x71d67fffeda60000, 37,  
` `0xfff7eee000000000, 43,  
` `6364136223846793005>  
64-bit Mersenne Twister by Matsumoto and Nishimura, 2000[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/numeric/random/dsc_mt19937_64&action=edit)  
`ranlux24_base` (C++11) |  [std::subtract_with_carry_engine](../numeric/random/subtract_with_carry_engine.html)<[std::uint_fast32_t](../types/integer.html), 24, 10, 24>[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/numeric/random/dsc_ranlux24_base&action=edit)  
`ranlux48_base` (C++11) |  [std::subtract_with_carry_engine](../numeric/random/subtract_with_carry_engine.html)<[std::uint_fast64_t](../types/integer.html), 48, 5, 12>[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/numeric/random/dsc_ranlux48_base&action=edit)  
`ranlux24` (C++11) |  [std::discard_block_engine](../numeric/random/discard_block_engine.html)<[std::ranlux24_base](../numeric/random/subtract_with_carry_engine.html), 223, 23>  
24-bit RANLUX generator by Martin Lüscher and Fred James, 1994[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/numeric/random/dsc_ranlux24&action=edit)  
`ranlux48` (C++11) |  [std::discard_block_engine](../numeric/random/discard_block_engine.html)<[std::ranlux48_base](../numeric/random/subtract_with_carry_engine.html), 389, 11>  
48-bit RANLUX generator by Martin Lüscher and Fred James, 1994[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/numeric/random/dsc_ranlux48&action=edit)  
`knuth_b` (C++11) |  [std::shuffle_order_engine](../numeric/random/shuffle_order_engine.html)<[std::minstd_rand0](../numeric/random/linear_congruential_engine.html), 256>[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/numeric/random/dsc_knuth_b&action=edit)  
`philox4x32` (C++26) |  [std::philox_engine](../numeric/random/philox_engine.html)<[std::uint_fast32_t](../types/integer.html), 32, 4, 10,  
` `0xCD9E8D57, 0x9E3779B9,  
` `0xD2511F53, 0xBB67AE85>[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/numeric/random/dsc_philox4x32&action=edit)  
`philox4x64` (C++26) |  [std::philox_engine](../numeric/random/philox_engine.html)<[std::uint_fast64_t](../types/integer.html), 64, 4, 10,  
` `0xCA5A826395121157, 0x9E3779B97F4A7C15,  
` `0xD2E7470EE14C6C93, 0xBB67AE8584CAA73B>[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/numeric/random/dsc_philox4x64&action=edit)  
`default_random_engine`(C++11) |  an implementation-defined [RandomNumberEngine](../named_req/RandomNumberEngine.html "cpp/named req/RandomNumberEngine") type   
  
#####  Non-deterministic random numbers   
  
---  
[ random_device](../numeric/random/random_device.html "cpp/numeric/random/random device")(C++11) |  non-deterministic random number generator using hardware entropy source   
(class) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/numeric/random/dsc_random_device&action=edit)  
  
#####  Uniform distributions   
  
[ uniform_int_distribution](../numeric/random/uniform_int_distribution.html "cpp/numeric/random/uniform int distribution")(C++11) |  produces integer values evenly distributed across a range   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/numeric/random/dsc_uniform_int_distribution&action=edit)  
[ uniform_real_distribution](../numeric/random/uniform_real_distribution.html "cpp/numeric/random/uniform real distribution")(C++11) |  produces real values evenly distributed across a range   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/numeric/random/dsc_uniform_real_distribution&action=edit)  
  
#####  Bernoulli distributions   
  
[ bernoulli_distribution](../numeric/random/bernoulli_distribution.html "cpp/numeric/random/bernoulli distribution")(C++11) |  produces bool values on a [Bernoulli distribution](https://en.wikipedia.org/wiki/Bernoulli_distribution "enwiki:Bernoulli distribution")   
(class) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/numeric/random/dsc_bernoulli_distribution&action=edit)  
[ binomial_distribution](../numeric/random/binomial_distribution.html "cpp/numeric/random/binomial distribution")(C++11) |  produces integer values on a [binomial distribution](https://en.wikipedia.org/wiki/Binomial_distribution "enwiki:Binomial distribution")   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/numeric/random/dsc_binomial_distribution&action=edit)  
[ negative_binomial_distribution](../numeric/random/negative_binomial_distribution.html "cpp/numeric/random/negative binomial distribution")(C++11) |  produces integer values on a [negative binomial distribution](https://en.wikipedia.org/wiki/Negative_binomial_distribution "enwiki:Negative binomial distribution")   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/numeric/random/dsc_negative_binomial_distribution&action=edit)  
[ geometric_distribution](../numeric/random/geometric_distribution.html "cpp/numeric/random/geometric distribution")(C++11) |  produces integer values on a [geometric distribution](https://en.wikipedia.org/wiki/Geometric_distribution "enwiki:Geometric distribution")   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/numeric/random/dsc_geometric_distribution&action=edit)  
  
#####  Poisson distributions   
  
[ poisson_distribution](../numeric/random/poisson_distribution.html "cpp/numeric/random/poisson distribution")(C++11) |  produces integer values on a [Poisson distribution](https://en.wikipedia.org/wiki/Poisson_distribution "enwiki:Poisson distribution")   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/numeric/random/dsc_poisson_distribution&action=edit)  
[ exponential_distribution](../numeric/random/exponential_distribution.html "cpp/numeric/random/exponential distribution")(C++11) |  produces real values on an [exponential distribution](https://en.wikipedia.org/wiki/Exponential_distribution "enwiki:Exponential distribution")   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/numeric/random/dsc_exponential_distribution&action=edit)  
[ gamma_distribution](../numeric/random/gamma_distribution.html "cpp/numeric/random/gamma distribution")(C++11) |  produces real values on a [gamma distribution](https://en.wikipedia.org/wiki/Gamma_distribution "enwiki:Gamma distribution")   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/numeric/random/dsc_gamma_distribution&action=edit)  
[ weibull_distribution](../numeric/random/weibull_distribution.html "cpp/numeric/random/weibull distribution")(C++11) |  produces real values on a [Weibull distribution](https://en.wikipedia.org/wiki/Weibull_distribution "enwiki:Weibull distribution")   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/numeric/random/dsc_weibull_distribution&action=edit)  
[ extreme_value_distribution](../numeric/random/extreme_value_distribution.html "cpp/numeric/random/extreme value distribution")(C++11) |  produces real values on an [extreme value distribution](https://en.wikipedia.org/wiki/Generalized_extreme_value_distribution "enwiki:Generalized extreme value distribution")   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/numeric/random/dsc_extreme_value_distribution&action=edit)  
  
#####  Normal distributions   
  
[ normal_distribution](../numeric/random/normal_distribution.html "cpp/numeric/random/normal distribution")(C++11) |  produces real values on a [standard normal (Gaussian) distribution](https://en.wikipedia.org/wiki/Normal_distribution "enwiki:Normal distribution")   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/numeric/random/dsc_normal_distribution&action=edit)  
[ lognormal_distribution](../numeric/random/lognormal_distribution.html "cpp/numeric/random/lognormal distribution")(C++11) |  produces real values on a [lognormal distribution](https://en.wikipedia.org/wiki/Lognormal_distribution "enwiki:Lognormal distribution")   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/numeric/random/dsc_lognormal_distribution&action=edit)  
[ chi_squared_distribution](../numeric/random/chi_squared_distribution.html "cpp/numeric/random/chi squared distribution")(C++11) |  produces real values on a [chi-squared distribution](https://en.wikipedia.org/wiki/Chi-squared_distribution "enwiki:Chi-squared distribution")   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/numeric/random/dsc_chi_squared_distribution&action=edit)  
[ cauchy_distribution](../numeric/random/cauchy_distribution.html "cpp/numeric/random/cauchy distribution")(C++11) |  produces real values on a [Cauchy distribution](https://en.wikipedia.org/wiki/Cauchy_distribution "enwiki:Cauchy distribution")   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/numeric/random/dsc_cauchy_distribution&action=edit)  
[ fisher_f_distribution](../numeric/random/fisher_f_distribution.html "cpp/numeric/random/fisher f distribution")(C++11) |  produces real values on a [Fisher's F-distribution](https://en.wikipedia.org/wiki/F-distribution "enwiki:F-distribution")   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/numeric/random/dsc_fisher_f_distribution&action=edit)  
[ student_t_distribution](../numeric/random/student_t_distribution.html "cpp/numeric/random/student t distribution")(C++11) |  produces real values on a [Student's t-distribution](https://en.wikipedia.org/wiki/Student%27s_t-distribution "enwiki:Student's t-distribution")   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/numeric/random/dsc_student_t_distribution&action=edit)  
  
#####  Sampling distributions   
  
[ discrete_distribution](../numeric/random/discrete_distribution.html "cpp/numeric/random/discrete distribution")(C++11) |  produces integer values on a discrete distribution   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/numeric/random/dsc_discrete_distribution&action=edit)  
[ piecewise_constant_distribution](../numeric/random/piecewise_constant_distribution.html "cpp/numeric/random/piecewise constant distribution")(C++11) |  produces real values distributed on constant subintervals   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/numeric/random/dsc_piecewise_constant_distribution&action=edit)  
[ piecewise_linear_distribution](../numeric/random/piecewise_linear_distribution.html "cpp/numeric/random/piecewise linear distribution")(C++11) |  produces real values distributed on defined subintervals   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/numeric/random/dsc_piecewise_linear_distribution&action=edit)  
  
#####  Utilities   
  
[ seed_seq](../numeric/random/seed_seq.html "cpp/numeric/random/seed seq")(C++11) |  general-purpose bias-eliminating scrambled seed sequence generator   
(class) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/numeric/random/dsc_seed_seq&action=edit)  
  
###  Functions  
  
[ generate_canonical](../numeric/random/generate_canonical.html "cpp/numeric/random/generate canonical")(C++11) |  evenly distributes real values of given precision across `[`​0​`, `1`)`   
(function template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/numeric/random/dsc_generate_canonical&action=edit)  
[ ranges::generate_random](../algorithm/ranges/generate_random.html "cpp/algorithm/ranges/generate random")(C++26) |  fills a range with random numbers from a uniform random bit generator  
(algorithm function object)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/algorithm/ranges/dsc_generate_random&action=edit)  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/header/random&action=edit&section=1 "Edit section: Synopsis")] Synopsis
    
    
    #include <initializer_list>
     
    namespace std {
      // uniform random bit generator requirements
      template<class G>
      concept uniform_random_bit_generator = /* see description */; // freestanding
     
      // class template linear_congruential_engine
      template<class UIntType, UIntType a, UIntType c, UIntType m>
      class linear_congruential_engine;                             // partially freestanding
     
      // class template mersenne_twister_engine
      template<class UIntType,
               size_t w,
               size_t n,
               size_t m,
               size_t r,
               UIntType a,
               size_t u,
               UIntType d,
               size_t s,
               UIntType b,
               size_t t,
               UIntType c,
               size_t l,
               UIntType f>
      class mersenne_twister_engine;                                // partially freestanding
     
      // class template subtract_with_carry_engine
      template<class UIntType, size_t w, size_t s, size_t r>
      class subtract_with_carry_engine;                             // partially freestanding
     
      // class template discard_block_engine
      template<class Engine, size_t p, size_t r>
      class discard_block_engine;                                   // partially freestanding
     
      // class template independent_bits_engine
      template<class Engine, size_t w, class UIntType>
      class independent_bits_engine;                                // partially freestanding
     
      // class template shuffle_order_engine
      template<class Engine, size_t k>
      class shuffle_order_engine;
     
      // class template philox_engine
      template<class UIntType, size_t w, size_t n, size_t r, UIntType... consts>
      class philox_engine;                                          // partially freestanding
     
      // engines and engine adaptors with predefined parameters
      using minstd_rand0          = /* see description */;          // freestanding
      using minstd_rand           = /* see description */;          // freestanding
      using mt19937               = /* see description */;          // freestanding
      using mt19937_64            = /* see description */;          // freestanding
      using ranlux24_base         = /* see description */;          // freestanding
      using ranlux48_base         = /* see description */;          // freestanding
      using ranlux24              = /* see description */;          // freestanding
      using ranlux48              = /* see description */;          // freestanding
      using knuth_b               = /* see description */;
      using philox4x32            = /* see description */;          // freestanding
      using philox4x64            = /* see description */;          // freestanding
     
      using default_random_engine = /* see description */;
     
      // class random_device
      class random_device;
     
      // class seed_seq
      class seed_seq;
     
      // function template generate_canonical
      template<class RealType, size_t digits, class URBG>
      RealType generate_canonical(URBG& g);
     
      namespace ranges {
        // generate_random
        template<class R, class G>
          requires output_range<R, invoke_result_t<G&>> &&
                   uniform_random_bit_generator<remove_cvref_t<G>>
        constexpr borrowed_iterator_t<R> generate_random(R&& r, G&& g);
     
        template<class G, output_iterator<invoke_result_t<G&>> O, sentinel_for<O> S>
          requires uniform_random_bit_generator<remove_cvref_t<G>>
        constexpr O generate_random(O first, S last, G&& g);
     
        template<class R, class G, class D>
          requires output_range<R, invoke_result_t<D&, G&>> && invocable<D&, G&> &&
                   uniform_random_bit_generator<remove_cvref_t<G>> &&
                   is_arithmetic_v<invoke_result_t<D&, G&>>
        constexpr borrowed_iterator_t<R> generate_random(R&& r, G&& g, D&& d);
     
        template<class G, class D,
                 output_iterator<invoke_result_t<D&, G&>> O, sentinel_for<O> S>
          requires invocable<D&, G&> && uniform_random_bit_generator<remove_cvref_t<G>> &&
                   is_arithmetic_v<invoke_result_t<D&, G&>>
        constexpr O generate_random(O first, S last, G&& g, D&& d);
      }
     
      // class template uniform_int_distribution
      template<class IntType = int>
      class uniform_int_distribution;                               // partially freestanding
     
      // class template uniform_real_distribution
      template<class RealType = double>
      class uniform_real_distribution;
     
      // class bernoulli_distribution
      class bernoulli_distribution;
     
      // class template binomial_distribution
      template<class IntType = int>
      class binomial_distribution;
     
      // class template geometric_distribution
      template<class IntType = int>
      class geometric_distribution;
     
      // class template negative_binomial_distribution
      template<class IntType = int>
      class negative_binomial_distribution;
     
      // class template poisson_distribution
      template<class IntType = int>
      class poisson_distribution;
     
      // class template exponential_distribution
      template<class RealType = double>
      class exponential_distribution;
     
      // class template gamma_distribution
      template<class RealType = double>
      class gamma_distribution;
     
      // class template weibull_distribution
      template<class RealType = double>
      class weibull_distribution;
     
      // class template extreme_value_distribution
      template<class RealType = double>
      class extreme_value_distribution;
     
      // class template normal_distribution
      template<class RealType = double>
      class normal_distribution;
     
      // class template lognormal_distribution
      template<class RealType = double>
      class lognormal_distribution;
     
      // class template chi_squared_distribution
      template<class RealType = double>
      class chi_squared_distribution;
     
      // class template cauchy_distribution
      template<class RealType = double>
      class cauchy_distribution;
     
      // class template fisher_f_distribution
      template<class RealType = double>
      class fisher_f_distribution;
     
      // class template student_t_distribution
      template<class RealType = double>
      class student_t_distribution;
     
      // class template discrete_distribution
      template<class IntType = int>
      class discrete_distribution;
     
      // class template piecewise_constant_distribution
      template<class RealType = double>
      class piecewise_constant_distribution;
     
      // class template piecewise_linear_distribution
      template<class RealType = double>
      class piecewise_linear_distribution;
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/random&action=edit&section=T-1 "Template:cpp/synopsis/random")] Concept [`uniform_random_bit_generator`](../numeric/random/UniformRandomBitGenerator.html "cpp/numeric/random/uniform random bit generator")
    
    
    namespace std {
      template<class G>
      concept uniform_random_bit_generator =
        invocable<G&> && unsigned_integral<invoke_result_t<G&>> && requires {
          {
            G::min()
          } -> same_as<invoke_result_t<G&>>;
          {
            G::max()
          } -> same_as<invoke_result_t<G&>>;
          requires bool_constant<(G::min() < G::max())>::value;
        };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/random&action=edit&section=T-2 "Template:cpp/synopsis/random")] Class template [std::linear_congruential_engine](../numeric/random/linear_congruential_engine.html "cpp/numeric/random/linear congruential engine")
    
    
    namespace std {
      template<class UIntType, UIntType a, UIntType c, UIntType m>
      class linear_congruential_engine
      {
      public:
        // types
        using result_type = UIntType;
     
        // engine characteristics
        static constexpr result_type multiplier = a;
        static constexpr result_type increment  = c;
        static constexpr result_type modulus    = m;
        static constexpr result_type min() { return c == 0u ? 1u : 0u; }
        static constexpr result_type max() { return m - 1u; }
        static constexpr result_type default_seed = 1u;
     
        // constructors and seeding functions
        linear_congruential_engine()
          : linear_congruential_engine(default_seed)
        {
        }
        explicit linear_congruential_engine(result_type s);
        template<class Sseq>
        explicit linear_congruential_engine(Sseq& q);
        void seed(result_type s = default_seed);
        template<class Sseq>
        void seed(Sseq& q);
     
        // equality operators
        friend bool operator==(const linear_congruential_engine& x,
                               const linear_congruential_engine& y);
     
        // generating functions
        result_type operator()();
        void discard(unsigned long long z);
     
        // inserters and extractors
        template<class CharT, class Traits>
        friend basic_ostream<CharT, Traits>&
          operator<<(basic_ostream<CharT, Traits>& os, // hosted
                     const linear_congruential_engine& x);
        template<class CharT, class Traits>
        friend basic_istream<CharT, Traits>&
          operator>>(basic_istream<CharT, Traits>& is, // hosted
                     linear_congruential_engine& x);
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/random&action=edit&section=T-3 "Template:cpp/synopsis/random")] Class template [std::mersenne_twister_engine](../numeric/random/mersenne_twister_engine.html "cpp/numeric/random/mersenne twister engine")
    
    
    namespace std {
      template<class UIntType,
               size_t w,
               size_t n,
               size_t m,
               size_t r,
               UIntType a,
               size_t u,
               UIntType d,
               size_t s,
               UIntType b,
               size_t t,
               UIntType c,
               size_t l,
               UIntType f>
      class mersenne_twister_engine
      {
      public:
        // types
        using result_type = UIntType;
     
        // engine characteristics
        static constexpr size_t word_size                   = w;
        static constexpr size_t state_size                  = n;
        static constexpr size_t shift_size                  = m;
        static constexpr size_t mask_bits                   = r;
        static constexpr UIntType xor_mask                  = a;
        static constexpr size_t tempering_u                 = u;
        static constexpr UIntType tempering_d               = d;
        static constexpr size_t tempering_s                 = s;
        static constexpr UIntType tempering_b               = b;
        static constexpr size_t tempering_t                 = t;
        static constexpr UIntType tempering_c               = c;
        static constexpr size_t tempering_l                 = l;
        static constexpr UIntType initialization_multiplier = f;
        static constexpr result_type min() { return 0; }
        static constexpr result_type max() { return /*2^w - 1*/; }
        static constexpr result_type default_seed = 5489u;
     
        // constructors and seeding functions
        mersenne_twister_engine()
          : mersenne_twister_engine(default_seed)
        {
        }
        explicit mersenne_twister_engine(result_type value);
        template<class Sseq>
        explicit mersenne_twister_engine(Sseq& q);
        void seed(result_type value = default_seed);
        template<class Sseq>
        void seed(Sseq& q);
     
        // equality operators
        friend bool operator==(const mersenne_twister_engine& x,
                               const mersenne_twister_engine& y);
     
        // generating functions
        result_type operator()();
        void discard(unsigned long long z);
     
        // inserters and extractors
        template<class CharT, class Traits>
        friend basic_ostream<CharT, Traits>&
          operator<<(basic_ostream<CharT, Traits>& os, // hosted
                     const mersenne_twister_engine& x);
        template<class CharT, class Traits>
        friend basic_istream<CharT, Traits>&
          operator>>(basic_istream<CharT, Traits>& is, // hosted
                     mersenne_twister_engine& x);
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/random&action=edit&section=T-4 "Template:cpp/synopsis/random")] Class template [std::subtract_with_carry_engine](../numeric/random/subtract_with_carry_engine.html "cpp/numeric/random/subtract with carry engine")
    
    
    namespace std {
      template<class UIntType, size_t w, size_t s, size_t r>
      class subtract_with_carry_engine
      {
      public:
        // types
        using result_type = UIntType;
     
        // engine characteristics
        static constexpr size_t word_size = w;
        static constexpr size_t short_lag = s;
        static constexpr size_t long_lag  = r;
        static constexpr result_type min() { return 0; }
        static constexpr result_type max() { return /*m - 1*/; }
        static constexpr uint_least32_t default_seed = 19780503u;
     
        // constructors and seeding functions
        subtract_with_carry_engine()
          : subtract_with_carry_engine(0u)
        {
        }
        explicit subtract_with_carry_engine(result_type value);
        template<class Sseq>
        explicit subtract_with_carry_engine(Sseq& q);
        void seed(result_type value = 0u);
        template<class Sseq>
        void seed(Sseq& q);
     
        // equality operators
        friend bool operator==(const subtract_with_carry_engine& x,
                               const subtract_with_carry_engine& y);
     
        // generating functions
        result_type operator()();
        void discard(unsigned long long z);
     
        // inserters and extractors
        template<class CharT, class Traits>
        friend basic_ostream<CharT, Traits>&
          operator<<(basic_ostream<CharT, Traits>& os, // hosted
                     const subtract_with_carry_engine& x);
        template<class CharT, class Traits>
        friend basic_istream<CharT, Traits>&
          operator>>(basic_istream<CharT, Traits>& is, // hosted
                     subtract_with_carry_engine& x);
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/random&action=edit&section=T-5 "Template:cpp/synopsis/random")] Class template std::philox_engine
    
    
    namespace std {
      template<class UIntType, size_t w, size_t n, size_t r, UIntType... consts>
      class philox_engine
      {
        static constexpr size_t /*array-size*/ = n / 2; // exposition only
      public:
        // types
        using result_type = UIntType;
     
        // engine characteristics
        static constexpr size_t word_size   = w;
        static constexpr size_t word_count  = n;
        static constexpr size_t round_count = r;
        static constexpr array<result_type, /*array-size*/> multipliers;
        static constexpr array < result_type, @exposition onlyid { array - size > }
        @round_consts;
        static constexpr result_type min() { return 0; }
        static constexpr result_type max() { return m - 1; }
        static constexpr result_type default_seed = 20111115u;
     
        // constructors and seeding functions
        philox_engine()
          : philox_engine(default_seed)
        {
        }
        explicit philox_engine(result_type value);
        template<class Sseq>
        explicit philox_engine(Sseq& q);
        void seed(result_type value = default_seed);
        template<class Sseq>
        void seed(Sseq& q);
     
        void set_counter(const array<result_type, n>& counter);
     
        // equality operators
        friend bool operator==(const philox_engine& x, const philox_engine& y);
     
        // generating functions
        result_type operator()();
        void discard(unsigned long long z);
     
        // inserters and extractors
        template<class CharT, class Traits>
        friend basic_ostream<CharT, Traits>&
          operator<<(basic_ostream<CharT, Traits>& os, // hosted
                     const philox_engine& x);
        template<class CharT, class Traits>
        friend basic_istream<CharT, Traits>&
          operator>>(basic_istream<CharT, Traits>& is, // hosted
                     philox_engine& x);
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/random&action=edit&section=T-6 "Template:cpp/synopsis/random")] Class template [std::discard_block_engine](../numeric/random/discard_block_engine.html "cpp/numeric/random/discard block engine")
    
    
    namespace std {
      template<class Engine, size_t p, size_t r>
      class discard_block_engine
      {
      public:
        // types
        using result_type = typename Engine::result_type;
     
        // engine characteristics
        static constexpr size_t block_size = p;
        static constexpr size_t used_block = r;
        static constexpr result_type min() { return Engine::min(); }
        static constexpr result_type max() { return Engine::max(); }
     
        // constructors and seeding functions
        discard_block_engine();
        explicit discard_block_engine(const Engine& e);
        explicit discard_block_engine(Engine&& e);
        explicit discard_block_engine(result_type s);
        template<class Sseq>
        explicit discard_block_engine(Sseq& q);
        void seed();
        void seed(result_type s);
        template<class Sseq>
        void seed(Sseq& q);
     
        // equality operators
        friend bool operator==(const discard_block_engine& x, const discard_block_engine& y);
     
        // generating functions
        result_type operator()();
        void discard(unsigned long long z);
     
        // property functions
        const Engine& base() const noexcept { return e; }
     
        // inserters and extractors
        template<class CharT, class Traits>
        friend basic_ostream<CharT, Traits>&
          operator<<(basic_ostream<CharT, Traits>& os, // hosted
                     const discard_block_engine& x);
        template<class CharT, class Traits>
        friend basic_istream<CharT, Traits>&
          operator>>(basic_istream<CharT, Traits>& is, // hosted
                     discard_block_engine& x);
     
      private:
        Engine e; // exposition only
        size_t n; // exposition only
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/random&action=edit&section=T-7 "Template:cpp/synopsis/random")] Class template [std::independent_bits_engine](../numeric/random/independent_bits_engine.html "cpp/numeric/random/independent bits engine")
    
    
    namespace std {
      template<class Engine, size_t w, class UIntType>
      class independent_bits_engine
      {
      public:
        // types
        using result_type = UIntType;
     
        // engine characteristics
        static constexpr result_type min() { return 0; }
        static constexpr result_type max() { return /*2^w - 1*/; }
     
        // constructors and seeding functions
        independent_bits_engine();
        explicit independent_bits_engine(const Engine& e);
        explicit independent_bits_engine(Engine&& e);
        explicit independent_bits_engine(result_type s);
        template<class Sseq>
        explicit independent_bits_engine(Sseq& q);
        void seed();
        void seed(result_type s);
        template<class Sseq>
        void seed(Sseq& q);
     
        // equality operators
        friend bool operator==(const independent_bits_engine& x,
                               const independent_bits_engine& y);
     
        // generating functions
        result_type operator()();
        void discard(unsigned long long z);
     
        // property functions
        const Engine& base() const noexcept { return e; }
     
        // inserters and extractors
        template<class CharT, class Traits>
        friend basic_ostream<CharT, Traits>&
          operator<<(basic_ostream<CharT, Traits>& os, // hosted
                     const independent_bits_engine& x);
        template<class CharT, class Traits>
        friend basic_istream<CharT, Traits>&
          operator>>(basic_istream<CharT, Traits>& is, // hosted
                     independent_bits_engine& x);
     
      private:
        Engine e; // exposition only
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/random&action=edit&section=T-8 "Template:cpp/synopsis/random")] Class template [std::shuffle_order_engine](../numeric/random/shuffle_order_engine.html "cpp/numeric/random/shuffle order engine")
    
    
    namespace std {
      template<class Engine, size_t k>
      class shuffle_order_engine
      {
      public:
        // types
        using result_type = typename Engine::result_type;
     
        // engine characteristics
        static constexpr size_t table_size = k;
        static constexpr result_type min() { return Engine::min(); }
        static constexpr result_type max() { return Engine::max(); }
     
        // constructors and seeding functions
        shuffle_order_engine();
        explicit shuffle_order_engine(const Engine& e);
        explicit shuffle_order_engine(Engine&& e);
        explicit shuffle_order_engine(result_type s);
        template<class Sseq>
        explicit shuffle_order_engine(Sseq& q);
        void seed();
        void seed(result_type s);
        template<class Sseq>
        void seed(Sseq& q);
     
        // equality operators
        friend bool operator==(const shuffle_order_engine& x, const shuffle_order_engine& y);
     
        // generating functions
        result_type operator()();
        void discard(unsigned long long z);
     
        // property functions
        const Engine& base() const noexcept { return e; }
     
        // inserters and extractors
        template<class CharT, class Traits>
        friend basic_ostream<CharT, Traits>& operator<<(basic_ostream<CharT, Traits>& os,
                                                        const shuffle_order_engine& x);
        template<class CharT, class Traits>
        friend basic_istream<CharT, Traits>& operator>>(basic_istream<CharT, Traits>& is,
                                                        shuffle_order_engine& x);
     
      private:
        Engine e;         // exposition only
        result_type V[k]; // exposition only
        result_type Y;    // exposition only
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/random&action=edit&section=T-9 "Template:cpp/synopsis/random")] Engines and engine adaptors with predefined parameters
    
    
    namespace std {
    using minstd_rand0 = linear_congruential_engine<uint_fast32_t, 16'807, 0, 2'147'483'647>;
    using minstd_rand = linear_congruential_engine<uint_fast32_t, 48'271, 0, 2'147'483'647>;
    using mt19937 = mersenne_twister_engine<uint_fast32_t,
                                            32,
                                            624,
                                            397,
                                            31,
                                            0x9908'b0df,
                                            11,
                                            0xffff'ffff,
                                            7,
                                            0x9d2c'5680,
                                            15,
                                            0xefc6'0000,
                                            18,
                                            1'812'433'253>; //'
    using mt19937_64 = mersenne_twister_engine<uint_fast64_t,
                                               64,
                                               312,
                                               156,
                                               31,
                                               0xb502'6f5a'a966'19e9,
                                               29,
                                               0x5555'5555'5555'5555,
                                               17,
                                               0x71d6'7fff'eda6'0000,
                                               37,
                                               0xfff7'eee0'0000'0000,
                                               43,
                                               6'364'136'223'846'793'005>;
    using ranlux24_base = subtract_with_carry_engine<uint_fast32_t, 24, 10, 24>;
    using ranlux48_base = subtract_with_carry_engine<uint_fast64_t, 48, 5, 12>;
    using ranlux24 = discard_block_engine<ranlux24_base, 223, 23>;
    using ranlux48 = discard_block_engine<ranlux48_base, 389, 11>;
    using knuth_b = shuffle_order_engine<minstd_rand0, 256>;
    using default_random_engine = /* implementation-defined */;
    using philox4x32 = philox_engine<uint_fast32_t,
                                     32,
                                     4,
                                     10,
                                     0xD2511F53,
                                     0x9E3779B9,
                                     0xCD9E8D57,
                                     0xBB67AE85>;
    using philox4x64 = philox_engine<uint_fast64_t,
                                     64,
                                     4,
                                     10,
                                     0xD2E7470EE14C6C93,
                                     0x9E3779B97F4A7C15,
                                     0xCA5A826395121157,
                                     0xBB67AE8584CAA73B>;
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/random&action=edit&section=T-10 "Template:cpp/synopsis/random")] Class [std::random_device](../numeric/random/random_device.html "cpp/numeric/random/random device")
    
    
    namespace std {
      class random_device
      {
      public:
        // types
        using result_type = unsigned int;
     
        // generator characteristics
        static constexpr result_type min() { return numeric_limits<result_type>::min(); }
        static constexpr result_type max() { return numeric_limits<result_type>::max(); }
     
        // constructors
        random_device()
          : random_device(/* implementation-defined */)
        {
        }
        explicit random_device(const string& token);
     
        // generating functions
        result_type operator()();
     
        // property functions
        double entropy() const noexcept;
     
        // no copy functions
        random_device(const random_device&)  = delete;
        void operator=(const random_device&) = delete;
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/random&action=edit&section=T-11 "Template:cpp/synopsis/random")] Class [std::seed_seq](../numeric/random/seed_seq.html "cpp/numeric/random/seed seq")
    
    
    namespace std {
      class seed_seq
      {
      public:
        // types
        using result_type = uint_least32_t;
     
        // constructors
        seed_seq() noexcept;
        template<class T>
        seed_seq(initializer_list<T> il);
        template<class InputIter>
        seed_seq(InputIter begin, InputIter end);
     
        // generating functions
        template<class RandomAccessIter>
        void generate(RandomAccessIter begin, RandomAccessIter end);
     
        // property functions
        size_t size() const noexcept;
        template<class OutputIter>
        void param(OutputIter dest) const;
     
        // no copy functions
        seed_seq(const seed_seq&)       = delete;
        void operator=(const seed_seq&) = delete;
     
      private:
        vector<result_type> v; // exposition only
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/random&action=edit&section=T-12 "Template:cpp/synopsis/random")] Class template [std::uniform_int_distribution](../numeric/random/uniform_int_distribution.html "cpp/numeric/random/uniform int distribution")
    
    
    namespace std {
      template<class IntType = int>
      class uniform_int_distribution
      {
      public:
        // types
        using result_type = IntType;
        using param_type  = /* unspecified */;
     
        // constructors and reset functions
        uniform_int_distribution()
          : uniform_int_distribution(0)
        {
        }
        explicit uniform_int_distribution(IntType a,
                                          IntType b = numeric_limits<IntType>::max());
        explicit uniform_int_distribution(const param_type& parm);
        void reset();
     
        // equality operators
        friend bool operator==(const uniform_int_distribution& x,
                               const uniform_int_distribution& y);
     
        // generating functions
        template<class URBG>
        result_type operator()(URBG& g);
        template<class URBG>
        result_type operator()(URBG& g, const param_type& parm);
     
        // property functions
        result_type a() const;
        result_type b() const;
        param_type param() const;
        void param(const param_type& parm);
        result_type min() const;
        result_type max() const;
     
        // inserters and extractors
        template<class CharT, class Traits>
        friend basic_ostream<CharT, Traits>&
          operator<<(basic_ostream<CharT, Traits>& os, // hosted
                     const uniform_int_distribution& x);
        template<class CharT, class Traits>
        friend basic_istream<CharT, Traits>&
          operator>>(basic_istream<CharT, Traits>& is, // hosted
                     uniform_int_distribution& x);
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/random&action=edit&section=T-13 "Template:cpp/synopsis/random")] Class template [std::uniform_real_distribution](../numeric/random/uniform_real_distribution.html "cpp/numeric/random/uniform real distribution")
    
    
    namespace std {
      template<class RealType = double>
      class uniform_real_distribution
      {
      public:
        // types
        using result_type = RealType;
        using param_type  = /* unspecified */;
     
        // constructors and reset functions
        uniform_real_distribution()
          : uniform_real_distribution(0.0)
        {
        }
        explicit uniform_real_distribution(RealType a, RealType b = 1.0);
        explicit uniform_real_distribution(const param_type& parm);
        void reset();
     
        // equality operators
        friend bool operator==(const uniform_real_distribution& x,
                               const uniform_real_distribution& y);
     
        // generating functions
        template<class URBG>
        result_type operator()(URBG& g);
        template<class URBG>
        result_type operator()(URBG& g, const param_type& parm);
     
        // property functions
        result_type a() const;
        result_type b() const;
        param_type param() const;
        void param(const param_type& parm);
        result_type min() const;
        result_type max() const;
     
        // inserters and extractors
        template<class CharT, class Traits>
        friend basic_ostream<CharT, Traits>& operator<<(basic_ostream<CharT, Traits>& os,
                                                        const uniform_real_distribution& x);
        template<class CharT, class Traits>
        friend basic_istream<CharT, Traits>& operator>>(basic_istream<CharT, Traits>& is,
                                                        uniform_real_distribution& x);
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/random&action=edit&section=T-14 "Template:cpp/synopsis/random")] Class [std::bernoulli_distribution](../numeric/random/bernoulli_distribution.html "cpp/numeric/random/bernoulli distribution")
    
    
    namespace std {
      class bernoulli_distribution
      {
      public:
        // types
        using result_type = bool;
        using param_type  = /* unspecified */;
     
        // constructors and reset functions
        bernoulli_distribution()
          : bernoulli_distribution(0.5)
        {
        }
        explicit bernoulli_distribution(double p);
        explicit bernoulli_distribution(const param_type& parm);
        void reset();
     
        // equality operators
        friend bool operator==(const bernoulli_distribution& x,
                               const bernoulli_distribution& y);
     
        // generating functions
        template<class URBG>
        result_type operator()(URBG& g);
        template<class URBG>
        result_type operator()(URBG& g, const param_type& parm);
     
        // property functions
        double p() const;
        param_type param() const;
        void param(const param_type& parm);
        result_type min() const;
        result_type max() const;
     
        // inserters and extractors
        template<class CharT, class Traits>
        friend basic_ostream<CharT, Traits>& operator<<(basic_ostream<CharT, Traits>& os,
                                                        const bernoulli_distribution& x);
        template<class CharT, class Traits>
        friend basic_istream<CharT, Traits>& operator>>(basic_istream<CharT, Traits>& is,
                                                        bernoulli_distribution& x);
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/random&action=edit&section=T-15 "Template:cpp/synopsis/random")] Class template [std::binomial_distribution](../numeric/random/binomial_distribution.html "cpp/numeric/random/binomial distribution")
    
    
    namespace std {
      template<class IntType = int>
      class binomial_distribution
      {
      public:
        // types
        using result_type = IntType;
        using param_type  = /* unspecified */;
     
        // constructors and reset functions
        binomial_distribution()
          : binomial_distribution(1)
        {
        }
        explicit binomial_distribution(IntType t, double p = 0.5);
        explicit binomial_distribution(const param_type& parm);
        void reset();
     
        // equality operators
        friend bool operator==(const binomial_distribution& x,
                               const binomial_distribution& y);
     
        // generating functions
        template<class URBG>
        result_type operator()(URBG& g);
        template<class URBG>
        result_type operator()(URBG& g, const param_type& parm);
     
        // property functions
        IntType t() const;
        double p() const;
        param_type param() const;
        void param(const param_type& parm);
        result_type min() const;
        result_type max() const;
     
        // inserters and extractors
        template<class CharT, class Traits>
        friend basic_ostream<CharT, Traits>& operator<<(basic_ostream<CharT, Traits>& os,
                                                        const binomial_distribution& x);
        template<class CharT, class Traits>
        friend basic_istream<CharT, Traits>& operator>>(basic_istream<CharT, Traits>& is,
                                                        binomial_distribution& x);
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/random&action=edit&section=T-16 "Template:cpp/synopsis/random")] Class template [std::geometric_distribution](../numeric/random/geometric_distribution.html "cpp/numeric/random/geometric distribution")
    
    
    namespace std {
      template<class IntType = int>
      class geometric_distribution
      {
      public:
        // types
        using result_type = IntType;
        using param_type  = /* unspecified */;
     
        // constructors and reset functions
        geometric_distribution()
          : geometric_distribution(0.5)
        {
        }
        explicit geometric_distribution(double p);
        explicit geometric_distribution(const param_type& parm);
        void reset();
     
        // equality operators
        friend bool operator==(const geometric_distribution& x,
                               const geometric_distribution& y);
     
        // generating functions
        template<class URBG>
        result_type operator()(URBG& g);
        template<class URBG>
        result_type operator()(URBG& g, const param_type& parm);
     
        // property functions
        double p() const;
        param_type param() const;
        void param(const param_type& parm);
        result_type min() const;
        result_type max() const;
     
        // inserters and extractors
        template<class CharT, class Traits>
        friend basic_ostream<CharT, Traits>& operator<<(basic_ostream<CharT, Traits>& os,
                                                        const geometric_distribution& x);
        template<class CharT, class Traits>
        friend basic_istream<CharT, Traits>& operator>>(basic_istream<CharT, Traits>& is,
                                                        geometric_distribution& x);
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/random&action=edit&section=T-17 "Template:cpp/synopsis/random")] Class template [std::negative_binomial_distribution](../numeric/random/negative_binomial_distribution.html "cpp/numeric/random/negative binomial distribution")
    
    
    namespace std {
      template<class IntType = int>
      class negative_binomial_distribution
      {
      public:
        // types
        using result_type = IntType;
        using param_type  = /* unspecified */;
     
        // constructor and reset functions
        negative_binomial_distribution()
          : negative_binomial_distribution(1)
        {
        }
        explicit negative_binomial_distribution(IntType k, double p = 0.5);
        explicit negative_binomial_distribution(const param_type& parm);
        void reset();
     
        // equality operators
        friend bool operator==(const negative_binomial_distribution& x,
                               const negative_binomial_distribution& y);
     
        // generating functions
        template<class URBG>
        result_type operator()(URBG& g);
        template<class URBG>
        result_type operator()(URBG& g, const param_type& parm);
     
        // property functions
        IntType k() const;
        double p() const;
        param_type param() const;
        void param(const param_type& parm);
        result_type min() const;
        result_type max() const;
     
        // inserters and extractors
        template<class CharT, class Traits>
        friend basic_ostream<CharT, Traits>& operator<<(
          basic_ostream<CharT, Traits>& os,
          const negative_binomial_distribution& x);
        template<class CharT, class Traits>
        friend basic_istream<CharT, Traits>& operator>>(basic_istream<CharT, Traits>& is,
                                                        negative_binomial_distribution& x);
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/random&action=edit&section=T-18 "Template:cpp/synopsis/random")] Class template [std::poisson_distribution](../numeric/random/poisson_distribution.html "cpp/numeric/random/poisson distribution")
    
    
    namespace std {
      template<class IntType = int>
      class poisson_distribution
      {
      public:
        // types
        using result_type = IntType;
        using param_type  = /* unspecified */;
     
        // constructors and reset functions
        poisson_distribution()
          : poisson_distribution(1.0)
        {
        }
        explicit poisson_distribution(double mean);
        explicit poisson_distribution(const param_type& parm);
        void reset();
     
        // equality operators
        friend bool operator==(const poisson_distribution& x, const poisson_distribution& y);
     
        // generating functions
        template<class URBG>
        result_type operator()(URBG& g);
        template<class URBG>
        result_type operator()(URBG& g, const param_type& parm);
     
        // property functions
        double mean() const;
        param_type param() const;
        void param(const param_type& parm);
        result_type min() const;
        result_type max() const;
     
        // inserters and extractors
        template<class CharT, class Traits>
        friend basic_ostream<CharT, Traits>& operator<<(basic_ostream<CharT, Traits>& os,
                                                        const poisson_distribution& x);
        template<class CharT, class Traits>
        friend basic_istream<CharT, Traits>& operator>>(basic_istream<CharT, Traits>& is,
                                                        poisson_distribution& x);
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/random&action=edit&section=T-19 "Template:cpp/synopsis/random")] Class template [std::exponential_distribution](../numeric/random/exponential_distribution.html "cpp/numeric/random/exponential distribution")
    
    
    namespace std {
      template<class RealType = double>
      class exponential_distribution
      {
      public:
        // types
        using result_type = RealType;
        using param_type  = /* unspecified */;
     
        // constructors and reset functions
        exponential_distribution()
          : exponential_distribution(1.0)
        {
        }
        explicit exponential_distribution(RealType lambda);
        explicit exponential_distribution(const param_type& parm);
        void reset();
     
        // equality operators
        friend bool operator==(const exponential_distribution& x,
                               const exponential_distribution& y);
     
        // generating functions
        template<class URBG>
        result_type operator()(URBG& g);
        template<class URBG>
        result_type operator()(URBG& g, const param_type& parm);
     
        // property functions
        RealType lambda() const;
        param_type param() const;
        void param(const param_type& parm);
        result_type min() const;
        result_type max() const;
     
        // inserters and extractors
        template<class CharT, class Traits>
        friend basic_ostream<CharT, Traits>& operator<<(basic_ostream<CharT, Traits>& os,
                                                        const exponential_distribution& x);
        template<class CharT, class Traits>
        friend basic_istream<CharT, Traits>& operator>>(basic_istream<CharT, Traits>& is,
                                                        exponential_distribution& x);
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/random&action=edit&section=T-20 "Template:cpp/synopsis/random")] Class template [std::gamma_distribution](../numeric/random/gamma_distribution.html "cpp/numeric/random/gamma distribution")
    
    
    namespace std {
      template<class RealType = double>
      class gamma_distribution
      {
      public:
        // types
        using result_type = RealType;
        using param_type  = /* unspecified */;
     
        // constructors and reset functions
        gamma_distribution()
          : gamma_distribution(1.0)
        {
        }
        explicit gamma_distribution(RealType alpha, RealType beta = 1.0);
        explicit gamma_distribution(const param_type& parm);
        void reset();
     
        // equality operators
        friend bool operator==(const gamma_distribution& x, const gamma_distribution& y);
     
        // generating functions
        template<class URBG>
        result_type operator()(URBG& g);
        template<class URBG>
        result_type operator()(URBG& g, const param_type& parm);
     
        // property functions
        RealType alpha() const;
        RealType beta() const;
        param_type param() const;
        void param(const param_type& parm);
        result_type min() const;
        result_type max() const;
     
        // inserters and extractors
        template<class CharT, class Traits>
        friend basic_ostream<CharT, Traits>& operator<<(basic_ostream<CharT, Traits>& os,
                                                        const gamma_distribution& x);
        template<class CharT, class Traits>
        friend basic_istream<CharT, Traits>& operator>>(basic_istream<CharT, Traits>& is,
                                                        gamma_distribution& x);
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/random&action=edit&section=T-21 "Template:cpp/synopsis/random")] Class template [std::weibull_distribution](../numeric/random/weibull_distribution.html "cpp/numeric/random/weibull distribution")
    
    
    namespace std {
      template<class RealType = double>
      class weibull_distribution
      {
      public:
        // types
        using result_type = RealType;
        using param_type  = /* unspecified */;
     
        // constructor and reset functions
        weibull_distribution()
          : weibull_distribution(1.0)
        {
        }
        explicit weibull_distribution(RealType a, RealType b = 1.0);
        explicit weibull_distribution(const param_type& parm);
        void reset();
     
        // equality operators
        friend bool operator==(const weibull_distribution& x, const weibull_distribution& y);
     
        // generating functions
        template<class URBG>
        result_type operator()(URBG& g);
        template<class URBG>
        result_type operator()(URBG& g, const param_type& parm);
     
        // property functions
        RealType a() const;
        RealType b() const;
        param_type param() const;
        void param(const param_type& parm);
        result_type min() const;
        result_type max() const;
     
        // inserters and extractors
        template<class CharT, class Traits>
        friend basic_ostream<CharT, Traits>& operator<<(basic_ostream<CharT, Traits>& os,
                                                        const weibull_distribution& x);
        template<class CharT, class Traits>
        friend basic_istream<CharT, Traits>& operator>>(basic_istream<CharT, Traits>& is,
                                                        weibull_distribution& x);
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/random&action=edit&section=T-22 "Template:cpp/synopsis/random")] Class template [std::extreme_value_distribution](../numeric/random/extreme_value_distribution.html "cpp/numeric/random/extreme value distribution")
    
    
    namespace std {
      template<class RealType = double>
      class extreme_value_distribution
      {
      public:
        // types
        using result_type = RealType;
        using param_type  = /* unspecified */;
     
        // constructor and reset functions
        extreme_value_distribution()
          : extreme_value_distribution(0.0)
        {
        }
        explicit extreme_value_distribution(RealType a, RealType b = 1.0);
        explicit extreme_value_distribution(const param_type& parm);
        void reset();
     
        // equality operators
        friend bool operator==(const extreme_value_distribution& x,
                               const extreme_value_distribution& y);
     
        // generating functions
        template<class URBG>
        result_type operator()(URBG& g);
        template<class URBG>
        result_type operator()(URBG& g, const param_type& parm);
     
        // property functions
        RealType a() const;
        RealType b() const;
        param_type param() const;
        void param(const param_type& parm);
        result_type min() const;
        result_type max() const;
     
        // inserters and extractors
        template<class CharT, class Traits>
        friend basic_ostream<CharT, Traits>& operator<<(basic_ostream<CharT, Traits>& os,
                                                        const extreme_value_distribution& x);
        template<class CharT, class Traits>
        friend basic_istream<CharT, Traits>& operator>>(basic_istream<CharT, Traits>& is,
                                                        extreme_value_distribution& x);
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/random&action=edit&section=T-23 "Template:cpp/synopsis/random")] Class template [std::normal_distribution](../numeric/random/normal_distribution.html "cpp/numeric/random/normal distribution")
    
    
    namespace std {
      template<class RealType = double>
      class normal_distribution
      {
      public:
        // types
        using result_type = RealType;
        using param_type  = /* unspecified */;
     
        // constructors and reset functions
        normal_distribution()
          : normal_distribution(0.0)
        {
        }
        explicit normal_distribution(RealType mean, RealType stddev = 1.0);
        explicit normal_distribution(const param_type& parm);
        void reset();
     
        // equality operators
        friend bool operator==(const normal_distribution& x, const normal_distribution& y);
     
        // generating functions
        template<class URBG>
        result_type operator()(URBG& g);
        template<class URBG>
        result_type operator()(URBG& g, const param_type& parm);
     
        // property functions
        RealType mean() const;
        RealType stddev() const;
        param_type param() const;
        void param(const param_type& parm);
        result_type min() const;
        result_type max() const;
     
        // inserters and extractors
        template<class CharT, class Traits>
        friend basic_ostream<CharT, Traits>& operator<<(basic_ostream<CharT, Traits>& os,
                                                        const normal_distribution& x);
        template<class CharT, class Traits>
        friend basic_istream<CharT, Traits>& operator>>(basic_istream<CharT, Traits>& is,
                                                        normal_distribution& x);
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/random&action=edit&section=T-24 "Template:cpp/synopsis/random")] Class template [std::lognormal_distribution](../numeric/random/lognormal_distribution.html "cpp/numeric/random/lognormal distribution")
    
    
    namespace std {
      template<class RealType = double>
      class lognormal_distribution
      {
      public:
        // types
        using result_type = RealType;
        using param_type  = /* unspecified */;
     
        // constructor and reset functions
        lognormal_distribution()
          : lognormal_distribution(0.0)
        {
        }
        explicit lognormal_distribution(RealType m, RealType s = 1.0);
        explicit lognormal_distribution(const param_type& parm);
        void reset();
     
        // equality operators
        friend bool operator==(const lognormal_distribution& x,
                               const lognormal_distribution& y);
     
        // generating functions
        template<class URBG>
        result_type operator()(URBG& g);
        template<class URBG>
        result_type operator()(URBG& g, const param_type& parm);
     
        // property functions
        RealType m() const;
        RealType s() const;
        param_type param() const;
        void param(const param_type& parm);
        result_type min() const;
        result_type max() const;
     
        // inserters and extractors
        template<class CharT, class Traits>
        friend basic_ostream<CharT, Traits>& operator<<(basic_ostream<CharT, Traits>& os,
                                                        const lognormal_distribution& x);
        template<class CharT, class Traits>
        friend basic_istream<CharT, Traits>& operator>>(basic_istream<CharT, Traits>& is,
                                                        lognormal_distribution& x);
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/random&action=edit&section=T-25 "Template:cpp/synopsis/random")] Class template [std::chi_squared_distribution](../numeric/random/chi_squared_distribution.html "cpp/numeric/random/chi squared distribution")
    
    
    namespace std {
      template<class RealType = double>
      class chi_squared_distribution
      {
      public:
        // types
        using result_type = RealType;
        using param_type  = /* unspecified */;
     
        // constructor and reset functions
        chi_squared_distribution()
          : chi_squared_distribution(1.0)
        {
        }
        explicit chi_squared_distribution(RealType n);
        explicit chi_squared_distribution(const param_type& parm);
        void reset();
     
        // equality operators
        friend bool operator==(const chi_squared_distribution& x,
                               const chi_squared_distribution& y);
     
        // generating functions
        template<class URBG>
        result_type operator()(URBG& g);
        template<class URBG>
        result_type operator()(URBG& g, const param_type& parm);
     
        // property functions
        RealType n() const;
        param_type param() const;
        void param(const param_type& parm);
        result_type min() const;
        result_type max() const;
     
        // inserters and extractors
        template<class CharT, class Traits>
        friend basic_ostream<CharT, Traits>& operator<<(basic_ostream<CharT, Traits>& os,
                                                        const chi_squared_distribution& x);
        template<class CharT, class Traits>
        friend basic_istream<CharT, Traits>& operator>>(basic_istream<CharT, Traits>& is,
                                                        chi_squared_distribution& x);
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/random&action=edit&section=T-26 "Template:cpp/synopsis/random")] Class template [std::cauchy_distribution](../numeric/random/cauchy_distribution.html "cpp/numeric/random/cauchy distribution")
    
    
    namespace std {
      template<class RealType = double>
      class cauchy_distribution
      {
      public:
        // types
        using result_type = RealType;
        using param_type  = /* unspecified */;
     
        // constructor and reset functions
        cauchy_distribution()
          : cauchy_distribution(0.0)
        {
        }
        explicit cauchy_distribution(RealType a, RealType b = 1.0);
        explicit cauchy_distribution(const param_type& parm);
        void reset();
     
        // equality operators
        friend bool operator==(const cauchy_distribution& x, const cauchy_distribution& y);
     
        // generating functions
        template<class URBG>
        result_type operator()(URBG& g);
        template<class URBG>
        result_type operator()(URBG& g, const param_type& parm);
     
        // property functions
        RealType a() const;
        RealType b() const;
        param_type param() const;
        void param(const param_type& parm);
        result_type min() const;
        result_type max() const;
     
        // inserters and extractors
        template<class CharT, class Traits>
        friend basic_ostream<CharT, Traits>& operator<<(basic_ostream<CharT, Traits>& os,
                                                        const cauchy_distribution& x);
        template<class CharT, class Traits>
        friend basic_istream<CharT, Traits>& operator>>(basic_istream<CharT, Traits>& is,
                                                        cauchy_distribution& x);
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/random&action=edit&section=T-27 "Template:cpp/synopsis/random")] Class template [std::fisher_f_distribution](../numeric/random/fisher_f_distribution.html "cpp/numeric/random/fisher f distribution")
    
    
    namespace std {
      template<class RealType = double>
      class fisher_f_distribution
      {
      public:
        // types
        using result_type = RealType;
        using param_type  = /* unspecified */;
     
        // constructor and reset functions
        fisher_f_distribution()
          : fisher_f_distribution(1.0)
        {
        }
        explicit fisher_f_distribution(RealType m, RealType n = 1.0);
        explicit fisher_f_distribution(const param_type& parm);
        void reset();
     
        // equality operators
        friend bool operator==(const fisher_f_distribution& x,
                               const fisher_f_distribution& y);
     
        // generating functions
        template<class URBG>
        result_type operator()(URBG& g);
        template<class URBG>
        result_type operator()(URBG& g, const param_type& parm);
     
        // property functions
        RealType m() const;
        RealType n() const;
        param_type param() const;
        void param(const param_type& parm);
        result_type min() const;
        result_type max() const;
     
        // inserters and extractors
        template<class CharT, class Traits>
        friend basic_ostream<CharT, Traits>& operator<<(basic_ostream<CharT, Traits>& os,
                                                        const fisher_f_distribution& x);
        template<class CharT, class Traits>
        friend basic_istream<CharT, Traits>& operator>>(basic_istream<CharT, Traits>& is,
                                                        fisher_f_distribution& x);
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/random&action=edit&section=T-28 "Template:cpp/synopsis/random")] Class template [std::student_t_distribution](../numeric/random/student_t_distribution.html "cpp/numeric/random/student t distribution")
    
    
    namespace std {
      template<class RealType = double>
      class student_t_distribution
      {
      public:
        // types
        using result_type = RealType;
        using param_type  = /* unspecified */;
     
        // constructor and reset functions
        student_t_distribution()
          : student_t_distribution(1.0)
        {
        }
        explicit student_t_distribution(RealType n);
        explicit student_t_distribution(const param_type& parm);
        void reset();
     
        // equality operators
        friend bool operator==(const student_t_distribution& x,
                               const student_t_distribution& y);
     
        // generating functions
        template<class URBG>
        result_type operator()(URBG& g);
        template<class URBG>
        result_type operator()(URBG& g, const param_type& parm);
     
        // property functions
        RealType n() const;
        param_type param() const;
        void param(const param_type& parm);
        result_type min() const;
        result_type max() const;
     
        // inserters and extractors
        template<class CharT, class Traits>
        friend basic_ostream<CharT, Traits>& operator<<(basic_ostream<CharT, Traits>& os,
                                                        const student_t_distribution& x);
        template<class CharT, class Traits>
        friend basic_istream<CharT, Traits>& operator>>(basic_istream<CharT, Traits>& is,
                                                        student_t_distribution& x);
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/random&action=edit&section=T-29 "Template:cpp/synopsis/random")] Class template [std::discrete_distribution](../numeric/random/discrete_distribution.html "cpp/numeric/random/discrete distribution")
    
    
    namespace std {
      template<class IntType = int>
      class discrete_distribution
      {
      public:
        // types
        using result_type = IntType;
        using param_type  = /* unspecified */;
     
        // constructor and reset functions
        discrete_distribution();
        template<class InputIter>
        discrete_distribution(InputIter firstW, InputIter lastW);
        discrete_distribution(initializer_list<double> wl);
        template<class UnaryOperation>
        discrete_distribution(size_t nw, double xmin, double xmax, UnaryOperation fw);
        explicit discrete_distribution(const param_type& parm);
        void reset();
     
        // equality operators
        friend bool operator==(const discrete_distribution& x,
                               const discrete_distribution& y);
     
        // generating functions
        template<class URBG>
        result_type operator()(URBG& g);
        template<class URBG>
        result_type operator()(URBG& g, const param_type& parm);
     
        // property functions
        vector<double> probabilities() const;
        param_type param() const;
        void param(const param_type& parm);
        result_type min() const;
        result_type max() const;
     
        // inserters and extractors
        template<class CharT, class Traits>
        friend basic_ostream<CharT, Traits>& operator<<(basic_ostream<CharT, Traits>& os,
                                                        const discrete_distribution& x);
        template<class CharT, class Traits>
        friend basic_istream<CharT, Traits>& operator>>(basic_istream<CharT, Traits>& is,
                                                        discrete_distribution& x);
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/random&action=edit&section=T-30 "Template:cpp/synopsis/random")] Class template [std::piecewise_constant_distribution](../numeric/random/piecewise_constant_distribution.html "cpp/numeric/random/piecewise constant distribution")
    
    
    namespace std {
      template<class RealType = double>
      class piecewise_constant_distribution
      {
      public:
        // types
        using result_type = RealType;
        using param_type  = /* unspecified */;
     
        // constructor and reset functions
        piecewise_constant_distribution();
        template<class InputIterB, class InputIterW>
        piecewise_constant_distribution(InputIterB firstB,
                                        InputIterB lastB,
                                        InputIterW firstW);
        template<class UnaryOperation>
        piecewise_constant_distribution(initializer_list<RealType> bl, UnaryOperation fw);
        template<class UnaryOperation>
        piecewise_constant_distribution(size_t nw,
                                        RealType xmin,
                                        RealType xmax,
                                        UnaryOperation fw);
        explicit piecewise_constant_distribution(const param_type& parm);
        void reset();
     
        // equality operators
        friend bool operator==(const piecewise_constant_distribution& x,
                               const piecewise_constant_distribution& y);
     
        // generating functions
        template<class URBG>
        result_type operator()(URBG& g);
        template<class URBG>
        result_type operator()(URBG& g, const param_type& parm);
     
        // property functions
        vector<result_type> intervals() const;
        vector<result_type> densities() const;
        param_type param() const;
        void param(const param_type& parm);
        result_type min() const;
        result_type max() const;
     
        // inserters and extractors
        template<class CharT, class Traits>
        friend basic_ostream<CharT, Traits>& operator<<(
          basic_ostream<CharT, Traits>& os,
          const piecewise_constant_distribution& x);
        template<class CharT, class Traits>
        friend basic_istream<CharT, Traits>& operator>>(basic_istream<CharT, Traits>& is,
                                                        piecewise_constant_distribution& x);
      };
    }

#### [[edit](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/synopsis/random&action=edit&section=T-31 "Template:cpp/synopsis/random")] Class template [std::piecewise_linear_distribution](../numeric/random/piecewise_linear_distribution.html "cpp/numeric/random/piecewise linear distribution")
    
    
    namespace std {
      template<class RealType = double>
      class piecewise_linear_distribution
      {
      public:
        // types
        using result_type = RealType;
        using param_type  = /* unspecified */;
     
        // constructor and reset functions
        piecewise_linear_distribution();
        template<class InputIterB, class InputIterW>
        piecewise_linear_distribution(InputIterB firstB, InputIterB lastB, InputIterW firstW);
        template<class UnaryOperation>
        piecewise_linear_distribution(initializer_list<RealType> bl, UnaryOperation fw);
        template<class UnaryOperation>
        piecewise_linear_distribution(size_t nw,
                                      RealType xmin,
                                      RealType xmax,
                                      UnaryOperation fw);
        explicit piecewise_linear_distribution(const param_type& parm);
        void reset();
     
        // equality operators
        friend bool operator==(const piecewise_linear_distribution& x,
                               const piecewise_linear_distribution& y);
     
        // generating functions
        template<class URBG>
        result_type operator()(URBG& g);
        template<class URBG>
        result_type operator()(URBG& g, const param_type& parm);
     
        // property functions
        vector<result_type> intervals() const;
        vector<result_type> densities() const;
        param_type param() const;
        void param(const param_type& parm);
        result_type min() const;
        result_type max() const;
     
        // inserters and extractors
        template<class CharT, class Traits>
        friend basic_ostream<CharT, Traits>& operator<<(
          basic_ostream<CharT, Traits>& os,
          const piecewise_linear_distribution& x);
        template<class CharT, class Traits>
        friend basic_istream<CharT, Traits>& operator>>(basic_istream<CharT, Traits>& is,
                                                        piecewise_linear_distribution& x);
      };
    }
