[C++](../../cpp.html "cpp")

[Compiler support](../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../freestanding.html "cpp/freestanding")  
[Language](../language.html "cpp/language")  
[Standard library](../standard_library.html "cpp/standard library")  
[Standard library headers](../headers.html "cpp/header")  
[Named requirements](../iterator/concepts.html "cpp/named req")  
[Feature test macros](../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../utility.html#Language_support "cpp/utility")  
[Concepts library](../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../error.html "cpp/error")  
[Memory management library](../memory.html "cpp/memory")  
[Metaprogramming library](../meta.html "cpp/meta") (C++11)  
[General utilities library](../utility.html "cpp/utility")  
[Containers library](../container.html "cpp/container")  
[Iterators library](../iterator.html "cpp/iterator")  
[Ranges library](../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../algorithm.html "cpp/algorithm")  
[Strings library](../string.html "cpp/string")  
[Text processing library](../text.html "cpp/text")  
[Numerics library](../numeric.html "cpp/numeric")  
[Date and time library](../chrono.html "cpp/chrono")  
[Input/output library](../io.html "cpp/io")  
[Filesystem library](../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../atomic.html "cpp/thread") (C++11)  
[Execution control library](../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../experimental.html "cpp/experimental")  
[Symbols index](../symbol_index.html "cpp/symbol index")  
[External libraries](../links/libs.html "cpp/links/libs")  
  


[Standard library headers](../headers.html "cpp/header")

| [Language support](../headers.html#Language_support_library "cpp/header")  
---  
[`<cfloat>`](cfloat.html "cpp/header/cfloat")  
[`<climits>`](climits.html "cpp/header/climits")  
[`<compare>`](compare.html "cpp/header/compare") (C++20)  
[`<contracts>`](contracts.html "cpp/header/contracts") (C++26)  
[`<coroutine>`](coroutine.html "cpp/header/coroutine") (C++20)  
[`<csetjmp>`](csetjmp.html "cpp/header/csetjmp")  
[`<csignal>`](csignal.html "cpp/header/csignal")  
[`<cstdarg>`](cstdarg.html "cpp/header/cstdarg")  
[`<cstddef>`](cstddef.html "cpp/header/cstddef")  
[`<cstdint>`](cstdint.html "cpp/header/cstdint") (C++11)  
[`<cstdlib>`](cstdlib.html "cpp/header/cstdlib")  
[`<exception>`](exception.html "cpp/header/exception")  
[`<initializer_list>`](initializer_list.html "cpp/header/initializer list") (C++11)` `  
[`<limits>`](limits.html "cpp/header/limits")  
[`<new>`](new.html "cpp/header/new")  
[`<source_location>`](source_location.html "cpp/header/source location") (C++20)  
[`<stdfloat>`](stdfloat.html "cpp/header/stdfloat") (C++23)  
[`<typeinfo>`](typeinfo.html "cpp/header/typeinfo")  
[`<version>`](version.html "cpp/header/version") (C++20)  
[Concepts](../headers.html#Concepts_library "cpp/header")  
[`<concepts>`](concepts.html "cpp/header/concepts") (C++20)  
[Diagnostics](../headers.html#Diagnostics_library "cpp/header")  
[`<cassert>`](cassert.html "cpp/header/cassert")  
[`<cerrno>`](cerrno.html "cpp/header/cerrno")  
[`<debugging>`](debugging.html "cpp/header/debugging") (C++26)  
[`<stacktrace>`](stacktrace.html "cpp/header/stacktrace") (C++23)  
[`<stdexcept>`](stdexcept.html "cpp/header/stdexcept")  
[`<system_error>`](system_error.html "cpp/header/system error") (C++11)  
[Memory management](../headers.html#Memory_management_library "cpp/header")  
**`< memory>`**  
[`<memory_resource>`](memory_resource.html "cpp/header/memory resource") (C++17)  
[`<scoped_allocator>`](scoped_allocator.html "cpp/header/scoped allocator") (C++11)  
[Metaprogramming](../headers.html#Metaprogramming_library "cpp/header")  
[`<type_traits>`](type_traits.html "cpp/header/type traits") (C++11)  
[`<ratio>`](ratio.html "cpp/header/ratio") (C++11)  
  
  
  
| [General utilities](../headers.html#General_utilities_library "cpp/header")  
---  
[`<any>`](any.html "cpp/header/any") (C++17)  
[`<bitset>`](bitset.html "cpp/header/bitset")  
[`<bit>`](bit.html "cpp/header/bit") (C++20)  
[`<charconv>`](charconv.html "cpp/header/charconv") (C++17)  
[`<expected>`](expected.html "cpp/header/expected") (C++23)  
[`<format>`](format.html "cpp/header/format") (C++20)  
[`<functional>`](functional.html "cpp/header/functional")  
[`<optional>`](optional.html "cpp/header/optional") (C++17)  
[`<stdbit.h>`](stdbit.h.html "cpp/header/stdbit.h") (C++26)  
[`<tuple>`](tuple.html "cpp/header/tuple") (C++11)  
[`<typeindex>`](typeindex.html "cpp/header/typeindex") (C++11)  
[`<utility>`](utility.html "cpp/header/utility")  
[`<variant>`](variant.html "cpp/header/variant") (C++17)  
[Containers](../headers.html#Containers_library "cpp/header")  
[`<array>`](array.html "cpp/header/array") (C++11)  
[`<deque>`](deque.html "cpp/header/deque")  
[`<flat_map>`](flat_map.html "cpp/header/flat map") (C++23)  
[`<flat_set>`](flat_set.html "cpp/header/flat set") (C++23)  
[`<forward_list>`](forward_list.html "cpp/header/forward list") (C++11)  
[`<hive>`](hive.html "cpp/header/hive") (C++26)  
[`<inplace_vector>`](inplace_vector.html "cpp/header/inplace vector") (C++26)` `  
[`<list>`](list.html "cpp/header/list")  
[`<map>`](map.html "cpp/header/map")  
[`<mdspan>`](mdspan.html "cpp/header/mdspan") (C++23)  
[`<queue>`](queue.html "cpp/header/queue")  
[`<set>`](set.html "cpp/header/set")  
[`<span>`](span.html "cpp/header/span") (C++20)  
[`<stack>`](stack.html "cpp/header/stack")  
[`<unordered_map>`](unordered_map.html "cpp/header/unordered map") (C++11)  
[`<unordered_set>`](unordered_set.html "cpp/header/unordered set") (C++11)  
[`<vector>`](vector.html "cpp/header/vector")  
[Iterators](../headers.html#Iterators_library "cpp/header")  
[`<iterator>`](iterator.html "cpp/header/iterator")  
[Ranges](../headers.html#Ranges_library "cpp/header")  
[`<generator>`](generator.html "cpp/header/generator") (C++23)  
[`<ranges>`](ranges.html "cpp/header/ranges") (C++20)  
  
| [Algorithms](../headers.html#Algorithms_library "cpp/header")  
---  
[`<algorithm>`](algorithm.html "cpp/header/algorithm")  
[`<numeric>`](numeric.html "cpp/header/numeric")  
[Strings](../headers.html#Strings_library "cpp/header")  
[`<cctype>`](cctype.html "cpp/header/cctype")  
[`<cstring>`](cstring.html "cpp/header/cstring")  
[`<cuchar>`](cuchar.html "cpp/header/cuchar") (C++11)  
[`<cwchar>`](cwchar.html "cpp/header/cwchar")  
[`<cwctype>`](cwctype.html "cpp/header/cwctype")  
[`<string_view>`](string_view.html "cpp/header/string view") (C++17)  
[`<string>`](string.html "cpp/header/string")  
[Text processing](../headers.html#Text_processing_library "cpp/header")  
[`<clocale>`](clocale.html "cpp/header/clocale")  
[`<codecvt>`](codecvt.html "cpp/header/codecvt") (C++11/17/26*)  
[`<locale>`](locale.html "cpp/header/locale")  
[`<regex>`](regex.html "cpp/header/regex") (C++11)  
[`<text_encoding>`](text_encoding.html "cpp/header/text encoding") (C++26)` `  
[Numerics](../headers.html#Numerics_library "cpp/header")  
[`<cfenv>`](cfenv.html "cpp/header/cfenv") (C++11)  
[`<cmath>`](cmath.html "cpp/header/cmath")  
[`<complex>`](complex.html "cpp/header/complex")  
[`<linalg>`](linalg.html "cpp/header/linalg") (C++26)  
[`<numbers>`](numbers.html "cpp/header/numbers") (C++20)  
[`<random>`](random.html "cpp/header/random") (C++11)  
[`<simd>`](simd.html "cpp/header/simd") (C++26)  
[`<stdckdint.h>`](stdckdint.h.html "cpp/header/stdckdint.h") (C++26)  
[`<valarray>`](valarray.html "cpp/header/valarray")  
[Time](../headers.html#Time_library "cpp/header")  
[`<chrono>`](chrono.html "cpp/header/chrono") (C++11)  
[`<ctime>`](ctime.html "cpp/header/ctime")  
[C compatibility](../headers.html#C_compatibility_headers "cpp/header")  
[`<ccomplex>`](ccomplex.html "cpp/header/ccomplex") (C++11/17/20*)  
[`<ciso646>`](ciso646.html "cpp/header/ciso646") (until C++20)  
[`<cstdalign>`](cstdalign.html "cpp/header/cstdalign") (C++11/17/20*)  
[`<cstdbool>`](cstdbool.html "cpp/header/cstdbool") (C++11/17/20*)  
[`<ctgmath>`](ctgmath.html "cpp/header/ctgmath") (C++11/17/20*)  
  
| [Input/output](../headers.html#Input.2Foutput_library "cpp/header")  
---  
[`<cinttypes>`](cinttypes.html "cpp/header/cinttypes") (C++11)  
[`<cstdio>`](cstdio.html "cpp/header/cstdio")  
[`<filesystem>`](filesystem.html "cpp/header/filesystem") (C++17)  
[`<fstream>`](fstream.html "cpp/header/fstream")  
[`<iomanip>`](iomanip.html "cpp/header/iomanip")  
[`<iosfwd>`](iosfwd.html "cpp/header/iosfwd")  
[`<iostream>`](iostream.html "cpp/header/iostream")  
[`<ios>`](ios.html "cpp/header/ios")  
[`<istream>`](istream.html "cpp/header/istream")  
[`<ostream>`](ostream.html "cpp/header/ostream")  
[`<print>`](print.html "cpp/header/print") (C++23)  
[`<spanstream>`](spanstream.html "cpp/header/spanstream") (C++23)  
[`<sstream>`](sstream.html "cpp/header/sstream")  
[`<streambuf>`](streambuf.html "cpp/header/streambuf")  
[`<strstream>`](strstream.html "cpp/header/strstream") (C++98/26*)  
[`<syncstream>`](syncstream.html "cpp/header/syncstream") (C++20)  
[Concurrency support](../headers.html#Concurrency_support_library "cpp/header")  
[`<atomic>`](atomic.html "cpp/header/atomic") (C++11)  
[`<barrier>`](barrier.html "cpp/header/barrier") (C++20)  
[`<condition_variable>`](condition_variable.html "cpp/header/condition variable") (C++11)  
[`<future>`](future.html "cpp/header/future") (C++11)  
[`<hazard_pointer>`](hazard_pointer.html "cpp/header/hazard pointer") (C++26)  
[`<latch>`](latch.html "cpp/header/latch") (C++20)  
[`<mutex>`](mutex.html "cpp/header/mutex") (C++11)  
[`<rcu>`](rcu.html "cpp/header/rcu") (C++26)  
[`<semaphore>`](semaphore.html "cpp/header/semaphore") (C++20)  
[`<shared_mutex>`](shared_mutex.html "cpp/header/shared mutex") (C++14)  
[`<stdatomic.h>`](stdatomic.h.html "cpp/header/stdatomic.h") (C++23)  
[`<stop_token>`](stop_token.html "cpp/header/stop token") (C++20)  
[`<thread>`](thread.html "cpp/header/thread") (C++11)  
[Execution support](../headers.html#Multi-purpose_headers "cpp/header")  
[`<execution>`](execution.html "cpp/header/execution") (C++17)  
  
  
  
  
  
  
  
  
  


This header is part of the [dynamic memory management](../memory.html "cpp/memory") library. 

| 

## Contents

  * [1 Includes](memory.html#Includes)
  * [2 Classes](memory.html#Classes)
    * [2.1 Pointer traits](memory.html#Pointer_traits)
    * [2.2 Garbage collector support](memory.html#Garbage_collector_support)
    * [2.3 Allocators](memory.html#Allocators)
    * [2.4 Uninitialized storage](memory.html#Uninitialized_storage)
    * [2.5 Smart pointers](memory.html#Smart_pointers)
    * [2.6 Smart pointer adaptors](memory.html#Smart_pointer_adaptors)
    * [2.7 Types for composite class design](memory.html#Types_for_composite_class_design)
    * [2.8 Helper classes](memory.html#Helper_classes)
    * [2.9 Forward declarations](memory.html#Forward_declarations)
  * [3 Tags](memory.html#Tags)
  * [4 Functions](memory.html#Functions)
    * [4.1 Uses-allocator construction](memory.html#Uses-allocator_construction)
    * [4.2 Miscellaneous](memory.html#Miscellaneous)
    * [4.3 Explicit lifetime management](memory.html#Explicit_lifetime_management)
    * [4.4 Garbage collector support](memory.html#Garbage_collector_support_2)
    * [4.5 Uninitialized storage](memory.html#Uninitialized_storage_2)
    * [4.6 Smart pointer non-member operations](memory.html#Smart_pointer_non-member_operations)
    * [4.7 Smart pointer adaptor creation](memory.html#Smart_pointer_adaptor_creation)
  * [5 Function-like entities](memory.html#Function-like_entities)
    * [5.1 Uninitialized storage](memory.html#Uninitialized_storage_3)
  * [6 Synopsis](memory.html#Synopsis)
    * [6.1 Helper concepts](memory.html#Helper_concepts)
    * [6.2 Class template std::pointer_traits](memory.html#Class_template_std::pointer_traits)
    * [6.3 Class std::allocator_arg_t](memory.html#Class_std::allocator_arg_t)
    * [6.4 Class template std::allocator_traits](memory.html#Class_template_std::allocator_traits)
    * [6.5 Class template std::allocator](memory.html#Class_template_std::allocator)
    * [6.6 Class template std::default_delete](memory.html#Class_template_std::default_delete)
    * [6.7 Class template std::unique_ptr](memory.html#Class_template_std::unique_ptr)
    * [6.8 Class std::bad_weak_ptr](memory.html#Class_std::bad_weak_ptr)
    * [6.9 Class template std::shared_ptr](memory.html#Class_template_std::shared_ptr)
    * [6.10 Class template std::weak_ptr](memory.html#Class_template_std::weak_ptr)
    * [6.11 Class template std::owner_less](memory.html#Class_template_std::owner_less)
    * [6.12 Class std::owner_hash](memory.html#Class_std::owner_hash)
    * [6.13 Class std::owner_equal](memory.html#Class_std::owner_equal)
    * [6.14 Class template std::enable_shared_from_this](memory.html#Class_template_std::enable_shared_from_this)
    * [6.15 Class template std::atomic's specialization for std::shared_ptr](memory.html#Class_template_std::atomic.27s_specialization_for_std::shared_ptr)
    * [6.16 Class template std::atomic's specialization for std::weak_ptr](memory.html#Class_template_std::atomic.27s_specialization_for_std::weak_ptr)
    * [6.17 Class template std::out_ptr_t](memory.html#Class_template_std::out_ptr_t)
    * [6.18 Class template std::inout_ptr_t](memory.html#Class_template_std::inout_ptr_t)
    * [6.19 Class template std::indirect](memory.html#Class_template_std::indirect)
    * [6.20 Class template std::polymorphic](memory.html#Class_template_std::polymorphic)

  
---  
  
###  Includes  
  
[ <compare>](compare.html "cpp/header/compare")(C++20) |  [Three-way comparison operator](../language/operator_comparison.html#Three-way_comparison "cpp/language/operator comparison") support  
  
###  Classes  
  
#####  Pointer traits   
  
[ pointer_traits](../memory/pointer_traits.html "cpp/memory/pointer traits")(C++11) |  provides information about pointer-like types   
(class template)   
  
#####  Garbage collector support   
  
[ pointer_safety](../memory/gc/pointer_safety.html "cpp/memory/gc/pointer safety")(C++11)(removed in C++23) |  lists pointer safety models   
(enum)   
  
#####  Allocators   
  
[ allocator](../memory/allocator.html "cpp/memory/allocator") |  the default allocator   
(class template)   
[ allocator_traits](../memory/allocator_traits.html "cpp/memory/allocator traits")(C++11) |  provides information about allocator types   
(class template)   
[ allocation_result](../memory/allocation_result.html "cpp/memory/allocation result")(C++23) |  records the address and the actual size of storage allocated by `allocate_at_least`   
(class template)   
[ uses_allocator](../memory/uses_allocator.html "cpp/memory/uses allocator")(C++11) |  checks if the specified type supports uses-allocator construction   
(class template)   
  
#####  Uninitialized storage   
  
[ raw_storage_iterator](../memory/raw_storage_iterator.html "cpp/memory/raw storage iterator")(deprecated in C++17)(removed in C++20) |  an iterator that allows standard algorithms to store results in uninitialized memory   
(class template)   
  
#####  Smart pointers   
  
[ unique_ptr](../memory/unique_ptr.html "cpp/memory/unique ptr")(C++11) |  smart pointer with unique object ownership semantics   
(class template)   
[ shared_ptr](../memory/shared_ptr.html "cpp/memory/shared ptr")(C++11) |  smart pointer with shared object ownership semantics   
(class template)   
[ weak_ptr](../memory/weak_ptr.html "cpp/memory/weak ptr")(C++11) |  weak reference to an object managed by [std::shared_ptr](../memory/shared_ptr.html "cpp/memory/shared ptr")   
(class template)   
[ auto_ptr](../memory/auto_ptr.html "cpp/memory/auto ptr")(deprecated in C++11)(removed in C++17) |  smart pointer with strict object ownership semantics   
(class template)   
  
#####  Smart pointer adaptors   
  
[ out_ptr_t](../memory/out_ptr_t.html "cpp/memory/out ptr t")(C++23) |  interoperates with foreign pointer setters and resets a smart pointer on destruction   
(class template)   
[ inout_ptr_t](../memory/inout_ptr_t.html "cpp/memory/inout ptr t")(C++23) |  interoperates with foreign pointer setters, obtains the initial pointer value from a smart pointer, and resets it on destruction   
(class template)   
  
#####  Types for composite class design   
  
[ indirect](../memory/indirect.html "cpp/memory/indirect")(C++26) |  a wrapper containing dynamically-allocated object with value-like semantics   
(class template)   
[ polymorphic](../memory/polymorphic.html "cpp/memory/polymorphic")(C++26) |  a polymorphic wrapper containing dynamically-allocated object with value-like semantics   
(class template)   
  
#####  Helper classes   
  
[ std::atomic<std::shared_ptr>](../memory/shared_ptr/atomic2.html "cpp/memory/shared ptr/atomic2")(C++20) |  atomic shared pointer   
(class template specialization)   
[ std::atomic<std::weak_ptr>](../memory/weak_ptr/atomic2.html "cpp/memory/weak ptr/atomic2")(C++20) |  atomic weak pointer   
(class template specialization)   
[ owner_less](../memory/owner_less.html "cpp/memory/owner less")(C++11) |  provides mixed-type owner-based ordering of shared and weak pointers   
(class template)   
[ owner_hash](../memory/owner_hash.html "cpp/memory/owner hash")(C++26) |  provides owner-based hashing for shared and weak pointers   
(class)   
[ owner_equal](../memory/owner_equal.html "cpp/memory/owner equal")(C++26) |  provides mixed-type owner-based equal comparisons of shared and weak pointers   
(class)   
[ enable_shared_from_this](../memory/enable_shared_from_this.html "cpp/memory/enable shared from this")(C++11) |  allows an object to create a `shared_ptr` referring to itself   
(class template)   
[ bad_weak_ptr](../memory/bad_weak_ptr.html "cpp/memory/bad weak ptr")(C++11) |  exception thrown when accessing a `weak_ptr` which refers to already destroyed object   
(class)   
[ default_delete](../memory/default_delete.html "cpp/memory/default delete")(C++11) |  default deleter for [unique_ptr](../memory/unique_ptr.html "cpp/memory/unique ptr")   
(class template)   
[ std::hash<std::unique_ptr>](../memory/unique_ptr/hash.html "cpp/memory/unique ptr/hash")(C++11) |  hash support for [`std::unique_ptr`](../memory/unique_ptr.html "cpp/memory/unique ptr")   
(class template specialization)   
[ std::hash<std::shared_ptr>](../memory/shared_ptr/hash.html "cpp/memory/shared ptr/hash")(C++11) |  hash support for [`std::shared_ptr`](../memory/shared_ptr.html "cpp/memory/shared ptr")   
(class template specialization)   
[ std::hash<std::indirect>](../memory/indirect/hash.html "cpp/memory/indirect/hash")(C++26) |  hash support for [`std::indirect`](../memory/indirect.html "cpp/memory/indirect")   
(class template specialization)   
  
#####  Forward declarations   
  
Defined in header `[<functional>](functional.html "cpp/header/functional")`  
[ hash](../utility/hash.html "cpp/utility/hash")(C++11) |  hash function object   
(class template)   
Defined in header `[<atomic>](atomic.html "cpp/header/atomic")`  
[ atomic](../atomic/atomic.html "cpp/atomic/atomic")(C++11) |  atomic class template and specializations for bool, integral, floating-point,(since C++20) and pointer types   
(class template)   
  
###  Tags  
  
[ allocator_argallocator_arg_t](../memory/allocator_arg.html "cpp/memory/allocator arg")(C++11) |  a tag used to select allocator-aware constructors  
(tag)  
  
###  Functions  
  
#####  Uses-allocator construction   
  
[ uses_allocator_construction_args](../memory/uses_allocator_construction_args.html "cpp/memory/uses allocator construction args")(C++20) |  prepares the argument list matching the flavor of uses-allocator construction required by the given type   
(function template)   
[ make_obj_using_allocator](../memory/make_obj_using_allocator.html "cpp/memory/make obj using allocator")(C++20) |  creates an object of the given type by means of uses-allocator construction   
(function template)   
[ uninitialized_construct_using_allocator](../memory/uninitialized_construct_using_allocator.html "cpp/memory/uninitialized construct using allocator")(C++20) |  creates an object of the given type at specified memory location by means of uses-allocator construction   
(function template)   
  
#####  Miscellaneous   
  
[ to_address](../memory/to_address.html "cpp/memory/to address")(C++20) |  obtains a raw pointer from a pointer-like type   
(function template)   
[ addressof](../memory/addressof.html "cpp/memory/addressof")(C++11) |  obtains actual address of an object, even if the `**&**` operator is overloaded   
(function template)   
[ align](../memory/align.html "cpp/memory/align")(C++11) |  aligns a pointer in a buffer   
(function)   
[ assume_aligned](../memory/assume_aligned.html "cpp/memory/assume aligned")(C++20) |  informs the compiler that a pointer is aligned   
(function template)   
[ is_sufficiently_aligned](../memory/is_sufficiently_aligned.html "cpp/memory/is sufficiently aligned")(C++26) |  checks whether the pointer points to an object whose alignment has at least the given value   
(function template)   
  
#####  Explicit lifetime management   
  
[ start_lifetime_asstart_lifetime_as_array](../memory/start_lifetime_as.html "cpp/memory/start lifetime as")(C++23) |  implicitly creates objects in given storage with the object representation reused   
(function template)   
  
#####  Garbage collector support   
  
[ declare_reachable](../memory/gc/declare_reachable.html "cpp/memory/gc/declare reachable")(C++11)(removed in C++23) |  declares that an object can not be recycled   
(function)   
[ undeclare_reachable](../memory/gc/undeclare_reachable.html "cpp/memory/gc/undeclare reachable")(C++11)(removed in C++23) |  declares that an object can be recycled   
(function template)   
[ declare_no_pointers](../memory/gc/declare_no_pointers.html "cpp/memory/gc/declare no pointers")(C++11)(removed in C++23) |  declares that a memory area does not contain traceable pointers   
(function)   
[ undeclare_no_pointers](../memory/gc/undeclare_no_pointers.html "cpp/memory/gc/undeclare no pointers")(C++11)(removed in C++23) |  cancels the effect of [std::declare_no_pointers](../memory/gc/declare_no_pointers.html "cpp/memory/gc/declare no pointers")   
(function)   
[ get_pointer_safety](../memory/gc/get_pointer_safety.html "cpp/memory/gc/get pointer safety")(C++11)(removed in C++23) |  returns the current pointer safety model   
(function)   
  
#####  Uninitialized storage   
  
[ uninitialized_copy](../memory/uninitialized_copy.html "cpp/memory/uninitialized copy") |  copies a range of objects to an uninitialized area of memory   
(function template)   
[ uninitialized_copy_n](../memory/uninitialized_copy_n.html "cpp/memory/uninitialized copy n")(C++11) |  copies a number of objects to an uninitialized area of memory   
(function template)   
[ uninitialized_fill](../memory/uninitialized_fill.html "cpp/memory/uninitialized fill") |  copies an object to an uninitialized area of memory, defined by a range   
(function template)   
[ uninitialized_fill_n](../memory/uninitialized_fill_n.html "cpp/memory/uninitialized fill n") |  copies an object to an uninitialized area of memory, defined by a start and a count   
(function template)   
[ uninitialized_move](../memory/uninitialized_move.html "cpp/memory/uninitialized move")(C++17) |  moves a range of objects to an uninitialized area of memory   
(function template)   
[ uninitialized_move_n](../memory/uninitialized_move_n.html "cpp/memory/uninitialized move n")(C++17) |  moves a number of objects to an uninitialized area of memory   
(function template)   
[ uninitialized_default_construct](../memory/uninitialized_default_construct.html "cpp/memory/uninitialized default construct")(C++17) |  constructs objects by [default-initialization](../language/default_initialization.html "cpp/language/default initialization") in an uninitialized area of memory, defined by a range   
(function template)   
[ uninitialized_default_construct_n](../memory/uninitialized_default_construct_n.html "cpp/memory/uninitialized default construct n")(C++17) |  constructs objects by [default-initialization](../language/default_initialization.html "cpp/language/default initialization") in an uninitialized area of memory, defined by a start and a count   
(function template)   
[ uninitialized_value_construct](../memory/uninitialized_value_construct.html "cpp/memory/uninitialized value construct")(C++17) |  constructs objects by [value-initialization](../language/value_initialization.html "cpp/language/value initialization") in an uninitialized area of memory, defined by a range   
(function template)   
[ uninitialized_value_construct_n](../memory/uninitialized_value_construct_n.html "cpp/memory/uninitialized value construct n")(C++17) |  constructs objects by [value-initialization](../language/value_initialization.html "cpp/language/value initialization") in an uninitialized area of memory, defined by a start and a count   
(function template)   
[ construct_at](../memory/construct_at.html "cpp/memory/construct at")(C++20) |  creates an object at a given address   
(function template)   
[ destroy_at](../memory/destroy_at.html "cpp/memory/destroy at")(C++17) |  destroys an object at a given address   
(function template)   
[ destroy](../memory/destroy.html "cpp/memory/destroy")(C++17) |  destroys a range of objects   
(function template)   
[ destroy_n](../memory/destroy_n.html "cpp/memory/destroy n")(C++17) |  destroys a number of objects in a range   
(function template)   
[ get_temporary_buffer](../memory/get_temporary_buffer.html "cpp/memory/get temporary buffer")(deprecated in C++17)(removed in C++20) |  obtains uninitialized storage   
(function template)   
[ return_temporary_buffer](../memory/return_temporary_buffer.html "cpp/memory/return temporary buffer")(deprecated in C++17)(removed in C++20) |  frees uninitialized storage   
(function template)   
  
#####  Smart pointer non-member operations   
  
[ make_uniquemake_unique_for_overwrite](../memory/unique_ptr/make_unique.html "cpp/memory/unique ptr/make unique")(C++14)(C++20) |  creates a unique pointer that manages a new object   
(function template)   
[ operator==operator!=operator<operator<=operator>operator>=operator<=>](../memory/unique_ptr/operator_cmp.html "cpp/memory/unique ptr/operator cmp")(removed in C++20)(C++20) |  compares to another `unique_ptr` or with nullptr   
(function template)   
[ make_sharedmake_shared_for_overwrite](../memory/shared_ptr/make_shared.html "cpp/memory/shared ptr/make shared")(C++20) |  creates a shared pointer that manages a new object   
(function template)   
[ allocate_sharedallocate_shared_for_overwrite](../memory/shared_ptr/allocate_shared.html "cpp/memory/shared ptr/allocate shared")(C++20) |  creates a shared pointer that manages a new object allocated using an allocator   
(function template)   
[ static_pointer_castdynamic_pointer_castconst_pointer_castreinterpret_pointer_cast](../memory/shared_ptr/pointer_cast.html "cpp/memory/shared ptr/pointer cast")(C++17) |  applies [`static_cast`](../language/static_cast.html "cpp/language/static cast"), [`dynamic_cast`](../language/dynamic_cast.html "cpp/language/dynamic cast"), [`const_cast`](../language/const_cast.html "cpp/language/const cast"), or [`reinterpret_cast`](../language/reinterpret_cast.html "cpp/language/reinterpret cast") to the stored pointer   
(function template)   
[ get_deleter](../memory/shared_ptr/get_deleter.html "cpp/memory/shared ptr/get deleter") |  returns the deleter of specified type, if owned   
(function template)   
[ operator==operator!=operator<operator<=operator>operator>=operator<=>](../memory/shared_ptr/operator_cmp.html "cpp/memory/shared ptr/operator cmp")(removed in C++20)(removed in C++20)(removed in C++20)(removed in C++20)(removed in C++20)(C++20) |  compares with another `shared_ptr` or with nullptr   
(function template)   
[ operator<<(std::shared_ptr)](../memory/shared_ptr/operator_ltlt.html "cpp/memory/shared ptr/operator ltlt") |  outputs the value of the stored pointer to an output stream   
(function template)   
[ operator<<(std::unique_ptr)](../memory/unique_ptr/operator_ltlt.html "cpp/memory/unique ptr/operator ltlt")(C++20) |  outputs the value of the managed pointer to an output stream   
(function template)   
[ std::swap(std::unique_ptr)](../memory/unique_ptr/swap2.html "cpp/memory/unique ptr/swap2")(C++11) |  specializes the [std::swap](../utility/swap.html "cpp/algorithm/swap") algorithm   
(function template)   
[ std::swap(std::shared_ptr)](../memory/shared_ptr/swap2.html "cpp/memory/shared ptr/swap2")(C++11) |  specializes the [std::swap](../utility/swap.html "cpp/algorithm/swap") algorithm   
(function template)   
[ std::swap(std::weak_ptr)](../memory/weak_ptr/swap2.html "cpp/memory/weak ptr/swap2")(C++11) |  specializes the [std::swap](../utility/swap.html "cpp/algorithm/swap") algorithm   
(function template)   
  
#####  Smart pointer adaptor creation   
  
[ out_ptr](../memory/out_ptr_t/out_ptr.html "cpp/memory/out ptr t/out ptr")(C++23) |  creates an `out_ptr_t` with an associated smart pointer and resetting arguments   
(function template)   
[ inout_ptr](../memory/inout_ptr_t/inout_ptr.html "cpp/memory/inout ptr t/inout ptr")(C++23) |  creates an `inout_ptr_t` with an associated smart pointer and resetting arguments   
(function template)   
[ std::atomic_is_lock_free(std::shared_ptr)std::atomic_load(std::shared_ptr)std::atomic_load_explicit(std::shared_ptr)std::atomic_store(std::shared_ptr)std::atomic_store_explicit(std::shared_ptr)std::atomic_exchange(std::shared_ptr)std::atomic_exchange_explicit(std::shared_ptr)std::atomic_compare_exchange_weak(std::shared_ptr)std::atomic_compare_exchange_strong(std::shared_ptr)std::atomic_compare_exchange_weak_explicit(std::shared_ptr)std::atomic_compare_exchange_strong_explicit(std::shared_ptr)](../memory/shared_ptr/atomic.html "cpp/memory/shared ptr/atomic")(deprecated in C++20)(removed in C++26) |  specializes atomic operations for `std::shared_ptr`   
(function template)   
---|---  
  
###  Function-like entities  
  
---  
Defined in namespace `std::ranges`  
  
#####  Uninitialized storage   
  
[ ranges::uninitialized_copy](../memory/ranges/uninitialized_copy.html "cpp/memory/ranges/uninitialized copy")(C++20) |  copies a range of objects to an uninitialized area of memory  
(algorithm function object)  
[ ranges::uninitialized_copy_n](../memory/ranges/uninitialized_copy_n.html "cpp/memory/ranges/uninitialized copy n")(C++20) |  copies a number of objects to an uninitialized area of memory  
(algorithm function object)  
[ ranges::uninitialized_fill](../memory/ranges/uninitialized_fill.html "cpp/memory/ranges/uninitialized fill")(C++20) |  copies an object to an uninitialized area of memory, defined by a range  
(algorithm function object)  
[ ranges::uninitialized_fill_n](../memory/ranges/uninitialized_fill_n.html "cpp/memory/ranges/uninitialized fill n")(C++20) |  copies an object to an uninitialized area of memory, defined by a start and a count  
(algorithm function object)  
[ ranges::uninitialized_move](../memory/ranges/uninitialized_move.html "cpp/memory/ranges/uninitialized move")(C++20) |  moves a range of objects to an uninitialized area of memory  
(algorithm function object)  
[ ranges::uninitialized_move_n](../memory/ranges/uninitialized_move_n.html "cpp/memory/ranges/uninitialized move n")(C++20) |  moves a number of objects to an uninitialized area of memory  
(algorithm function object)  
[ ranges::uninitialized_default_construct](../memory/ranges/uninitialized_default_construct.html "cpp/memory/ranges/uninitialized default construct")(C++20) |  constructs objects by [default-initialization](../language/default_initialization.html "cpp/language/default initialization") in an uninitialized area of memory, defined by a range  
(algorithm function object)  
[ ranges::uninitialized_default_construct_n](../memory/ranges/uninitialized_default_construct_n.html "cpp/memory/ranges/uninitialized default construct n")(C++20) |  constructs objects by [default-initialization](../language/default_initialization.html "cpp/language/default initialization") in an uninitialized area of memory, defined by a start and count  
(algorithm function object)  
[ ranges::uninitialized_value_construct](../memory/ranges/uninitialized_value_construct.html "cpp/memory/ranges/uninitialized value construct")(C++20) |  constructs objects by [value-initialization](../language/value_initialization.html "cpp/language/value initialization") in an uninitialized area of memory, defined by a range  
(algorithm function object)  
[ ranges::uninitialized_value_construct_n](../memory/ranges/uninitialized_value_construct_n.html "cpp/memory/ranges/uninitialized value construct n")(C++20) |  constructs objects by [value-initialization](../language/value_initialization.html "cpp/language/value initialization") in an uninitialized area of memory, defined by a start and a count  
(algorithm function object)  
[ ranges::construct_at](../memory/ranges/construct_at.html "cpp/memory/ranges/construct at")(C++20) |  creates an object at a given address  
(algorithm function object)  
[ ranges::destroy_at](../memory/ranges/destroy_at.html "cpp/memory/ranges/destroy at")(C++20) |  destroys an object at a given address  
(algorithm function object)  
[ ranges::destroy](../memory/ranges/destroy.html "cpp/memory/ranges/destroy")(C++20) |  destroys a range of objects  
(algorithm function object)  
[ ranges::destroy_n](../memory/ranges/destroy_n.html "cpp/memory/ranges/destroy n")(C++20) |  destroys a number of objects in a range  
(algorithm function object)  
  
### Synopsis
    
    
    #include <compare>
     
    namespace std {
      // pointer Traits
      template<class Ptr>
      struct pointer_traits; // freestanding
      template<class T>
      struct pointer_traits<T*>; // freestanding
     
      // pointer conversion
      template<class T>
      constexpr T* to_address(T* p) noexcept; // freestanding
      template<class Ptr>
      constexpr auto to_address(const Ptr& p) noexcept; // freestanding
     
      // pointer alignment
      void* align(size_t alignment, size_t size, void*& ptr, size_t& space); // freestanding
      template<size_t N, class T>
      constexpr T* assume_aligned(T* ptr); // freestanding
      template<size_t Alignment, class T>
      bool is_sufficiently_aligned(T* ptr);
     
      // explicit lifetime management
      template<class T>
      T* start_lifetime_as(void* p) noexcept; // freestanding
      template<class T>
      const T* start_lifetime_as(const void* p) noexcept; // freestanding
      template<class T>
      volatile T* start_lifetime_as(volatile void* p) noexcept; // freestanding
      template<class T>
      const volatile T* start_lifetime_as(const volatile void* p) noexcept; // freestanding
      template<class T>
      T* start_lifetime_as_array(void* p, size_t n) noexcept; // freestanding
      template<class T>
      const T* start_lifetime_as_array(const void* p, size_t n) noexcept; // freestanding
      template<class T>
      volatile T* start_lifetime_as_array(volatile void* p,
                                          size_t n) noexcept; // freestanding
      template<class T>
      const volatile T* start_lifetime_as_array(const volatile void* p, // freestanding
                                                size_t n) noexcept;
      template<class T>
      T* trivially_relocate(T* first, T* last, T* result); // freestanding
      template<class T>
      constexpr T* relocate(T* first, T* last, T* result); // freestanding
     
      // allocator argument tag
      struct allocator_arg_t
      {
        explicit allocator_arg_t() = default;
      };                                                // freestanding
      inline constexpr allocator_arg_t allocator_arg{}; // freestanding
     
      // uses_allocator
      template<class T, class Alloc>
      struct uses_allocator; // freestanding
     
      // uses_allocator
      template<class T, class Alloc>
      constexpr bool uses_allocator_v = uses_allocator<T, Alloc>::value; // freestanding
     
      // uses-allocator construction
      template<class T, class Alloc, class... Args>
      constexpr auto uses_allocator_construction_args(const Alloc& alloc, // freestanding
                                                      Args&&... args) noexcept;
      template<class T, class Alloc, class Tuple1, class Tuple2>
      constexpr auto uses_allocator_construction_args(const Alloc& alloc, // freestanding
                                                      piecewise_construct_t,
                                                      Tuple1&& x,
                                                      Tuple2&& y) noexcept;
      template<class T, class Alloc>
      constexpr auto uses_allocator_construction_args(
        const Alloc& alloc) noexcept; // freestanding
      template<class T, class Alloc, class U, class V>
      constexpr auto uses_allocator_construction_args(const Alloc& alloc, // freestanding
                                                      U&& u,
                                                      V&& v) noexcept;
      template<class T, class Alloc, class U, class V>
      constexpr auto uses_allocator_construction_args(const Alloc& alloc, // freestanding
                                                      pair<U, V>& pr) noexcept;
      template<class T, class Alloc, class U, class V>
      constexpr auto uses_allocator_construction_args(const Alloc& alloc, // freestanding
                                                      const pair<U, V>& pr) noexcept;
      template<class T, class Alloc, class U, class V>
      constexpr auto uses_allocator_construction_args(const Alloc& alloc, // freestanding
                                                      pair<U, V>&& pr) noexcept;
      template<class T, class Alloc, class U, class V>
      constexpr auto uses_allocator_construction_args(const Alloc& alloc, // freestanding
                                                      const pair<U, V>&& pr) noexcept;
      template<class T, class Alloc, /*pair-like*/ P>
      constexpr auto uses_allocator_construction_args(const Alloc& alloc, // freestanding
                                                      P&& p) noexcept;
      template<class T, class Alloc, class U>
      constexpr auto uses_allocator_construction_args(const Alloc& alloc, // freestanding
                                                      U&& u) noexcept;
      template<class T, class Alloc, class... Args>
      constexpr T make_obj_using_allocator(const Alloc& alloc,
                                           Args&&... args); // freestanding
      template<class T, class Alloc, class... Args>
      constexpr T* uninitialized_construct_using_allocator(T* p, // freestanding
                                                           const Alloc& alloc,
                                                           Args&&... args);
     
      // allocator Traits
      template<class Alloc>
      struct allocator_traits; // freestanding
     
      template<class Pointer, class SizeType = size_t>
      struct allocation_result
      { // freestanding
        Pointer ptr;
        SizeType count;
      };
     
      // the default allocator
      template<class T>
      class allocator;
      template<class T, class U>
      constexpr bool operator==(const allocator<T>&, const allocator<U>&) noexcept;
     
      // addressof
      template<class T>
      constexpr T* addressof(T& r) noexcept; // freestanding
      template<class T>
      const T* addressof(const T&&) = delete; // freestanding
     
      // specialized algorithms
      // special memory concepts
      template<class I>
      concept [no-throw-input-iterator](../memory/ranges/nothrow_concepts.html) = /* see description */; // exposition-only
      template<class I>
      concept [no-throw-forward-iterator](../memory/ranges/nothrow_concepts.html) = /* see description */; // exposition-only
      template<class S, class I>
      concept no-throw-sentinel-for = /* see description */; // exposition-only
      template<class R>
      concept [no-throw-input-range](../memory/ranges/nothrow_concepts.html) = /* see description */; // exposition-only
      template<class R>
      concept [no-throw-forward-range](../memory/ranges/nothrow_concepts.html) = /* see description */; // exposition-only
     
      template<class NoThrowForwardIter>
      constexpr void uninitialized_default_construct(NoThrowForwardIter first, // freestanding
                                                     NoThrowForwardIter last);
      template<class ExecutionPolicy, class NoThrowForwardIter>
      void uninitialized_default_construct(ExecutionPolicy&& exec, // freestanding-deleted,
                                           NoThrowForwardIter first,
                                           NoThrowForwardIter last);
      template<class NoThrowForwardIter, class Size>
      constexpr NoThrowForwardIter uninitialized_default_construct_n(NoThrowForwardIter first,
                                                                     Size n); // freestanding
      template<class ExecutionPolicy, class NoThrowForwardIter, class Size>
      NoThrowForwardIter uninitialized_default_construct_n(
        ExecutionPolicy&& exec, // freestanding-deleted,
        NoThrowForwardIter first,
        Size n);
     
      namespace ranges {
        template<[no-throw-forward-iterator](../memory/ranges/nothrow_concepts.html) I, no-throw-sentinel-for<I> S>
          requires default_initializable<iter_value_t<I>>
        constexpr I uninitialized_default_construct(I first, S last); // freestanding
        template<[no-throw-forward-range](../memory/ranges/nothrow_concepts.html) R>
          requires default_initializable<range_value_t<R>>
        constexpr borrowed_iterator_t<R> uninitialized_default_construct(
          R&& r); // freestanding
     
        template<[no-throw-forward-iterator](../memory/ranges/nothrow_concepts.html) I>
          requires default_initializable<iter_value_t<I>>
        constexpr I uninitialized_default_construct_n(I first, // freestanding
                                                      iter_difference_t<I> n);
      }
     
      template<class NoThrowForwardIter>
      constexpr void uninitialized_value_construct(NoThrowForwardIter first, // freestanding
                                                   NoThrowForwardIter last);
      template<class ExecutionPolicy, class NoThrowForwardIter>
      void uninitialized_value_construct(ExecutionPolicy&& exec, // freestanding-deleted,
                                         NoThrowForwardIter first,
                                         NoThrowForwardIter last);
      template<class NoThrowForwardIter, class Size>
      constexpr NoThrowForwardIter uninitialized_value_construct_n(NoThrowForwardIter first,
                                                                   Size n); // freestanding
      template<class ExecutionPolicy, class NoThrowForwardIter, class Size>
      NoThrowForwardIter uninitialized_value_construct_n(
        ExecutionPolicy&& exec, // freestanding-deleted,
        NoThrowForwardIter first,
        Size n);
     
      namespace ranges {
        template<[no-throw-forward-iterator](../memory/ranges/nothrow_concepts.html) I, no-throw-sentinel-for<I> S>
          requires default_initializable<iter_value_t<I>>
        constexpr I uninitialized_value_construct(I first, S last); // freestanding
        template<[no-throw-forward-range](../memory/ranges/nothrow_concepts.html) R>
          requires default_initializable<range_value_t<R>>
        constexpr borrowed_iterator_t<R> uninitialized_value_construct(R&& r); // freestanding
     
        template<[no-throw-forward-iterator](../memory/ranges/nothrow_concepts.html) I>
          requires default_initializable<iter_value_t<I>>
        constexpr I uninitialized_value_construct_n(I first, // freestanding
                                                    iter_difference_t<I> n);
      }
     
      template<class InputIter, class NoThrowForwardIter>
      constexpr NoThrowForwardIter uninitialized_copy(InputIter first, // freestanding
                                                      InputIter last,
                                                      NoThrowForwardIter result);
      template<class ExecutionPolicy, class ForwardIter, class NoThrowForwardIter>
      NoThrowForwardIter uninitialized_copy(ExecutionPolicy&& exec, // freestanding-deleted,
                                            ForwardIter first,
                                            ForwardIter last,
                                            NoThrowForwardIter result);
      template<class InputIter, class Size, class NoThrowForwardIter>
      constexpr NoThrowForwardIter uninitialized_copy_n(InputIter first, // freestanding
                                                        Size n,
                                                        NoThrowForwardIter result);
      template<class ExecutionPolicy,
               class ForwardIter,
               class Size,
               class NoThrowForwardIter>
      NoThrowForwardIter uninitialized_copy_n(ExecutionPolicy&& exec, // freestanding-deleted,
                                              ForwardIter first,
                                              Size n,
                                              NoThrowForwardIter result);
     
      namespace ranges {
        template<class I, class O>
        using uninitialized_copy_result = in_out_result<I, O>; // freestanding
        template<input_iterator I,
                 sentinel_for<I> S1,
                 [no-throw-forward-iterator](../memory/ranges/nothrow_concepts.html) O,
                 no-throw-sentinel-for<O> S2>
          requires constructible_from<iter_value_t<O>, iter_reference_t<I>>
        constexpr uninitialized_copy_result<I, O>
        uninitialized_copy(I ifirst, S1 ilast, O ofirst, S2 olast); // freestanding
        template<input_range IR, [no-throw-forward-range](../memory/ranges/nothrow_concepts.html) OR>
          requires constructible_from<range_value_t<OR>, range_reference_t<IR>>
        constexpr uninitialized_copy_result<borrowed_iterator_t<IR>, borrowed_iterator_t<OR>>
        uninitialized_copy(IR&& in_range, OR&& out_range); // freestanding
     
        template<class I, class O>
        using uninitialized_copy_n_result = in_out_result<I, O>; // freestanding
        template<input_iterator I,
                 [no-throw-forward-iterator](../memory/ranges/nothrow_concepts.html) O,
                 no-throw-sentinel-for<O> S>
          requires constructible_from<iter_value_t<O>, iter_reference_t<I>>
        constexpr uninitialized_copy_n_result<I, O> uninitialized_copy_n(
          I ifirst,
          iter_difference_t<I> n, // freestanding
          O ofirst,
          S olast);
      }
     
      template<class InputIter, class NoThrowForwardIter>
      constexpr NoThrowForwardIter uninitialized_move(InputIter first, // freestanding
                                                      InputIter last,
                                                      NoThrowForwardIter result);
      template<class ExecutionPolicy, class ForwardIter, class NoThrowForwardIter>
      NoThrowForwardIter uninitialized_move(ExecutionPolicy&& exec, // freestanding-deleted,
                                            ForwardIter first,
                                            ForwardIter last,
                                            NoThrowForwardIter result);
      template<class InputIter, class Size, class NoThrowForwardIter>
      constexpr pair<InputIter, NoThrowForwardIter> uninitialized_move_n(
        InputIter first,
        Size n, // freestanding
        NoThrowForwardIter result);
      template<class ExecutionPolicy, class ForwardIter, class Size, class NoThrowForwardIter>
      pair<ForwardIter, NoThrowForwardIter> uninitialized_move_n(
        ExecutionPolicy&& exec, // freestanding-deleted,
        ForwardIter first,
        Size n,
        NoThrowForwardIter result);
     
      namespace ranges {
        template<class I, class O>
        using uninitialized_move_result = in_out_result<I, O>; // freestanding
        template<input_iterator I,
                 sentinel_for<I> S1,
                 [no-throw-forward-iterator](../memory/ranges/nothrow_concepts.html) O,
                 no-throw-sentinel-for<O> S2>
          requires constructible_from<iter_value_t<O>, iter_rvalue_reference_t<I>>
        constexpr uninitialized_move_result<I, O>
        uninitialized_move(I ifirst, S1 ilast, O ofirst, S2 olast); // freestanding
        template<input_range IR, [no-throw-forward-range](../memory/ranges/nothrow_concepts.html) OR>
          requires constructible_from<range_value_t<OR>, range_rvalue_reference_t<IR>>
        constexpr uninitialized_move_result<borrowed_iterator_t<IR>, borrowed_iterator_t<OR>>
        uninitialized_move(IR&& in_range, OR&& out_range); // freestanding
     
        template<class I, class O>
        using uninitialized_move_n_result = in_out_result<I, O>; // freestanding
        template<input_iterator I,
                 [no-throw-forward-iterator](../memory/ranges/nothrow_concepts.html) O,
                 no-throw-sentinel-for<O> S>
          requires constructible_from<iter_value_t<O>, iter_rvalue_reference_t<I>>
        constexpr uninitialized_move_n_result<I, O> uninitialized_move_n(
          I ifirst,
          iter_difference_t<I> n, // freestanding
          O ofirst,
          S olast);
      }
     
      template<class NoThrowForwardIter, class T>
      constexpr void uninitialized_fill(NoThrowForwardIter first, // freestanding
                                        NoThrowForwardIter last,
                                        const T& x);
      template<class ExecutionPolicy, class NoThrowForwardIter, class T>
      void uninitialized_fill(ExecutionPolicy&& exec, // freestanding-deleted,
                              NoThrowForwardIter first,
                              NoThrowForwardIter last,
                              const T& x);
      template<class NoThrowForwardIter, class Size, class T>
      constexpr NoThrowForwardIter uninitialized_fill_n(NoThrowForwardIter first,
                                                        Size n,
                                                        const T& x); // freestanding
      template<class ExecutionPolicy, class NoThrowForwardIter, class Size, class T>
      NoThrowForwardIter uninitialized_fill_n(ExecutionPolicy&& exec, // freestanding-deleted,
                                              NoThrowForwardIter first,
                                              Size n,
                                              const T& x);
     
      namespace ranges {
        template<[no-throw-forward-iterator](../memory/ranges/nothrow_concepts.html) I, no-throw-sentinel-for<I> S, class T>
          requires constructible_from<iter_value_t<I>, const T&>
        constexpr I uninitialized_fill(I first, S last, const T& x); // freestanding
        template<[no-throw-forward-range](../memory/ranges/nothrow_concepts.html) R, class T>
          requires constructible_from<range_value_t<R>, const T&>
        constexpr borrowed_iterator_t<R> uninitialized_fill(R&& r,
                                                            const T& x); // freestanding
     
        template<[no-throw-forward-iterator](../memory/ranges/nothrow_concepts.html) I, class T>
          requires constructible_from<iter_value_t<I>, const T&>
        constexpr I uninitialized_fill_n(I first, // freestanding
                                         iter_difference_t<I> n,
                                         const T& x);
      }
     
      // construct_at
      template<class T, class... Args>
      constexpr T* construct_at(T* location, Args&&... args); // freestanding
     
      namespace ranges {
        template<class T, class... Args>
        constexpr T* construct_at(T* location, Args&&... args); // freestanding
      }
     
      // destroy
      template<class T>
      constexpr void destroy_at(T* location); // freestanding
      template<class NoThrowForwardIter>
      constexpr void destroy(NoThrowForwardIter first, // freestanding
                             NoThrowForwardIter last);
      template<class ExecutionPolicy, class NoThrowForwardIter>
      void destroy(ExecutionPolicy&& exec, // freestanding-deleted,
                   NoThrowForwardIter first,
                   NoThrowForwardIter last);
      template<class NoThrowForwardIter, class Size>
      constexpr NoThrowForwardIter destroy_n(NoThrowForwardIter first, // freestanding
                                             Size n);
      template<class ExecutionPolicy, class NoThrowForwardIter, class Size>
      NoThrowForwardIter destroy_n(ExecutionPolicy&& exec, // freestanding-deleted,
                                   NoThrowForwardIter first,
                                   Size n);
     
      namespace ranges {
        template<destructible T>
        constexpr void destroy_at(T* location) noexcept; // freestanding
     
        template<[no-throw-input-iterator](../memory/ranges/nothrow_concepts.html) I, no-throw-sentinel-for<I> S>
          requires destructible<iter_value_t<I>>
        constexpr I destroy(I first, S last) noexcept; // freestanding
        template<[no-throw-input-range](../memory/ranges/nothrow_concepts.html) R>
          requires destructible<range_value_t<R>>
        constexpr borrowed_iterator_t<R> destroy(R&& r) noexcept; // freestanding
     
        template<[no-throw-input-iterator](../memory/ranges/nothrow_concepts.html) I>
          requires destructible<iter_value_t<I>>
        constexpr I destroy_n(I first, iter_difference_t<I> n) noexcept; // freestanding
      }
     
      // class template unique_ptr
      template<class T>
      struct default_delete; // freestanding
      template<class T>
      struct default_delete<T[]>; // freestanding
      template<class T, class D = default_delete<T>>
      class unique_ptr; // freestanding
      template<class T, class D>
      class unique_ptr<T[], D>; // freestanding
     
      template<class T, class... Args>
      constexpr unique_ptr<T> make_unique(Args&&... args); // T is not array
      template<class T>
      constexpr unique_ptr<T> make_unique(size_t n); // T is U[]
      template<class T, class... Args>
      /* unspecified */ make_unique(Args&&...) = delete; // T is U[N]
     
      template<class T>
      constexpr unique_ptr<T> make_unique_for_overwrite(); // T is not array
      template<class T>
      constexpr unique_ptr<T> make_unique_for_overwrite(size_t n); // T is U[]
      template<class T, class... Args>
      /* unspecified */ make_unique_for_overwrite(Args&&...) = delete; // T is U[N]
     
      template<class T, class D>
      constexpr void swap(unique_ptr<T, D>& x, unique_ptr<T, D>& y) noexcept; // freestanding
     
      template<class T1, class D1, class T2, class D2>
      constexpr bool operator==(const unique_ptr<T1, D1>& x, // freestanding
                                const unique_ptr<T2, D2>& y);
      template<class T1, class D1, class T2, class D2>
      bool operator<(const unique_ptr<T1, D1>& x,
                     const unique_ptr<T2, D2>& y); // freestanding
      template<class T1, class D1, class T2, class D2>
      bool operator>(const unique_ptr<T1, D1>& x,
                     const unique_ptr<T2, D2>& y); // freestanding
      template<class T1, class D1, class T2, class D2>
      bool operator<=(const unique_ptr<T1, D1>& x,
                      const unique_ptr<T2, D2>& y); // freestanding
      template<class T1, class D1, class T2, class D2>
      bool operator>=(const unique_ptr<T1, D1>& x,
                      const unique_ptr<T2, D2>& y); // freestanding
      template<class T1, class D1, class T2, class D2>
        requires three_way_comparable_with<typename unique_ptr<T1, D1>::pointer,
                                           typename unique_ptr<T2, D2>::pointer>
      compare_three_way_result_t<typename unique_ptr<T1, D1>::pointer,
                                 typename unique_ptr<T2, D2>::pointer>
      operator<=>(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y); // freestanding
     
      template<class T, class D>
      constexpr bool operator==(const unique_ptr<T, D>& x,
                                nullptr_t) noexcept; // freestanding
      template<class T, class D>
      constexpr bool operator<(const unique_ptr<T, D>& x, nullptr_t); // freestanding
      template<class T, class D>
      constexpr bool operator<(nullptr_t, const unique_ptr<T, D>& y); // freestanding
      template<class T, class D>
      constexpr bool operator>(const unique_ptr<T, D>& x, nullptr_t); // freestanding
      template<class T, class D>
      constexpr bool operator>(nullptr_t, const unique_ptr<T, D>& y); // freestanding
      template<class T, class D>
      constexpr bool operator<=(const unique_ptr<T, D>& x, nullptr_t); // freestanding
      template<class T, class D>
      constexpr bool operator<=(nullptr_t, const unique_ptr<T, D>& y); // freestanding
      template<class T, class D>
      constexpr bool operator>=(const unique_ptr<T, D>& x, nullptr_t); // freestanding
      template<class T, class D>
      constexpr bool operator>=(nullptr_t, const unique_ptr<T, D>& y); // freestanding
      template<class T, class D>
        requires three_way_comparable<typename unique_ptr<T, D>::pointer>
      constexpr compare_three_way_result_t<typename unique_ptr<T, D>::pointer> operator<=>(
        const unique_ptr<T, D>& x,
        nullptr_t); // freestanding
     
      template<class E, class T, class Y, class D>
      basic_ostream<E, T>& operator<<(basic_ostream<E, T>& os, const unique_ptr<Y, D>& p);
     
      // class bad_weak_ptr
      class bad_weak_ptr;
     
      // class template shared_ptr
      template<class T>
      class shared_ptr;
     
      // shared_ptr creation
      template<class T, class... Args>
      shared_ptr<T> make_shared(Args&&... args); // T is not array
      template<class T, class A, class... Args>
      shared_ptr<T> allocate_shared(const A& a, Args&&... args); // T is not array
     
      template<class T>
      shared_ptr<T> make_shared(size_t N); // T is U[]
      template<class T, class A>
      shared_ptr<T> allocate_shared(const A& a, size_t N); // T is U[]
     
      template<class T>
      shared_ptr<T> make_shared(); // T is U[N]
      template<class T, class A>
      shared_ptr<T> allocate_shared(const A& a); // T is U[N]
     
      template<class T>
      shared_ptr<T> make_shared(size_t N, const remove_extent_t<T>& u); // T is U[]
      template<class T, class A>
      shared_ptr<T> allocate_shared(const A& a,
                                    size_t N,
                                    const remove_extent_t<T>& u); // T is U[]
     
      template<class T>
      shared_ptr<T> make_shared(const remove_extent_t<T>& u); // T is U[N]
      template<class T, class A>
      shared_ptr<T> allocate_shared(const A& a, const remove_extent_t<T>& u); // T is U[N]
     
      template<class T>
      shared_ptr<T> make_shared_for_overwrite(); // T is not U[]
      template<class T, class A>
      shared_ptr<T> allocate_shared_for_overwrite(const A& a); // T is not U[]
     
      template<class T>
      shared_ptr<T> make_shared_for_overwrite(size_t N); // T is U[]
      template<class T, class A>
      shared_ptr<T> allocate_shared_for_overwrite(const A& a, size_t N); // T is U[]
     
      // shared_ptr comparisons
      template<class T, class U>
      bool operator==(const shared_ptr<T>& a, const shared_ptr<U>& b) noexcept;
      template<class T, class U>
      strong_ordering operator<=>(const shared_ptr<T>& a, const shared_ptr<U>& b) noexcept;
     
      template<class T>
      bool operator==(const shared_ptr<T>& x, nullptr_t) noexcept;
      template<class T>
      strong_ordering operator<=>(const shared_ptr<T>& x, nullptr_t) noexcept;
     
      // shared_ptr specialized algorithms
      template<class T>
      void swap(shared_ptr<T>& a, shared_ptr<T>& b) noexcept;
     
      // shared_ptr casts
      template<class T, class U>
      shared_ptr<T> static_pointer_cast(const shared_ptr<U>& r) noexcept;
      template<class T, class U>
      shared_ptr<T> static_pointer_cast(shared_ptr<U>&& r) noexcept;
      template<class T, class U>
      shared_ptr<T> dynamic_pointer_cast(const shared_ptr<U>& r) noexcept;
      template<class T, class U>
      shared_ptr<T> dynamic_pointer_cast(shared_ptr<U>&& r) noexcept;
      template<class T, class U>
      shared_ptr<T> const_pointer_cast(const shared_ptr<U>& r) noexcept;
      template<class T, class U>
      shared_ptr<T> const_pointer_cast(shared_ptr<U>&& r) noexcept;
      template<class T, class U>
      shared_ptr<T> reinterpret_pointer_cast(const shared_ptr<U>& r) noexcept;
      template<class T, class U>
      shared_ptr<T> reinterpret_pointer_cast(shared_ptr<U>&& r) noexcept;
     
      // shared_ptr get_deleter
      template<class D, class T>
      D* get_deleter(const shared_ptr<T>& p) noexcept;
     
      // shared_ptr I/O
      template<class E, class T, class Y>
      basic_ostream<E, T>& operator<<(basic_ostream<E, T>& os, const shared_ptr<Y>& p);
     
      // class template weak_ptr
      template<class T>
      class weak_ptr;
     
      // weak_ptr specialized algorithms
      template<class T>
      void swap(weak_ptr<T>& a, weak_ptr<T>& b) noexcept;
     
      // class template owner_less
      template<class T = void>
      struct owner_less;
     
      // struct owner_hash
      struct owner_hash;
     
      // struct owner_equal
      struct owner_equal;
     
      // class template enable_shared_from_this
      template<class T>
      class enable_shared_from_this;
     
      // hash support
      template<class T>
      struct hash; // freestanding
      template<class T, class D>
      struct hash<unique_ptr<T, D>>; // freestanding
      template<class T>
      struct hash<shared_ptr<T>>;
     
      // atomic smart pointers
      template<class T>
      struct atomic; // freestanding
      template<class T>
      struct atomic<shared_ptr<T>>;
      template<class T>
      struct atomic<weak_ptr<T>>;
     
      // class template out_ptr_t
      template<class Smart, class Pointer, class... Args>
      class out_ptr_t; // freestanding
     
      // function template out_ptr
      template<class Pointer = void, class Smart, class... Args>
      auto out_ptr(Smart& s, Args&&... args); // freestanding
     
      // class template inout_ptr_t
      template<class Smart, class Pointer, class... Args>
      class inout_ptr_t; // freestanding
     
      // function template inout_ptr
      template<class Pointer = void, class Smart, class... Args>
      auto inout_ptr(Smart& s, Args&&... args); // freestanding
     
      // class template indirect
      template<class T, class Allocator = allocator<T>>
      class indirect;
     
      // hash support
      template<class T, class Alloc>
      struct hash<indirect<T, Alloc>>;
     
      // class template polymorphic
      template<class T, class Allocator = allocator<T>>
      class polymorphic;
     
      namespace pmr {
        template<class T>
        using indirect = indirect<T, polymorphic_allocator<T>>;
        template<class T>
        using polymorphic = polymorphic<T, polymorphic_allocator<T>>;
      }
    }

#### Helper concepts

Note: [These names](../memory/ranges/nothrow_concepts.html "cpp/memory/ranges/nothrow concepts") are only for exposition, they are not part of the interface. 
    
    
    template<class I>
    concept [no-throw-input-iterator](../memory/ranges/nothrow_concepts.html) = // exposition only
      input_iterator<I> &&
      is_lvalue_reference_v<iter_reference_t<I>> &&
      same_as<remove_cvref_t<iter_reference_t<I>>, iter_value_t<I>>;
     
    template<class S, class I>
    concept no-throw-sentinel-for = sentinel_for<S, I>; // exposition only
     
    template<class R>
    concept [no-throw-input-range](../memory/ranges/nothrow_concepts.html) = // exposition only
      [ranges::range](../ranges/range.html)<R> &&
      [no-throw-input-iterator](../memory/ranges/nothrow_concepts.html)<[ranges::iterator_t](../ranges/iterator_t.html)<R>> &&
      no-throw-sentinel-for<[ranges::sentinel_t](../ranges/iterator_t.html)<R>, [ranges::iterator_t](../ranges/iterator_t.html)<R>>;
     
    template<class I>
    concept [no-throw-forward-iterator](../memory/ranges/nothrow_concepts.html) = // exposition only
      [no-throw-input-iterator](../memory/ranges/nothrow_concepts.html)<I> &&
      forward_iterator<I> &&
      no-throw-sentinel-for<I, I>;
     
    template<class R>
    concept [no-throw-forward-range](../memory/ranges/nothrow_concepts.html) = // exposition only
      [no-throw-input-range](../memory/ranges/nothrow_concepts.html)<R> &&
      [no-throw-forward-iterator](../memory/ranges/nothrow_concepts.html)<[ranges::iterator_t](../ranges/iterator_t.html)<R>>;

#### Class template [std::pointer_traits](../memory/pointer_traits.html "cpp/memory/pointer traits")
    
    
    namespace std {
      template<class Ptr>
      struct pointer_traits
      {
        /* see description */;
      };
     
      template<class T>
      struct pointer_traits<T*>
      {
        using pointer         = T*;
        using element_type    = T;
        using difference_type = ptrdiff_t;
     
        template<class U>
        using rebind = U*;
     
        static constexpr pointer pointer_to(/* see description */ r) noexcept;
      };
    }

#### Class [std::allocator_arg_t](../memory/allocator_arg_t.html "cpp/memory/allocator arg t")
    
    
    namespace std {
      struct allocator_arg_t { explicit allocator_arg_t() = default; };
      inline constexpr allocator_arg_t allocator_arg{};
    }

#### Class template [std::allocator_traits](../memory/allocator_traits.html "cpp/memory/allocator traits")
    
    
    namespace std {
      template<class Alloc>
      struct allocator_traits
      {
        using allocator_type                         = Alloc;
     
        using value_type                             = typename Alloc::value_type;
     
        using pointer                                = /* see description */;
        using const_pointer                          = /* see description */;
        using void_pointer                           = /* see description */;
        using const_void_pointer                     = /* see description */;
     
        using difference_type                        = /* see description */;
        using size_type                              = /* see description */;
     
        using propagate_on_container_copy_assignment = /* see description */;
        using propagate_on_container_move_assignment = /* see description */;
        using propagate_on_container_swap            = /* see description */;
        using is_always_equal                        = /* see description */;
     
        template<class T>
        using rebind_alloc = /* see description */;
        template<class T>
        using rebind_traits = allocator_traits<rebind_alloc<T>>;
     
        static constexpr pointer allocate(Alloc& a, size_type n);
        static constexpr pointer allocate(Alloc& a, size_type n, const_void_pointer hint);
        static constexpr allocation_result<pointer, size_type> allocate_at_least(Alloc& a,
                                                                                 size_type n);
     
        static constexpr void deallocate(Alloc& a, pointer p, size_type n);
     
        template<class T, class... Args>
        static constexpr void construct(Alloc& a, T* p, Args&&... args);
     
        template<class T>
        static constexpr void destroy(Alloc& a, T* p);
     
        static constexpr size_type max_size(const Alloc& a) noexcept;
     
        static constexpr Alloc select_on_container_copy_construction(const Alloc& rhs);
      };
    }

#### Class template [std::allocator](../memory/allocator.html "cpp/memory/allocator")
    
    
    namespace std {
      template<class T>
      class allocator
      {
      public:
        using value_type                             = T;
        using size_type                              = size_t;
        using difference_type                        = ptrdiff_t;
        using propagate_on_container_move_assignment = true_type;
     
        constexpr allocator() noexcept;
        constexpr allocator(const allocator&) noexcept;
        template<class U>
        constexpr allocator(const allocator<U>&) noexcept;
        constexpr ~allocator();
        constexpr allocator& operator=(const allocator&) = default;
     
        constexpr T* allocate(size_t n);
        constexpr allocation_result<T*> allocate_at_least(size_t n);
        constexpr void deallocate(T* p, size_t n);
      };
    }

#### Class template [std::default_delete](../memory/default_delete.html "cpp/memory/default delete")
    
    
    namespace std {
      template<class T>
      struct default_delete
      {
        constexpr default_delete() noexcept = default;
        template<class U>
        constexpr default_delete(const default_delete<U>&) noexcept;
        constexpr void operator()(T*) const;
      };
     
      template<class T>
      struct default_delete<T[]>
      {
        constexpr default_delete() noexcept = default;
        template<class U>
        constexpr default_delete(const default_delete<U[]>&) noexcept;
        template<class U>
        constexpr void operator()(U* ptr) const;
      };
    }

#### Class template [std::unique_ptr](../memory/unique_ptr.html "cpp/memory/unique ptr")
    
    
    namespace std {
      template<class T, class D = default_delete<T>>
      class unique_ptr
      {
      public:
        using pointer      = /* see description */;
        using element_type = T;
        using deleter_type = D;
     
        // constructors
        constexpr unique_ptr() noexcept;
        constexpr explicit unique_ptr(type_identity_t<pointer> p) noexcept;
        constexpr unique_ptr(type_identity_t<pointer> p, /* see description */ d1) noexcept;
        constexpr unique_ptr(type_identity_t<pointer> p, /* see description */ d2) noexcept;
        constexpr unique_ptr(unique_ptr&& u) noexcept;
        constexpr unique_ptr(nullptr_t) noexcept;
        template<class U, class E>
        constexpr unique_ptr(unique_ptr<U, E>&& u) noexcept;
     
        // destructor
        constexpr ~unique_ptr();
     
        // assignment
        constexpr unique_ptr& operator=(unique_ptr&& u) noexcept;
        template<class U, class E>
        constexpr unique_ptr& operator=(unique_ptr<U, E>&& u) noexcept;
        constexpr unique_ptr& operator=(nullptr_t) noexcept;
     
        // observers
        constexpr add_lvalue_reference_t<T> operator*() const noexcept(/* see description */);
        constexpr pointer operator->() const noexcept;
        constexpr pointer get() const noexcept;
        constexpr deleter_type& get_deleter() noexcept;
        constexpr const deleter_type& get_deleter() const noexcept;
        constexpr explicit operator bool() const noexcept;
     
        // modifiers
        constexpr pointer release() noexcept;
        constexpr void reset(pointer p = pointer()) noexcept;
        constexpr void swap(unique_ptr& u) noexcept;
     
        // disable copy from lvalue
        unique_ptr(const unique_ptr&)            = delete;
        unique_ptr& operator=(const unique_ptr&) = delete;
      };
     
      template<class T, class D>
      class unique_ptr<T[], D>
      {
      public:
        using pointer      = /* see description */;
        using element_type = T;
        using deleter_type = D;
     
        // constructors
        constexpr unique_ptr() noexcept;
        template<class U>
        constexpr explicit unique_ptr(U p) noexcept;
        template<class U>
        constexpr unique_ptr(U p, /* see description */ d) noexcept;
        template<class U>
        constexpr unique_ptr(U p, /* see description */ d) noexcept;
        constexpr unique_ptr(unique_ptr&& u) noexcept;
        template<class U, class E>
        constexpr unique_ptr(unique_ptr<U, E>&& u) noexcept;
        constexpr unique_ptr(nullptr_t) noexcept;
     
        // destructor
        constexpr ~unique_ptr();
     
        // assignment
        constexpr unique_ptr& operator=(unique_ptr&& u) noexcept;
        template<class U, class E>
        constexpr unique_ptr& operator=(unique_ptr<U, E>&& u) noexcept;
        constexpr unique_ptr& operator=(nullptr_t) noexcept;
     
        // observers
        constexpr T& operator[](size_t i) const;
        constexpr pointer get() const noexcept;
        constexpr deleter_type& get_deleter() noexcept;
        constexpr const deleter_type& get_deleter() const noexcept;
        constexpr explicit operator bool() const noexcept;
     
        // modifiers
        constexpr pointer release() noexcept;
        template<class U>
        constexpr void reset(U p) noexcept;
        constexpr void reset(nullptr_t = nullptr) noexcept;
        constexpr void swap(unique_ptr& u) noexcept;
     
        // disable copy from lvalue
        unique_ptr(const unique_ptr&)            = delete;
        unique_ptr& operator=(const unique_ptr&) = delete;
      };
    }

#### Class [std::bad_weak_ptr](../memory/bad_weak_ptr.html "cpp/memory/bad weak ptr")
    
    
    namespace std {
      class bad_weak_ptr : public exception
      {
      public:
        // for the specification of the special member functions
        const char* what() const noexcept override;
      };
    }

#### Class template [std::shared_ptr](../memory/shared_ptr.html "cpp/memory/shared ptr")
    
    
    namespace std {
      template<class T>
      class shared_ptr
      {
      public:
        using element_type = remove_extent_t<T>;
        using weak_type    = weak_ptr<T>;
     
        // constructors
        constexpr shared_ptr() noexcept;
        constexpr shared_ptr(nullptr_t) noexcept
          : shared_ptr()
        {
        }
        template<class Y>
        explicit shared_ptr(Y* p);
        template<class Y, class D>
        shared_ptr(Y* p, D d);
        template<class Y, class D, class A>
        shared_ptr(Y* p, D d, A a);
        template<class D>
        shared_ptr(nullptr_t p, D d);
        template<class D, class A>
        shared_ptr(nullptr_t p, D d, A a);
        template<class Y>
        shared_ptr(const shared_ptr<Y>& r, element_type* p) noexcept;
        template<class Y>
        shared_ptr(shared_ptr<Y>&& r, element_type* p) noexcept;
        shared_ptr(const shared_ptr& r) noexcept;
        template<class Y>
        shared_ptr(const shared_ptr<Y>& r) noexcept;
        shared_ptr(shared_ptr&& r) noexcept;
        template<class Y>
        shared_ptr(shared_ptr<Y>&& r) noexcept;
        template<class Y>
        explicit shared_ptr(const weak_ptr<Y>& r);
        template<class Y, class D>
        shared_ptr(unique_ptr<Y, D>&& r);
     
        // destructor
        ~shared_ptr();
     
        // assignment
        shared_ptr& operator=(const shared_ptr& r) noexcept;
        template<class Y>
        shared_ptr& operator=(const shared_ptr<Y>& r) noexcept;
        shared_ptr& operator=(shared_ptr&& r) noexcept;
        template<class Y>
        shared_ptr& operator=(shared_ptr<Y>&& r) noexcept;
        template<class Y, class D>
        shared_ptr& operator=(unique_ptr<Y, D>&& r);
     
        // modifiers
        void swap(shared_ptr& r) noexcept;
        void reset() noexcept;
        template<class Y>
        void reset(Y* p);
        template<class Y, class D>
        void reset(Y* p, D d);
        template<class Y, class D, class A>
        void reset(Y* p, D d, A a);
     
        // observers
        element_type* get() const noexcept;
        T& operator*() const noexcept;
        T* operator->() const noexcept;
        element_type& operator[](ptrdiff_t i) const;
        long use_count() const noexcept;
        explicit operator bool() const noexcept;
        template<class U>
        bool owner_before(const shared_ptr<U>& b) const noexcept;
        template<class U>
        bool owner_before(const weak_ptr<U>& b) const noexcept;
        size_t owner_hash() const noexcept;
        template<class U>
        bool owner_equal(const shared_ptr<U>& b) const noexcept;
        template<class U>
        bool owner_equal(const weak_ptr<U>& b) const noexcept;
      };
     
      template<class T>
      shared_ptr(weak_ptr<T>) -> shared_ptr<T>;
      template<class T, class D>
      shared_ptr(unique_ptr<T, D>) -> shared_ptr<T>;
    }

#### Class template [std::weak_ptr](../memory/weak_ptr.html "cpp/memory/weak ptr")
    
    
    namespace std {
      template<class T>
      class weak_ptr
      {
      public:
        using element_type = remove_extent_t<T>;
     
        // constructors
        constexpr weak_ptr() noexcept;
        template<class Y>
        weak_ptr(const shared_ptr<Y>& r) noexcept;
        weak_ptr(const weak_ptr& r) noexcept;
        template<class Y>
        weak_ptr(const weak_ptr<Y>& r) noexcept;
        weak_ptr(weak_ptr&& r) noexcept;
        template<class Y>
        weak_ptr(weak_ptr<Y>&& r) noexcept;
     
        // destructor
        ~weak_ptr();
     
        // assignment
        weak_ptr& operator=(const weak_ptr& r) noexcept;
        template<class Y>
        weak_ptr& operator=(const weak_ptr<Y>& r) noexcept;
        template<class Y>
        weak_ptr& operator=(const shared_ptr<Y>& r) noexcept;
        weak_ptr& operator=(weak_ptr&& r) noexcept;
        template<class Y>
        weak_ptr& operator=(weak_ptr<Y>&& r) noexcept;
     
        // modifiers
        void swap(weak_ptr& r) noexcept;
        void reset() noexcept;
     
        // observers
        long use_count() const noexcept;
        bool expired() const noexcept;
        shared_ptr<T> lock() const noexcept;
        template<class U>
        bool owner_before(const shared_ptr<U>& b) const noexcept;
        template<class U>
        bool owner_before(const weak_ptr<U>& b) const noexcept;
        size_t owner_hash() const noexcept;
        template<class U>
        bool owner_equal(const shared_ptr<U>& b) const noexcept;
        template<class U>
        bool owner_equal(const weak_ptr<U>& b) const noexcept;
      };
     
      template<class T>
      weak_ptr(shared_ptr<T>) -> weak_ptr<T>;
    }

#### Class template [std::owner_less](../memory/owner_less.html "cpp/memory/owner less")
    
    
    namespace std {
      template<class T = void>
      struct owner_less;
     
      template<class T>
      struct owner_less<shared_ptr<T>>
      {
        bool operator()(const shared_ptr<T>&, const shared_ptr<T>&) const noexcept;
        bool operator()(const shared_ptr<T>&, const weak_ptr<T>&) const noexcept;
        bool operator()(const weak_ptr<T>&, const shared_ptr<T>&) const noexcept;
      };
     
      template<class T>
      struct owner_less<weak_ptr<T>>
      {
        bool operator()(const weak_ptr<T>&, const weak_ptr<T>&) const noexcept;
        bool operator()(const shared_ptr<T>&, const weak_ptr<T>&) const noexcept;
        bool operator()(const weak_ptr<T>&, const shared_ptr<T>&) const noexcept;
      };
     
      template<>
      struct owner_less<void>
      {
        template<class T, class U>
        bool operator()(const shared_ptr<T>&, const shared_ptr<U>&) const noexcept;
        template<class T, class U>
        bool operator()(const shared_ptr<T>&, const weak_ptr<U>&) const noexcept;
        template<class T, class U>
        bool operator()(const weak_ptr<T>&, const shared_ptr<U>&) const noexcept;
        template<class T, class U>
        bool operator()(const weak_ptr<T>&, const weak_ptr<U>&) const noexcept;
     
        using is_transparent = /* unspecified */;
      };
    }

#### Class std::owner_hash
    
    
    namespace std {
      struct owner_hash
      {
        template<class T>
        size_t operator()(const shared_ptr<T>&) const noexcept;
     
        template<class T>
        size_t operator()(const weak_ptr<T>&) const noexcept;
     
        using is_transparent = /* unspecified */;
      };
    }

#### Class std::owner_equal
    
    
    namespace std {
      struct owner_equal
      {
        template<class T, class U>
        bool operator()(const shared_ptr<T>&, const shared_ptr<U>&) const noexcept;
        template<class T, class U>
        bool operator()(const shared_ptr<T>&, const weak_ptr<U>&) const noexcept;
        template<class T, class U>
        bool operator()(const weak_ptr<T>&, const shared_ptr<U>&) const noexcept;
        template<class T, class U>
        bool operator()(const weak_ptr<T>&, const weak_ptr<U>&) const noexcept;
     
        using is_transparent = /* unspecified */;
      };
    }

#### Class template [std::enable_shared_from_this](../memory/enable_shared_from_this.html "cpp/memory/enable shared from this")
    
    
    namespace std {
      template<class T>
      class enable_shared_from_this
      {
      protected:
        constexpr enable_shared_from_this() noexcept;
        enable_shared_from_this(const enable_shared_from_this&) noexcept;
        enable_shared_from_this& operator=(const enable_shared_from_this&) noexcept;
        ~enable_shared_from_this();
     
      public:
        shared_ptr<T> shared_from_this();
        shared_ptr<T const> shared_from_this() const;
        weak_ptr<T> weak_from_this() noexcept;
        weak_ptr<T const> weak_from_this() const noexcept;
     
      private:
        mutable weak_ptr<T> /*weak-this*/; // exposition-only
      };
    }

#### Class template [std::atomic](../atomic/atomic.html "cpp/atomic/atomic")'s specialization for [std::shared_ptr](../memory/shared_ptr.html "cpp/memory/shared ptr")
    
    
    namespace std {
      template<class T> struct atomic<shared_ptr<T>> {
        using value_type = shared_ptr<T>;
        static constexpr bool is_always_lock_free = /* implementation-defined */;
     
        bool is_lock_free() const noexcept;
        void store(shared_ptr<T> desired, memory_order order = memory_order::seq_cst) noexcept;
        shared_ptr<T> load(memory_order order = memory_order::seq_cst) const noexcept;
        operator shared_ptr<T>() const noexcept;
     
        shared_ptr<T> exchange(shared_ptr<T> desired,
                               memory_order order = memory_order::seq_cst) noexcept;
     
        bool compare_exchange_weak(shared_ptr<T>& expected, shared_ptr<T> desired,
                                   memory_order success, memory_order failure) noexcept;
        bool compare_exchange_strong(shared_ptr<T>& expected, shared_ptr<T> desired,
                                     memory_order success, memory_order failure) noexcept;
     
        bool compare_exchange_weak(shared_ptr<T>& expected, shared_ptr<T> desired,
                                   memory_order order = memory_order::seq_cst) noexcept;
        bool compare_exchange_strong(shared_ptr<T>& expected, shared_ptr<T> desired,
                                     memory_order order = memory_order::seq_cst) noexcept;
     
        constexpr atomic() noexcept = default;
        atomic(shared_ptr<T> desired) noexcept;
        atomic(const atomic&) = delete;
        void operator=(const atomic&) = delete;
        void operator=(shared_ptr<T> desired) noexcept;
     
      private:
        shared_ptr<T> p;            // exposition only
      };
    }

#### Class template [std::atomic](../atomic/atomic.html "cpp/atomic/atomic")'s specialization for [std::weak_ptr](../memory/weak_ptr.html "cpp/memory/weak ptr")
    
    
    namespace std {
      template<class T> struct atomic<weak_ptr<T>> {
        using value_type = weak_ptr<T>;
        static constexpr bool is_always_lock_free = /* implementation-defined */;
     
        bool is_lock_free() const noexcept;
        void store(weak_ptr<T> desired, memory_order order = memory_order::seq_cst) noexcept;
        weak_ptr<T> load(memory_order order = memory_order::seq_cst) const noexcept;
        operator weak_ptr<T>() const noexcept;
     
        weak_ptr<T> exchange(weak_ptr<T> desired,
                             memory_order order = memory_order::seq_cst) noexcept;
     
        bool compare_exchange_weak(weak_ptr<T>& expected, weak_ptr<T> desired,
                                   memory_order success, memory_order failure) noexcept;
        bool compare_exchange_strong(weak_ptr<T>& expected, weak_ptr<T> desired,
                                     memory_order success, memory_order failure) noexcept;
     
        bool compare_exchange_weak(weak_ptr<T>& expected, weak_ptr<T> desired,
                                   memory_order order = memory_order::seq_cst) noexcept;
        bool compare_exchange_strong(weak_ptr<T>& expected, weak_ptr<T> desired,
                                     memory_order order = memory_order::seq_cst) noexcept;
     
        constexpr atomic() noexcept = default;
        atomic(weak_ptr<T> desired) noexcept;
        atomic(const atomic&) = delete;
        void operator=(const atomic&) = delete;
        void operator=(weak_ptr<T> desired) noexcept;
     
      private:
        weak_ptr<T> p;              // exposition only
      };
    }

#### Class template [std::out_ptr_t](../memory/out_ptr_t.html)
    
    
    namespace std {
      template<class Smart, class Pointer, class... Args>
      class out_ptr_t
      {
      public:
        explicit out_ptr_t(Smart&, Args...);
        out_ptr_t(const out_ptr_t&) = delete;
     
        ~out_ptr_t();
     
        operator Pointer*() const noexcept;
        operator void**() const noexcept;
     
      private:
        Smart& s;         // exposition-only
        tuple<Args...> a; // exposition-only
        Pointer p;        // exposition-only
      };
    }

#### Class template [std::inout_ptr_t](../memory/inout_ptr_t.html)
    
    
    namespace std {
      template<class Smart, class Pointer, class... Args>
      class inout_ptr_t
      {
      public:
        explicit inout_ptr_t(Smart&, Args...);
        inout_ptr_t(const inout_ptr_t&) = delete;
     
        ~inout_ptr_t();
     
        operator Pointer*() const noexcept;
        operator void**() const noexcept;
     
      private:
        Smart& s;         // exposition-only
        tuple<Args...> a; // exposition-only
        Pointer p;        // exposition-only
      };
    }

#### Class template std::indirect
    
    
    namespace std {
      template<class T, class Allocator = allocator<T>>
      class indirect
      {
      public:
        using value_type     = T;
        using allocator_type = Allocator;
        using pointer        = typename allocator_traits<Allocator>::pointer;
        using const_pointer  = typename allocator_traits<Allocator>::const_pointer;
     
        // constructors
        constexpr explicit indirect();
        constexpr explicit indirect(allocator_arg_t, const Allocator& a);
        constexpr indirect(const indirect& other);
        constexpr indirect(allocator_arg_t, const Allocator& a, const indirect& other);
        constexpr indirect(indirect&& other) noexcept;
        constexpr indirect(allocator_arg_t,
                           const Allocator& a,
                           indirect&& other) noexcept(/* see description */);
        template<class U = T>
        constexpr explicit indirect(U&& u);
        template<class U = T>
        constexpr explicit indirect(allocator_arg_t, const Allocator& a, U&& u);
        template<class... Us>
        constexpr explicit indirect(in_place_t, Us&&... us);
        template<class... Us>
        constexpr explicit indirect(allocator_arg_t,
                                    const Allocator& a,
                                    in_place_t,
                                    Us&&... us);
        template<class I, class... Us>
        constexpr explicit indirect(in_place_t, initializer_list<I> ilist, Us&&... us);
        template<class I, class... Us>
        constexpr explicit indirect(allocator_arg_t,
                                    const Allocator& a,
                                    in_place_t,
                                    initializer_list<I> ilist,
                                    Us&&... us);
     
        // destructor
        constexpr ~indirect();
     
        // assignment
        constexpr indirect& operator=(const indirect& other);
        constexpr indirect& operator=(indirect&& other) noexcept(/* see description */);
        template<class U = T>
        constexpr indirect& operator=(U&& u);
     
        // observers
        constexpr const T& operator*() const& noexcept;
        constexpr T& operator*() & noexcept;
        constexpr const T&& operator*() const&& noexcept;
        constexpr T&& operator*() && noexcept;
        constexpr const_pointer operator->() const noexcept;
        constexpr pointer operator->() noexcept;
        constexpr bool valueless_after_move() const noexcept;
        constexpr allocator_type get_allocator() const noexcept;
     
        // swap
        constexpr void swap(indirect& other) noexcept(/* see description */);
        friend constexpr void swap(indirect& lhs,
                                   indirect& rhs) noexcept(/* see description */);
     
        // relational operators
        template<class U, class AA>
        friend constexpr bool operator==(
          const indirect& lhs,
          const indirect<U, AA>& rhs) noexcept(/* see description */);
        template<class U, class AA>
        friend constexpr auto operator<=>(const indirect& lhs, const indirect<U, AA>& rhs)
          -> /*synth-three-way-result*/<T, U>;
     
        // comparison with T
        template<class U>
        friend constexpr bool operator==(const indirect& lhs,
                                         const U& rhs) noexcept(/* see description */);
        template<class U>
        friend constexpr auto operator<=>(const indirect& lhs, const U& rhs)
          -> /*synth-three-way-result*/<T, U>;
     
      private:
        pointer /*p*/;                     // exposition-only
        Allocator /*alloc*/ = Allocator(); // exposition-only
      };
      template<class Value>
      indirect(Value) -> indirect<Value>;
      template<class Allocator, class Value>
      indirect(allocator_arg_t, Allocator, Value)
        -> indirect<Value,
                    typename allocator_traits<Allocator>::template rebind_alloc<Value>>;
    }

#### Class template std::polymorphic
    
    
    namespace std {
      template<class T, class Allocator = allocator<T>>
      class polymorphic
      {
      public:
        using value_type     = T;
        using allocator_type = Allocator;
        using pointer        = typename allocator_traits<Allocator>::pointer;
        using const_pointer  = typename allocator_traits<Allocator>::const_pointer;
     
        // constructors
        constexpr explicit polymorphic();
        constexpr explicit polymorphic(allocator_arg_t, const Allocator& a);
        constexpr polymorphic(const polymorphic& other);
        constexpr polymorphic(allocator_arg_t, const Allocator& a, const polymorphic& other);
        constexpr polymorphic(polymorphic&& other) noexcept;
        constexpr polymorphic(allocator_arg_t,
                              const Allocator& a,
                              polymorphic&& other) noexcept(/* see description */);
        template<class U = T>
        constexpr explicit polymorphic(U&& u);
        template<class U = T>
        constexpr explicit polymorphic(allocator_arg_t, const Allocator& a, U&& u);
        template<class U, class... Ts>
        constexpr explicit polymorphic(in_place_type_t<U>, Ts&&... ts);
        template<class U, class... Ts>
        constexpr explicit polymorphic(allocator_arg_t,
                                       const Allocator& a,
                                       in_place_type_t<U>,
                                       Ts&&... ts);
        template<class U, class I, class... Us>
        constexpr explicit polymorphic(in_place_type_t<U>,
                                       initializer_list<I> ilist,
                                       Us&&... us);
        template<class U, class I, class... Us>
        constexpr explicit polymorphic(allocator_arg_t,
                                       const Allocator& a,
                                       in_place_type_t<U>,
                                       initializer_list<I> ilist,
                                       Us&&... us);
     
        // destructor
        constexpr ~polymorphic();
     
        // assignment
        constexpr polymorphic& operator=(const polymorphic& other);
        constexpr polymorphic& operator=(polymorphic&& other) noexcept(/* see description */);
     
        // observers
        constexpr const T& operator*() const noexcept;
        constexpr T& operator*() noexcept;
        constexpr const_pointer operator->() const noexcept;
        constexpr pointer operator->() noexcept;
        constexpr bool valueless_after_move() const noexcept;
        constexpr allocator_type get_allocator() const noexcept;
     
        // swap
        constexpr void swap(polymorphic& other) noexcept(/* see description */);
        friend constexpr void swap(polymorphic& lhs,
                                   polymorphic& rhs) noexcept(/* see description */);
     
      private:
        Allocator /*alloc*/ = Allocator(); // exposition-only
      };
    }
