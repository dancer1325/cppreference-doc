[C++](../../cpp.html "cpp")

[Compiler support](../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../freestanding.html "cpp/freestanding")  
[Language](../language.html "cpp/language")  
[Standard library](../standard_library.html "cpp/standard library")  
[Standard library headers](../headers.html "cpp/header")  
[Named requirements](../iterator/concepts.html "cpp/named req")  
[Feature test macros](../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../utility.html#Language_support "cpp/utility")  
[Concepts library](../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../error.html "cpp/error")  
[Memory management library](../memory.html "cpp/memory")  
[Metaprogramming library](../meta.html "cpp/meta") (C++11)  
[General utilities library](../utility.html "cpp/utility")  
[Containers library](../container.html "cpp/container")  
[Iterators library](../iterator.html "cpp/iterator")  
[Ranges library](../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../algorithm.html "cpp/algorithm")  
[Strings library](../string.html "cpp/string")  
[Text processing library](../text.html "cpp/text")  
[Numerics library](../numeric.html "cpp/numeric")  
[Date and time library](../chrono.html "cpp/chrono")  
[Input/output library](../io.html "cpp/io")  
[Filesystem library](../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../atomic.html "cpp/thread") (C++11)  
[Execution control library](../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../experimental.html "cpp/experimental")  
[Symbols index](../symbol_index.html "cpp/symbol index")  
[External libraries](../links/libs.html "cpp/links/libs")  
  


[C++ named requirements](../iterator/concepts.html "cpp/named req")

| [Basic](../iterator/concepts.html#Basic "cpp/named req")  
---  
[DefaultConstructible](DefaultConstructible.html "cpp/named req/DefaultConstructible")  
[MoveConstructible](MoveConstructible.html "cpp/named req/MoveConstructible")(C++11)  
[CopyConstructible](CopyConstructible.html "cpp/named req/CopyConstructible")  
[CopyAssignable](CopyAssignable.html "cpp/named req/CopyAssignable")  
[MoveAssignable](MoveAssignable.html "cpp/named req/MoveAssignable")(C++11)  
[Destructible](Destructible.html "cpp/named req/Destructible")  
[Type properties](../iterator/concepts.html#Type_properties "cpp/named req")  
[ScalarType](ScalarType.html "cpp/named req/ScalarType")  
[PODType](PODType.html "cpp/named req/PODType")  
[TriviallyCopyable](TriviallyCopyable.html "cpp/named req/TriviallyCopyable")(C++11)  
[TrivialType](TrivialType.html "cpp/named req/TrivialType")(C++11)  
[StandardLayoutType](StandardLayoutType.html "cpp/named req/StandardLayoutType")(C++11)` `  
[ImplicitLifetimeType](ImplicitLifetimeType.html "cpp/named req/ImplicitLifetimeType")  
[Library-wide](../iterator/concepts.html#Library-wide "cpp/named req")  
[BooleanTestable](BooleanTestable.html "cpp/named req/BooleanTestable")  
[EqualityComparable](EqualityComparable.html "cpp/named req/EqualityComparable")  
[LessThanComparable](LessThanComparable.html "cpp/named req/LessThanComparable")  
[Swappable](Swappable.html "cpp/named req/Swappable")  
[ValueSwappable](ValueSwappable.html "cpp/named req/ValueSwappable")(C++11)  
[NullablePointer](NullablePointer.html "cpp/named req/NullablePointer")(C++11)  
[Hash](Hash.html "cpp/named req/Hash")(C++11)  
[Allocator](Allocator.html "cpp/named req/Allocator")  
[FunctionObject](FunctionObject.html "cpp/named req/FunctionObject")  
[Callable](Callable.html "cpp/named req/Callable")  
[Predicate](Predicate.html "cpp/named req/Predicate")  
[BinaryPredicate](BinaryPredicate.html "cpp/named req/BinaryPredicate")  
[Compare](Compare.html "cpp/named req/Compare")  
  
  
  
  
  
  
  
  
  
| [Container](../iterator/concepts.html#Container "cpp/named req")  
---  
[Container](Container.html "cpp/named req/Container")  
[ReversibleContainer](ReversibleContainer.html "cpp/named req/ReversibleContainer")  
**AllocatorAwareContainer**  
[SequenceContainer](SequenceContainer.html "cpp/named req/SequenceContainer")  
[ContiguousContainer](ContiguousContainer.html "cpp/named req/ContiguousContainer")(C++17)  
[AssociativeContainer](AssociativeContainer.html "cpp/named req/AssociativeContainer")  
[UnorderedAssociativeContainer](UnorderedAssociativeContainer.html "cpp/named req/UnorderedAssociativeContainer")(C++11)` `  
[Container element](../iterator/concepts.html#Container_element "cpp/named req")  
[DefaultInsertable](DefaultInsertable.html "cpp/named req/DefaultInsertable")(C++11)  
[CopyInsertable](CopyInsertable.html "cpp/named req/CopyInsertable")(C++11)  
[MoveInsertable](MoveInsertable.html "cpp/named req/MoveInsertable")(C++11)  
[EmplaceConstructible](EmplaceConstructible.html "cpp/named req/EmplaceConstructible")(C++11)  
[Erasable](Erasable.html "cpp/named req/Erasable")(C++11)  
[Iterator](../iterator/concepts.html#Iterator "cpp/named req")  
[LegacyIterator](Iterator.html "cpp/named req/Iterator")  
[LegacyInputIterator](InputIterator.html "cpp/named req/InputIterator")  
[LegacyOutputIterator](OutputIterator.html "cpp/named req/OutputIterator")  
[LegacyForwardIterator](ForwardIterator.html "cpp/named req/ForwardIterator")  
[LegacyBidirectionalIterator](BidirectionalIterator.html "cpp/named req/BidirectionalIterator")  
[LegacyRandomAccessIterator](RandomAccessIterator.html "cpp/named req/RandomAccessIterator")  
[LegacyContiguousIterator](ContiguousIterator.html "cpp/named req/ContiguousIterator")(C++17)  
[ConstexprIterator](ConstexprIterator.html "cpp/named req/ConstexprIterator")(C++20)  
[Stream I/O](../iterator/concepts.html#Stream_I.2FO_functions "cpp/named req")  
[FormattedInputFunction](FormattedInputFunction.html "cpp/named req/FormattedInputFunction")  
[UnformattedInputFunction](UnformattedInputFunction.html "cpp/named req/UnformattedInputFunction")  
[FormattedOutputFunction](FormattedOutputFunction.html "cpp/named req/FormattedOutputFunction")  
[UnformattedOutputFunction](UnformattedOutputFunction.html "cpp/named req/UnformattedOutputFunction")  
[Formatters](../iterator/concepts.html#Formatters "cpp/named req")  
[BasicFormatter](BasicFormatter.html "cpp/named req/BasicFormatter")(C++20)  
[Formatter](Formatter.html "cpp/named req/Formatter")(C++20)  
  
| [Random Numbers](../iterator/concepts.html#Random_Number_Generation "cpp/named req")  
---  
[SeedSequence](SeedSequence.html "cpp/named req/SeedSequence")(C++11)  
[RandomNumberEngine](RandomNumberEngine.html "cpp/named req/RandomNumberEngine")(C++11)  
[RandomNumberDistribution](RandomNumberDistribution.html "cpp/named req/RandomNumberDistribution")(C++11)  
[UniformRandomBitGenerator](UniformRandomBitGenerator.html "cpp/named req/UniformRandomBitGenerator")(C++11)  
[RandomNumberEngineAdaptor](RandomNumberEngineAdaptor.html "cpp/named req/RandomNumberEngineAdaptor")(C++11)  
[Concurrency](../iterator/concepts.html#Concurrency "cpp/named req")  
[BasicLockable](BasicLockable.html "cpp/named req/BasicLockable")(C++11)  
[Lockable](Lockable.html "cpp/named req/Lockable")(C++11)  
[TimedLockable](TimedLockable.html "cpp/named req/TimedLockable")(C++11)  
[SharedLockable](SharedLockable.html "cpp/named req/SharedLockable")(C++14)  
[SharedTimedLockable](SharedTimedLockable.html "cpp/named req/SharedTimedLockable")(C++14)  
[Mutex](Mutex.html "cpp/named req/Mutex")(C++11)  
[TimedMutex](TimedMutex.html "cpp/named req/TimedMutex")(C++11)  
[SharedMutex](SharedMutex.html "cpp/named req/SharedMutex")(C++17)  
[SharedTimedMutex](SharedTimedMutex.html "cpp/named req/SharedTimedMutex")(C++14)  
[Ranges](../iterator/concepts.html#Ranges "cpp/named req")  
[RangeAdaptorObject](RangeAdaptorObject.html "cpp/named req/RangeAdaptorObject")(C++20)  
[RangeAdaptorClosureObject](RangeAdaptorClosureObject.html "cpp/named req/RangeAdaptorClosureObject")(C++20)  
[Multidimensional View](../iterator/concepts.html#Multidimensional_View_Customization "cpp/named req")  
[LayoutMapping](LayoutMapping.html "cpp/named req/LayoutMapping")(C++23)  
[LayoutMappingPolicy](LayoutMappingPolicy.html "cpp/named req/LayoutMappingPolicy")(C++23)  
[AccessorPolicy](AccessorPolicy.html "cpp/named req/AccessorPolicy")(C++23)  
[Other](../iterator/concepts.html#Other "cpp/named req")  
| [CharTraits](CharTraits.html "cpp/named req/CharTraits")  
---  
[RegexTraits](RegexTraits.html "cpp/named req/RegexTraits")(C++11)` `  
[BitmaskType](BitmaskType.html "cpp/named req/BitmaskType")  
[LiteralType](LiteralType.html "cpp/named req/LiteralType")(C++11)  
[NumericType](NumericType.html "cpp/named req/NumericType")  
  
| [UnaryTypeTrait](UnaryTypeTrait.html "cpp/named req/UnaryTypeTrait")(C++11)  
---  
[BinaryTypeTrait](BinaryTypeTrait.html "cpp/named req/BinaryTypeTrait")(C++11)  
[TransformationTrait](TransformationTrait.html "cpp/named req/TransformationTrait")(C++11)  
[Clock](Clock.html "cpp/named req/Clock")(C++11)  
[TrivialClock](TrivialClock.html "cpp/named req/TrivialClock")(C++11)  
  
  
  
  


An **AllocatorAwareContainer** is a [Container](Container.html "cpp/named req/Container") that holds an instance of an [Allocator](Allocator.html "cpp/named req/Allocator") and uses that instance in all its member functions to allocate and deallocate memory and to construct and destroy objects in that memory (such objects may be container elements, nodes, or, for unordered containers, bucket arrays), except that [std::basic_string](../string/basic_string.html "cpp/string/basic string") specializations do not use the allocators for construction/destruction of their elements(since C++23). 

The following rules apply to container construction: 

  * Copy constructors of AllocatorAwareContainers obtain their instances of the allocator by calling [std::allocator_traits](../memory/allocator_traits.html)<allocator_type>::select_on_container_copy_construction on the allocator of the container being copied. 
  * Move constructors obtain their instances of allocators by move-constructing from the allocator belonging to the old container. 
  * All other constructors take a const allocator_type& parameter. 



The only way to replace an allocator is copy-assignment, move-assignment, and swap: 

  * Copy-assignment will replace the allocator only if [std::allocator_traits](../memory/allocator_traits.html)<allocator_type>::propagate_on_container_copy_assignment::value is true. 
  * Move-assignment will replace the allocator only if [std::allocator_traits](../memory/allocator_traits.html)<allocator_type>::propagate_on_container_move_assignment::value is true. 
  * Swap will replace the allocator only if [std::allocator_traits](../memory/allocator_traits.html)<allocator_type>::propagate_on_container_swap::value is true. Specifically, it will exchange the allocator instances through an unqualified call to the non-member function swap, see [Swappable](Swappable.html "cpp/named req/Swappable"). If swap does not propagate the allocator, swapping two containers with unequal allocators is undefined behavior. 
  * The accessor `get_allocator()` obtains a copy of the allocator that was used to construct the container or installed by the most recent allocator replacement operation. 



The only exception is [std::basic_string](../string/basic_string.html)<CharT,Traits,Allocator>::assign, which may also propagate the allocator. 

## Contents

  * [1 Requirements](AllocatorAwareContainer.html#Requirements)
    * [1.1 Types](AllocatorAwareContainer.html#Types)
    * [1.2 Statements](AllocatorAwareContainer.html#Statements)
    * [1.3 Expressions](AllocatorAwareContainer.html#Expressions)
  * [2 Notes](AllocatorAwareContainer.html#Notes)
  * [3 Standard library](AllocatorAwareContainer.html#Standard_library)
  * [4 Defect reports](AllocatorAwareContainer.html#Defect_reports)

  
---  
  
### Requirements

A type satisfies AllocatorAwareContainer if it satisfies [Container](Container.html "cpp/named req/Container") and, given the following types and values, the semantic and complexity requirements in the tables below are satisfied: 

Type  |  Definition   
---|---  
`X` |  an AllocatorAwareContainer type   
`T` |  the `value_type` of `X`  
`A` |  the allocator type used by `X`  
Value  |  Definition   
a, b |  non-const lvalues of type `X`  
c |  an lvalue of type const X  
t |  an lvalue or a const rvalue of type `X`  
rv |  a non-const rvalue of type `X`  
m |  a value of type `A`  
  
#### Types

Name  |  Type  | Requirement   
---|---|---  
typename X::allocator_type | `A` | `X::allocator_type::value_type` and `X::value_type` are the same.   
  
#### Statements

Statement  | Semantics  | Complexity   
---|---|---  
X u;  
X u = X(); | Precondition  | `A` is [DefaultConstructible](DefaultConstructible.html "cpp/named req/DefaultConstructible").  | Constant   
Postcondition  | u.empty() and u.get_allocator() == A() are both true.   
X u(m); | Postcondition  | u.empty() and u.get_allocator() == m are both true.  | Constant   
X u(t, m); | Precondition  | `T` is [CopyInsertable](CopyInsertable.html "cpp/named req/CopyInsertable") into `X`.  | Linear   
Postcondition  | u == t and u.get_allocator() == m are both true.   
X u(rv); | Postcondition  | 

  * u has the same elements as rv had before this construction. 
  * The value of u.get_allocator() is the same as the value of rv.get_allocator() before this construction. 

| Constant   
X u(rv, m); | Precondition  | `T` is [MoveInsertable](MoveInsertable.html "cpp/named req/MoveInsertable") into `X`.  | 

  * Constant if m == rv.get_allocator() is true. 
  * Otherwise linear. 

  
Postcondition  | 

  * u has the same elements, or copies of the elements, that rv had before this construction. 
  * u.get_allocator() == m is true. 

  
  
#### Expressions

Expression  |  Type  | Semantics  |  Complexity   
---|---|---|---  
c.get_allocator() | `A` | No direct semantic requirement.  | Constant   
a = t | `X&` | Precondition  | `T` is [CopyInsertable](CopyInsertable.html "cpp/named req/CopyInsertable") into `X` and [CopyAssignable](CopyAssignable.html "cpp/named req/CopyAssignable").  | Linear   
Postcondition  | a == t is true.   
a = rv | `X&` | Precondition  | If the allocator will **not** be replaced by move-assignment (see [above](AllocatorAwareContainer.html#Replacing_allocator)), then `T` is [MoveInsertable](MoveInsertable.html "cpp/named req/MoveInsertable") into `X` and [MoveAssignable](MoveAssignable.html "cpp/named req/MoveAssignable").  | Linear   
Effect  | All existing elements of a are either move assigned to or destroyed.   
Postcondition  | If a and rv do not refer the same object, a is equal to the value that rv had before the assignment.   
a.swap(b) | void | Effect  | Exchanges the contents of a and b.  | Constant   
  
### Notes

AllocatorAwareContainers always call [std::allocator_traits](../memory/allocator_traits.html)<A>::construct(m, p, args) to construct an object of type `T` at p using args, with m == get_allocator(). The default `construct` in [std::allocator](../memory/allocator.html "cpp/memory/allocator") calls ::new((void*)p) T(args)(until C++20)[std::allocator](../memory/allocator.html "cpp/memory/allocator") has no `construct` member and [std::construct_at](../memory/construct_at.html)(p, args) is called when constructing elements(since C++20), but specialized allocators may choose a different definition. 

### Standard library

All standard library string types and containers (except [std::array](../container/array.html "cpp/container/array") and [std::inplace_vector](../container/inplace_vector.html)) are AllocatorAwareContainers: 

[ basic_string](../string/basic_string.html "cpp/string/basic string") |  stores and manipulates sequences of characters   
(class template)   
---|---  
[ deque](../container/deque.html "cpp/container/deque") |  double-ended queue   
(class template)   
[ forward_list](../container/forward_list.html "cpp/container/forward list")(C++11) |  singly-linked list   
(class template)   
[ list](../container/list.html "cpp/container/list") |  doubly-linked list   
(class template)   
[ vector](../container/vector.html "cpp/container/vector") |  resizable contiguous array   
(class template)   
[ map](../container/map.html "cpp/container/map") |  collection of key-value pairs, sorted by keys, keys are unique   
(class template)   
[ multimap](../container/multimap.html "cpp/container/multimap") |  collection of key-value pairs, sorted by keys   
(class template)   
[ set](../container/set.html "cpp/container/set") |  collection of unique keys, sorted by keys   
(class template)   
[ multiset](../container/multiset.html "cpp/container/multiset") |  collection of keys, sorted by keys   
(class template)   
[ unordered_map](../container/unordered_map.html "cpp/container/unordered map")(C++11) |  collection of key-value pairs, hashed by keys, keys are unique   
(class template)   
[ unordered_multimap](../container/unordered_multimap.html "cpp/container/unordered multimap")(C++11) |  collection of key-value pairs, hashed by keys   
(class template)   
[ unordered_set](../container/unordered_set.html "cpp/container/unordered set")(C++11) |  collection of unique keys, hashed by keys   
(class template)   
[ unordered_multiset](../container/unordered_multiset.html "cpp/container/unordered multiset")(C++11) |  collection of keys, hashed by keys   
(class template)   
  
### Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[LWG 2839](https://cplusplus.github.io/LWG/issue2839) | C++11  | self move assignment of standard containers was not allowed  | allowed but the result is unspecified 
