[C++](../../cpp.html "cpp")

[Compiler support](../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../freestanding.html "cpp/freestanding")  
[Language](../language.html "cpp/language")  
[Standard library](../standard_library.html "cpp/standard library")  
[Standard library headers](../headers.html "cpp/header")  
[Named requirements](../iterator/concepts.html "cpp/named req")  
[Feature test macros](../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../utility.html#Language_support "cpp/utility")  
[Concepts library](../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../error.html "cpp/error")  
[Memory management library](../memory.html "cpp/memory")  
[Metaprogramming library](../meta.html "cpp/meta") (C++11)  
[General utilities library](../utility.html "cpp/utility")  
[Containers library](../container.html "cpp/container")  
[Iterators library](../iterator.html "cpp/iterator")  
[Ranges library](../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../algorithm.html "cpp/algorithm")  
[Strings library](../string.html "cpp/string")  
[Text processing library](../text.html "cpp/text")  
[Numerics library](../numeric.html "cpp/numeric")  
[Date and time library](../chrono.html "cpp/chrono")  
[Input/output library](../io.html "cpp/io")  
[Filesystem library](../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../atomic.html "cpp/thread") (C++11)  
[Execution control library](../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../experimental.html "cpp/experimental")  
[Symbols index](../symbol_index.html "cpp/symbol index")  
[External libraries](../links/libs.html "cpp/links/libs")  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/navbar_content&action=edit)

[C++ named requirements](../iterator/concepts.html "cpp/named req")

| [Basic](../iterator/concepts.html#Basic "cpp/named req")  
---  
[DefaultConstructible](DefaultConstructible.html "cpp/named req/DefaultConstructible")  
[MoveConstructible](MoveConstructible.html "cpp/named req/MoveConstructible")(C++11)  
[CopyConstructible](CopyConstructible.html "cpp/named req/CopyConstructible")  
[CopyAssignable](CopyAssignable.html "cpp/named req/CopyAssignable")  
[MoveAssignable](MoveAssignable.html "cpp/named req/MoveAssignable")(C++11)  
[Destructible](Destructible.html "cpp/named req/Destructible")  
[Type properties](../iterator/concepts.html#Type_properties "cpp/named req")  
[ScalarType](ScalarType.html "cpp/named req/ScalarType")  
[PODType](PODType.html "cpp/named req/PODType")  
[TriviallyCopyable](TriviallyCopyable.html "cpp/named req/TriviallyCopyable")(C++11)  
[TrivialType](TrivialType.html "cpp/named req/TrivialType")(C++11)  
[StandardLayoutType](StandardLayoutType.html "cpp/named req/StandardLayoutType")(C++11)` `  
[ImplicitLifetimeType](ImplicitLifetimeType.html "cpp/named req/ImplicitLifetimeType")  
[Library-wide](../iterator/concepts.html#Library-wide "cpp/named req")  
[BooleanTestable](BooleanTestable.html "cpp/named req/BooleanTestable")  
[EqualityComparable](EqualityComparable.html "cpp/named req/EqualityComparable")  
[LessThanComparable](LessThanComparable.html "cpp/named req/LessThanComparable")  
[Swappable](Swappable.html "cpp/named req/Swappable")  
[ValueSwappable](ValueSwappable.html "cpp/named req/ValueSwappable")(C++11)  
[NullablePointer](NullablePointer.html "cpp/named req/NullablePointer")(C++11)  
[Hash](Hash.html "cpp/named req/Hash")(C++11)  
[Allocator](Allocator.html "cpp/named req/Allocator")  
[FunctionObject](FunctionObject.html "cpp/named req/FunctionObject")  
[Callable](Callable.html "cpp/named req/Callable")  
[Predicate](Predicate.html "cpp/named req/Predicate")  
[BinaryPredicate](BinaryPredicate.html "cpp/named req/BinaryPredicate")  
[Compare](Compare.html "cpp/named req/Compare")  
  
  
  
  
  
  
  
  
  
| [Container](../iterator/concepts.html#Container "cpp/named req")  
---  
[Container](Container.html "cpp/named req/Container")  
[ReversibleContainer](ReversibleContainer.html "cpp/named req/ReversibleContainer")  
[AllocatorAwareContainer](AllocatorAwareContainer.html "cpp/named req/AllocatorAwareContainer")  
**SequenceContainer**  
[ContiguousContainer](ContiguousContainer.html "cpp/named req/ContiguousContainer")(C++17)  
[AssociativeContainer](AssociativeContainer.html "cpp/named req/AssociativeContainer")  
[UnorderedAssociativeContainer](UnorderedAssociativeContainer.html "cpp/named req/UnorderedAssociativeContainer")(C++11)` `  
[Container element](../iterator/concepts.html#Container_element "cpp/named req")  
[DefaultInsertable](DefaultInsertable.html "cpp/named req/DefaultInsertable")(C++11)  
[CopyInsertable](CopyInsertable.html "cpp/named req/CopyInsertable")(C++11)  
[MoveInsertable](MoveInsertable.html "cpp/named req/MoveInsertable")(C++11)  
[EmplaceConstructible](EmplaceConstructible.html "cpp/named req/EmplaceConstructible")(C++11)  
[Erasable](Erasable.html "cpp/named req/Erasable")(C++11)  
[Iterator](../iterator/concepts.html#Iterator "cpp/named req")  
[LegacyIterator](Iterator.html "cpp/named req/Iterator")  
[LegacyInputIterator](InputIterator.html "cpp/named req/InputIterator")  
[LegacyOutputIterator](OutputIterator.html "cpp/named req/OutputIterator")  
[LegacyForwardIterator](ForwardIterator.html "cpp/named req/ForwardIterator")  
[LegacyBidirectionalIterator](BidirectionalIterator.html "cpp/named req/BidirectionalIterator")  
[LegacyRandomAccessIterator](RandomAccessIterator.html "cpp/named req/RandomAccessIterator")  
[LegacyContiguousIterator](ContiguousIterator.html "cpp/named req/ContiguousIterator")(C++17)  
[ConstexprIterator](ConstexprIterator.html "cpp/named req/ConstexprIterator")(C++20)  
[Stream I/O](../iterator/concepts.html#Stream_I.2FO_functions "cpp/named req")  
[FormattedInputFunction](FormattedInputFunction.html "cpp/named req/FormattedInputFunction")  
[UnformattedInputFunction](UnformattedInputFunction.html "cpp/named req/UnformattedInputFunction")  
[FormattedOutputFunction](FormattedOutputFunction.html "cpp/named req/FormattedOutputFunction")  
[UnformattedOutputFunction](UnformattedOutputFunction.html "cpp/named req/UnformattedOutputFunction")  
[Formatters](../iterator/concepts.html#Formatters "cpp/named req")  
[BasicFormatter](BasicFormatter.html "cpp/named req/BasicFormatter")(C++20)  
[Formatter](Formatter.html "cpp/named req/Formatter")(C++20)  
  
| [Random Numbers](../iterator/concepts.html#Random_Number_Generation "cpp/named req")  
---  
[SeedSequence](SeedSequence.html "cpp/named req/SeedSequence")(C++11)  
[RandomNumberEngine](RandomNumberEngine.html "cpp/named req/RandomNumberEngine")(C++11)  
[RandomNumberDistribution](RandomNumberDistribution.html "cpp/named req/RandomNumberDistribution")(C++11)  
[UniformRandomBitGenerator](UniformRandomBitGenerator.html "cpp/named req/UniformRandomBitGenerator")(C++11)  
[RandomNumberEngineAdaptor](RandomNumberEngineAdaptor.html "cpp/named req/RandomNumberEngineAdaptor")(C++11)  
[Concurrency](../iterator/concepts.html#Concurrency "cpp/named req")  
[BasicLockable](BasicLockable.html "cpp/named req/BasicLockable")(C++11)  
[Lockable](Lockable.html "cpp/named req/Lockable")(C++11)  
[TimedLockable](TimedLockable.html "cpp/named req/TimedLockable")(C++11)  
[SharedLockable](SharedLockable.html "cpp/named req/SharedLockable")(C++14)  
[SharedTimedLockable](SharedTimedLockable.html "cpp/named req/SharedTimedLockable")(C++14)  
[Mutex](Mutex.html "cpp/named req/Mutex")(C++11)  
[TimedMutex](TimedMutex.html "cpp/named req/TimedMutex")(C++11)  
[SharedMutex](SharedMutex.html "cpp/named req/SharedMutex")(C++17)  
[SharedTimedMutex](SharedTimedMutex.html "cpp/named req/SharedTimedMutex")(C++14)  
[Ranges](../iterator/concepts.html#Ranges "cpp/named req")  
[RangeAdaptorObject](RangeAdaptorObject.html "cpp/named req/RangeAdaptorObject")(C++20)  
[RangeAdaptorClosureObject](RangeAdaptorClosureObject.html "cpp/named req/RangeAdaptorClosureObject")(C++20)  
[Multidimensional View](../iterator/concepts.html#Multidimensional_View_Customization "cpp/named req")  
[LayoutMapping](LayoutMapping.html "cpp/named req/LayoutMapping")(C++23)  
[LayoutMappingPolicy](LayoutMappingPolicy.html "cpp/named req/LayoutMappingPolicy")(C++23)  
[AccessorPolicy](AccessorPolicy.html "cpp/named req/AccessorPolicy")(C++23)  
[Other](../iterator/concepts.html#Other "cpp/named req")  
| [CharTraits](CharTraits.html "cpp/named req/CharTraits")  
---  
[RegexTraits](RegexTraits.html "cpp/named req/RegexTraits")(C++11)` `  
[BitmaskType](BitmaskType.html "cpp/named req/BitmaskType")  
[LiteralType](LiteralType.html "cpp/named req/LiteralType")(C++11)  
[NumericType](NumericType.html "cpp/named req/NumericType")  
  
| [UnaryTypeTrait](UnaryTypeTrait.html "cpp/named req/UnaryTypeTrait")(C++11)  
---  
[BinaryTypeTrait](BinaryTypeTrait.html "cpp/named req/BinaryTypeTrait")(C++11)  
[TransformationTrait](TransformationTrait.html "cpp/named req/TransformationTrait")(C++11)  
[Clock](Clock.html "cpp/named req/Clock")(C++11)  
[TrivialClock](TrivialClock.html "cpp/named req/TrivialClock")(C++11)  
  
  
  
  
[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/named_req/navbar_content&action=edit)

A **SequenceContainer** is a [Container](Container.html "cpp/named req/Container") that stores objects of the same type in a linear arrangement. 

## Contents

  * [1 Requirements](SequenceContainer.html#Requirements)
  * [2 Standard library](SequenceContainer.html#Standard_library)
    * [2.1 Usage notes](SequenceContainer.html#Usage_notes)
  * [3 Defect reports](SequenceContainer.html#Defect_reports)

  
---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/named_req/SequenceContainer&action=edit&section=1 "Edit section: Requirements")] Requirements

Given the following types and values: 

Type  |  Definition   
---|---  
`C` |  a sequence container class   
`T` |  the element type of `C`  
`A` |  the allocator type of `C`: 

  * `C::allocator_type` if it exists, 
  * otherwise [std::allocator](../memory/allocator.html)<T>

  
`R` (since C++23) |  a type that models [`_container-compatible-range_`](../ranges/to.html#container_compatible_range "cpp/ranges/to") ﻿`<T>`  
`Args` (since C++11) |  a template parameter pack   
`Iter` |  `C::iterator`  
`Ref` |  `C::reference`  
`CRef` |  `C::const_reference`  
Value  |  Definition   
v |  a value of type `C`  
cv |  a value of type const C  
i, j |  [LegacyInputIterators](InputIterator.html "cpp/named req/InputIterator") such that `[`i`, `j`)` is a [valid range](../iterator.html#Ranges "cpp/iterator") and that the iterators refer to elements implicitly convertible to `C::value_type`  
rg (since C++23) |  a value of type `R`  
il (since C++11) |  a value of type [std::initializer_list](../utility/initializer_list.html)<C::value_type>  
n |  a value of type `C::size_type`  
p |  a valid [const iterator](../iterator.html "cpp/iterator") into v  
q |  a [valid dereferenceable](../iterator.html#Dereferenceability_and_validity "cpp/iterator") const iterator into v  
q1, q2 |  const iterators into v such that `[`q1`, `q2`)` is a valid range   
t |  a value(until C++11)an [lvalue](../language/value_category.html "cpp/language/value category") or const rvalue(since C++11) of type `C::value_type`  
rv (since C++11) |  a non-const rvalue of type `C::value_type`  
args (since C++11) |  a function parameter pack with the pattern `Arg&&`  
  
`C` satisfies the requirements of SequenceContainer if all following conditions are satisfied: 

  * `C` satisfies the requirements of [Container](Container.html "cpp/named req/Container"). 
  * The following statements and expressions are well-formed and have the specified semantics: 



Basic operations  
(required for all sequence containers in the [standard library](SequenceContainer.html#Standard_library) except [std::array](../container/array.html "cpp/container/array")(since C++11))  
---  
Statement  |  Semantics[[1]](SequenceContainer.html#cite_note-1)  
C c(n, t); | Effect  | Constructs the sequence container holding n copies of t.   
Precondition  |  |  `T` is [CopyInsertable](CopyInsertable.html "cpp/named req/CopyInsertable") into `C`.  | (since C++11)  
---|---  
Postcondition  | [std::distance](../iterator/distance.html)(c.begin(), c.end()) is n.   
C c(i, j); | Effect  | Constructs the sequence container equal, element-wise, to the range `[`i`, `j`)`. 

  * Each iterator in the range `[`i`, `j`)` is dereferenced exactly once. 

  
Precondition  |  |  `T` is [EmplaceConstructible](EmplaceConstructible.html "cpp/named req/EmplaceConstructible") into `C` from *i.  | (since C++11)  
---|---  
Postcondition  | [std::distance](../iterator/distance.html)(c.begin(), c.end()) is [std::distance](../iterator/distance.html)(i, j).   
Expression  |  Type  | Semantics   
C([std::from_range](../ranges/from_range.html), rg)  
(since C++23) | `C` | Effect  | Constructs the sequence container equal, element-wise, to the range rg. 

  * Each iterator in the range rg is dereferenced exactly once. 

  
Precondition  | `T` is [EmplaceConstructible](EmplaceConstructible.html "cpp/named req/EmplaceConstructible") into `X` from *[ranges::begin](../ranges/begin.html)(rg).   
Postcondition  | [std::distance](../iterator/distance.html)(begin(), end()) is [ranges::distance](../iterator/ranges/distance.html)(rg).   
C(il)  
(since C++11) | `C` | Equivalent to C(il.begin(), il.end()).   
v = il  
(since C++11) | `C&` | Effect  | Assigns the range represented by il into v.[[2]](SequenceContainer.html#cite_note-2)  
Return value  | *this  
Precondition  | `T` is [CopyInsertable](CopyInsertable.html "cpp/named req/CopyInsertable") into `C` and [CopyAssignable](CopyAssignable.html "cpp/named req/CopyAssignable").   
Postcondition  | Existing elements of v are either destroyed or assigned to.   
v.emplace(p, args)  
(since C++11) | `Iter` | Effect  | Insert an object of type `T`, constructed with [std::forward](../utility/forward.html)<Args>(args)... before p.   
Return value  | An iterator that points to the new element constructed from args into v.   
Precondition  | `T` is [EmplaceConstructible](EmplaceConstructible.html "cpp/named req/EmplaceConstructible") into `C` from args.   
v.insert(p, t) | `Iter` | Effect  | Inserts a copy of t before p.   
Return value  | An iterator that points to the copy of t inserted into v.   
Precondition  |  |  `T` is [CopyInsertable](CopyInsertable.html "cpp/named req/CopyInsertable") into `C`.  | (since C++11)  
---|---  
v.insert(p, rv)  
(since C++11) | `Iter` | Effect  | Inserts a copy of rv before p, possibly using move semantics.   
Return value  | An iterator that points to the copy of rv inserted into v.   
Precondition  | `T` is [MoveInsertable](MoveInsertable.html "cpp/named req/MoveInsertable") into `C`.   
v.insert(p, n, t) | `Iter` | Effect  | Inserts n copies of t before p.   
Return value  | An iterator that points to the copy of the first element inserted into v, or p if n is ​0​.   
Precondition  |  |  `T` is [CopyInsertable](CopyInsertable.html "cpp/named req/CopyInsertable") into `C` and [CopyAssignable](CopyAssignable.html "cpp/named req/CopyAssignable").  | (since C++11)  
---|---  
v.insert(p, i, j) | `Iter` | Effect  | Inserts copies of elements in `[`i`, `j`)` before p. 

  * Each iterator in the range `[`i`, `j`)` is dereferenced exactly once. 

  
Return value  | An iterator that points to the copy of the first element inserted into v, or p if i == j is true.   
Precondition  |  | 

  * `T` is [EmplaceConstructible](EmplaceConstructible.html "cpp/named req/EmplaceConstructible") into `C` from *i. 

| (since C++11)  
---|---  
  
  * i and j are not in v. 

  
v.insert_range(p, rg)  
(since C++23) | `Iter` | Effect  | Inserts copies of elements in rg before p. 

  * Each iterator in the range rg is dereferenced exactly once. 

  
Return value  | An iterator that points to the copy of the first element inserted into v, or p if rg is empty.   
Precondition  | 

  * `T` is [EmplaceConstructible](EmplaceConstructible.html "cpp/named req/EmplaceConstructible") into `C` from *[ranges::begin](../ranges/begin.html)(rg). 
  * rg and v do not overlap. 

  
v.insert(p, il)  
(since C++11) | `Iter` | Equivalent to v.insert(p, il.begin(), il.end()).   
v.erase(q) | `Iter` | Effect  | Erases the element pointed to by q.   
Return value  | An iterator that points to the element immediately following q prior to the element being erased, or v.end() if no such element exists.   
v.erase(q1, q2) | `Iter` | Effect  | Erases elements in `[`q1`, `q2`)`.   
Return value  | An iterator that points to the element pointed to by q2 prior to any elements being erased, or v.end() if no such element exists.   
v.clear() | void | Effect  | Destroys all elements in v. 

  * Invalidates all references, pointers, and iterators referring to the elements of v and may invalidate the past-the-end iterator. 

  
Postcondition  | v.empty() is true.   
Complexity  | Linear.   
v.assign(i, j) | void | Effect  | Replaces elements in v with a copy of `[`i`, `j`)`. 

  * Invalidates all references, pointers and iterators referring to the elements of v. 
  * Each iterator in `[`i`, `j`)` is dereferenced exactly once. 

  
Precondition  |  | 

  * `T` is [EmplaceConstructible](EmplaceConstructible.html "cpp/named req/EmplaceConstructible") into `C` from *i. 
  * `T` is assignable from *i. 

| (since C++11)  
---|---  
  
  * i and j are not in v. 

  
v.assign_range(rg)  
(since C++23) | void | Effect  | Replaces elements in v with a copy of each element in rg. 

  * If [std::assignable_from](../concepts/assignable_from.html)  
` `<T&, [ranges::range_reference_t](../ranges/range_reference_t.html)<R>> is not modeled, the program is ill-formed. 
  * Invalidates all references, pointers and iterators referring to the elements of v. 
  * Each iterator in the range rg is dereferenced exactly once. 

  
Precondition  | 

  * `T` is [EmplaceConstructible](EmplaceConstructible.html "cpp/named req/EmplaceConstructible") into `C` from *[ranges::begin](../ranges/begin.html)(rg). 
  * rg and v do not overlap. 

  
v.assign(il)  
(since C++11) | void | Equivalent to v.assign(il.begin(), il.end()).   
v.assign(n, t) | void | Effect  | Replaces elements in v with n copies of t.   
Precondition  |  |  `T` is [CopyInsertable](CopyInsertable.html "cpp/named req/CopyInsertable") into `C` and [CopyAssignable](CopyAssignable.html "cpp/named req/CopyAssignable").  | (since C++11)  
---|---  
Extra operations[[3]](SequenceContainer.html#cite_note-3)  
(only required for specified sequence containers, omitting `std::`)  
Expression  |  Type  | Semantics   
v.front() | `Ref` | Containers  | `[basic_string](../string/basic_string.html "cpp/string/basic string"), [array](../container/array.html "cpp/container/array"), [vector](../container/vector.html "cpp/container/vector"), [inplace_vector](../container/inplace_vector.html "cpp/container/inplace vector"), [deque](../container/deque.html "cpp/container/deque"), [list](../container/list.html "cpp/container/list"), [forward_list](../container/forward_list.html "cpp/container/forward list")`  
Return value  | *v.begin()  
cv.front() | `CRef` | Containers  | `[basic_string](../string/basic_string.html "cpp/string/basic string"), [array](../container/array.html "cpp/container/array"), [vector](../container/vector.html "cpp/container/vector"), [inplace_vector](../container/inplace_vector.html "cpp/container/inplace vector"), [deque](../container/deque.html "cpp/container/deque"), [list](../container/list.html "cpp/container/list"), [forward_list](../container/forward_list.html "cpp/container/forward list")`  
Return value  | *cv.begin()  
v.back() | `Ref` | Containers  | `[basic_string](../string/basic_string.html "cpp/string/basic string"), [array](../container/array.html "cpp/container/array"), [vector](../container/vector.html "cpp/container/vector"), [inplace_vector](../container/inplace_vector.html "cpp/container/inplace vector"), [deque](../container/deque.html "cpp/container/deque"), [list](../container/list.html "cpp/container/list")`  
Equivalent to auto tmp = v.end(); \--tmp; return *tmp;[[4]](SequenceContainer.html#cite_note-4).   
cv.back() | `CRef` | Containers  | `[basic_string](../string/basic_string.html "cpp/string/basic string"), [array](../container/array.html "cpp/container/array"), [vector](../container/vector.html "cpp/container/vector"), [inplace_vector](../container/inplace_vector.html "cpp/container/inplace vector"), [deque](../container/deque.html "cpp/container/deque"), [list](../container/list.html "cpp/container/list")`  
Equivalent to auto tmp = cv.end(); \--tmp; return *tmp;[[5]](SequenceContainer.html#cite_note-5).   
v.emplace_front(args)  
(since C++11) | void | Containers  | `[deque](../container/deque.html "cpp/container/deque"), [list](../container/list.html "cpp/container/list"), [forward_list](../container/forward_list.html "cpp/container/forward list")`  
Effect  | Prepends an object of type `T` constructed with [std::forward](../utility/forward.html)<Args>(args)....   
Return value  | v.front()  
Precondition  | `T` is [EmplaceConstructible](EmplaceConstructible.html "cpp/named req/EmplaceConstructible") into `C` from args.   
v.emplace_back(args)  
(since C++11) | void | Containers  | `[vector](../container/vector.html "cpp/container/vector"), [inplace_vector](../container/inplace_vector.html "cpp/container/inplace vector"), [deque](../container/deque.html "cpp/container/deque"), [list](../container/list.html "cpp/container/list")`  
Effect  | Appends an object of type `T` constructed with [std::forward](../utility/forward.html)<Args>(args)....   
Return value  | v.back()  
Precondition  | `T` is [EmplaceConstructible](EmplaceConstructible.html "cpp/named req/EmplaceConstructible") into `C` from args.   
v.push_front(t) | void | Containers  | `[deque](../container/deque.html "cpp/container/deque"), [list](../container/list.html "cpp/container/list"), [forward_list](../container/forward_list.html "cpp/container/forward list")`  
Effect  | Prepends a copy of t.   
Precondition  |  |  `T` is [CopyInsertable](CopyInsertable.html "cpp/named req/CopyInsertable") into `C`.  | (since C++11)  
---|---  
v.push_front(rv)  
(since C++11) | void | Containers  | `[deque](../container/deque.html "cpp/container/deque"), [list](../container/list.html "cpp/container/list"), [forward_list](../container/forward_list.html "cpp/container/forward list")`  
Effect  | Prepends a copy of rv, possibly using move semantics.   
Precondition  | `T` is [MoveInsertable](MoveInsertable.html "cpp/named req/MoveInsertable") into `C`.   
v.prepend_range(rg)  
(since C++23) | void | Containers  | `[deque](../container/deque.html "cpp/container/deque"), [list](../container/list.html "cpp/container/list"), [forward_list](../container/forward_list.html "cpp/container/forward list")`  
Effect  | Inserts[[6]](SequenceContainer.html#cite_note-range-6) copies of elements in rg before v.begin(). 

  * Each iterator in the range rg is dereferenced exactly once. 

  
Precondition  | `T` is [EmplaceConstructible](EmplaceConstructible.html "cpp/named req/EmplaceConstructible") into `C` from *[ranges::begin](../ranges/begin.html)(rg).   
v.push_back(t) | void | Containers  | `[basic_string](../string/basic_string.html "cpp/string/basic string"), [vector](../container/vector.html "cpp/container/vector"), [inplace_vector](../container/inplace_vector.html "cpp/container/inplace vector"), [deque](../container/deque.html "cpp/container/deque"), [list](../container/list.html "cpp/container/list")`  
Effect  | Appends a copy of t.   
Precondition  |  |  `T` is [CopyInsertable](CopyInsertable.html "cpp/named req/CopyInsertable") into `C`.  | (since C++11)  
---|---  
v.push_back(rv)  
(since C++11) | void | Containers  | `[basic_string](../string/basic_string.html "cpp/string/basic string"), [vector](../container/vector.html "cpp/container/vector"), [inplace_vector](../container/inplace_vector.html "cpp/container/inplace vector"), [deque](../container/deque.html "cpp/container/deque"), [list](../container/list.html "cpp/container/list")`  
Effect  | Appends a copy of rv, possibly using move semantics.   
Precondition  | `T` is [MoveInsertable](MoveInsertable.html "cpp/named req/MoveInsertable") into `C`.   
v.append_range(rg)  
(since C++23) | void | Containers  | `[vector](../container/vector.html "cpp/container/vector"), [inplace_vector](../container/inplace_vector.html "cpp/container/inplace vector"), [deque](../container/deque.html "cpp/container/deque"), [list](../container/list.html "cpp/container/list")`  
Effect  | Inserts[[6]](SequenceContainer.html#cite_note-range-6) copies of elements in rg before v.end(). 

  * Each iterator in the range rg is dereferenced exactly once. 

  
Precondition  | `T` is [EmplaceConstructible](EmplaceConstructible.html "cpp/named req/EmplaceConstructible") into `C` from *[ranges::begin](../ranges/begin.html)(rg).   
v.pop_front() | void | Containers  | `[deque](../container/deque.html "cpp/container/deque"), [list](../container/list.html "cpp/container/list"), [forward_list](../container/forward_list.html "cpp/container/forward list")`  
Effect  | Destroys the first element.   
Precondition  | a.empty() is false.   
v.pop_back() | void | Containers  | `[basic_string](../string/basic_string.html "cpp/string/basic string"), [vector](../container/vector.html "cpp/container/vector"), [inplace_vector](../container/inplace_vector.html "cpp/container/inplace vector"), [deque](../container/deque.html "cpp/container/deque"), [list](../container/list.html "cpp/container/list")`  
Effect  | Destroys the last element.   
Precondition  | a.empty() is false.   
v[n] | `Ref` | Containers  | `[basic_string](../string/basic_string.html "cpp/string/basic string"), [array](../container/array.html "cpp/container/array"), [vector](../container/vector.html "cpp/container/vector"), [inplace_vector](../container/inplace_vector.html "cpp/container/inplace vector"), [deque](../container/deque.html "cpp/container/deque")`  
Equivalent to return *(v.begin() + n);.   
cv[n] | `CRef` | Containers  | `[basic_string](../string/basic_string.html "cpp/string/basic string"), [array](../container/array.html "cpp/container/array"), [vector](../container/vector.html "cpp/container/vector"), [inplace_vector](../container/inplace_vector.html "cpp/container/inplace vector"), [deque](../container/deque.html "cpp/container/deque")`  
Equivalent to return *(cv.begin() + n);.   
v.at(n) | `Ref` | Containers  | `[basic_string](../string/basic_string.html "cpp/string/basic string"), [array](../container/array.html "cpp/container/array"), [vector](../container/vector.html "cpp/container/vector"), [inplace_vector](../container/inplace_vector.html "cpp/container/inplace vector"), [deque](../container/deque.html "cpp/container/deque")`  
Return value  | *(v.begin() + n)  
Exceptions  | Throws [std::out_of_range](../error/out_of_range.html "cpp/error/out of range") if n >= v.size() is true.   
cv.at(n) | `CRef` | Containers  | `[basic_string](../string/basic_string.html "cpp/string/basic string"), [array](../container/array.html "cpp/container/array"), [vector](../container/vector.html "cpp/container/vector"), [inplace_vector](../container/inplace_vector.html "cpp/container/inplace vector"), [deque](../container/deque.html "cpp/container/deque")`  
Return value  | *(cv.begin() + n)  
Exceptions  | Throws [std::out_of_range](../error/out_of_range.html "cpp/error/out of range") if n >= cv.size() is true.   
Notes   
  
  1. [↑](SequenceContainer.html#cite_ref-1) For an expression whose effect is equivalent to some other operations, the conditions of the expressions inside those operations are inherited on top of the conditions listed in the table.
  2. [↑](SequenceContainer.html#cite_ref-2) [std::array](../container/array.html "cpp/container/array") supports assignment from a [brace-enclosed initializer list](../language/initialization.html "cpp/language/initialization"), but not from an [std::initializer_list](../utility/initializer_list.html "cpp/utility/initializer list").
  3. [↑](SequenceContainer.html#cite_ref-3) All operations below except `prepend_range` and `append_range`(since C++23) take amortized constant time.
  4. [↑](SequenceContainer.html#cite_ref-4) In C++98, tmp was declared to have type `C::iterator`.
  5. [↑](SequenceContainer.html#cite_ref-5) In C++98, tmp was declared to have type `C::const_iterator`.
  6. ↑ [6.0](SequenceContainer.html#cite_ref-range_6-0) [6.1](SequenceContainer.html#cite_ref-range_6-1) Insertion order, relative to order of elements in rg, is non-reversing.

  
  
Additionally, for every sequence container: 

  * A constructor template that takes two input iterators and the member function template overloads of `insert`, `append`, `assign`, `replace` that take two input iterators do not participate in overload resolution if the corresponding template argument does not satisfy [LegacyInputIterator](InputIterator.html "cpp/named req/InputIterator"). 



  * A deduction guide that has either a [LegacyInputIterator](InputIterator.html "cpp/named req/InputIterator") or an `Allocator` template parameter does not participate in overload resolution if the type that does not qualify as an input iterator or an allocator respectively is deduced for that parameter. 

| (since C++17)  
---|---  
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/named_req/SequenceContainer&action=edit&section=2 "Edit section: Standard library")] Standard library

The following standard library string types and containers satisfy the SequenceContainer requirements: 

[ basic_string](../string/basic_string.html "cpp/string/basic string") |  stores and manipulates sequences of characters   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/string/dsc_basic_string&action=edit)  
---|---  
[ array](../container/array.html "cpp/container/array")(C++11) |  fixed-sized inplace contiguous array   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/container/dsc_array&action=edit)  
[ vector](../container/vector.html "cpp/container/vector") |  resizable contiguous array   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/container/dsc_vector&action=edit)  
[ inplace_vector](../container/inplace_vector.html "cpp/container/inplace vector")(C++26) |  resizable, fixed capacity, inplace contiguous array   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/container/dsc_inplace_vector&action=edit)  
[ deque](../container/deque.html "cpp/container/deque") |  double-ended queue   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/container/dsc_deque&action=edit)  
[ forward_list](../container/forward_list.html "cpp/container/forward list")(C++11) |  singly-linked list   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/container/dsc_forward_list&action=edit)  
[ list](../container/list.html "cpp/container/list") |  doubly-linked list   
(class template) [[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/container/dsc_list&action=edit)  
  
#### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/named_req/SequenceContainer&action=edit&section=3 "Edit section: Usage notes")] Usage notes

Container  | Pros  | Cons   
---|---|---  
[std::vector](../container/vector.html "cpp/container/vector") | Fast access, contiguous storage  | Mostly inefficient insertions/deletions   
[std::inplace_vector](../container/inplace_vector.html) | Fast access, inplace contiguous storage  | Fixed capacity and mostly inefficient insertions/deletions   
[std::array](../container/array.html "cpp/container/array") | Fast access, inplace contiguous storage  | Fixed number of elements and no insertion/deletion   
[std::deque](../container/deque.html "cpp/container/deque") | Fast access, efficient insertion/deletion at the beginning/end  | Inefficient insertion/deletion in the middle of the sequence   
[std::list](../container/list.html "cpp/container/list")  
[std::forward_list](../container/forward_list.html "cpp/container/forward list") | Efficient insertion/deletion in the middle of the sequence  | Access is mostly linear-time   
  
### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/named_req/SequenceContainer&action=edit&section=4 "Edit section: Defect reports")] Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[LWG 139](https://cplusplus.github.io/LWG/issue139) | C++98  | the optional operations were not required to  
be implemented for the designated containers  | required with amortized time   
[LWG 149](https://cplusplus.github.io/LWG/issue149) | C++98  | v.insert(p, t) returned `Iter` while  
v.insert(p, n, t) and v.insert(p, n, t)  
returned void | they all return `Iter`  
[LWG 151](https://cplusplus.github.io/LWG/issue151) | C++98  | q1 was required to be dereferenceable[[1]](SequenceContainer.html#cite_note-7) | it can be non-dereferenceable   
[LWG 355](https://cplusplus.github.io/LWG/issue355) | C++98  | calling v.back() or v.pop_back() would  
execute \--v.end(), which is dangerous[[2]](SequenceContainer.html#cite_note-8) | decrements a copy  
of v.end() instead   
[LWG 589](https://cplusplus.github.io/LWG/issue589) | C++98  | the elements that i and j refer to  
might not be convertible to `C::value_type` | they are implicitly  
convertible to `C::value_type`  
[LWG 2194](https://cplusplus.github.io/LWG/issue2194) | C++11  | [std::queue](../container/queue.html "cpp/container/queue"), [std::priority_queue](../container/priority_queue.html "cpp/container/priority queue") and  
[std::stack](../container/stack.html "cpp/container/stack") were also SequenceContainers[[3]](SequenceContainer.html#cite_note-9) | they are not SequenceContainers   
[LWG 2231](https://cplusplus.github.io/LWG/issue2231) | C++11  | the complexity requirement of v.clear()  
was mistakenly omitted in C++11  | complexity reaffirmed as linear   
[LWG 3927](https://cplusplus.github.io/LWG/issue3927) | C++98  | operator[] had no implicit requirement  | added the implicit requirement   
  
  1. [↑](SequenceContainer.html#cite_ref-7) It is a defect because it makes the behavior of v.erase(v.begin(), v.end()) undefined is v is an empty container.
  2. [↑](SequenceContainer.html#cite_ref-8) If the type of v.end() is a fundamental type, \--v.end() is ill-formed. It is dangerous when the type of v is templated, in this case this bug can be difficult to be found.
  3. [↑](SequenceContainer.html#cite_ref-9) They were not documented as SequenceContainers in C++98.


