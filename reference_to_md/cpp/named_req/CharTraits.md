
  


[C++ named requirements](../iterator/concepts.html "cpp/named req")

| [Basic](../iterator/concepts.html#Basic "cpp/named req")  
---  
[DefaultConstructible](DefaultConstructible.html "cpp/named req/DefaultConstructible")  
[MoveConstructible](MoveConstructible.html "cpp/named req/MoveConstructible")(C++11)  
[CopyConstructible](CopyConstructible.html "cpp/named req/CopyConstructible")  
[CopyAssignable](CopyAssignable.html "cpp/named req/CopyAssignable")  
[MoveAssignable](MoveAssignable.html "cpp/named req/MoveAssignable")(C++11)  
[Destructible](Destructible.html "cpp/named req/Destructible")  
[Type properties](../iterator/concepts.html#Type_properties "cpp/named req")  
[ScalarType](ScalarType.html "cpp/named req/ScalarType")  
[PODType](PODType.html "cpp/named req/PODType")  
[TriviallyCopyable](TriviallyCopyable.html "cpp/named req/TriviallyCopyable")(C++11)  
[TrivialType](TrivialType.html "cpp/named req/TrivialType")(C++11)  
[StandardLayoutType](StandardLayoutType.html "cpp/named req/StandardLayoutType")(C++11)` `  
[ImplicitLifetimeType](ImplicitLifetimeType.html "cpp/named req/ImplicitLifetimeType")  
[Library-wide](../iterator/concepts.html#Library-wide "cpp/named req")  
[BooleanTestable](BooleanTestable.html "cpp/named req/BooleanTestable")  
[EqualityComparable](EqualityComparable.html "cpp/named req/EqualityComparable")  
[LessThanComparable](LessThanComparable.html "cpp/named req/LessThanComparable")  
[Swappable](Swappable.html "cpp/named req/Swappable")  
[ValueSwappable](ValueSwappable.html "cpp/named req/ValueSwappable")(C++11)  
[NullablePointer](NullablePointer.html "cpp/named req/NullablePointer")(C++11)  
[Hash](Hash.html "cpp/named req/Hash")(C++11)  
[Allocator](Allocator.html "cpp/named req/Allocator")  
[FunctionObject](FunctionObject.html "cpp/named req/FunctionObject")  
[Callable](Callable.html "cpp/named req/Callable")  
[Predicate](Predicate.html "cpp/named req/Predicate")  
[BinaryPredicate](BinaryPredicate.html "cpp/named req/BinaryPredicate")  
[Compare](Compare.html "cpp/named req/Compare")  
  
  
  
  
  
  
  
  
  
| [Container](../iterator/concepts.html#Container "cpp/named req")  
---  
[Container](Container.html "cpp/named req/Container")  
[ReversibleContainer](ReversibleContainer.html "cpp/named req/ReversibleContainer")  
[AllocatorAwareContainer](AllocatorAwareContainer.html "cpp/named req/AllocatorAwareContainer")  
[SequenceContainer](SequenceContainer.html "cpp/named req/SequenceContainer")  
[ContiguousContainer](ContiguousContainer.html "cpp/named req/ContiguousContainer")(C++17)  
[AssociativeContainer](AssociativeContainer.html "cpp/named req/AssociativeContainer")  
[UnorderedAssociativeContainer](UnorderedAssociativeContainer.html "cpp/named req/UnorderedAssociativeContainer")(C++11)` `  
[Container element](../iterator/concepts.html#Container_element "cpp/named req")  
[DefaultInsertable](DefaultInsertable.html "cpp/named req/DefaultInsertable")(C++11)  
[CopyInsertable](CopyInsertable.html "cpp/named req/CopyInsertable")(C++11)  
[MoveInsertable](MoveInsertable.html "cpp/named req/MoveInsertable")(C++11)  
[EmplaceConstructible](EmplaceConstructible.html "cpp/named req/EmplaceConstructible")(C++11)  
[Erasable](Erasable.html "cpp/named req/Erasable")(C++11)  
[Iterator](../iterator/concepts.html#Iterator "cpp/named req")  
[LegacyIterator](Iterator.html "cpp/named req/Iterator")  
[LegacyInputIterator](InputIterator.html "cpp/named req/InputIterator")  
[LegacyOutputIterator](OutputIterator.html "cpp/named req/OutputIterator")  
[LegacyForwardIterator](ForwardIterator.html "cpp/named req/ForwardIterator")  
[LegacyBidirectionalIterator](BidirectionalIterator.html "cpp/named req/BidirectionalIterator")  
[LegacyRandomAccessIterator](RandomAccessIterator.html "cpp/named req/RandomAccessIterator")  
[LegacyContiguousIterator](ContiguousIterator.html "cpp/named req/ContiguousIterator")(C++17)  
[ConstexprIterator](ConstexprIterator.html "cpp/named req/ConstexprIterator")(C++20)  
[Stream I/O](../iterator/concepts.html#Stream_I.2FO_functions "cpp/named req")  
[FormattedInputFunction](FormattedInputFunction.html "cpp/named req/FormattedInputFunction")  
[UnformattedInputFunction](UnformattedInputFunction.html "cpp/named req/UnformattedInputFunction")  
[FormattedOutputFunction](FormattedOutputFunction.html "cpp/named req/FormattedOutputFunction")  
[UnformattedOutputFunction](UnformattedOutputFunction.html "cpp/named req/UnformattedOutputFunction")  
[Formatters](../iterator/concepts.html#Formatters "cpp/named req")  
[BasicFormatter](BasicFormatter.html "cpp/named req/BasicFormatter")(C++20)  
[Formatter](Formatter.html "cpp/named req/Formatter")(C++20)  
  
| [Random Numbers](../iterator/concepts.html#Random_Number_Generation "cpp/named req")  
---  
[SeedSequence](SeedSequence.html "cpp/named req/SeedSequence")(C++11)  
[RandomNumberEngine](RandomNumberEngine.html "cpp/named req/RandomNumberEngine")(C++11)  
[RandomNumberDistribution](RandomNumberDistribution.html "cpp/named req/RandomNumberDistribution")(C++11)  
[UniformRandomBitGenerator](UniformRandomBitGenerator.html "cpp/named req/UniformRandomBitGenerator")(C++11)  
[RandomNumberEngineAdaptor](RandomNumberEngineAdaptor.html "cpp/named req/RandomNumberEngineAdaptor")(C++11)  
[Concurrency](../iterator/concepts.html#Concurrency "cpp/named req")  
[BasicLockable](BasicLockable.html "cpp/named req/BasicLockable")(C++11)  
[Lockable](Lockable.html "cpp/named req/Lockable")(C++11)  
[TimedLockable](TimedLockable.html "cpp/named req/TimedLockable")(C++11)  
[SharedLockable](SharedLockable.html "cpp/named req/SharedLockable")(C++14)  
[SharedTimedLockable](SharedTimedLockable.html "cpp/named req/SharedTimedLockable")(C++14)  
[Mutex](Mutex.html "cpp/named req/Mutex")(C++11)  
[TimedMutex](TimedMutex.html "cpp/named req/TimedMutex")(C++11)  
[SharedMutex](SharedMutex.html "cpp/named req/SharedMutex")(C++17)  
[SharedTimedMutex](SharedTimedMutex.html "cpp/named req/SharedTimedMutex")(C++14)  
[Ranges](../iterator/concepts.html#Ranges "cpp/named req")  
[RangeAdaptorObject](RangeAdaptorObject.html "cpp/named req/RangeAdaptorObject")(C++20)  
[RangeAdaptorClosureObject](RangeAdaptorClosureObject.html "cpp/named req/RangeAdaptorClosureObject")(C++20)  
[Multidimensional View](../iterator/concepts.html#Multidimensional_View_Customization "cpp/named req")  
[LayoutMapping](LayoutMapping.html "cpp/named req/LayoutMapping")(C++23)  
[LayoutMappingPolicy](LayoutMappingPolicy.html "cpp/named req/LayoutMappingPolicy")(C++23)  
[AccessorPolicy](AccessorPolicy.html "cpp/named req/AccessorPolicy")(C++23)  
[Other](../iterator/concepts.html#Other "cpp/named req")  
| **CharTraits**  
---  
[RegexTraits](RegexTraits.html "cpp/named req/RegexTraits")(C++11)` `  
[BitmaskType](BitmaskType.html "cpp/named req/BitmaskType")  
[LiteralType](LiteralType.html "cpp/named req/LiteralType")(C++11)  
[NumericType](NumericType.html "cpp/named req/NumericType")  
  
| [UnaryTypeTrait](UnaryTypeTrait.html "cpp/named req/UnaryTypeTrait")(C++11)  
---  
[BinaryTypeTrait](BinaryTypeTrait.html "cpp/named req/BinaryTypeTrait")(C++11)  
[TransformationTrait](TransformationTrait.html "cpp/named req/TransformationTrait")(C++11)  
[Clock](Clock.html "cpp/named req/Clock")(C++11)  
[TrivialClock](TrivialClock.html "cpp/named req/TrivialClock")(C++11)  
  
  
  
  


**CharTraits** is a traits class that abstracts basic character and string operations for a given character type. Most standard library string and input/output classes require a CharTraits template type parameter alongside a corresponding character template type parameter. 

## Contents

  * [1 Requirements](CharTraits.html#Requirements)
  * [2 Types](CharTraits.html#Types)
  * [3 Expressions](CharTraits.html#Expressions)
  * [4 Standard library](CharTraits.html#Standard_library)
    * [4.1 Strings](CharTraits.html#Strings)
    * [4.2 Streams](CharTraits.html#Streams)
    * [4.3 Stream iterators](CharTraits.html#Stream_iterators)
    * [4.4 Stream buffers](CharTraits.html#Stream_buffers)
    * [4.5 Stream buffer iterators](CharTraits.html#Stream_buffer_iterators)
  * [5 Defect reports](CharTraits.html#Defect_reports)

  
---  
  
### Requirements

No operation listed below on CharTraits may throw an exception. 

Given 

  * `CharT`, a character type 
  * `X`, a CharTraits type for type `CharT`
  * c, d, values of type `CharT`
  * p, q, values of type const CharT*
  * s, a value of type `CharT*`
  * n, i, j, values of type [std::size_t](../types/size_t.html "cpp/types/size t")
  * e, f, values of type `X::int_type`
  * pos, a value of type `X::pos_type`
  * state, a value of type `X::state_type`
  * r, an lvalue of type `CharT`



### Types

Type | Semantics   
---|---  
`X::char_type` |  `CharT`  
`X::int_type` |  A type that can hold all valid values of `X::char_type` plus X::eof()  
`X::off_type` |  Invokes implementation-defined behavior if not [std::streamoff](../io/streamoff.html "cpp/io/streamoff") when `X` is used as the traits template parameter in input/output classes.   
`X::pos_type` | 

  * Functions in input/output classes returning this type use X::pos_type(X::off_type(-1)) as an invalid value to signal an error 
  * Use of this invalid value as an argument to any [std::istream](../io/basic_istream.html "cpp/io/basic istream"), [std::ostream](../io/basic_ostream.html "cpp/io/basic ostream") or [std::streambuf](../io/basic_streambuf.html "cpp/io/basic streambuf") member taking a value of this type is undefined behavior 
  * Invokes implementation-defined behavior if this type is not [std::streampos](../io/fpos.html "cpp/io/fpos") when `X` is used as the traits template parameter in input/output classes 

  
`X::state_type` |  [Destructible](Destructible.html "cpp/named req/Destructible"), [CopyAssignable](CopyAssignable.html "cpp/named req/CopyAssignable"), [CopyConstructible](CopyConstructible.html "cpp/named req/CopyConstructible"), [DefaultConstructible](DefaultConstructible.html "cpp/named req/DefaultConstructible")  
  
### Expressions

Expression | Return type | Semantics |  Complexity   
---|---|---|---  
X::eq(c, d) |  bool |  Returns: whether c is to be treated as equal to d |  Constant   
X::lt(c, d) |  bool |  Returns: whether c is to be treated as less than d |  Constant   
X::compare(p, q, n) |  int |  Returns: 

  * ​0​ if for each i in `[`​0​`, `n`)`, X::eq(p[i], q[i]) is true
  * Else, a negative value if 
    * For some j in `[`​0​`, `n`)`, X::lt(p[j], q[j]) is true and 
    * For each i in `[`​0​`, `j`)`, X::eq(p[i], q[i]) is true
  * Else a positive value 

|  Linear   
X::length(p) |  [std::size_t](../types/size_t.html "cpp/types/size t") |  Returns: the smallest i such that X::eq(p[i], CharT()) is true |  Linear   
X::find(p, n, c) |  const X::char_type* |  Returns: 

  * The smallest q in `[`p`, `p + n`)` such that X::eq(*q, c) is true
  * ​0​ otherwise 

|  Linear   
X::move(s, p, n) |  `X::char_type*` | 

  * For each i in `[`​0​`, `n`)`, performs X::assign(s[i], p[i])
  * Copies correctly even where the ranges `[`p`, `p + n`)` and `[`s`, `s + n`)` overlap 
  * Returns: s

|  Linear   
X::copy(s, p, n) |  `X::char_type*` | 

  * Requires: `[`p`, `p + n`)` and `[`s`, `s + n`)` do not overlap 
  * Returns: s
  * For each i in `[`​0​`, `n`)`, performs X::assign(s[i], p[i])

|  Linear   
X::assign(r, d) |  (Not used)  |  Assigns r = d |  Constant   
X::assign(s, n, c) |  `X::char_type*` | 

  * For each i in `[`​0​`, `n`)`, performs X::assign(s[i], c). 
  * Returns: s

|  Linear   
X::not_eof(e) |  `X::int_type` |  Returns: 

  * e if X::eq_int_type(e, X::eof()) is false
  * Otherwise a value f such that X::eq_int_type(f, X::eof()) is false

|  Constant   
X::to_char_type(e) |  `X::char_type` |  Returns: 

  * If for some c, X::eq_int_type(e, X::to_int_type(c)) is true, c
  * Else some unspecified value 

|  Constant   
X::to_int_type(c) |  `X::int_type` |  Returns: some value e, constrained by the definitions of `X::to_char_type` and `X::eq_int_type` |  Constant   
X::eq_int_type(e, f) |  bool | 

  * For all c and d, X::eq(c, d) is equal to X::eq_int_type(X::to_int_type(c),  
X::to_int_type(d))
  * Returns: 
    * Yields X::eq(c, d) if for some c and d, e == X::to_int_type(c) and f == X::to_int_type(d)
    * Otherwise, yields true if e and f are both copies of X::eof()
    * Otherwise, yields false if one of e and f is a copy of X::eof() and the other is not 
    * Otherwise the value is unspecified 

|  Constant   
X::eof() |  `X::int_type` |  Returns: a value e such that X::eq_int_type(e, X::to_int_type(c)) is false for all values c |  Constant   
  
### Standard library

CharTraits is required by the following standard library class templates as a template type parameter: 

#####  Strings   
  
---  
[ basic_string](../string/basic_string.html "cpp/string/basic string") |  stores and manipulates sequences of characters   
(class template)   
[ basic_string_view](../string/basic_string_view.html "cpp/string/basic string view")(C++17) |  read-only string view   
(class template)   
  
#####  Streams   
  
[ basic_ios](../io/basic_ios.html "cpp/io/basic ios") |  manages an arbitrary stream buffer   
(class template)   
[ basic_istream](../io/basic_istream.html "cpp/io/basic istream") |  wraps a given abstract device ([std::basic_streambuf](../io/basic_streambuf.html "cpp/io/basic streambuf"))  
and provides high-level input interface   
(class template)   
[ basic_ifstream](../io/basic_ifstream.html "cpp/io/basic ifstream") |  implements high-level file stream input operations   
(class template)   
[ basic_istringstream](../io/basic_istringstream.html "cpp/io/basic istringstream") |  implements high-level string stream input operations   
(class template)   
[ basic_ispanstream](../io/basic_ispanstream.html "cpp/io/basic ispanstream")(C++23) |  implements fixed character buffer input operations   
(class template)   
[ basic_ostream](../io/basic_ostream.html "cpp/io/basic ostream") |  wraps a given abstract device ([std::basic_streambuf](../io/basic_streambuf.html "cpp/io/basic streambuf"))  
and provides high-level output interface   
(class template)   
[ basic_ofstream](../io/basic_ofstream.html "cpp/io/basic ofstream") |  implements high-level file stream output operations   
(class template)   
[ basic_ostringstream](../io/basic_ostringstream.html "cpp/io/basic ostringstream") |  implements high-level string stream output operations   
(class template)   
[ basic_osyncstream](../io/basic_osyncstream.html "cpp/io/basic osyncstream")(C++20) |  synchronized output stream wrapper   
(class template)   
[ basic_ospanstream](../io/basic_ospanstream.html "cpp/io/basic ospanstream")(C++23) |  implements fixed character buffer output operations   
(class template)   
[ basic_iostream](../io/basic_iostream.html "cpp/io/basic iostream") |  wraps a given abstract device ([std::basic_streambuf](../io/basic_streambuf.html "cpp/io/basic streambuf"))  
and provides high-level input/output interface   
(class template)   
[ basic_fstream](../io/basic_fstream.html "cpp/io/basic fstream") |  implements high-level file stream input/output operations   
(class template)   
[ basic_stringstream](../io/basic_stringstream.html "cpp/io/basic stringstream") |  implements high-level string stream input/output operations   
(class template)   
[ basic_spanstream](../io/basic_spanstream.html "cpp/io/basic spanstream")(C++23) |  implements fixed character buffer input/output operations   
(class template)   
  
#####  Stream iterators   
  
[ istream_iterator](../iterator/istream_iterator.html "cpp/iterator/istream iterator") |  input iterator that reads from [std::basic_istream](../io/basic_istream.html "cpp/io/basic istream")   
(class template)   
[ ostream_iterator](../iterator/ostream_iterator.html "cpp/iterator/ostream iterator") |  output iterator that writes to [std::basic_ostream](../io/basic_ostream.html "cpp/io/basic ostream")   
(class template)   
  
#####  Stream buffers   
  
[ basic_streambuf](../io/basic_streambuf.html "cpp/io/basic streambuf") |  abstracts a raw device   
(class template)   
[ basic_filebuf](../io/basic_filebuf.html "cpp/io/basic filebuf") |  implements raw file device   
(class template)   
[ basic_stringbuf](../io/basic_stringbuf.html "cpp/io/basic stringbuf") |  implements raw string device   
(class template)   
[ basic_syncbuf](../io/basic_syncbuf.html "cpp/io/basic syncbuf")(C++20) |  synchronized output device wrapper   
(class template)   
[ basic_spanbuf](../io/basic_spanbuf.html "cpp/io/basic spanbuf")(C++23) |  implements raw fixed character buffer device   
(class template)   
  
#####  Stream buffer iterators   
  
[ istreambuf_iterator](../iterator/istreambuf_iterator.html "cpp/iterator/istreambuf iterator") |  input iterator that reads from [std::basic_streambuf](../io/basic_streambuf.html "cpp/io/basic streambuf")   
(class template)   
[ ostreambuf_iterator](../iterator/ostreambuf_iterator.html "cpp/iterator/ostreambuf iterator") |  output iterator that writes to [std::basic_streambuf](../io/basic_streambuf.html "cpp/io/basic streambuf")   
(class template)   
  
  
CharTraits is satisfied by the following standard library explicit specializations of [std::char_traits](../string/char_traits.html "cpp/string/char traits"): 

template<> class char_traits<char>;  
template<> class char_traits<wchar_t>;  
template<> class char_traits<char8_t>;  
template<> class char_traits<char16_t>;  
template<> class char_traits<char32_t>; |  |    
  
(since C++20)  
(since C++11)  
(since C++11)  
---|---|---  
| |   
  
### Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[LWG 335](https://cplusplus.github.io/LWG/issue335) | C++98  | the requirements on the binary overload of  
`assign` did not prevent assignments to rvalues  | its first argument  
can only be an lvalue   
[LWG 352](https://cplusplus.github.io/LWG/issue352) | C++98  | `X::state_type` was only  
required to be [CopyConstructible](CopyConstructible.html "cpp/named req/CopyConstructible") | it is also required to be  
[CopyAssignable](CopyAssignable.html "cpp/named req/CopyAssignable") and [DefaultConstructible](DefaultConstructible.html "cpp/named req/DefaultConstructible")  
[LWG 3085](https://cplusplus.github.io/LWG/issue3085) | C++98  | X::copy(s, p, n) only required p not  
in `[`s`, `s + n`)`, which is too weak[[1]](CharTraits.html#cite_note-1) | requires `[`p`, `p + n`)` and  
`[`s`, `s + n`)` not to overlap   
  
  1. [↑](CharTraits.html#cite_ref-1) `[`p`, `p + n`)` and `[`s`, `s + n`)` can overlap, using [std::memcpy](../string/byte/memcpy.html "cpp/string/byte/memcpy") to implement `X::copy` results in undefined behavior in this case.


