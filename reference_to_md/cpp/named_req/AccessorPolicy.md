
  


[C++ named requirements](../iterator/concepts.html "cpp/named req")

| [Basic](../iterator/concepts.html#Basic "cpp/named req")  
---  
[DefaultConstructible](DefaultConstructible.html "cpp/named req/DefaultConstructible")  
[MoveConstructible](MoveConstructible.html "cpp/named req/MoveConstructible")(C++11)  
[CopyConstructible](CopyConstructible.html "cpp/named req/CopyConstructible")  
[CopyAssignable](CopyAssignable.html "cpp/named req/CopyAssignable")  
[MoveAssignable](MoveAssignable.html "cpp/named req/MoveAssignable")(C++11)  
[Destructible](Destructible.html "cpp/named req/Destructible")  
[Type properties](../iterator/concepts.html#Type_properties "cpp/named req")  
[ScalarType](ScalarType.html "cpp/named req/ScalarType")  
[PODType](PODType.html "cpp/named req/PODType")  
[TriviallyCopyable](TriviallyCopyable.html "cpp/named req/TriviallyCopyable")(C++11)  
[TrivialType](TrivialType.html "cpp/named req/TrivialType")(C++11)  
[StandardLayoutType](StandardLayoutType.html "cpp/named req/StandardLayoutType")(C++11)` `  
[ImplicitLifetimeType](ImplicitLifetimeType.html "cpp/named req/ImplicitLifetimeType")  
[Library-wide](../iterator/concepts.html#Library-wide "cpp/named req")  
[BooleanTestable](BooleanTestable.html "cpp/named req/BooleanTestable")  
[EqualityComparable](EqualityComparable.html "cpp/named req/EqualityComparable")  
[LessThanComparable](LessThanComparable.html "cpp/named req/LessThanComparable")  
[Swappable](Swappable.html "cpp/named req/Swappable")  
[ValueSwappable](ValueSwappable.html "cpp/named req/ValueSwappable")(C++11)  
[NullablePointer](NullablePointer.html "cpp/named req/NullablePointer")(C++11)  
[Hash](Hash.html "cpp/named req/Hash")(C++11)  
[Allocator](Allocator.html "cpp/named req/Allocator")  
[FunctionObject](FunctionObject.html "cpp/named req/FunctionObject")  
[Callable](Callable.html "cpp/named req/Callable")  
[Predicate](Predicate.html "cpp/named req/Predicate")  
[BinaryPredicate](BinaryPredicate.html "cpp/named req/BinaryPredicate")  
[Compare](Compare.html "cpp/named req/Compare")  
  
  
  
  
  
  
  
  
  
| [Container](../iterator/concepts.html#Container "cpp/named req")  
---  
[Container](Container.html "cpp/named req/Container")  
[ReversibleContainer](ReversibleContainer.html "cpp/named req/ReversibleContainer")  
[AllocatorAwareContainer](AllocatorAwareContainer.html "cpp/named req/AllocatorAwareContainer")  
[SequenceContainer](SequenceContainer.html "cpp/named req/SequenceContainer")  
[ContiguousContainer](ContiguousContainer.html "cpp/named req/ContiguousContainer")(C++17)  
[AssociativeContainer](AssociativeContainer.html "cpp/named req/AssociativeContainer")  
[UnorderedAssociativeContainer](UnorderedAssociativeContainer.html "cpp/named req/UnorderedAssociativeContainer")(C++11)` `  
[Container element](../iterator/concepts.html#Container_element "cpp/named req")  
[DefaultInsertable](DefaultInsertable.html "cpp/named req/DefaultInsertable")(C++11)  
[CopyInsertable](CopyInsertable.html "cpp/named req/CopyInsertable")(C++11)  
[MoveInsertable](MoveInsertable.html "cpp/named req/MoveInsertable")(C++11)  
[EmplaceConstructible](EmplaceConstructible.html "cpp/named req/EmplaceConstructible")(C++11)  
[Erasable](Erasable.html "cpp/named req/Erasable")(C++11)  
[Iterator](../iterator/concepts.html#Iterator "cpp/named req")  
[LegacyIterator](Iterator.html "cpp/named req/Iterator")  
[LegacyInputIterator](InputIterator.html "cpp/named req/InputIterator")  
[LegacyOutputIterator](OutputIterator.html "cpp/named req/OutputIterator")  
[LegacyForwardIterator](ForwardIterator.html "cpp/named req/ForwardIterator")  
[LegacyBidirectionalIterator](BidirectionalIterator.html "cpp/named req/BidirectionalIterator")  
[LegacyRandomAccessIterator](RandomAccessIterator.html "cpp/named req/RandomAccessIterator")  
[LegacyContiguousIterator](ContiguousIterator.html "cpp/named req/ContiguousIterator")(C++17)  
[ConstexprIterator](ConstexprIterator.html "cpp/named req/ConstexprIterator")(C++20)  
[Stream I/O](../iterator/concepts.html#Stream_I.2FO_functions "cpp/named req")  
[FormattedInputFunction](FormattedInputFunction.html "cpp/named req/FormattedInputFunction")  
[UnformattedInputFunction](UnformattedInputFunction.html "cpp/named req/UnformattedInputFunction")  
[FormattedOutputFunction](FormattedOutputFunction.html "cpp/named req/FormattedOutputFunction")  
[UnformattedOutputFunction](UnformattedOutputFunction.html "cpp/named req/UnformattedOutputFunction")  
[Formatters](../iterator/concepts.html#Formatters "cpp/named req")  
[BasicFormatter](BasicFormatter.html "cpp/named req/BasicFormatter")(C++20)  
[Formatter](Formatter.html "cpp/named req/Formatter")(C++20)  
  
| [Random Numbers](../iterator/concepts.html#Random_Number_Generation "cpp/named req")  
---  
[SeedSequence](SeedSequence.html "cpp/named req/SeedSequence")(C++11)  
[RandomNumberEngine](RandomNumberEngine.html "cpp/named req/RandomNumberEngine")(C++11)  
[RandomNumberDistribution](RandomNumberDistribution.html "cpp/named req/RandomNumberDistribution")(C++11)  
[UniformRandomBitGenerator](UniformRandomBitGenerator.html "cpp/named req/UniformRandomBitGenerator")(C++11)  
[RandomNumberEngineAdaptor](RandomNumberEngineAdaptor.html "cpp/named req/RandomNumberEngineAdaptor")(C++11)  
[Concurrency](../iterator/concepts.html#Concurrency "cpp/named req")  
[BasicLockable](BasicLockable.html "cpp/named req/BasicLockable")(C++11)  
[Lockable](Lockable.html "cpp/named req/Lockable")(C++11)  
[TimedLockable](TimedLockable.html "cpp/named req/TimedLockable")(C++11)  
[SharedLockable](SharedLockable.html "cpp/named req/SharedLockable")(C++14)  
[SharedTimedLockable](SharedTimedLockable.html "cpp/named req/SharedTimedLockable")(C++14)  
[Mutex](Mutex.html "cpp/named req/Mutex")(C++11)  
[TimedMutex](TimedMutex.html "cpp/named req/TimedMutex")(C++11)  
[SharedMutex](SharedMutex.html "cpp/named req/SharedMutex")(C++17)  
[SharedTimedMutex](SharedTimedMutex.html "cpp/named req/SharedTimedMutex")(C++14)  
[Ranges](../iterator/concepts.html#Ranges "cpp/named req")  
[RangeAdaptorObject](RangeAdaptorObject.html "cpp/named req/RangeAdaptorObject")(C++20)  
[RangeAdaptorClosureObject](RangeAdaptorClosureObject.html "cpp/named req/RangeAdaptorClosureObject")(C++20)  
[Multidimensional View](../iterator/concepts.html#Multidimensional_View_Customization "cpp/named req")  
[LayoutMapping](LayoutMapping.html "cpp/named req/LayoutMapping")(C++23)  
[LayoutMappingPolicy](LayoutMappingPolicy.html "cpp/named req/LayoutMappingPolicy")(C++23)  
**AccessorPolicy**(C++23)  
[Other](../iterator/concepts.html#Other "cpp/named req")  
| [CharTraits](CharTraits.html "cpp/named req/CharTraits")  
---  
[RegexTraits](RegexTraits.html "cpp/named req/RegexTraits")(C++11)` `  
[BitmaskType](BitmaskType.html "cpp/named req/BitmaskType")  
[LiteralType](LiteralType.html "cpp/named req/LiteralType")(C++11)  
[NumericType](NumericType.html "cpp/named req/NumericType")  
  
| [UnaryTypeTrait](UnaryTypeTrait.html "cpp/named req/UnaryTypeTrait")(C++11)  
---  
[BinaryTypeTrait](BinaryTypeTrait.html "cpp/named req/BinaryTypeTrait")(C++11)  
[TransformationTrait](TransformationTrait.html "cpp/named req/TransformationTrait")(C++11)  
[Clock](Clock.html "cpp/named req/Clock")(C++11)  
[TrivialClock](TrivialClock.html "cpp/named req/TrivialClock")(C++11)  
  
  
  
  


**AccessorPolicy** defines how elements are accessed from a given data handle to such elements and an index. It is used as a policy in [std::mdspan](../container/mdspan.html) to specify the access to a reference of an element using an underlying 1D index. 

## Contents

  * [1 Requirements](AccessorPolicy.html#Requirements)
    * [1.1 Legend](AccessorPolicy.html#Legend)
    * [1.2 Member types](AccessorPolicy.html#Member_types)
    * [1.3 Member functions](AccessorPolicy.html#Member_functions)
  * [2 Accessible range](AccessorPolicy.html#Accessible_range)
  * [3 Standard library](AccessorPolicy.html#Standard_library)

  
---  
  
### Requirements

A type `A` satisfies AccessorPolicy if it models [`copyable`](../concepts/copyable.html "cpp/concepts/copyable"), and the following are true: 

  * [std::is_nothrow_move_constructible_v](../types/is_move_constructible.html)<A>
  * [std::is_nothrow_move_assignable_v](../types/is_move_assignable.html)<A>
  * [std::is_nothrow_swappable_v](../types/is_swappable.html)<A>



And, given the following types and values, the expressions shown in the table below are valid and have the indicated semantics: 

#### Legend

Type  |  Definition   
---|---  
`A` |  an accessor policy type   
`OP` |  an offset policy type   
Value  |  Definition   
a |  a value of type (possibly const-qualified) `A`  
p |  a value of type (possibly const-qualified) `A::data_handle_type`  
i, j, n |  values of type [std::size_t](../types/size_t.html)  
  
#### Member types

Type  | Definition  | Requirements   
---|---|---  
`A::element_type` | unspecified  | 

  * A complete object type that is not an abstract class type 

  
`A::data_handle_type` | unspecified[[1]](AccessorPolicy.html#cite_note-1) | 

  * Models [`copyable`](../concepts/copyable.html "cpp/concepts/copyable")
  * The following values are all true: 



    

  * [std::is_nothrow_move_constructible_v](../types/is_move_constructible.html)  
<typename A::data_handle_type>
  * [std::is_nothrow_move_assignable_v](../types/is_move_assignable.html)  
<typename A::data_handle_type>
  * [std::is_nothrow_swappable_v](../types/is_swappable.html)  
<typename A::data_handle_type>

  
`A::reference` | unspecified[[2]](AccessorPolicy.html#cite_note-2) | 

  * [std::common_reference_with](../concepts/common_reference_with.html)<typename A::reference&&,  
typename A::element_type&> is true

  
`A::offset_policy` | `OP` | 

  * Satisfies the requirements of AccessorPolicy
  * [std::constructible_from](../concepts/constructible_from.html)<OP, const A&> is true
  * typename OP​::​element_type and typename A​::​element_type are the same type 

  
  
  1. [↑](AccessorPolicy.html#cite_ref-1) Not required to be element_type*.
  2. [↑](AccessorPolicy.html#cite_ref-2) Not required to be element_type&.



#### Member functions

Expression  | Return type  | Semantics   
---|---|---  
a.access(p, i) | typename A::reference | 

  * The expression is [equality-preserving](../concepts.html#Equality_preservation "cpp/concepts"). 

  
a.offset(p, i) | typename A::offset_policy  
` `::data_handle_type | 

  * A value q such that for b being A::offset_policy(a), and any integer n for which `[`​0​`, `n`)` is an accessible range (see below) of p and a. 



    

  * `[`​0​`, `n - i`)` is an accessible range of q and b; and 
  * b.access(q, j) provides access to the same element as a.access(p, i + j), for every j in the range `[`​0​`, `n - i`)`. 



  * The expression is [equality-preserving](../concepts.html#Equality_preservation "cpp/concepts"). 

  
  
### Accessible range

A range of indices `[`​0​`, `N`)` is an _accessible range_ of a given data handle and an accessor if, for each index in the range, the access member function produces a valid reference to an element. 

### Standard library

The following standard library types satisfy AccessorPolicy requirements: 

[ default_accessor](../container/mdspan/default_accessor.html "cpp/container/mdspan/default accessor")(C++23) |  a type for indexed access to elements of `mdspan`   
(class template)   
---|---  
[ aligned_accessor](https://en.cppreference.com/mwiki/index.php?title=cpp/container/mdspan/aligned_accessor&action=edit&redlink=1 "cpp/container/mdspan/aligned accessor（页面不存在）")(C++26) |  a type for aligned access to elements of `mdspan`   
(class template)   
Defined in namespace `std::linalg`  
[ scaled_accessor](https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/linalg/scaled_accessor&action=edit&redlink=1 "cpp/numeric/linalg/scaled accessor（页面不存在）")(C++26) |  std::mdspan accessor policy whose reference represents the product of a scaling factor that is fixed and its nested std::mdspan accessor's reference   
(class template)   
[ conjugated_accessor](https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/linalg/conjugated_accessor&action=edit&redlink=1 "cpp/numeric/linalg/conjugated accessor（页面不存在）")(C++26) |  std::mdspan accessor policy whose reference represents the complex conjugate of its nested std::mdspan accessor's reference   
(class template) 
