
  


[C++ named requirements](../iterator/concepts.html "cpp/named req")

| [Basic](../iterator/concepts.html#Basic "cpp/named req")  
---  
[DefaultConstructible](DefaultConstructible.html "cpp/named req/DefaultConstructible")  
[MoveConstructible](MoveConstructible.html "cpp/named req/MoveConstructible")(C++11)  
[CopyConstructible](CopyConstructible.html "cpp/named req/CopyConstructible")  
[CopyAssignable](CopyAssignable.html "cpp/named req/CopyAssignable")  
[MoveAssignable](MoveAssignable.html "cpp/named req/MoveAssignable")(C++11)  
[Destructible](Destructible.html "cpp/named req/Destructible")  
[Type properties](../iterator/concepts.html#Type_properties "cpp/named req")  
[ScalarType](ScalarType.html "cpp/named req/ScalarType")  
[PODType](PODType.html "cpp/named req/PODType")  
[TriviallyCopyable](TriviallyCopyable.html "cpp/named req/TriviallyCopyable")(C++11)  
[TrivialType](TrivialType.html "cpp/named req/TrivialType")(C++11)  
[StandardLayoutType](StandardLayoutType.html "cpp/named req/StandardLayoutType")(C++11)` `  
[ImplicitLifetimeType](ImplicitLifetimeType.html "cpp/named req/ImplicitLifetimeType")  
[Library-wide](../iterator/concepts.html#Library-wide "cpp/named req")  
[BooleanTestable](BooleanTestable.html "cpp/named req/BooleanTestable")  
[EqualityComparable](EqualityComparable.html "cpp/named req/EqualityComparable")  
[LessThanComparable](LessThanComparable.html "cpp/named req/LessThanComparable")  
[Swappable](Swappable.html "cpp/named req/Swappable")  
[ValueSwappable](ValueSwappable.html "cpp/named req/ValueSwappable")(C++11)  
[NullablePointer](NullablePointer.html "cpp/named req/NullablePointer")(C++11)  
[Hash](Hash.html "cpp/named req/Hash")(C++11)  
[Allocator](Allocator.html "cpp/named req/Allocator")  
[FunctionObject](FunctionObject.html "cpp/named req/FunctionObject")  
[Callable](Callable.html "cpp/named req/Callable")  
[Predicate](Predicate.html "cpp/named req/Predicate")  
[BinaryPredicate](BinaryPredicate.html "cpp/named req/BinaryPredicate")  
[Compare](Compare.html "cpp/named req/Compare")  
  
  
  
  
  
  
  
  
  
| [Container](../iterator/concepts.html#Container "cpp/named req")  
---  
[Container](Container.html "cpp/named req/Container")  
[ReversibleContainer](ReversibleContainer.html "cpp/named req/ReversibleContainer")  
[AllocatorAwareContainer](AllocatorAwareContainer.html "cpp/named req/AllocatorAwareContainer")  
[SequenceContainer](SequenceContainer.html "cpp/named req/SequenceContainer")  
[ContiguousContainer](ContiguousContainer.html "cpp/named req/ContiguousContainer")(C++17)  
[AssociativeContainer](AssociativeContainer.html "cpp/named req/AssociativeContainer")  
[UnorderedAssociativeContainer](UnorderedAssociativeContainer.html "cpp/named req/UnorderedAssociativeContainer")(C++11)` `  
[Container element](../iterator/concepts.html#Container_element "cpp/named req")  
[DefaultInsertable](DefaultInsertable.html "cpp/named req/DefaultInsertable")(C++11)  
[CopyInsertable](CopyInsertable.html "cpp/named req/CopyInsertable")(C++11)  
[MoveInsertable](MoveInsertable.html "cpp/named req/MoveInsertable")(C++11)  
[EmplaceConstructible](EmplaceConstructible.html "cpp/named req/EmplaceConstructible")(C++11)  
[Erasable](Erasable.html "cpp/named req/Erasable")(C++11)  
[Iterator](../iterator/concepts.html#Iterator "cpp/named req")  
[LegacyIterator](Iterator.html "cpp/named req/Iterator")  
[LegacyInputIterator](InputIterator.html "cpp/named req/InputIterator")  
[LegacyOutputIterator](OutputIterator.html "cpp/named req/OutputIterator")  
[LegacyForwardIterator](ForwardIterator.html "cpp/named req/ForwardIterator")  
[LegacyBidirectionalIterator](BidirectionalIterator.html "cpp/named req/BidirectionalIterator")  
[LegacyRandomAccessIterator](RandomAccessIterator.html "cpp/named req/RandomAccessIterator")  
[LegacyContiguousIterator](ContiguousIterator.html "cpp/named req/ContiguousIterator")(C++17)  
[ConstexprIterator](ConstexprIterator.html "cpp/named req/ConstexprIterator")(C++20)  
[Stream I/O](../iterator/concepts.html#Stream_I.2FO_functions "cpp/named req")  
[FormattedInputFunction](FormattedInputFunction.html "cpp/named req/FormattedInputFunction")  
[UnformattedInputFunction](UnformattedInputFunction.html "cpp/named req/UnformattedInputFunction")  
[FormattedOutputFunction](FormattedOutputFunction.html "cpp/named req/FormattedOutputFunction")  
[UnformattedOutputFunction](UnformattedOutputFunction.html "cpp/named req/UnformattedOutputFunction")  
[Formatters](../iterator/concepts.html#Formatters "cpp/named req")  
[BasicFormatter](BasicFormatter.html "cpp/named req/BasicFormatter")(C++20)  
[Formatter](Formatter.html "cpp/named req/Formatter")(C++20)  
  
| [Random Numbers](../iterator/concepts.html#Random_Number_Generation "cpp/named req")  
---  
[SeedSequence](SeedSequence.html "cpp/named req/SeedSequence")(C++11)  
[RandomNumberEngine](RandomNumberEngine.html "cpp/named req/RandomNumberEngine")(C++11)  
[RandomNumberDistribution](RandomNumberDistribution.html "cpp/named req/RandomNumberDistribution")(C++11)  
[UniformRandomBitGenerator](UniformRandomBitGenerator.html "cpp/named req/UniformRandomBitGenerator")(C++11)  
[RandomNumberEngineAdaptor](RandomNumberEngineAdaptor.html "cpp/named req/RandomNumberEngineAdaptor")(C++11)  
[Concurrency](../iterator/concepts.html#Concurrency "cpp/named req")  
[BasicLockable](BasicLockable.html "cpp/named req/BasicLockable")(C++11)  
[Lockable](Lockable.html "cpp/named req/Lockable")(C++11)  
[TimedLockable](TimedLockable.html "cpp/named req/TimedLockable")(C++11)  
[SharedLockable](SharedLockable.html "cpp/named req/SharedLockable")(C++14)  
[SharedTimedLockable](SharedTimedLockable.html "cpp/named req/SharedTimedLockable")(C++14)  
[Mutex](Mutex.html "cpp/named req/Mutex")(C++11)  
[TimedMutex](TimedMutex.html "cpp/named req/TimedMutex")(C++11)  
[SharedMutex](SharedMutex.html "cpp/named req/SharedMutex")(C++17)  
[SharedTimedMutex](SharedTimedMutex.html "cpp/named req/SharedTimedMutex")(C++14)  
[Ranges](../iterator/concepts.html#Ranges "cpp/named req")  
[RangeAdaptorObject](RangeAdaptorObject.html "cpp/named req/RangeAdaptorObject")(C++20)  
[RangeAdaptorClosureObject](RangeAdaptorClosureObject.html "cpp/named req/RangeAdaptorClosureObject")(C++20)  
[Multidimensional View](../iterator/concepts.html#Multidimensional_View_Customization "cpp/named req")  
**LayoutMapping**(C++23)  
[LayoutMappingPolicy](LayoutMappingPolicy.html "cpp/named req/LayoutMappingPolicy")(C++23)  
[AccessorPolicy](AccessorPolicy.html "cpp/named req/AccessorPolicy")(C++23)  
[Other](../iterator/concepts.html#Other "cpp/named req")  
| [CharTraits](CharTraits.html "cpp/named req/CharTraits")  
---  
[RegexTraits](RegexTraits.html "cpp/named req/RegexTraits")(C++11)` `  
[BitmaskType](BitmaskType.html "cpp/named req/BitmaskType")  
[LiteralType](LiteralType.html "cpp/named req/LiteralType")(C++11)  
[NumericType](NumericType.html "cpp/named req/NumericType")  
  
| [UnaryTypeTrait](UnaryTypeTrait.html "cpp/named req/UnaryTypeTrait")(C++11)  
---  
[BinaryTypeTrait](BinaryTypeTrait.html "cpp/named req/BinaryTypeTrait")(C++11)  
[TransformationTrait](TransformationTrait.html "cpp/named req/TransformationTrait")(C++11)  
[Clock](Clock.html "cpp/named req/Clock")(C++11)  
[TrivialClock](TrivialClock.html "cpp/named req/TrivialClock")(C++11)  
  
  
  
  


**LayoutMapping** controls the mapping of a multidimensional index to a one-dimensional offset to data handle in [std::mdspan](../container/mdspan.html). 

## Contents

  * [1 Requirements](LayoutMapping.html#Requirements)
    * [1.1 Legend](LayoutMapping.html#Legend)
    * [1.2 Member types](LayoutMapping.html#Member_types)
    * [1.3 Member functions and operators](LayoutMapping.html#Member_functions_and_operators)
  * [2 Concept](LayoutMapping.html#Concept)
  * [3 Standard library](LayoutMapping.html#Standard_library)
  * [4 See also](LayoutMapping.html#See_also)

  
---  
  
### Requirements

A type `M` satisfies LayoutMapping if it models [`copyable`](../concepts/copyable.html "cpp/concepts/copyable") and [`equality_comparable`](../concepts/equality_comparable.html "cpp/concepts/equality comparable"), and the following are true: 

  * [std::is_nothrow_move_constructible_v](../types/is_move_constructible.html)<M>
  * [std::is_nothrow_move_assignable_v](../types/is_move_assignable.html)<M>
  * [std::is_nothrow_swappable_v](../types/is_swappable.html)<M>



And, given the following types and values, the expressions shown in the table below are valid and have the indicated semantics: 

#### Legend

Type  |  Definition   
---|---  
`M` |  a layout mapping class   
Value  |  Definition   
m |  a value of type (possibly const-qualified) `M`  
i, j |  packs of (possibly const-qualified) integers that are multidimensional indices in m.extents()  
r |  a (possibly const-qualified) rank index of typename M​::​extents_type  
d_r |  a pack of (possibly const-qualified) integers for which sizeof...(d_r) == M​::​extents_type​::​rank() is true, the element at rank index r is equal to 1, and all other elements are equal to ​0​  
  
#### Member types

Name | Type | Requirements   
---|---|---  
`M::extents_type` | Specialization of class template [std::extents](../container/mdspan/extents.html) |   
`M::index_type` | typename M::extents_type::index_type |   
`M::rank_type` | typename M::extents_type::rank_type |   
`M::layout_type` | Layout mapping policy `MP` where typename MP::template mapping<E> is `M`  
for some extents type `E` | [LayoutMappingPolicy](LayoutMappingPolicy.html "cpp/named req/LayoutMappingPolicy") for which `M` is mapping type of `MP`  
  
#### Member functions and operators

Expression | Return type | Semantics   
---|---|---  
m.extents() | const typename M​::​extents_type& | Returns constant reference to associated multidimensional index space   
m(i...) | typename M​::​index_type | 

  * Returns a nonnegative integer o such that o < [std::numeric_limits](../types/numeric_limits.html)<typename M​::​index_type>​::​max() and o <= [std::numeric_limits](../types/numeric_limits.html)<[std::size_t](../types/size_t.html)>​::​max() are both true. 
  * Such expression is equivalent to m(static_cast<typename M::index_type>(i)...). 

  
m.required_span_size() | typename M​::​index_type | 

  * Returns 1 plus the maximum value of m(i...) for all i if the size of the multidimensional index space m.extents() is not 0. 
  * Otherwise, returns ​0​. 

  
m.is_unique() | bool | Returns true only if for every i and j where (i != j || ...) is true, m(i...) != m(j...) is true. [[note 1]](LayoutMapping.html#cite_note-1)  
m.is_exhaustive() | bool | Returns true only if for all k in the range `[`​0​`, `m.required_span_size()`)`, there exists an i such that m(i...) equals k. [[note 2]](LayoutMapping.html#cite_note-2)  
m.is_strided() | bool | Returns true only if for every rank index r of m.extents(), there exists an integer s_r such that, for all i where (i + d_r) is a multidimensional index in m.extents(), m((i + d_r)...) - m(i...) equals s_r. [[note 3]](LayoutMapping.html#cite_note-3)  
m.stride(r) | typename M​::​index_type | 

  * The precondition is that m.is_strided() is true. 
  * Returns a stride s_r at rank index r as defined in m.is_strided() above. 

  
M::is_always_unique() | bool | 

  * Returns true only if m.is_unique() is true for all possible objects m of type `M`. [[note 4]](LayoutMapping.html#cite_note-4)
  * The return value is always a constant expression. 

  
M::is_always_exhaustive() | bool | 

  * Returns true only if m.is_exhaustive() is true for all possible objects m of type `M`. [[note 5]](LayoutMapping.html#cite_note-5)
  * The return value is always a constant expression. 

  
M::is_always_strided() | bool | 

  * Returns true only if m.is_strided() is true for all possible objects m of type `M`. [[note 6]](LayoutMapping.html#cite_note-6)
  * The return value is always a constant expression. 

  
  
  1. [↑](LayoutMapping.html#cite_ref-1) A mapping can return false even if the condition is met. For certain layouts, it is possibly not feasible to determine efficiently whether the layout is unique.
  2. [↑](LayoutMapping.html#cite_ref-2) Same as above, but in the case of exhaustive layouts.
  3. [↑](LayoutMapping.html#cite_ref-3) Same as above, but in the case of strided layouts.
  4. [↑](LayoutMapping.html#cite_ref-4) A mapping can return false even if the condition is met. For certain layout mappings, it is possibly not feasible to determine whether every instance is unique.
  5. [↑](LayoutMapping.html#cite_ref-5) Same as above, but in the case of exhaustive instances.
  6. [↑](LayoutMapping.html#cite_ref-6) Same as above, but in the case of strided instances.



### Concept

For the constraints uses under std::layout_stride::mapping, the following exposition-only concept is defined. 

template< class M >  
concept /*layout-mapping-alike*/ = requires   
{  
requires /*is-extents*/<typename M::extents_type>;  
{ M::is_always_strided() } -> [std::same_as](../concepts/same_as.html)<bool>;  
{ M::is_always_exhaustive() } -> [std::same_as](../concepts/same_as.html)<bool>;  
{ M::is_always_unique() } -> [std::same_as](../concepts/same_as.html)<bool>;  
[std::bool_constant](../types/integral_constant.html)<M::is_always_strided()>::value;  
[std::bool_constant](../types/integral_constant.html)<M::is_always_exhaustive()>::value;  
[std::bool_constant](../types/integral_constant.html)<M::is_always_unique()>::value;  
}; |  | (exposition only*)  
---|---|---  
| |   
  
Defines the minimal usability constraints of the LayoutMapping requirement. This concept checks that the predicate mapping trait functions above exist, are constant expressions, and have a return type of bool. 

/*is-extents*/<E> is true if and only if `E` is a specialization of std::extents. 

### Standard library

The following standard library types satisfy LayoutMapping requirements: 

[ mapping](../container/mdspan/layout_left/mapping.html "cpp/container/mdspan/layout left/mapping") |  a layout mapping of layout_left  
(public member class template of `std::layout_left`)  
---|---  
[ mapping](../container/mdspan/layout_right/mapping.html "cpp/container/mdspan/layout right/mapping") |  a layout mapping of layout_right  
(public member class template of `std::layout_right`)  
[ mapping](../container/mdspan/layout_stride/mapping.html "cpp/container/mdspan/layout stride/mapping") |  a layout mapping of layout_stride  
(public member class template of `std::layout_stride`)  
[ mapping](https://en.cppreference.com/mwiki/index.php?title=cpp/container/mdspan/layout_left_padded/mapping&action=edit&redlink=1 "cpp/container/mdspan/layout left padded/mapping \(page does not exist\)") |  a layout mapping of layout_left_padded  
(public member class template of `std::layout_left_padded<PaddingValue>`)  
[ mapping](https://en.cppreference.com/mwiki/index.php?title=cpp/container/mdspan/layout_right_padded/mapping&action=edit&redlink=1 "cpp/container/mdspan/layout right padded/mapping \(page does not exist\)") |  a layout mapping of layout_right_padded  
(public member class template of `std::layout_right_padded<PaddingValue>`)  
  
### See also

  * [LayoutMappingPolicy](LayoutMappingPolicy.html "cpp/named req/LayoutMappingPolicy")


