
  


[C++ named requirements](../iterator/concepts.html "cpp/named req")

| [Basic](../iterator/concepts.html#Basic "cpp/named req")  
---  
[DefaultConstructible](DefaultConstructible.html "cpp/named req/DefaultConstructible")  
[MoveConstructible](MoveConstructible.html "cpp/named req/MoveConstructible")(C++11)  
[CopyConstructible](CopyConstructible.html "cpp/named req/CopyConstructible")  
[CopyAssignable](CopyAssignable.html "cpp/named req/CopyAssignable")  
[MoveAssignable](MoveAssignable.html "cpp/named req/MoveAssignable")(C++11)  
[Destructible](Destructible.html "cpp/named req/Destructible")  
[Type properties](../iterator/concepts.html#Type_properties "cpp/named req")  
[ScalarType](ScalarType.html "cpp/named req/ScalarType")  
[PODType](PODType.html "cpp/named req/PODType")  
[TriviallyCopyable](TriviallyCopyable.html "cpp/named req/TriviallyCopyable")(C++11)  
[TrivialType](TrivialType.html "cpp/named req/TrivialType")(C++11)  
[StandardLayoutType](StandardLayoutType.html "cpp/named req/StandardLayoutType")(C++11)` `  
[ImplicitLifetimeType](ImplicitLifetimeType.html "cpp/named req/ImplicitLifetimeType")  
[Library-wide](../iterator/concepts.html#Library-wide "cpp/named req")  
[BooleanTestable](BooleanTestable.html "cpp/named req/BooleanTestable")  
[EqualityComparable](EqualityComparable.html "cpp/named req/EqualityComparable")  
[LessThanComparable](LessThanComparable.html "cpp/named req/LessThanComparable")  
**Swappable**  
[ValueSwappable](ValueSwappable.html "cpp/named req/ValueSwappable")(C++11)  
[NullablePointer](NullablePointer.html "cpp/named req/NullablePointer")(C++11)  
[Hash](Hash.html "cpp/named req/Hash")(C++11)  
[Allocator](Allocator.html "cpp/named req/Allocator")  
[FunctionObject](FunctionObject.html "cpp/named req/FunctionObject")  
[Callable](Callable.html "cpp/named req/Callable")  
[Predicate](Predicate.html "cpp/named req/Predicate")  
[BinaryPredicate](BinaryPredicate.html "cpp/named req/BinaryPredicate")  
[Compare](Compare.html "cpp/named req/Compare")  
  
  
  
  
  
  
  
  
  
| [Container](../iterator/concepts.html#Container "cpp/named req")  
---  
[Container](Container.html "cpp/named req/Container")  
[ReversibleContainer](ReversibleContainer.html "cpp/named req/ReversibleContainer")  
[AllocatorAwareContainer](AllocatorAwareContainer.html "cpp/named req/AllocatorAwareContainer")  
[SequenceContainer](SequenceContainer.html "cpp/named req/SequenceContainer")  
[ContiguousContainer](ContiguousContainer.html "cpp/named req/ContiguousContainer")(C++17)  
[AssociativeContainer](AssociativeContainer.html "cpp/named req/AssociativeContainer")  
[UnorderedAssociativeContainer](UnorderedAssociativeContainer.html "cpp/named req/UnorderedAssociativeContainer")(C++11)` `  
[Container element](../iterator/concepts.html#Container_element "cpp/named req")  
[DefaultInsertable](DefaultInsertable.html "cpp/named req/DefaultInsertable")(C++11)  
[CopyInsertable](CopyInsertable.html "cpp/named req/CopyInsertable")(C++11)  
[MoveInsertable](MoveInsertable.html "cpp/named req/MoveInsertable")(C++11)  
[EmplaceConstructible](EmplaceConstructible.html "cpp/named req/EmplaceConstructible")(C++11)  
[Erasable](Erasable.html "cpp/named req/Erasable")(C++11)  
[Iterator](../iterator/concepts.html#Iterator "cpp/named req")  
[LegacyIterator](Iterator.html "cpp/named req/Iterator")  
[LegacyInputIterator](InputIterator.html "cpp/named req/InputIterator")  
[LegacyOutputIterator](OutputIterator.html "cpp/named req/OutputIterator")  
[LegacyForwardIterator](ForwardIterator.html "cpp/named req/ForwardIterator")  
[LegacyBidirectionalIterator](BidirectionalIterator.html "cpp/named req/BidirectionalIterator")  
[LegacyRandomAccessIterator](RandomAccessIterator.html "cpp/named req/RandomAccessIterator")  
[LegacyContiguousIterator](ContiguousIterator.html "cpp/named req/ContiguousIterator")(C++17)  
[ConstexprIterator](ConstexprIterator.html "cpp/named req/ConstexprIterator")(C++20)  
[Stream I/O](../iterator/concepts.html#Stream_I.2FO_functions "cpp/named req")  
[FormattedInputFunction](FormattedInputFunction.html "cpp/named req/FormattedInputFunction")  
[UnformattedInputFunction](UnformattedInputFunction.html "cpp/named req/UnformattedInputFunction")  
[FormattedOutputFunction](FormattedOutputFunction.html "cpp/named req/FormattedOutputFunction")  
[UnformattedOutputFunction](UnformattedOutputFunction.html "cpp/named req/UnformattedOutputFunction")  
[Formatters](../iterator/concepts.html#Formatters "cpp/named req")  
[BasicFormatter](BasicFormatter.html "cpp/named req/BasicFormatter")(C++20)  
[Formatter](Formatter.html "cpp/named req/Formatter")(C++20)  
  
| [Random Numbers](../iterator/concepts.html#Random_Number_Generation "cpp/named req")  
---  
[SeedSequence](SeedSequence.html "cpp/named req/SeedSequence")(C++11)  
[RandomNumberEngine](RandomNumberEngine.html "cpp/named req/RandomNumberEngine")(C++11)  
[RandomNumberDistribution](RandomNumberDistribution.html "cpp/named req/RandomNumberDistribution")(C++11)  
[UniformRandomBitGenerator](UniformRandomBitGenerator.html "cpp/named req/UniformRandomBitGenerator")(C++11)  
[RandomNumberEngineAdaptor](RandomNumberEngineAdaptor.html "cpp/named req/RandomNumberEngineAdaptor")(C++11)  
[Concurrency](../iterator/concepts.html#Concurrency "cpp/named req")  
[BasicLockable](BasicLockable.html "cpp/named req/BasicLockable")(C++11)  
[Lockable](Lockable.html "cpp/named req/Lockable")(C++11)  
[TimedLockable](TimedLockable.html "cpp/named req/TimedLockable")(C++11)  
[SharedLockable](SharedLockable.html "cpp/named req/SharedLockable")(C++14)  
[SharedTimedLockable](SharedTimedLockable.html "cpp/named req/SharedTimedLockable")(C++14)  
[Mutex](Mutex.html "cpp/named req/Mutex")(C++11)  
[TimedMutex](TimedMutex.html "cpp/named req/TimedMutex")(C++11)  
[SharedMutex](SharedMutex.html "cpp/named req/SharedMutex")(C++17)  
[SharedTimedMutex](SharedTimedMutex.html "cpp/named req/SharedTimedMutex")(C++14)  
[Ranges](../iterator/concepts.html#Ranges "cpp/named req")  
[RangeAdaptorObject](RangeAdaptorObject.html "cpp/named req/RangeAdaptorObject")(C++20)  
[RangeAdaptorClosureObject](RangeAdaptorClosureObject.html "cpp/named req/RangeAdaptorClosureObject")(C++20)  
[Multidimensional View](../iterator/concepts.html#Multidimensional_View_Customization "cpp/named req")  
[LayoutMapping](LayoutMapping.html "cpp/named req/LayoutMapping")(C++23)  
[LayoutMappingPolicy](LayoutMappingPolicy.html "cpp/named req/LayoutMappingPolicy")(C++23)  
[AccessorPolicy](AccessorPolicy.html "cpp/named req/AccessorPolicy")(C++23)  
[Other](../iterator/concepts.html#Other "cpp/named req")  
| [CharTraits](CharTraits.html "cpp/named req/CharTraits")  
---  
[RegexTraits](RegexTraits.html "cpp/named req/RegexTraits")(C++11)` `  
[BitmaskType](BitmaskType.html "cpp/named req/BitmaskType")  
[LiteralType](LiteralType.html "cpp/named req/LiteralType")(C++11)  
[NumericType](NumericType.html "cpp/named req/NumericType")  
  
| [UnaryTypeTrait](UnaryTypeTrait.html "cpp/named req/UnaryTypeTrait")(C++11)  
---  
[BinaryTypeTrait](BinaryTypeTrait.html "cpp/named req/BinaryTypeTrait")(C++11)  
[TransformationTrait](TransformationTrait.html "cpp/named req/TransformationTrait")(C++11)  
[Clock](Clock.html "cpp/named req/Clock")(C++11)  
[TrivialClock](TrivialClock.html "cpp/named req/TrivialClock")(C++11)  
  
  
  
  


Any lvalue or rvalue of this type can be swapped with any lvalue or rvalue of some other type, using unqualified function call swap() in the context where both [std::swap](../utility/swap.html "cpp/algorithm/swap") and the user-defined swap()s are visible. 

## Contents

  * [1 Requirements](Swappable.html#Requirements)
  * [2 Notes](Swappable.html#Notes)
  * [3 Example](Swappable.html#Example)
  * [4 Defect reports](Swappable.html#Defect_reports)
  * [5 See also](Swappable.html#See_also)

  
---  
  
### Requirements

Type U is swappable with type T if, for any object u of type U and any object t of type T, 

Expression | Requirements | Semantics   
---|---|---  
#include <algorithm> // until C++11  
#include <utility> // since C++11  
using [std::swap](../algorithm/swap.html);  
swap(u, t); | After the call, the value of `t` is the value held by `u` before the call, and the value of `u` is the value held by `t` before the call.  | Calls the function named swap() found by overload resolution among all functions with that name that are found by [argument-dependent lookup](../language/adl.html "cpp/language/adl") and the two [std::swap](../utility/swap.html "cpp/algorithm/swap") templates defined in the header [`<algorithm>`](../header/algorithm.html "cpp/header/algorithm")(until C++11)[`<utility>`](../header/utility.html "cpp/header/utility")(since C++11).   
#include <algorithm> // until C++11  
#include <utility> // since C++11  
using [std::swap](../algorithm/swap.html);  
swap(t, u); | Same  | Same   
  
Many standard library functions (for example, many algorithms) expect their arguments to satisfy Swappable, which means that any time the standard library performs a swap, it uses the equivalent of using [std::swap](../algorithm/swap.html); swap(t, u);. 

Typical implementations either 

1) Define a non-member swap in the enclosing namespace, which may forward to a member swap if access to non-public data members is required.

2) Define a [friend function](../language/friend.html "cpp/language/friend") in-class (this approach hides the class-specific swap from name lookup other than ADL).

### Notes

It is unspecified whether [`<algorithm>`](../header/algorithm.html "cpp/header/algorithm")(until C++11)[`<utility>`](../header/utility.html "cpp/header/utility")(since C++11) is actually included when the standard library functions perform the swap, so the user-provided swap() should not expect it to be included. 

### Example

Run this code
    
    
    #include <iostream>
    #include <vector>
     
    struct IntVector
    {
        [std::vector](../container/vector.html)<int> v;
     
        IntVector& operator=(IntVector) = delete; // not assignable
     
        void swap(IntVector& other)
        {
            v.swap(other.v);
        }
     
        void operator()(auto rem, auto term = " ")
        {
            [std::cout](../io/cout.html) << rem << "{{";
            for (int n{}; int e : v)
                [std::cout](../io/cout.html) << (n++ ? ", " : "") << e;
            [std::cout](../io/cout.html) << "}}" << term;
        }
    };
     
    void swap(IntVector& v1, IntVector& v2)
    {
        v1.swap(v2);
    }
     
    int main()
    {
        IntVector v1{{1, 1, 1, 1}}, v2{{2222, 2222}};
     
        auto prn = [&]{ v1("v1", ", "), v2("v2", ";\n"); };
     
    //  std::swap(v1, v2); // Compiler error! std::swap requires MoveAssignable
        prn();
        [std::iter_swap](../algorithm/iter_swap.html)(&v1, &v2); // OK: library calls unqualified swap()
        prn();
        std::[ranges::swap](http://en.cppreference.com/w/cpp/ranges-utility-placeholder/swap)(v1, v2); // OK: library calls unqualified swap()
        prn();
    }

Output: 
    
    
    v1{{1, 1, 1, 1}}, v2{{2222, 2222}};
    v1{{2222, 2222}}, v2{{1, 1, 1, 1}};
    v1{{1, 1, 1, 1}}, v2{{2222, 2222}};

### Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[LWG 226](https://cplusplus.github.io/LWG/issue226) | C++98  | it was unclear how the standard library uses `swap` | clarified to use both `std::` and ADL-found `swap`  
  
### See also

[ is_swappable_withis_swappableis_nothrow_swappable_withis_nothrow_swappable](../types/is_swappable.html "cpp/types/is swappable")(C++17)(C++17)(C++17)(C++17) |  checks if objects of a type can be swapped with objects of same or different type   
(class template)   
---|---  
[ swappableswappable_with](../concepts/swappable.html "cpp/concepts/swappable")(C++20) |  specifies that a type can be swapped or that two types can be swapped with each other   
(concept) 
