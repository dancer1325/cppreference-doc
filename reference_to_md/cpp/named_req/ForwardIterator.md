
  


[C++ named requirements](../iterator/concepts.html "cpp/named req")

| [Basic](../iterator/concepts.html#Basic "cpp/named req")  
---  
[DefaultConstructible](DefaultConstructible.html "cpp/named req/DefaultConstructible")  
[MoveConstructible](MoveConstructible.html "cpp/named req/MoveConstructible")(C++11)  
[CopyConstructible](CopyConstructible.html "cpp/named req/CopyConstructible")  
[CopyAssignable](CopyAssignable.html "cpp/named req/CopyAssignable")  
[MoveAssignable](MoveAssignable.html "cpp/named req/MoveAssignable")(C++11)  
[Destructible](Destructible.html "cpp/named req/Destructible")  
[Type properties](../iterator/concepts.html#Type_properties "cpp/named req")  
[ScalarType](ScalarType.html "cpp/named req/ScalarType")  
[PODType](PODType.html "cpp/named req/PODType")  
[TriviallyCopyable](TriviallyCopyable.html "cpp/named req/TriviallyCopyable")(C++11)  
[TrivialType](TrivialType.html "cpp/named req/TrivialType")(C++11)  
[StandardLayoutType](StandardLayoutType.html "cpp/named req/StandardLayoutType")(C++11)` `  
[ImplicitLifetimeType](ImplicitLifetimeType.html "cpp/named req/ImplicitLifetimeType")  
[Library-wide](../iterator/concepts.html#Library-wide "cpp/named req")  
[BooleanTestable](BooleanTestable.html "cpp/named req/BooleanTestable")  
[EqualityComparable](EqualityComparable.html "cpp/named req/EqualityComparable")  
[LessThanComparable](LessThanComparable.html "cpp/named req/LessThanComparable")  
[Swappable](Swappable.html "cpp/named req/Swappable")  
[ValueSwappable](ValueSwappable.html "cpp/named req/ValueSwappable")(C++11)  
[NullablePointer](NullablePointer.html "cpp/named req/NullablePointer")(C++11)  
[Hash](Hash.html "cpp/named req/Hash")(C++11)  
[Allocator](Allocator.html "cpp/named req/Allocator")  
[FunctionObject](FunctionObject.html "cpp/named req/FunctionObject")  
[Callable](Callable.html "cpp/named req/Callable")  
[Predicate](Predicate.html "cpp/named req/Predicate")  
[BinaryPredicate](BinaryPredicate.html "cpp/named req/BinaryPredicate")  
[Compare](Compare.html "cpp/named req/Compare")  
  
  
  
  
  
  
  
  
  
| [Container](../iterator/concepts.html#Container "cpp/named req")  
---  
[Container](Container.html "cpp/named req/Container")  
[ReversibleContainer](ReversibleContainer.html "cpp/named req/ReversibleContainer")  
[AllocatorAwareContainer](AllocatorAwareContainer.html "cpp/named req/AllocatorAwareContainer")  
[SequenceContainer](SequenceContainer.html "cpp/named req/SequenceContainer")  
[ContiguousContainer](ContiguousContainer.html "cpp/named req/ContiguousContainer")(C++17)  
[AssociativeContainer](AssociativeContainer.html "cpp/named req/AssociativeContainer")  
[UnorderedAssociativeContainer](UnorderedAssociativeContainer.html "cpp/named req/UnorderedAssociativeContainer")(C++11)` `  
[Container element](../iterator/concepts.html#Container_element "cpp/named req")  
[DefaultInsertable](DefaultInsertable.html "cpp/named req/DefaultInsertable")(C++11)  
[CopyInsertable](CopyInsertable.html "cpp/named req/CopyInsertable")(C++11)  
[MoveInsertable](MoveInsertable.html "cpp/named req/MoveInsertable")(C++11)  
[EmplaceConstructible](EmplaceConstructible.html "cpp/named req/EmplaceConstructible")(C++11)  
[Erasable](Erasable.html "cpp/named req/Erasable")(C++11)  
[Iterator](../iterator/concepts.html#Iterator "cpp/named req")  
[LegacyIterator](Iterator.html "cpp/named req/Iterator")  
[LegacyInputIterator](InputIterator.html "cpp/named req/InputIterator")  
[LegacyOutputIterator](OutputIterator.html "cpp/named req/OutputIterator")  
**LegacyForwardIterator**  
[LegacyBidirectionalIterator](BidirectionalIterator.html "cpp/named req/BidirectionalIterator")  
[LegacyRandomAccessIterator](RandomAccessIterator.html "cpp/named req/RandomAccessIterator")  
[LegacyContiguousIterator](ContiguousIterator.html "cpp/named req/ContiguousIterator")(C++17)  
[ConstexprIterator](ConstexprIterator.html "cpp/named req/ConstexprIterator")(C++20)  
[Stream I/O](../iterator/concepts.html#Stream_I.2FO_functions "cpp/named req")  
[FormattedInputFunction](FormattedInputFunction.html "cpp/named req/FormattedInputFunction")  
[UnformattedInputFunction](UnformattedInputFunction.html "cpp/named req/UnformattedInputFunction")  
[FormattedOutputFunction](FormattedOutputFunction.html "cpp/named req/FormattedOutputFunction")  
[UnformattedOutputFunction](UnformattedOutputFunction.html "cpp/named req/UnformattedOutputFunction")  
[Formatters](../iterator/concepts.html#Formatters "cpp/named req")  
[BasicFormatter](BasicFormatter.html "cpp/named req/BasicFormatter")(C++20)  
[Formatter](Formatter.html "cpp/named req/Formatter")(C++20)  
  
| [Random Numbers](../iterator/concepts.html#Random_Number_Generation "cpp/named req")  
---  
[SeedSequence](SeedSequence.html "cpp/named req/SeedSequence")(C++11)  
[RandomNumberEngine](RandomNumberEngine.html "cpp/named req/RandomNumberEngine")(C++11)  
[RandomNumberDistribution](RandomNumberDistribution.html "cpp/named req/RandomNumberDistribution")(C++11)  
[UniformRandomBitGenerator](UniformRandomBitGenerator.html "cpp/named req/UniformRandomBitGenerator")(C++11)  
[RandomNumberEngineAdaptor](RandomNumberEngineAdaptor.html "cpp/named req/RandomNumberEngineAdaptor")(C++11)  
[Concurrency](../iterator/concepts.html#Concurrency "cpp/named req")  
[BasicLockable](BasicLockable.html "cpp/named req/BasicLockable")(C++11)  
[Lockable](Lockable.html "cpp/named req/Lockable")(C++11)  
[TimedLockable](TimedLockable.html "cpp/named req/TimedLockable")(C++11)  
[SharedLockable](SharedLockable.html "cpp/named req/SharedLockable")(C++14)  
[SharedTimedLockable](SharedTimedLockable.html "cpp/named req/SharedTimedLockable")(C++14)  
[Mutex](Mutex.html "cpp/named req/Mutex")(C++11)  
[TimedMutex](TimedMutex.html "cpp/named req/TimedMutex")(C++11)  
[SharedMutex](SharedMutex.html "cpp/named req/SharedMutex")(C++17)  
[SharedTimedMutex](SharedTimedMutex.html "cpp/named req/SharedTimedMutex")(C++14)  
[Ranges](../iterator/concepts.html#Ranges "cpp/named req")  
[RangeAdaptorObject](RangeAdaptorObject.html "cpp/named req/RangeAdaptorObject")(C++20)  
[RangeAdaptorClosureObject](RangeAdaptorClosureObject.html "cpp/named req/RangeAdaptorClosureObject")(C++20)  
[Multidimensional View](../iterator/concepts.html#Multidimensional_View_Customization "cpp/named req")  
[LayoutMapping](LayoutMapping.html "cpp/named req/LayoutMapping")(C++23)  
[LayoutMappingPolicy](LayoutMappingPolicy.html "cpp/named req/LayoutMappingPolicy")(C++23)  
[AccessorPolicy](AccessorPolicy.html "cpp/named req/AccessorPolicy")(C++23)  
[Other](../iterator/concepts.html#Other "cpp/named req")  
| [CharTraits](CharTraits.html "cpp/named req/CharTraits")  
---  
[RegexTraits](RegexTraits.html "cpp/named req/RegexTraits")(C++11)` `  
[BitmaskType](BitmaskType.html "cpp/named req/BitmaskType")  
[LiteralType](LiteralType.html "cpp/named req/LiteralType")(C++11)  
[NumericType](NumericType.html "cpp/named req/NumericType")  
  
| [UnaryTypeTrait](UnaryTypeTrait.html "cpp/named req/UnaryTypeTrait")(C++11)  
---  
[BinaryTypeTrait](BinaryTypeTrait.html "cpp/named req/BinaryTypeTrait")(C++11)  
[TransformationTrait](TransformationTrait.html "cpp/named req/TransformationTrait")(C++11)  
[Clock](Clock.html "cpp/named req/Clock")(C++11)  
[TrivialClock](TrivialClock.html "cpp/named req/TrivialClock")(C++11)  
  
  
  
  


A **LegacyForwardIterator** is a [LegacyIterator](Iterator.html "cpp/named req/Iterator") that can read data from the pointed-to element. 

Unlike [LegacyInputIterator](InputIterator.html "cpp/named req/InputIterator") and [LegacyOutputIterator](OutputIterator.html "cpp/named req/OutputIterator"), it can be used in multipass algorithms. 

If a **LegacyForwardIterator** it originates from a [Container](Container.html "cpp/named req/Container"), then it's value type is the same as the container's, so dereferencing (*it) obtains the container's value type. 

## Contents

  * [1 Requirements](ForwardIterator.html#Requirements)
  * [2 Equality domain](ForwardIterator.html#Equality_domain)
  * [3 Multi-pass guarantee](ForwardIterator.html#Multi-pass_guarantee)
  * [4 Concept](ForwardIterator.html#Concept)
  * [5 Notes](ForwardIterator.html#Notes)
  * [6 Defect reports](ForwardIterator.html#Defect_reports)
  * [7 See also](ForwardIterator.html#See_also)

  
---  
  
### Requirements

Type  |  Definition   
---|---  
`X` |  A forward iterator type   
`T` |  The [value type](../iterator.html#Types_and_writability "cpp/iterator") of `X` (i.e. [std::iterator_traits](../iterator/iterator_traits.html)<X>::value_type)   
`Ref` |  [std::iterator_traits](../iterator/iterator_traits.html)<X>::reference  
Value  |  Definition   
i, j |  Values of type `X` or const X  
r |  A value of type `X&`  
  
`X` satisfies LegacyForwardIterator if all following conditions are satisfied: 

  * `X` satisfies [LegacyInputIterator](InputIterator.html "cpp/named req/InputIterator"). 
  * `X` satisfies [DefaultConstructible](DefaultConstructible.html "cpp/named req/DefaultConstructible"). 
  * If `X` is a [mutable iterator](../iterator.html "cpp/iterator"), `Ref` is a reference to `T`. 
  * If `X` is a constant iterator, `Ref` is a reference to const T. 
  * Objects of the type `X` provide [multi-pass guarantee](ForwardIterator.html#Multi-pass_guarantee). 
  * If i and j are equal, then either i and j are both [dereferenceable](../iterator.html#Dereferenceability_and_validity "cpp/iterator") or else neither is dereferenceable. 
  * If i and j are both dereferenceable, then i == j if and only if *i and *j are bound to the same object. 
  * The following expressions must be valid and have their specified effects: 

Expression  | Type  | Effects   
---|---|---  
r++ | convertible to const X& | Equivalent to X x = r;  
++r;  
return x;.   
*i++ | `Ref` |   
  
### Equality domain

The [domain](InputIterator.html#Equality_domain "cpp/named req/InputIterator") of == for forward iterators is that of iterators over the same [underlying sequence](../iterator.html#Dereferenceability_and_validity "cpp/iterator"). 

However, [value-initialized](../language/value_initialization.html "cpp/language/value initialization") forward iterators can be compared, and must compare equal to other value-initialized iterators of the same type. In other words, value-initialized forward iterators behave as if they refer past the end of the same empty sequence.  | (since C++14)  
---|---  
  
### Multi-pass guarantee

Two dereferenceable iterators a and b of type `X` offer the _multi-pass guarantee_ if all following conditions are satisfied: 

  * a == b implies ++a == ++b. 
  * Any of the following conditions is satisfied: 



    

  * `X` is a pointer type. 
  * The expression (void)++X(a), *a is equivalent to the expression *a. 



###  Concept

For the definition of [std::iterator_traits](../iterator/iterator_traits.html "cpp/iterator/iterator traits"), the following exposition-only concept is defined.  |  template<class It>  
concept __LegacyForwardIterator =  
__LegacyInputIterator<It> && [std::constructible_from](../concepts/constructible_from.html)<It> &&  
[std::is_reference_v](../types/is_reference.html)<[std::iter_reference_t](../iterator/iter_t.html)<It>> &&  
[std::same_as](../concepts/same_as.html)<  
[std::remove_cvref_t](../types/remove_cvref.html)<[std::iter_reference_t](../iterator/iter_t.html)<It>>,  
typename [std::indirectly_readable_traits](../iterator/readable_traits.html)<It>::value_type> &&  
requires(It it) {  
{ it++ } -> [std::convertible_to](../concepts/convertible_to.html)<const It&>;  
{ *it++ } -> [std::same_as](../concepts/same_as.html)<[std::iter_reference_t](../iterator/iter_t.html)<It>>;  
}; |  |   
---|---|---  
| |   
  
where the exposition-only concept `__LegacyInputIterator<T>` is described in [LegacyInputIterator](InputIterator.html#Concept "cpp/named req/InputIterator"). 

(since C++20)  
  
### Notes

Unlike the [std::forward_iterator](../iterator/forward_iterator.html "cpp/iterator/forward iterator") concept, the LegacyForwardIterator requirements requires dereference to return a reference. 

### Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[LWG 1212](https://cplusplus.github.io/LWG/issue1212)  
([N3066](https://wg21.link/N3066))  | C++98  | the type of *i++ did not match the type of  
*i\-- required by [LegacyBidirectionalIterator](BidirectionalIterator.html "cpp/named req/BidirectionalIterator") | changed the  
type to `Ref`  
[LWG 1311](https://cplusplus.github.io/LWG/issue1311)  
([N3066](https://wg21.link/N3066))  | C++98  | “a == b implies ++a == ++b” alone  
did not offer multipass guarantee[[1]](ForwardIterator.html#cite_note-1) | also requires “a == b  
implies ++a != b”[[2]](ForwardIterator.html#cite_note-2)  
[LWG 3798](https://cplusplus.github.io/LWG/issue3798) | C++20  | `__LegacyForwardIterator` required  
[std::iter_reference_t](../iterator/iter_t.html)<It> to be an lvalue reference type  | also allows rvalue  
reference types   
  
  1. [↑](ForwardIterator.html#cite_ref-1) In the scenario where a and b use the same underlying iterator, evaluating the expression ++a == ++b actually increments the underlying container twice, but the result is still true.
  2. [↑](ForwardIterator.html#cite_ref-2) Formally also requires implying ++b != a.



### See also

[ forward_iterator](../iterator/forward_iterator.html "cpp/iterator/forward iterator")(C++20) |  specifies that an [`input_iterator`](../iterator/input_iterator.html "cpp/iterator/input iterator") is a forward iterator, supporting equality comparison and multi-pass   
(concept)   
---|---  
[**Iterator library**](../iterator.html "cpp/iterator") |  provides definitions for iterators, iterator traits, adaptors, and utility functions 
