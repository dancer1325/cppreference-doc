
  


[C++ named requirements](../iterator/concepts.html "cpp/named req")

| [Basic](../iterator/concepts.html#Basic "cpp/named req")  
---  
[DefaultConstructible](DefaultConstructible.html "cpp/named req/DefaultConstructible")  
[MoveConstructible](MoveConstructible.html "cpp/named req/MoveConstructible")(C++11)  
[CopyConstructible](CopyConstructible.html "cpp/named req/CopyConstructible")  
[CopyAssignable](CopyAssignable.html "cpp/named req/CopyAssignable")  
[MoveAssignable](MoveAssignable.html "cpp/named req/MoveAssignable")(C++11)  
[Destructible](Destructible.html "cpp/named req/Destructible")  
[Type properties](../iterator/concepts.html#Type_properties "cpp/named req")  
[ScalarType](ScalarType.html "cpp/named req/ScalarType")  
[PODType](PODType.html "cpp/named req/PODType")  
[TriviallyCopyable](TriviallyCopyable.html "cpp/named req/TriviallyCopyable")(C++11)  
[TrivialType](TrivialType.html "cpp/named req/TrivialType")(C++11)  
[StandardLayoutType](StandardLayoutType.html "cpp/named req/StandardLayoutType")(C++11)` `  
[ImplicitLifetimeType](ImplicitLifetimeType.html "cpp/named req/ImplicitLifetimeType")  
[Library-wide](../iterator/concepts.html#Library-wide "cpp/named req")  
[BooleanTestable](BooleanTestable.html "cpp/named req/BooleanTestable")  
[EqualityComparable](EqualityComparable.html "cpp/named req/EqualityComparable")  
[LessThanComparable](LessThanComparable.html "cpp/named req/LessThanComparable")  
[Swappable](Swappable.html "cpp/named req/Swappable")  
[ValueSwappable](ValueSwappable.html "cpp/named req/ValueSwappable")(C++11)  
[NullablePointer](NullablePointer.html "cpp/named req/NullablePointer")(C++11)  
[Hash](Hash.html "cpp/named req/Hash")(C++11)  
[Allocator](Allocator.html "cpp/named req/Allocator")  
[FunctionObject](FunctionObject.html "cpp/named req/FunctionObject")  
[Callable](Callable.html "cpp/named req/Callable")  
[Predicate](Predicate.html "cpp/named req/Predicate")  
[BinaryPredicate](BinaryPredicate.html "cpp/named req/BinaryPredicate")  
[Compare](Compare.html "cpp/named req/Compare")  
  
  
  
  
  
  
  
  
  
| [Container](../iterator/concepts.html#Container "cpp/named req")  
---  
[Container](Container.html "cpp/named req/Container")  
[ReversibleContainer](ReversibleContainer.html "cpp/named req/ReversibleContainer")  
[AllocatorAwareContainer](AllocatorAwareContainer.html "cpp/named req/AllocatorAwareContainer")  
[SequenceContainer](SequenceContainer.html "cpp/named req/SequenceContainer")  
[ContiguousContainer](ContiguousContainer.html "cpp/named req/ContiguousContainer")(C++17)  
[AssociativeContainer](AssociativeContainer.html "cpp/named req/AssociativeContainer")  
[UnorderedAssociativeContainer](UnorderedAssociativeContainer.html "cpp/named req/UnorderedAssociativeContainer")(C++11)` `  
[Container element](../iterator/concepts.html#Container_element "cpp/named req")  
[DefaultInsertable](DefaultInsertable.html "cpp/named req/DefaultInsertable")(C++11)  
[CopyInsertable](CopyInsertable.html "cpp/named req/CopyInsertable")(C++11)  
[MoveInsertable](MoveInsertable.html "cpp/named req/MoveInsertable")(C++11)  
[EmplaceConstructible](EmplaceConstructible.html "cpp/named req/EmplaceConstructible")(C++11)  
[Erasable](Erasable.html "cpp/named req/Erasable")(C++11)  
[Iterator](../iterator/concepts.html#Iterator "cpp/named req")  
[LegacyIterator](Iterator.html "cpp/named req/Iterator")  
**LegacyInputIterator**  
[LegacyOutputIterator](OutputIterator.html "cpp/named req/OutputIterator")  
[LegacyForwardIterator](ForwardIterator.html "cpp/named req/ForwardIterator")  
[LegacyBidirectionalIterator](BidirectionalIterator.html "cpp/named req/BidirectionalIterator")  
[LegacyRandomAccessIterator](RandomAccessIterator.html "cpp/named req/RandomAccessIterator")  
[LegacyContiguousIterator](ContiguousIterator.html "cpp/named req/ContiguousIterator")(C++17)  
[ConstexprIterator](ConstexprIterator.html "cpp/named req/ConstexprIterator")(C++20)  
[Stream I/O](../iterator/concepts.html#Stream_I.2FO_functions "cpp/named req")  
[FormattedInputFunction](FormattedInputFunction.html "cpp/named req/FormattedInputFunction")  
[UnformattedInputFunction](UnformattedInputFunction.html "cpp/named req/UnformattedInputFunction")  
[FormattedOutputFunction](FormattedOutputFunction.html "cpp/named req/FormattedOutputFunction")  
[UnformattedOutputFunction](UnformattedOutputFunction.html "cpp/named req/UnformattedOutputFunction")  
[Formatters](../iterator/concepts.html#Formatters "cpp/named req")  
[BasicFormatter](BasicFormatter.html "cpp/named req/BasicFormatter")(C++20)  
[Formatter](Formatter.html "cpp/named req/Formatter")(C++20)  
  
| [Random Numbers](../iterator/concepts.html#Random_Number_Generation "cpp/named req")  
---  
[SeedSequence](SeedSequence.html "cpp/named req/SeedSequence")(C++11)  
[RandomNumberEngine](RandomNumberEngine.html "cpp/named req/RandomNumberEngine")(C++11)  
[RandomNumberDistribution](RandomNumberDistribution.html "cpp/named req/RandomNumberDistribution")(C++11)  
[UniformRandomBitGenerator](UniformRandomBitGenerator.html "cpp/named req/UniformRandomBitGenerator")(C++11)  
[RandomNumberEngineAdaptor](RandomNumberEngineAdaptor.html "cpp/named req/RandomNumberEngineAdaptor")(C++11)  
[Concurrency](../iterator/concepts.html#Concurrency "cpp/named req")  
[BasicLockable](BasicLockable.html "cpp/named req/BasicLockable")(C++11)  
[Lockable](Lockable.html "cpp/named req/Lockable")(C++11)  
[TimedLockable](TimedLockable.html "cpp/named req/TimedLockable")(C++11)  
[SharedLockable](SharedLockable.html "cpp/named req/SharedLockable")(C++14)  
[SharedTimedLockable](SharedTimedLockable.html "cpp/named req/SharedTimedLockable")(C++14)  
[Mutex](Mutex.html "cpp/named req/Mutex")(C++11)  
[TimedMutex](TimedMutex.html "cpp/named req/TimedMutex")(C++11)  
[SharedMutex](SharedMutex.html "cpp/named req/SharedMutex")(C++17)  
[SharedTimedMutex](SharedTimedMutex.html "cpp/named req/SharedTimedMutex")(C++14)  
[Ranges](../iterator/concepts.html#Ranges "cpp/named req")  
[RangeAdaptorObject](RangeAdaptorObject.html "cpp/named req/RangeAdaptorObject")(C++20)  
[RangeAdaptorClosureObject](RangeAdaptorClosureObject.html "cpp/named req/RangeAdaptorClosureObject")(C++20)  
[Multidimensional View](../iterator/concepts.html#Multidimensional_View_Customization "cpp/named req")  
[LayoutMapping](LayoutMapping.html "cpp/named req/LayoutMapping")(C++23)  
[LayoutMappingPolicy](LayoutMappingPolicy.html "cpp/named req/LayoutMappingPolicy")(C++23)  
[AccessorPolicy](AccessorPolicy.html "cpp/named req/AccessorPolicy")(C++23)  
[Other](../iterator/concepts.html#Other "cpp/named req")  
| [CharTraits](CharTraits.html "cpp/named req/CharTraits")  
---  
[RegexTraits](RegexTraits.html "cpp/named req/RegexTraits")(C++11)` `  
[BitmaskType](BitmaskType.html "cpp/named req/BitmaskType")  
[LiteralType](LiteralType.html "cpp/named req/LiteralType")(C++11)  
[NumericType](NumericType.html "cpp/named req/NumericType")  
  
| [UnaryTypeTrait](UnaryTypeTrait.html "cpp/named req/UnaryTypeTrait")(C++11)  
---  
[BinaryTypeTrait](BinaryTypeTrait.html "cpp/named req/BinaryTypeTrait")(C++11)  
[TransformationTrait](TransformationTrait.html "cpp/named req/TransformationTrait")(C++11)  
[Clock](Clock.html "cpp/named req/Clock")(C++11)  
[TrivialClock](TrivialClock.html "cpp/named req/TrivialClock")(C++11)  
  
  
  
  


A **LegacyInputIterator** is a [LegacyIterator](Iterator.html "cpp/named req/Iterator") that can read from the pointed-to element. LegacyInputIterators only guarantee validity for single pass algorithms: once a LegacyInputIterator i has been incremented, all copies of its previous value may be invalidated. 

## Contents

  * [1 Requirements](InputIterator.html#Requirements)
  * [2 Equality domain](InputIterator.html#Equality_domain)
  * [3 Notes](InputIterator.html#Notes)
  * [4 Concept](InputIterator.html#Concept)
  * [5 Defect reports](InputIterator.html#Defect_reports)
  * [6 See also](InputIterator.html#See_also)

  
---  
  
### Requirements

Type  |  Definition   
---|---  
`X` |  An input iterator type   
`T` |  The [value type](../iterator.html#Types_and_writability "cpp/iterator") of `X` (i.e. [std::iterator_traits](../iterator/iterator_traits.html)<X>::value_type)   
`R` |  [std::iterator_traits](../iterator/iterator_traits.html)<X>::reference  
Value  |  Definition   
i, j |  Values of type `X` or const X  
r |  A value of type `X&`  
Other  |  Definition   
`m` |  An identifier which possibly denotes a data member or member function   
  
  
`X` satisfies LegacyInputIterator if all following conditions are satisfied: 

  * `X` satisfies [LegacyIterator](Iterator.html "cpp/named req/Iterator"). 
  * `X` satisfies [EqualityComparable](EqualityComparable.html "cpp/named req/EqualityComparable"). 
  * The following expressions are well-formed and have the specified semantics: 

Expression  | Type  | Semantics   
---|---|---  
i != j |  | a type satisfying [BooleanTestable](BooleanTestable.html "cpp/named req/BooleanTestable") | (until C++20)  
---|---  
a type modeling [`_boolean-testable_`](../concepts/boolean-testable.html "cpp/concepts/boolean-testable") | (since C++20)  
Precondition  | i and j are in the [domain](InputIterator.html#Equality_domain) of ==.   
Effect  | Equivalent to !(i == j).   
*i | `R`, convertible to `T` | Precondition  | i is [dereferenceable](../iterator.html#Dereferenceability_and_validity "cpp/iterator").   
Effect  | 

  * The expression (void)*i, *i is equivalent to *i. 
  * If i and j are in the domain of ==, and i == j, then *i is equivalent to *j. 

  
i->m |  | Precondition  | i is dereferenceable.   
Effect  | Equivalent to (*i).m.   
++r | `X&` | Precondition  | r is dereferenceable.   
Postcondition  | 

  * r is dereferenceable or r is past-the-end. 
  * Any copies of the previous value of r are no longer required to be either dereferenceable or to be in the domain of ==. 

  
(void)r++ |  | Effect  | Equivalent to (void)++r.   
*r++ | convertible to `T` | Effect  | Equivalent to T x = *r; ++r; return x;.   
  
### Equality domain

The term _the domain of ==_ is used in the ordinary mathematical sense to denote the set of values which can be compared using ==. This set can change over time. 

Each algorithm places additional requirements on the equality domain for the iterator values it uses. These requirements can be inferred from the uses that algorithm makes of == and !=. 

### Notes

For an input iterator `X` that is not a [LegacyForwardIterator](ForwardIterator.html "cpp/named req/ForwardIterator"), [std::iterator_traits](../iterator/iterator_traits.html)<X>::reference does not have to be a reference type: dereferencing an input iterator may return a proxy object or [std::iterator_traits](../iterator/iterator_traits.html)<X>::value_type itself by value (as in the case of [`std::istreambuf_iterator`](../iterator/istreambuf_iterator.html "cpp/iterator/istreambuf iterator")). 

###  Concept

For the definition of [std::iterator_traits](../iterator/iterator_traits.html "cpp/iterator/iterator traits"), the following exposition-only concept is defined.  |  template<class I>  
concept __LegacyInputIterator =  
__LegacyIterator<I> && [std::equality_comparable](../concepts/equality_comparable.html)<I> && requires(I i)  
{  
typename [std::incrementable_traits](../iterator/incrementable_traits.html)<I>::difference_type;  
typename [std::indirectly_readable_traits](../iterator/readable_traits.html)<I>::value_type;  
typename [std::common_reference_t](../types/common_reference.html)<[std::iter_reference_t](../iterator/iter_t.html)<I>&&,  
typename [std::indirectly_readable_traits](../iterator/readable_traits.html)<I>::value_type&>;  
*i++;  
typename [std::common_reference_t](../types/common_reference.html)<decltype(*i++)&&,  
typename [std::indirectly_readable_traits](../iterator/readable_traits.html)<I>::value_type&>;  
requires [std::signed_integral](../concepts/signed_integral.html)<typename [std::incrementable_traits](../iterator/incrementable_traits.html)<I>::difference_type>;  
}; |  |   
---|---|---  
| |   
  
where the exposition-only concept `__LegacyIterator` is described in [LegacyIterator](Iterator.html#Concept "cpp/named req/Iterator"). 

(since C++20)  
  
### Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[LWG 98](https://cplusplus.github.io/LWG/issue98) | C++98  | the return type of *i++ was required to be `T` | it can be any type convertible to `T`  
[LWG 2114](https://cplusplus.github.io/LWG/issue2114)  
([P2167R3](https://wg21.link/P2167R3))  | C++98  | convertibility to bool was too weak to  
reflect the expectation of implementations  | requirements strengthened   
  
### See also

[ input_iterator](../iterator/input_iterator.html "cpp/iterator/input iterator")(C++20) |  specifies that a type is an input iterator, that is, its referenced values can be read and it can be both pre- and post-incremented   
(concept)   
---|---  
[**Iterator library**](../iterator.html "cpp/iterator") |  provides definitions for iterators, iterator traits, adaptors, and utility functions 
