
  


[C++ named requirements](../iterator/concepts.html "cpp/named req")

| [Basic](../iterator/concepts.html#Basic "cpp/named req")  
---  
[DefaultConstructible](DefaultConstructible.html "cpp/named req/DefaultConstructible")  
[MoveConstructible](MoveConstructible.html "cpp/named req/MoveConstructible")(C++11)  
[CopyConstructible](CopyConstructible.html "cpp/named req/CopyConstructible")  
[CopyAssignable](CopyAssignable.html "cpp/named req/CopyAssignable")  
[MoveAssignable](MoveAssignable.html "cpp/named req/MoveAssignable")(C++11)  
[Destructible](Destructible.html "cpp/named req/Destructible")  
[Type properties](../iterator/concepts.html#Type_properties "cpp/named req")  
[ScalarType](ScalarType.html "cpp/named req/ScalarType")  
[PODType](PODType.html "cpp/named req/PODType")  
[TriviallyCopyable](TriviallyCopyable.html "cpp/named req/TriviallyCopyable")(C++11)  
[TrivialType](TrivialType.html "cpp/named req/TrivialType")(C++11)  
[StandardLayoutType](StandardLayoutType.html "cpp/named req/StandardLayoutType")(C++11)` `  
[ImplicitLifetimeType](ImplicitLifetimeType.html "cpp/named req/ImplicitLifetimeType")  
[Library-wide](../iterator/concepts.html#Library-wide "cpp/named req")  
[BooleanTestable](BooleanTestable.html "cpp/named req/BooleanTestable")  
[EqualityComparable](EqualityComparable.html "cpp/named req/EqualityComparable")  
[LessThanComparable](LessThanComparable.html "cpp/named req/LessThanComparable")  
[Swappable](Swappable.html "cpp/named req/Swappable")  
[ValueSwappable](ValueSwappable.html "cpp/named req/ValueSwappable")(C++11)  
[NullablePointer](NullablePointer.html "cpp/named req/NullablePointer")(C++11)  
[Hash](Hash.html "cpp/named req/Hash")(C++11)  
[Allocator](Allocator.html "cpp/named req/Allocator")  
[FunctionObject](FunctionObject.html "cpp/named req/FunctionObject")  
[Callable](Callable.html "cpp/named req/Callable")  
[Predicate](Predicate.html "cpp/named req/Predicate")  
[BinaryPredicate](BinaryPredicate.html "cpp/named req/BinaryPredicate")  
[Compare](Compare.html "cpp/named req/Compare")  
  
  
  
  
  
  
  
  
  
| [Container](../iterator/concepts.html#Container "cpp/named req")  
---  
[Container](Container.html "cpp/named req/Container")  
[ReversibleContainer](ReversibleContainer.html "cpp/named req/ReversibleContainer")  
[AllocatorAwareContainer](AllocatorAwareContainer.html "cpp/named req/AllocatorAwareContainer")  
[SequenceContainer](SequenceContainer.html "cpp/named req/SequenceContainer")  
[ContiguousContainer](ContiguousContainer.html "cpp/named req/ContiguousContainer")(C++17)  
[AssociativeContainer](AssociativeContainer.html "cpp/named req/AssociativeContainer")  
[UnorderedAssociativeContainer](UnorderedAssociativeContainer.html "cpp/named req/UnorderedAssociativeContainer")(C++11)` `  
[Container element](../iterator/concepts.html#Container_element "cpp/named req")  
[DefaultInsertable](DefaultInsertable.html "cpp/named req/DefaultInsertable")(C++11)  
[CopyInsertable](CopyInsertable.html "cpp/named req/CopyInsertable")(C++11)  
[MoveInsertable](MoveInsertable.html "cpp/named req/MoveInsertable")(C++11)  
[EmplaceConstructible](EmplaceConstructible.html "cpp/named req/EmplaceConstructible")(C++11)  
[Erasable](Erasable.html "cpp/named req/Erasable")(C++11)  
[Iterator](../iterator/concepts.html#Iterator "cpp/named req")  
[LegacyIterator](Iterator.html "cpp/named req/Iterator")  
[LegacyInputIterator](InputIterator.html "cpp/named req/InputIterator")  
[LegacyOutputIterator](OutputIterator.html "cpp/named req/OutputIterator")  
[LegacyForwardIterator](ForwardIterator.html "cpp/named req/ForwardIterator")  
[LegacyBidirectionalIterator](BidirectionalIterator.html "cpp/named req/BidirectionalIterator")  
[LegacyRandomAccessIterator](RandomAccessIterator.html "cpp/named req/RandomAccessIterator")  
[LegacyContiguousIterator](ContiguousIterator.html "cpp/named req/ContiguousIterator")(C++17)  
[ConstexprIterator](ConstexprIterator.html "cpp/named req/ConstexprIterator")(C++20)  
[Stream I/O](../iterator/concepts.html#Stream_I.2FO_functions "cpp/named req")  
[FormattedInputFunction](FormattedInputFunction.html "cpp/named req/FormattedInputFunction")  
[UnformattedInputFunction](UnformattedInputFunction.html "cpp/named req/UnformattedInputFunction")  
[FormattedOutputFunction](FormattedOutputFunction.html "cpp/named req/FormattedOutputFunction")  
[UnformattedOutputFunction](UnformattedOutputFunction.html "cpp/named req/UnformattedOutputFunction")  
[Formatters](../iterator/concepts.html#Formatters "cpp/named req")  
[BasicFormatter](BasicFormatter.html "cpp/named req/BasicFormatter")(C++20)  
[Formatter](Formatter.html "cpp/named req/Formatter")(C++20)  
  
| [Random Numbers](../iterator/concepts.html#Random_Number_Generation "cpp/named req")  
---  
[SeedSequence](SeedSequence.html "cpp/named req/SeedSequence")(C++11)  
[RandomNumberEngine](RandomNumberEngine.html "cpp/named req/RandomNumberEngine")(C++11)  
[RandomNumberDistribution](RandomNumberDistribution.html "cpp/named req/RandomNumberDistribution")(C++11)  
[UniformRandomBitGenerator](UniformRandomBitGenerator.html "cpp/named req/UniformRandomBitGenerator")(C++11)  
[RandomNumberEngineAdaptor](RandomNumberEngineAdaptor.html "cpp/named req/RandomNumberEngineAdaptor")(C++11)  
[Concurrency](../iterator/concepts.html#Concurrency "cpp/named req")  
[BasicLockable](BasicLockable.html "cpp/named req/BasicLockable")(C++11)  
[Lockable](Lockable.html "cpp/named req/Lockable")(C++11)  
[TimedLockable](TimedLockable.html "cpp/named req/TimedLockable")(C++11)  
[SharedLockable](SharedLockable.html "cpp/named req/SharedLockable")(C++14)  
[SharedTimedLockable](SharedTimedLockable.html "cpp/named req/SharedTimedLockable")(C++14)  
[Mutex](Mutex.html "cpp/named req/Mutex")(C++11)  
[TimedMutex](TimedMutex.html "cpp/named req/TimedMutex")(C++11)  
[SharedMutex](SharedMutex.html "cpp/named req/SharedMutex")(C++17)  
[SharedTimedMutex](SharedTimedMutex.html "cpp/named req/SharedTimedMutex")(C++14)  
[Ranges](../iterator/concepts.html#Ranges "cpp/named req")  
[RangeAdaptorObject](RangeAdaptorObject.html "cpp/named req/RangeAdaptorObject")(C++20)  
[RangeAdaptorClosureObject](RangeAdaptorClosureObject.html "cpp/named req/RangeAdaptorClosureObject")(C++20)  
[Multidimensional View](../iterator/concepts.html#Multidimensional_View_Customization "cpp/named req")  
[LayoutMapping](LayoutMapping.html "cpp/named req/LayoutMapping")(C++23)  
[LayoutMappingPolicy](LayoutMappingPolicy.html "cpp/named req/LayoutMappingPolicy")(C++23)  
[AccessorPolicy](AccessorPolicy.html "cpp/named req/AccessorPolicy")(C++23)  
[Other](../iterator/concepts.html#Other "cpp/named req")  
| [CharTraits](CharTraits.html "cpp/named req/CharTraits")  
---  
[RegexTraits](RegexTraits.html "cpp/named req/RegexTraits")(C++11)` `  
[BitmaskType](BitmaskType.html "cpp/named req/BitmaskType")  
**LiteralType**(C++11)  
[NumericType](NumericType.html "cpp/named req/NumericType")  
  
| [UnaryTypeTrait](UnaryTypeTrait.html "cpp/named req/UnaryTypeTrait")(C++11)  
---  
[BinaryTypeTrait](BinaryTypeTrait.html "cpp/named req/BinaryTypeTrait")(C++11)  
[TransformationTrait](TransformationTrait.html "cpp/named req/TransformationTrait")(C++11)  
[Clock](Clock.html "cpp/named req/Clock")(C++11)  
[TrivialClock](TrivialClock.html "cpp/named req/TrivialClock")(C++11)  
  
  
  
  


Specifies that a type is a _literal type_. Literal types are the types of [`constexpr` variables](../language/constexpr.html#constexpr_variable "cpp/language/constexpr") and they can be constructed, manipulated, and returned from [`constexpr` functions](../language/constexpr.html#constexpr_function "cpp/language/constexpr"). 

Note: the standard doesn't define a named requirement with this name. This is a type category defined by the core language. It is included here as a named requirement only for consistency. 

## Contents

  * [1 Requirements](LiteralType.html#Requirements)
  * [2 Notes](LiteralType.html#Notes)
  * [3 Example](LiteralType.html#Example)
  * [4 Defect reports](LiteralType.html#Defect_reports)
  * [5 See also](LiteralType.html#See_also)

  
---  
  
### Requirements

A literal type is any of the following: 

  * possibly cv-qualified void (so that constexpr functions can return void); 

| (since C++14)  
---|---  
  
  * [scalar type](ScalarType.html "cpp/named req/ScalarType"); 
  * [reference type](../language/reference.html "cpp/language/reference"); 
  * an [array](../language/array.html "cpp/language/array") of literal type; 
  * possibly cv-qualified class type that has all of the following properties: 



    

  * has a trivial(until C++20)constexpr(since C++20) [destructor](../language/destructor.html "cpp/language/destructor"), 
  * all of its non-static non-variant data members and base classes are of non-volatile literal types, and 
  * is one of 



    

    

  * a [lambda type](../language/lambda.html "cpp/language/lambda"), 


| (since C++17)  
---|---  
  
    

    

  * an [aggregate](../language/aggregate_initialization.html#Definitions "cpp/language/aggregate initialization") union type that 



    

  * has no [variant members](../language/union.html#Union-like_classes "cpp/language/union"), or 
  * has at least one variant member of non-volatile literal type, 



  * a non-union [aggregate](../language/aggregate_initialization.html#Definitions "cpp/language/aggregate initialization") type, and each of its [anonymous union](../language/union.html#Anonymous_unions "cpp/language/union") members 



    

  * has no [variant members](../language/union.html#Union-like_classes "cpp/language/union"), or 
  * has at least one variant member of non-volatile literal type, 



  * a type with at least one constexpr (possibly template) constructor that is not a copy or move constructor. 



### Notes

A type can be literal even if all of its constexpr constructors are deleted, inaccessible, or cannot participate in overload resolution. 
    
    
    struct A { constexpr A(int) = delete; char c; }; // A is a literal type
    constexpr A v = [std::bit_cast](../numeric/bit_cast.html)<A>('0'); // OK in C++20
                                           // v has literal type and thus can be constexpr

### Example

Literal type that extends string literals:

Run this code
    
    
    #include <cstddef>
    #include <iostream>
    #include <stdexcept>
     
    class conststr // conststr is a literal type
    {
        const char* p;
        [std::size_t](../types/size_t.html) sz;
    public:
        template<[std::size_t](../types/size_t.html) N>
        constexpr conststr(const char(&a)[N]) : p(a), sz(N - 1) {}
     
        constexpr char operator[]([std::size_t](../types/size_t.html) n) const
        {
            return n < sz ? p[n] : throw [std::out_of_range](../error/out_of_range.html)("");
        }
     
        constexpr [std::size_t](../types/size_t.html) size() const { return sz; }
    };
     
    constexpr [std::size_t](../types/size_t.html) count_lower(conststr s)
    {
        [std::size_t](../types/size_t.html) c{};
        for ([std::size_t](../types/size_t.html) n{}; n != s.size(); ++n)
            if ('a' <= s[n] && s[n] <= 'z')
                ++c;
        return c;
    }
     
    // An output function that requires a compile-time constant N, for testing
    template<int N>
    struct constN
    {
        constN() { [std::cout](../io/cout.html) << N << '\n'; }
    };
     
    int main()
    {
        [std::cout](../io/cout.html) << "The number of lowercase letters in \"Hello, world!\" is ";
        constN<count_lower("Hello, world!")>(); // the string literal is implicitly
                                                // converted to conststr
    }

Output: 
    
    
    The number of lowercase letters in "Hello, world!" is 9

### Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[CWG 1453](https://cplusplus.github.io/CWG/issues/1453.html) | C++11  | a literal class could have volatile data members  | not allowed   
[CWG 1951](https://cplusplus.github.io/CWG/issues/1951.html) | C++11  
C++14  | it was unclear whether cv-qualified void (C++14)  
and class types (C++11) are literal types  | they are   
[CWG 2096](https://cplusplus.github.io/CWG/issues/2096.html) | C++11  | for a union type to be literal, all its non-  
static data members must be literal  | only one non-static data  
member needs to be   
[CWG 2598](https://cplusplus.github.io/CWG/issues/2598.html) | C++11  | for a union type to be literal, it must have  
at least one non-static data member  | it can have no non-  
static data member   
  
### See also

[ is_literal_type](../types/is_literal_type.html "cpp/types/is literal type")(C++11)(deprecated in C++17)(removed in C++20) |  checks if a type is a literal type   
(class template)   
---|---
