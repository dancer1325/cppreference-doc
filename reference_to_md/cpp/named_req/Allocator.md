[C++](../../cpp.html "cpp")

[Compiler support](../compiler_support.html "cpp/compiler support")  
---  
[Freestanding and hosted](../freestanding.html "cpp/freestanding")  
[Language](../language.html "cpp/language")  
[Standard library](../standard_library.html "cpp/standard library")  
[Standard library headers](../headers.html "cpp/header")  
[Named requirements](../iterator/concepts.html "cpp/named req")  
[Feature test macros](../experimental/feature_test.html "cpp/feature test") (C++20)  
[Language support library](../utility.html#Language_support "cpp/utility")  
[Concepts library](../concepts.html "cpp/concepts") (C++20)  
[Diagnostics library](../error.html "cpp/error")  
[Memory management library](../memory.html "cpp/memory")  
[Metaprogramming library](../meta.html "cpp/meta") (C++11)  
[General utilities library](../utility.html "cpp/utility")  
[Containers library](../container.html "cpp/container")  
[Iterators library](../iterator.html "cpp/iterator")  
[Ranges library](../ranges.html "cpp/ranges") (C++20)  
[Algorithms library](../algorithm.html "cpp/algorithm")  
[Strings library](../string.html "cpp/string")  
[Text processing library](../text.html "cpp/text")  
[Numerics library](../numeric.html "cpp/numeric")  
[Date and time library](../chrono.html "cpp/chrono")  
[Input/output library](../io.html "cpp/io")  
[Filesystem library](../filesystem.html "cpp/filesystem") (C++17)  
[Concurrency support library](../atomic.html "cpp/thread") (C++11)  
[Execution control library](../experimental/execution.html "cpp/execution") (C++26)  
[Technical specifications](../experimental.html "cpp/experimental")  
[Symbols index](../symbol_index.html "cpp/symbol index")  
[External libraries](../links/libs.html "cpp/links/libs")  
  


[C++ named requirements](../iterator/concepts.html "cpp/named req")

| [Basic](../iterator/concepts.html#Basic "cpp/named req")  
---  
[DefaultConstructible](DefaultConstructible.html "cpp/named req/DefaultConstructible")  
[MoveConstructible](MoveConstructible.html "cpp/named req/MoveConstructible")(C++11)  
[CopyConstructible](CopyConstructible.html "cpp/named req/CopyConstructible")  
[CopyAssignable](CopyAssignable.html "cpp/named req/CopyAssignable")  
[MoveAssignable](MoveAssignable.html "cpp/named req/MoveAssignable")(C++11)  
[Destructible](Destructible.html "cpp/named req/Destructible")  
[Type properties](../iterator/concepts.html#Type_properties "cpp/named req")  
[ScalarType](ScalarType.html "cpp/named req/ScalarType")  
[PODType](PODType.html "cpp/named req/PODType")  
[TriviallyCopyable](TriviallyCopyable.html "cpp/named req/TriviallyCopyable")(C++11)  
[TrivialType](TrivialType.html "cpp/named req/TrivialType")(C++11)  
[StandardLayoutType](StandardLayoutType.html "cpp/named req/StandardLayoutType")(C++11)` `  
[ImplicitLifetimeType](ImplicitLifetimeType.html "cpp/named req/ImplicitLifetimeType")  
[Library-wide](../iterator/concepts.html#Library-wide "cpp/named req")  
[BooleanTestable](BooleanTestable.html "cpp/named req/BooleanTestable")  
[EqualityComparable](EqualityComparable.html "cpp/named req/EqualityComparable")  
[LessThanComparable](LessThanComparable.html "cpp/named req/LessThanComparable")  
[Swappable](Swappable.html "cpp/named req/Swappable")  
[ValueSwappable](ValueSwappable.html "cpp/named req/ValueSwappable")(C++11)  
[NullablePointer](NullablePointer.html "cpp/named req/NullablePointer")(C++11)  
[Hash](Hash.html "cpp/named req/Hash")(C++11)  
**Allocator**  
[FunctionObject](FunctionObject.html "cpp/named req/FunctionObject")  
[Callable](Callable.html "cpp/named req/Callable")  
[Predicate](Predicate.html "cpp/named req/Predicate")  
[BinaryPredicate](BinaryPredicate.html "cpp/named req/BinaryPredicate")  
[Compare](Compare.html "cpp/named req/Compare")  
  
  
  
  
  
  
  
  
  
| [Container](../iterator/concepts.html#Container "cpp/named req")  
---  
[Container](Container.html "cpp/named req/Container")  
[ReversibleContainer](ReversibleContainer.html "cpp/named req/ReversibleContainer")  
[AllocatorAwareContainer](AllocatorAwareContainer.html "cpp/named req/AllocatorAwareContainer")  
[SequenceContainer](SequenceContainer.html "cpp/named req/SequenceContainer")  
[ContiguousContainer](ContiguousContainer.html "cpp/named req/ContiguousContainer")(C++17)  
[AssociativeContainer](AssociativeContainer.html "cpp/named req/AssociativeContainer")  
[UnorderedAssociativeContainer](UnorderedAssociativeContainer.html "cpp/named req/UnorderedAssociativeContainer")(C++11)` `  
[Container element](../iterator/concepts.html#Container_element "cpp/named req")  
[DefaultInsertable](DefaultInsertable.html "cpp/named req/DefaultInsertable")(C++11)  
[CopyInsertable](CopyInsertable.html "cpp/named req/CopyInsertable")(C++11)  
[MoveInsertable](MoveInsertable.html "cpp/named req/MoveInsertable")(C++11)  
[EmplaceConstructible](EmplaceConstructible.html "cpp/named req/EmplaceConstructible")(C++11)  
[Erasable](Erasable.html "cpp/named req/Erasable")(C++11)  
[Iterator](../iterator/concepts.html#Iterator "cpp/named req")  
[LegacyIterator](Iterator.html "cpp/named req/Iterator")  
[LegacyInputIterator](InputIterator.html "cpp/named req/InputIterator")  
[LegacyOutputIterator](OutputIterator.html "cpp/named req/OutputIterator")  
[LegacyForwardIterator](ForwardIterator.html "cpp/named req/ForwardIterator")  
[LegacyBidirectionalIterator](BidirectionalIterator.html "cpp/named req/BidirectionalIterator")  
[LegacyRandomAccessIterator](RandomAccessIterator.html "cpp/named req/RandomAccessIterator")  
[LegacyContiguousIterator](ContiguousIterator.html "cpp/named req/ContiguousIterator")(C++17)  
[ConstexprIterator](ConstexprIterator.html "cpp/named req/ConstexprIterator")(C++20)  
[Stream I/O](../iterator/concepts.html#Stream_I.2FO_functions "cpp/named req")  
[FormattedInputFunction](FormattedInputFunction.html "cpp/named req/FormattedInputFunction")  
[UnformattedInputFunction](UnformattedInputFunction.html "cpp/named req/UnformattedInputFunction")  
[FormattedOutputFunction](FormattedOutputFunction.html "cpp/named req/FormattedOutputFunction")  
[UnformattedOutputFunction](UnformattedOutputFunction.html "cpp/named req/UnformattedOutputFunction")  
[Formatters](../iterator/concepts.html#Formatters "cpp/named req")  
[BasicFormatter](BasicFormatter.html "cpp/named req/BasicFormatter")(C++20)  
[Formatter](Formatter.html "cpp/named req/Formatter")(C++20)  
  
| [Random Numbers](../iterator/concepts.html#Random_Number_Generation "cpp/named req")  
---  
[SeedSequence](SeedSequence.html "cpp/named req/SeedSequence")(C++11)  
[RandomNumberEngine](RandomNumberEngine.html "cpp/named req/RandomNumberEngine")(C++11)  
[RandomNumberDistribution](RandomNumberDistribution.html "cpp/named req/RandomNumberDistribution")(C++11)  
[UniformRandomBitGenerator](UniformRandomBitGenerator.html "cpp/named req/UniformRandomBitGenerator")(C++11)  
[RandomNumberEngineAdaptor](RandomNumberEngineAdaptor.html "cpp/named req/RandomNumberEngineAdaptor")(C++11)  
[Concurrency](../iterator/concepts.html#Concurrency "cpp/named req")  
[BasicLockable](BasicLockable.html "cpp/named req/BasicLockable")(C++11)  
[Lockable](Lockable.html "cpp/named req/Lockable")(C++11)  
[TimedLockable](TimedLockable.html "cpp/named req/TimedLockable")(C++11)  
[SharedLockable](SharedLockable.html "cpp/named req/SharedLockable")(C++14)  
[SharedTimedLockable](SharedTimedLockable.html "cpp/named req/SharedTimedLockable")(C++14)  
[Mutex](Mutex.html "cpp/named req/Mutex")(C++11)  
[TimedMutex](TimedMutex.html "cpp/named req/TimedMutex")(C++11)  
[SharedMutex](SharedMutex.html "cpp/named req/SharedMutex")(C++17)  
[SharedTimedMutex](SharedTimedMutex.html "cpp/named req/SharedTimedMutex")(C++14)  
[Ranges](../iterator/concepts.html#Ranges "cpp/named req")  
[RangeAdaptorObject](RangeAdaptorObject.html "cpp/named req/RangeAdaptorObject")(C++20)  
[RangeAdaptorClosureObject](RangeAdaptorClosureObject.html "cpp/named req/RangeAdaptorClosureObject")(C++20)  
[Multidimensional View](../iterator/concepts.html#Multidimensional_View_Customization "cpp/named req")  
[LayoutMapping](LayoutMapping.html "cpp/named req/LayoutMapping")(C++23)  
[LayoutMappingPolicy](LayoutMappingPolicy.html "cpp/named req/LayoutMappingPolicy")(C++23)  
[AccessorPolicy](AccessorPolicy.html "cpp/named req/AccessorPolicy")(C++23)  
[Other](../iterator/concepts.html#Other "cpp/named req")  
| [CharTraits](CharTraits.html "cpp/named req/CharTraits")  
---  
[RegexTraits](RegexTraits.html "cpp/named req/RegexTraits")(C++11)` `  
[BitmaskType](BitmaskType.html "cpp/named req/BitmaskType")  
[LiteralType](LiteralType.html "cpp/named req/LiteralType")(C++11)  
[NumericType](NumericType.html "cpp/named req/NumericType")  
  
| [UnaryTypeTrait](UnaryTypeTrait.html "cpp/named req/UnaryTypeTrait")(C++11)  
---  
[BinaryTypeTrait](BinaryTypeTrait.html "cpp/named req/BinaryTypeTrait")(C++11)  
[TransformationTrait](TransformationTrait.html "cpp/named req/TransformationTrait")(C++11)  
[Clock](Clock.html "cpp/named req/Clock")(C++11)  
[TrivialClock](TrivialClock.html "cpp/named req/TrivialClock")(C++11)  
  
  
  
  


Encapsulates strategies for access/addressing, allocation/deallocation and construction/destruction of objects. 

Every standard library component that may need to allocate or release storage, from [std::string](../string/basic_string.html "cpp/string/basic string"), [std::vector](../container/vector.html "cpp/container/vector"), and every container, except [std::array](../container/array.html "cpp/container/array")(since C++11) and std::inplace_vector(since C++26), to [std::shared_ptr](../memory/shared_ptr.html "cpp/memory/shared ptr") and [std::function](../utility/functional/function.html "cpp/utility/functional/function")(until C++17), does so through an **Allocator** : an object of a class type that satisfies the following requirements. 

The implementation of many allocator requirements is optional because all [AllocatorAwareContainer](AllocatorAwareContainer.html "cpp/named req/AllocatorAwareContainer") access allocators indirectly through [std::allocator_traits](../memory/allocator_traits.html "cpp/memory/allocator traits"), and [std::allocator_traits](../memory/allocator_traits.html "cpp/memory/allocator traits") supplies the default implementation of those requirements. 

## Contents

  * [1 Requirements](Allocator.html#Requirements)
    * [1.1 Allocator completeness requirements](Allocator.html#Allocator_completeness_requirements)
  * [2 Stateful and stateless allocators](Allocator.html#Stateful_and_stateless_allocators)
  * [3 Fancy pointers](Allocator.html#Fancy_pointers)
  * [4 Concept](Allocator.html#Concept)
  * [5 Standard library](Allocator.html#Standard_library)
  * [6 Examples](Allocator.html#Examples)
  * [7 Defect reports](Allocator.html#Defect_reports)

  
---  
  
### Requirements

Given 

  * `T`, a non-const, non-reference type(until C++11)non-const object type(since C++11)(until C++17)cv-unqualified object type(since C++17), 
  * `A`, an Allocator type for type `T`, 
  * a, an object of type `A`, 
  * `B`, the corresponding Allocator type for some cv-unqualified object type `U` (as obtained by rebinding `A`), 
  * b, an object of type `B`, 
  * p, a value of type [std::allocator_traits](../memory/allocator_traits.html)<A>::pointer, obtained by calling [std::allocator_traits](../memory/allocator_traits.html)<A>::allocate(), 
  * cp, a value of type [std::allocator_traits](../memory/allocator_traits.html)<A>::const_pointer, obtained by conversion from p, 
  * vp, a value of type [std::allocator_traits](../memory/allocator_traits.html)<A>::void_pointer, obtained by conversion from p, 
  * cvp, a value of type [std::allocator_traits](../memory/allocator_traits.html)<A>::const_void_pointer, obtained by conversion from cp or from vp, 
  * xp, a dereferenceable pointer to some cv-unqualified object type `X`, 
  * r, an lvalue of type `T` obtained by the expression *p, 
  * n, a value of type [std::allocator_traits](../memory/allocator_traits.html)<A>::size_type. 

Inner types  Type-id | Aliased type | Requirements   
---|---|---  
`A::pointer` (optional) | _(unspecified)_[[1]](Allocator.html#cite_note-1) | 

  * Satisfies [NullablePointer](NullablePointer.html "cpp/named req/NullablePointer"), [LegacyRandomAccessIterator](RandomAccessIterator.html "cpp/named req/RandomAccessIterator"), and [LegacyContiguousIterator](ContiguousIterator.html "cpp/named req/ContiguousIterator"). 

  
`A::const_pointer` (optional) | _(unspecified)_ | 

  * Satisfies [NullablePointer](NullablePointer.html "cpp/named req/NullablePointer"), [LegacyRandomAccessIterator](RandomAccessIterator.html "cpp/named req/RandomAccessIterator"), and [LegacyContiguousIterator](ContiguousIterator.html "cpp/named req/ContiguousIterator"). 
  * `A::pointer` is convertible to `A::const_pointer`. 

  
`A::void_pointer` (optional) | _(unspecified)_ | 

  * Satisfies [NullablePointer](NullablePointer.html "cpp/named req/NullablePointer"). 
  * `A::pointer` is convertible to `A::void_pointer`. 
  * `B::void_pointer` and `A::void_pointer` are the same type. 

  
`A::const_void_pointer` (optional) | _(unspecified)_ | 

  * Satisfies [NullablePointer](NullablePointer.html "cpp/named req/NullablePointer"). 
  * `A::pointer`, `A::const_pointer`, and `A::void_pointer` are convertible to `A::const_void_pointer`. 
  * `B::const_void_pointer` and `A::const_void_pointer` are the same type. 

  
`A::value_type` | `T` |   
`A::size_type` (optional) | _(unspecified)_ | 

  * An unsigned integer type. 
  * Can represent the size of the largest object `A` can allocate. 

  
`A::difference_type` (optional) | _(unspecified)_ | 

  * A signed integer type. 
  * Can represent the difference of any two pointers to the objects allocated by `A`. 

  
`A::template rebind<U>::other`  
(optional)[[2]](Allocator.html#cite_note-2) | `B` | 

  * For any `U`, `B::template rebind<T>::other` is `A`. 

  
Operations on pointers  Expression | Return type | Requirements   
---|---|---  
*p | `T&` |   
*cp | const T& | *cp and *p identify the same object.   
p->m | _(as is)_ | Same as (*p).m, if (*p).m is well-defined.   
cp->m | _(as is)_ | Same as (*cp).m, if (*cp).m is well-defined.   
static_cast<A::pointer>(vp) | _(as is)_ | static_cast<A::pointer>(vp) == p  
static_cast<A::const_pointer>(cvp) | _(as is)_ | static_cast<A::const_pointer>(cvp) == cp  
[std::pointer_traits](../memory/pointer_traits.html)<A::pointer>::pointer_to(r) | _(as is)_ |   
Storage and lifetime operations  Expression | Return type | Requirements   
---|---|---  
a.allocate(n) | `A::pointer` | Allocates storage suitable for an array object of type `T[n]` and creates the array, but does not construct array elements. May throw exceptions. If n == 0, the return value is unspecified.   
a.allocate(n, cvp) (optional) | Same as a.allocate(n), but may use cvp (nullptr or a pointer obtained from a.allocate()) in unspecified manner to aid locality.   
a.allocate_at_least(n) (optional) (since C++23) | [std::allocation_result](../memory/allocation_result.html)  
<A::pointer> | Allocates storage suitable for an array object of type `T[cnt]` and creates the array, but does not construct array elements, then returns {p, cnt}, where p points to the storage and cnt is not less than n. May throw exceptions.   
a.deallocate(p, n) | _(not used)_ | Deallocates storage pointed to p, which must be a value returned by a previous call to `allocate` or `allocate_at_least`(since C++23) that has not been invalidated by an intervening call to `deallocate`. n must match the value previously passed to `allocate`or be between the request and returned number of elements via `allocate_at_least` (may be equal to either bound)(since C++23). Does not throw exceptions.   
a.max_size() (optional) | `A::size_type` | The largest value that can be passed to A::allocate().   
a.construct(xp, args...) (optional) | _(not used)_ | Constructs an object of type `X` in previously-allocated storage at the address pointed to by xp, using args... as the constructor arguments.   
a.destroy(xp) (optional) | _(not used)_ | Destructs an object of type `X` pointed to by xp, but does not deallocate any storage.   
Relationship between instances  Expression | Return type | Requirements   
---|---|---  
a1 == a2 | bool | 

  * true only if the storage allocated by the allocator a1 can be deallocated through a2. 
  * Establishes reflexive, symmetric, and transitive relationship. 
  * Does not throw exceptions. 

  
a1 != a2 | 

  * Same as !(a1 == a2). 

  
Declaration | Effect | Requirements   
A a1(a) | Copy-constructs a1 such that a1 == a.  
(Note: Every Allocator also satisfies [CopyConstructible](CopyConstructible.html "cpp/named req/CopyConstructible").)  | 

  * Does not throw exceptions. 

  
A a1 = a  
A a(b) | Constructs a such that B(a) == b and A(b) == a.  
(Note: This implies that all allocators related by `rebind` maintain each other's resources, such as memory pools.)  | 

  * Does not throw exceptions. 

  
A a1(std::move(a)) | Constructs a1 such that it equals the prior value of a.  | 

  * Does not throw exceptions. 
  * The value of a is unchanged and a1 == a. 

  
A a1 = std::move(a)  
A a(std::move(b)) | Constructs a such that it equals the prior value of A(b).  | 

  * Does not throw exceptions. 

  
Type-id | Aliased type | Requirements   
`A::is_always_equal`  
(optional) | [std::true_type](../types/integral_constant.html "cpp/types/integral constant") or [std::false_type](../types/integral_constant.html "cpp/types/integral constant") or derived from such.  | 

  * true if any two allocators of type `A` always compare equal. 
  * (If not provided, [std::allocator_traits](../memory/allocator_traits.html "cpp/memory/allocator traits") defaults this to [std::is_empty](../types/is_empty.html)<A>::type.) 

  
Influence on container operations  Expression | Return type | Description   
---|---|---  
a.select_on_container_copy_construction()  
(optional) | `A` | 

  * Provides an instance of `A` to be used by the container that is copy-constructed from the one that uses a currently. 
  * (Usually returns either a copy of a or a default-constructed `A`.) 

  
Type-id | Aliased type | Description   
`A::propagate_on_container_copy_assignment`  
(optional) | [std::true_type](../types/integral_constant.html "cpp/types/integral constant") or [std::false_type](../types/integral_constant.html "cpp/types/integral constant") or derived from such.  | 

  * [std::true_type](../types/integral_constant.html "cpp/types/integral constant") or derived from it if the allocator of type `A` needs to be copied when the container that uses it is copy-assigned. 
  * If this member is [std::true_type](../types/integral_constant.html "cpp/types/integral constant") or derived from it, then `A` must satisfy [CopyAssignable](CopyAssignable.html "cpp/named req/CopyAssignable") and the copy operation must not throw exceptions. 
  * Note that if the allocators of the source and the target containers do not compare equal, copy assignment has to deallocate the target's memory using the old allocator and then allocate it using the new allocator before copying the elements (and the allocator). 

  
`A::propagate_on_container_move_assignment`  
(optional) | 

  * [std::true_type](../types/integral_constant.html "cpp/types/integral constant") or derived from it if the allocator of type `A` needs to be moved when the container that uses it is move-assigned. 
  * If this member is [std::true_type](../types/integral_constant.html "cpp/types/integral constant") or derived from it, then `A` must satisfy [MoveAssignable](MoveAssignable.html "cpp/named req/MoveAssignable") and the move operation must not throw exceptions. 
  * If this member is not provided or derived from [std::false_type](../types/integral_constant.html "cpp/types/integral constant") and the allocators of the source and the target containers do not compare equal, move assignment cannot take ownership of the source memory and must move-assign or move-construct the elements individually, resizing its own memory as needed. 

  
`A::propagate_on_container_swap`  
(optional) | 

  * [std::true_type](../types/integral_constant.html "cpp/types/integral constant") or derived from it if the allocators of type `A` need to be swapped when two containers that use them are swapped. 
  * If this member is [std::true_type](../types/integral_constant.html "cpp/types/integral constant") or derived from it, type `A` must satisfy [Swappable](Swappable.html "cpp/named req/Swappable") and the swap operation must not throw exceptions. 
  * If this member is not provided or derived from [std::false_type](../types/integral_constant.html "cpp/types/integral constant") and the allocators of the two containers do not compare equal, the behavior of container swap is undefined. 

  
  
Notes: 

  1. [↑](Allocator.html#cite_ref-1) See also [fancy pointers](Allocator.html#Fancy_pointers) below.
  2. [↑](Allocator.html#cite_ref-2) `rebind` is only optional (provided by [std::allocator_traits](../memory/allocator_traits.html "cpp/memory/allocator traits")) if this allocator is a template of the form `SomeAllocator<T, Args>`, where `Args` is zero or more additional template type parameters.



Given 

  * x1 and x2, objects of (possibly different) types `X::void_pointer`, `X::const_void_pointer`, `X::pointer`, or `X::const_pointer`



    Then, x1 and x2 are _equivalently-valued_ pointer values, if and only if both x1 and x2 can be explicitly converted to the two corresponding objects px1 and px2 of type `X::const_pointer`, using a sequence of static_casts using only these four types, and the expression px1 == px2 evaluates to true. 

Given 

  * w1 and w2, objects of type `X::void_pointer`



    Then, for the expression w1 == w2 and w1 != w2 either or both objects may be replaced by an _equivalently-valued_ object of type `X::const_void_pointer` with no change in semantics. 

Given 

  * p1 and p2, objects of type `X::pointer`



    Then, for the expressions p1 == p2, p1 != p2, p1 < p2, p1 <= p2, p1 >= p2, p1 > p2, p1 - p2 either or both objects may be replaced by an _equivalently-valued_ object of type `X::const_pointer` with no change in semantics. 

The above requirements make it possible to compare [Container](Container.html "cpp/named req/Container")'s `iterator`s and `const_iterator`s. 

####  Allocator completeness requirements

An allocator type `X` for type `T` additionally satisfies the _allocator completeness requirements_ if both of the following are true regardless of whether `T` is a complete type: 

  * `X` is a complete type. 
  * Except for `value_type`, all the member types of [std::allocator_traits](../memory/allocator_traits.html)<X> are complete types. 

| (since C++17)  
---|---  
  
### Stateful and stateless allocators

Every Allocator type is either _stateful_ or _stateless_. Generally, a stateful allocator type can have unequal values which denote distinct memory resources, while a stateless allocator type denotes a single memory resource. 

Although custom allocators are not required to be stateless, whether and how the use of stateful allocators in the standard library is implementation-defined. Use of unequal allocator values may result in implementation-defined runtime errors or undefined behavior if the implementation does not support such usage.  | (until C++11)  
---|---  
Custom allocators may contain state. Each container or another allocator-aware object stores an instance of the supplied allocator and controls allocator replacement through [std::allocator_traits](../memory/allocator_traits.html "cpp/memory/allocator traits").  | (since C++11)  
  
Instances of a stateless allocator type always compare equal. Stateless allocator types are typically implemented as empty classes and suitable for [empty base class optimization](../language/ebo.html "cpp/language/ebo"). 

The member type `is_always_equal` of [std::allocator_traits](../memory/allocator_traits.html "cpp/memory/allocator traits") is intendedly used for determining whether an allocator type is stateless.  | (since C++11)  
---|---  
  
### Fancy pointers

When the member type `pointer` is not a raw pointer type, it is commonly referred to as a ["fancy pointer"](https://wg21.link/P0773R0). Such pointers were introduced to support segmented memory architectures and are used today to access objects allocated in address spaces that differ from the homogeneous virtual address space that is accessed by raw pointers. An example of a fancy pointer is the mapping address-independent pointer [`boost::interprocess::offset_ptr`](https://www.boost.org/doc/libs/release/doc/html/interprocess/offset_ptr.html), which makes it possible to allocate node-based data structures such as [std::set](../container/set.html "cpp/container/set") in shared memory and memory mapped files mapped in different addresses in every process. Fancy pointers can be used independently of the allocator that provided them, through the class template [std::pointer_traits](../memory/pointer_traits.html "cpp/memory/pointer traits")(since C++11). The function std::to_address can be used to obtain a raw pointer from a fancy pointer.(since C++20)

Use of fancy pointers and customized size/different type in the standard libary are conditionally supported. Implementations may require that member type `pointer`, `const_pointer`, `size_type`, and `difference_type` are `value_type*`, const value_type*, [std::size_t](../types/size_t.html "cpp/types/size t"), and [std::ptrdiff_t](../types/ptrdiff_t.html "cpp/types/ptrdiff t"), respectively.  | (until C++11)  
---|---  
  
###  Concept

For the definition of the query object std::get_allocator, the following exposition-only concept is defined.  |  template<class Alloc>  
concept /*simple-allocator*/ = requires(Alloc alloc, [std::size_t](../types/size_t.html) n)  
{  
{ *alloc.allocate(n) } -> [std::same_as](../concepts/same_as.html)<typename Alloc::value_type&>;  
{ alloc.deallocate(alloc.allocate(n), n) };   
} && [std::copy_constructible](../concepts/copy_constructible.html)<Alloc>  
&& [std::equality_comparable](../concepts/equality_comparable.html)<Alloc>; |  |   
---|---|---  
| |   
  
The exposition-only concept /*simple-allocator*/ defines the minimal usability constraints of the **Allocator** requirement. 

(since C++26)  
  
### Standard library

The following standard library components satisfy the Allocator requirements: 

[ allocator](../memory/allocator.html "cpp/memory/allocator") |  the default allocator   
(class template)   
---|---  
[ scoped_allocator_adaptor](../memory/scoped_allocator_adaptor.html "cpp/memory/scoped allocator adaptor")(C++11) |  implements multi-level allocator for multi-level containers   
(class template)   
[ polymorphic_allocator](../memory/polymorphic_allocator.html "cpp/memory/polymorphic allocator")(C++17) |  an allocator that supports run-time polymorphism based on the [std::pmr::memory_resource](../memory/memory_resource.html "cpp/memory/memory resource") it is constructed with   
(class template)   
  
### Examples

Demonstrates a C++11 allocator, except for `[[[nodiscard](../language/attributes/nodiscard.html "cpp/language/attributes/nodiscard")]]` added to match C++20 style.

Run this code
    
    
    #include <cstdlib>
    #include <iostream>
    #include <limits>
    #include <new>
    #include <vector>
     
    template<class T>
    struct Mallocator
    {
        typedef T value_type;
     
        Mallocator() = default;
     
        template<class U>
        constexpr Mallocator(const Mallocator <U>&) noexcept {}
     
        [[nodiscard]] T* allocate([std::size_t](../types/size_t.html) n)
        {
            if (n > [std::numeric_limits](../types/numeric_limits.html)<[std::size_t](../types/size_t.html)>::max() / sizeof(T))
                throw [std::bad_array_new_length](../memory/new/bad_array_new_length.html)();
     
            if (auto p = static_cast<T*>([std::malloc](../memory/c/malloc.html)(n * sizeof(T))))
            {
                report(p, n);
                return p;
            }
     
            throw [std::bad_alloc](../memory/new/bad_alloc.html)();
        }
     
        void deallocate(T* p, [std::size_t](../types/size_t.html) n) noexcept
        {
            report(p, n, 0);
            [std::free](../memory/c/free.html)(p);
        }
    private:
        void report(T* p, [std::size_t](../types/size_t.html) n, bool alloc = true) const
        {
            [std::cout](../io/cout.html) << (alloc ? "Alloc: " : "Dealloc: ") << sizeof(T) * n
                      << " bytes at " << [std::hex](../io/manip/hex.html) << [std::showbase](../io/manip/showbase.html)
                      << reinterpret_cast<void*>(p) << [std::dec](../io/manip/hex.html) << '\n';
        }
    };
     
    template<class T, class U>
    bool operator==(const Mallocator <T>&, const Mallocator <U>&) { return true; }
     
    template<class T, class U>
    bool operator!=(const Mallocator <T>&, const Mallocator <U>&) { return false; }
     
    int main()
    {
        [std::vector](../container/vector.html)<int, Mallocator<int>> v(8);
        v.push_back(42);
    }

Possible output: 
    
    
    Alloc: 32 bytes at 0x2020c20
    Alloc: 64 bytes at 0x2023c60
    Dealloc: 32 bytes at 0x2020c20
    Dealloc: 64 bytes at 0x2023c60

### Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards. 

DR  | Applied to  | Behavior as published  | Correct behavior   
---|---|---|---  
[LWG 179](https://cplusplus.github.io/LWG/issue179) | C++98  | `pointer` and `const_pointer` were not  
required to be comparable with each other  | required   
[LWG 199](https://cplusplus.github.io/LWG/issue199) | C++98  | the return value of a.allocate(0) was unclear  | it is unspecified   
[LWG 258](https://cplusplus.github.io/LWG/issue258)  
([N2436](https://wg21.link/N2436))  | C++98  | the equality relationship between allocators were  
not required to be reflexive, symmetric or transitive  | required to be reflexive,  
symmetric and transitive   
[LWG 274](https://cplusplus.github.io/LWG/issue274) | C++98  | `T` could be a const-qualified type or reference type,  
making [std::allocator](../memory/allocator.html "cpp/memory/allocator") possibly ill-formed[[1]](Allocator.html#cite_note-3) | prohibited these types   
[LWG 2016](https://cplusplus.github.io/LWG/issue2016) | C++11  | the copy, move and swap operations of  
allocator might be throwing when used  | required to be non-throwing   
[LWG 2081](https://cplusplus.github.io/LWG/issue2081) | C++98  
C++11  | allocators were not required to support copy  
assignment (C++98) and move assignment (C++11)  | required   
[LWG 2108](https://cplusplus.github.io/LWG/issue2108) | C++11  | there was no way to show an allocator is stateless  | `is_always_equal` provided   
[LWG 2263](https://cplusplus.github.io/LWG/issue2263) | C++11  | the resolution of [LWG issue 179](https://cplusplus.github.io/LWG/issue179) was accidently dropped in C++11  
and not generalized to `void_pointer` and `const_void_pointer` | restored and generalized   
[LWG 2447](https://cplusplus.github.io/LWG/issue2447) | C++11  | `T` could be a volatile-qualified object type  | prohibited these types   
[LWG 2593](https://cplusplus.github.io/LWG/issue2593) | C++11  | moving from an allocator might modify its value  | modification forbidden   
[P0593R6](https://wg21.link/P0593R6) | C++98  | `allocate` were not required to create an  
array object in the storage it allocated  | required   
  
  1. [↑](Allocator.html#cite_ref-3) The member types `reference` and `const_reference` of [std::allocator](../memory/allocator.html "cpp/memory/allocator") are defined as `T&` and `const T&` respectively. 
     * If `T` is a reference type, `reference` and `const_reference` are ill-formed because reference to reference cannot be formed ([reference collapsing](../language/reference.html#Reference_collapsing "cpp/language/reference") was introduced in C++11). 
     * If `T` is const-qualified, `reference` and `const_reference` are the same, and the overload set of [`address()`](../memory/allocator/address.html "cpp/memory/allocator/address") is ill-formed.


  *[_(as is)_]: A::pointer
